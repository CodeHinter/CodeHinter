<s>class temp {        public static int simpleUpdate(String query) throws SQLException {
            Connection conn = null;
            Statement st = null;
            try {
                conn = dataSource.getConnection();
                st = conn.createStatement();
                int res = st.executeUpdate(query);
                conn.commit();
                return res;
            } catch (SQLException e) {
                try {
                    conn.rollback();
                } catch (Exception e1) {
                }
                throw e;
            } finally {
                try {
                    st.close();
                } catch (Exception e) {
                }
                try {
                    conn.close();
                } catch (Exception e) {
                }
            }
        }
} </s>
<s>class temp {    public static boolean BMPfromURL(URL url, MainClass mc) {
        TextField TF = mc.TF;
        PixCanvas canvas = mc.canvas;
        Image image = null;
        try {
            image = Toolkit.getDefaultToolkit().createImage(BMPReader.getBMPImage(url.openStream()));
        } catch (IOException e) {
            return false;
        }
        if (image == null) {
            TF.setText("Error not a typical image BMP format");
            return false;
        }
        MediaTracker tr = new MediaTracker(canvas);
        tr.addImage(image, 0);
        try {
            tr.waitForID(0);
        } catch (InterruptedException e) {
        }
        ;
        if (tr.isErrorID(0)) {
            Tools.debug(OpenOther.class, "Tracker error " + tr.getErrorsAny().toString());
            return false;
        }
        PixObject po = new PixObject(url, image, canvas, false, null);
        mc.vimages.addElement(po);
        TF.setText(url.toString());
        canvas.repaint();
        return true;
    }
} </s>
<s>class temp {    public void run() {
        if (isRunning) return;
        isRunning = true;
        Core core = Core.getInstance();
        URL url = null;
        InputStream input = null;
        DataInputStream datastream;
        try {
            url = new URL(Constants.UpdateCheckUrl);
        } catch (MalformedURLException e) {
            if (!firstRun) core.showMessage(1, core.getString("error"), core.getString("errorUpdateCheck"));
            isRunning = false;
            return;
        }
        try {
            input = url.openStream();
        } catch (IOException e) {
            if (!firstRun) core.showMessage(1, core.getString("error"), core.getString("errorUpdateCheck"));
            isRunning = false;
            return;
        }
        datastream = new DataInputStream(new BufferedInputStream(input));
        String line = null;
        try {
            line = datastream.readLine();
        } catch (IOException e) {
            e.printStackTrace();
            if (!firstRun) core.showMessage(1, core.getString("error"), core.getString("errorUpdateCheck"));
            isRunning = false;
            return;
        }
        if (line == null) {
            if (!firstRun) core.showMessage(1, core.getString("error"), core.getString("errorUpdateCheck"));
            isRunning = false;
            return;
        }
        if (line.trim().equalsIgnoreCase(Constants.version)) {
            if (!firstRun) core.showMessage(0, core.getString("checkUpdateButton"), core.getString("versionMatch"));
        } else {
            core.showMessage(1, core.getString("checkUpdateButton"), core.getString("errorNewerVersion") + ": " + line);
        }
        isRunning = false;
    }
} </s>
<s>class temp {    protected Connection openRelativeFile(String file) throws IOException {
        if (cachedBits == null) {
            cachedBits = new ByteArray(url.openConnection().getInputStream()).getBytes();
        }
        ZipInputStream zin = new ZipInputStream(new ByteArrayInputStream(cachedBits));
        ZipEntry zentry;
        while (true) {
            zentry = zin.getNextEntry();
            if (zentry == null) {
                throw new IOException("Couldn't find resource " + file + " in ZIP-file");
            }
            if (zentry.getName().equals(file)) {
                return new Connection(zin, zentry.getSize());
            }
        }
    }
} </s>
<s>class temp {    public static void copyFile(File fromFile, File toFile) throws IOException {
        FileReader from = new FileReader(fromFile);
        FileWriter to = new FileWriter(toFile);
        char[] buffer = new char[4096];
        int bytes_read;
        while ((bytes_read = from.read(buffer)) != -1) {
            to.write(buffer, 0, bytes_read);
        }
        to.flush();
        to.close();
        from.close();
    }
} </s>
<s>class temp {    private void bootKernel(String conf) {
        try {
            AssetManager am = getResources().getAssets();
            InputStream is = am.open(conf + ".conf");
            Properties props = new Properties();
            props.load(is);
            is.close();
            Log.d("bootKernel", "Listing sdcard assets...");
            String[] sdcardfiles = am.list("sdcard");
            for (String file : sdcardfiles) {
                Log.d("bootKernel", "Copying sdcard asset " + file + ".");
                AssetFileDescriptor afd = am.openFd("sdcard/" + file);
                FileInputStream fis = afd.createInputStream();
                FileChannel fic = fis.getChannel();
                FileOutputStream fos = new FileOutputStream("/sdcard/" + file);
                FileChannel foc = fos.getChannel();
                fic.transferTo(0, fic.size(), foc);
                fic.close();
                foc.close();
            }
            Configuration gconf = new JavaPropertiesConfiguration(props);
            Configuration bconf = gconf.subset("boot");
            String kclass_name = bconf.getString("kernel");
            Log.d("bootKernel", "Attempting to load kernel from class '" + kclass_name + "'...");
            Class<? extends Kernel> kclass = Class.forName(kclass_name).asSubclass(Kernel.class);
            Kernel kernel = kclass.newInstance();
            Log.d("bootKernel", "Kernel loaded, proceeding with boot...");
            BootContext bctx = new SimpleBootContext(gconf, AndroidBridgeService.class, AndroidBridgeServiceImpl.class);
            kernel.boot(bctx).get();
            Log.d("bootKernel", "Kernel boot complete.");
        } catch (Exception e) {
            Log.e("bootKernel", "Unable to boot kernel due to exception.", e);
            finish();
        }
    }
} </s>
<s>class temp {    public static void main(String[] args) throws Exception {
        if (args.length < 2) {
            System.err.println("Usage:  java SOAPClient4XG " + "http://soapURL soapEnvelopefile.xml" + " [SOAPAction]");
            System.err.println("SOAPAction is optional.");
            System.exit(1);
        }
        String SOAPUrl = args[0];
        String xmlFile2Send = args[1];
        String SOAPAction = "";
        if (args.length > 2) SOAPAction = args[2];
        URL url = new URL(SOAPUrl);
        URLConnection connection = url.openConnection();
        HttpURLConnection httpConn = (HttpURLConnection) connection;
        FileInputStream fin = new FileInputStream(xmlFile2Send);
        ByteArrayOutputStream bout = new ByteArrayOutputStream();
        copy(fin, bout);
        fin.close();
        byte[] b = bout.toByteArray();
        httpConn.setRequestProperty("Content-Length", String.valueOf(b.length));
        httpConn.setRequestProperty("Content-Type", "text/xml; charset=utf-8");
        httpConn.setRequestProperty("SOAPAction", SOAPAction);
        httpConn.setRequestMethod("POST");
        httpConn.setDoOutput(true);
        httpConn.setDoInput(true);
        OutputStream out = httpConn.getOutputStream();
        out.write(b);
        out.close();
        InputStreamReader isr = new InputStreamReader(httpConn.getInputStream());
        BufferedReader in = new BufferedReader(isr);
        String inputLine;
        while ((inputLine = in.readLine()) != null) System.out.println(inputLine);
        in.close();
    }
} </s>
<s>class temp {    public static boolean changeCredentials() {
        boolean passed = false;
        boolean credentials = false;
        HashMap info = null;
        Debug.log("Main.changeCredentials", "show dialog for userinfo");
        info = getUserInfo();
        if ((Boolean) info.get("submit")) {
            try {
                MessageDigest md5 = MessageDigest.getInstance("MD5");
                md5.update(info.get("password").toString().getBytes());
                String passHash = new BigInteger(1, md5.digest()).toString(16);
                Debug.log("Main.changeCredentials", "validate credentials with the database");
                passed = xmlRpcC.checkUser(info.get("username").toString(), passHash);
                Debug.log("Main.changeCredentials", "write the credentials to file");
                xmlC.writeUserdata(userdataFile, info.get("username").toString(), passHash);
                credentials = passed;
                testVar = true;
            } catch (Exception ex) {
                System.out.println(ex.toString());
                if (ex.getMessage().toLowerCase().contains("unable")) {
                    JOptionPane.showMessageDialog(null, "Database problem occured, please try again later", "Error", JOptionPane.ERROR_MESSAGE);
                    passed = true;
                    testVar = false;
                } else {
                    passed = Boolean.parseBoolean(ex.getMessage());
                    JOptionPane.showMessageDialog(null, "Invallid userdata, try again", "Invallid userdata", JOptionPane.ERROR_MESSAGE);
                }
            }
        } else {
            if (new File(userdataFile).exists()) {
                testVar = true;
                credentials = true;
            } else {
                testVar = false;
                JOptionPane.showMessageDialog(null, "No userdata was entered\nNo tests will be executed until you enter them ", "Warning", JOptionPane.ERROR_MESSAGE);
            }
            passed = true;
        }
        while (!passed) {
            Debug.log("Main.changeCredentials", "show dialog for userinfo");
            info = getUserInfo();
            if ((Boolean) info.get("submit")) {
                try {
                    MessageDigest md5 = MessageDigest.getInstance("MD5");
                    md5.update(info.get("password").toString().getBytes());
                    String passHash = new BigInteger(1, md5.digest()).toString(16);
                    Debug.log("Main.changeCredentials", "validate credentials with the database");
                    passed = xmlRpcC.checkUser(info.get("username").toString(), passHash);
                    Debug.log("Main.changeCredentials", "write credentials to local xml file");
                    xmlC.writeUserdata(userdataFile, info.get("username").toString(), passHash);
                    credentials = passed;
                    testVar = true;
                } catch (Exception ex) {
                    Debug.log("Main.changeCredentials", "credential validation failed");
                    passed = Boolean.parseBoolean(ex.getMessage());
                    JOptionPane.showMessageDialog(null, "Invallid userdata, try again", "Invallid userdata", JOptionPane.ERROR_MESSAGE);
                }
            } else {
                if (new File(userdataFile).exists()) {
                    testVar = true;
                    credentials = true;
                } else {
                    testVar = false;
                    JOptionPane.showMessageDialog(null, "No userdata was entered\nNo tests will be executed untill u enter them ", "Warning", JOptionPane.ERROR_MESSAGE);
                }
                passed = true;
            }
        }
        return credentials;
    }
} </s>
<s>class temp {    public static synchronized String encrypt(String plaintext) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        MessageDigest md = null;
        md = MessageDigest.getInstance("SHA");
        md.update(plaintext.getBytes("UTF-8"));
        byte raw[] = md.digest();
        String hash = (new BASE64Encoder()).encode(raw);
        return hash;
    }
} </s>
<s>class temp {    public static byte[] generateAuthId(String userName, String password) {
        byte[] ret = new byte[16];
        try {
            MessageDigest messageDigest = MessageDigest.getInstance("MD5");
            String str = userName + password;
            messageDigest.update(str.getBytes());
            ret = messageDigest.digest();
        } catch (NoSuchAlgorithmException ex) {
            ex.printStackTrace();
        }
        return ret;
    }
} </s>
<s>class temp {    public boolean restore(File directory) {
        log.debug("restore file from directory " + directory.getAbsolutePath());
        try {
            if (!directory.exists()) return false;
            String[] operationFileNames = directory.list();
            if (operationFileNames.length < 6) {
                log.error("Only " + operationFileNames.length + " files found in directory " + directory.getAbsolutePath());
                return false;
            }
            int fileCount = 0;
            for (int i = 0; i < operationFileNames.length; i++) {
                if (!operationFileNames[i].toUpperCase().endsWith(".XML")) continue;
                log.debug("found file: " + operationFileNames[i]);
                fileCount++;
                File filein = new File(directory.getAbsolutePath() + File.separator + operationFileNames[i]);
                File fileout = new File(operationsDirectory + File.separator + operationFileNames[i]);
                FileReader in = new FileReader(filein);
                FileWriter out = new FileWriter(fileout);
                int c;
                while ((c = in.read()) != -1) out.write(c);
                in.close();
                out.close();
            }
            if (fileCount < 6) return false;
            return true;
        } catch (Exception e) {
            log.error("Exception while restoring operations files, may not be complete: " + e);
            return false;
        }
    }
} </s>
<s>class temp {    private void displayDiffResults() throws IOException {
        File outFile = File.createTempFile("diff", ".htm");
        outFile.deleteOnExit();
        FileOutputStream outStream = new FileOutputStream(outFile);
        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));
        out.write("<html><head><title>LOC Differences</title>\n" + SCRIPT + "</head>\n" + "<body bgcolor='#ffffff'>\n" + "<div onMouseOver=\"window.defaultStatus='Metrics'\">\n");
        if (addedTable.length() > 0) {
            out.write("<table border><tr><th>Files Added:</th>" + "<th>Add</th><th>Type</th></tr>");
            out.write(addedTable.toString());
            out.write("</table><br><br>");
        }
        if (modifiedTable.length() > 0) {
            out.write("<table border><tr><th>Files Modified:</th>" + "<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>" + "<th>Total</th><th>Type</th></tr>");
            out.write(modifiedTable.toString());
            out.write("</table><br><br>");
        }
        if (deletedTable.length() > 0) {
            out.write("<table border><tr><th>Files Deleted:</th>" + "<th>Del</th><th>Type</th></tr>");
            out.write(deletedTable.toString());
            out.write("</table><br><br>");
        }
        out.write("<table name=METRICS BORDER>\n");
        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {
            out.write("<tr><td>Base:&nbsp;</td><td>");
            out.write(Long.toString(base));
            out.write("</td></tr>\n<tr><td>Deleted:&nbsp;</td><td>");
            out.write(Long.toString(deleted));
            out.write("</td></tr>\n<tr><td>Modified:&nbsp;</td><td>");
            out.write(Long.toString(modified));
            out.write("</td></tr>\n<tr><td>Added:&nbsp;</td><td>");
            out.write(Long.toString(added));
            out.write("</td></tr>\n<tr><td>New & Changed:&nbsp;</td><td>");
            out.write(Long.toString(added + modified));
            out.write("</td></tr>\n");
        }
        out.write("<tr><td>Total:&nbsp;</td><td>");
        out.write(Long.toString(total));
        out.write("</td></tr>\n</table></div>");
        redlinesOut.close();
        out.flush();
        InputStream redlines = new FileInputStream(redlinesTempFile);
        byte[] buffer = new byte[4096];
        int bytesRead;
        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);
        outStream.write("</BODY></HTML>".getBytes());
        outStream.close();
        Browser.launch(outFile.toURL().toString());
    }
} </s>
<s>class temp {    public static String md5(String word) {
        MessageDigest alg = null;
        try {
            alg = MessageDigest.getInstance("MD5");
        } catch (NoSuchAlgorithmException ex) {
            Logger.getLogger(ServletUtils.class.getName()).log(Level.SEVERE, null, ex);
        }
        alg.reset();
        alg.update(word.getBytes());
        byte[] digest = alg.digest();
        StringBuilder hashedWord = new StringBuilder();
        String hx;
        for (int i = 0; i < digest.length; i++) {
            hx = Integer.toHexString(0xFF & digest[i]);
            if (hx.length() == 1) {
                hx = "0" + hx;
            }
            hashedWord.append(hx);
        }
        return hashedWord.toString();
    }
} </s>
<s>class temp {    @Override
    public void execute(String[] args) throws Exception {
        Options cmdLineOptions = getCommandOptions();
        try {
            GnuParser parser = new GnuParser();
            CommandLine commandLine = parser.parse(cmdLineOptions, TolvenPlugin.getInitArgs());
            String srcRepositoryURLString = commandLine.getOptionValue(CMD_LINE_SRC_REPOSITORYURL_OPTION);
            Plugins libraryPlugins = RepositoryMetadata.getRepositoryPlugins(new URL(srcRepositoryURLString));
            String srcPluginId = commandLine.getOptionValue(CMD_LINE_SRC_PLUGIN_ID_OPTION);
            PluginDetail plugin = RepositoryMetadata.getPluginDetail(srcPluginId, libraryPlugins);
            if (plugin == null) {
                throw new RuntimeException("Could not locate plugin: " + srcPluginId + " in repository: " + srcRepositoryURLString);
            }
            String srcPluginVersionString = commandLine.getOptionValue(CMD_LINE_SRC_PLUGIN_VERSION_OPTION);
            PluginVersionDetail srcPluginVersion = null;
            if (srcPluginVersion == null) {
                srcPluginVersion = RepositoryMetadata.getLatestVersion(plugin);
            } else {
                srcPluginVersion = RepositoryMetadata.getPluginVersionDetail(srcPluginVersionString, plugin);
            }
            if (plugin == null) {
                throw new RuntimeException("Could not find a plugin version for: " + srcPluginId + " in repository: " + srcRepositoryURLString);
            }
            String destPluginId = commandLine.getOptionValue(CMD_LINE_DEST_PLUGIN_ID_OPTION);
            FileUtils.deleteDirectory(getPluginTmpDir());
            URL srcURL = new URL(srcPluginVersion.getUri());
            File newPluginDir = new File(getPluginTmpDir(), destPluginId);
            try {
                InputStream in = null;
                FileOutputStream out = null;
                File tmpZip = new File(getPluginTmpDir(), new File(srcURL.getFile()).getName());
                try {
                    in = srcURL.openStream();
                    out = new FileOutputStream(tmpZip);
                    IOUtils.copy(in, out);
                    TolvenZip.unzip(tmpZip, newPluginDir);
                } finally {
                    if (in != null) {
                        in.close();
                    }
                    if (out != null) {
                        out.close();
                    }
                    if (tmpZip != null) {
                        tmpZip.delete();
                    }
                }
                File pluginManifestFile = new File(newPluginDir, "tolven-plugin.xml");
                if (!pluginManifestFile.exists()) {
                    throw new RuntimeException(srcURL.toExternalForm() + "has no plugin manifest");
                }
                Plugin pluginManifest = RepositoryMetadata.getPlugin(pluginManifestFile.toURI().toURL());
                pluginManifest.setId(destPluginId);
                String destPluginVersion = commandLine.getOptionValue(CMD_LINE_DEST_PLUGIN_VERSION_OPTION);
                if (destPluginVersion == null) {
                    destPluginVersion = DEFAULT_DEST_VERSION;
                }
                pluginManifest.setVersion(destPluginVersion);
                String pluginManifestXML = RepositoryMetadata.getPluginManifest(pluginManifest);
                FileUtils.writeStringToFile(pluginManifestFile, pluginManifestXML);
                File pluginFragmentManifestFile = new File(newPluginDir, "tolven-plugin-fragment.xml");
                if (pluginFragmentManifestFile.exists()) {
                    PluginFragment pluginManifestFragment = RepositoryMetadata.getPluginFragment(pluginFragmentManifestFile.toURI().toURL());
                    Requires requires = pluginManifestFragment.getRequires();
                    if (requires == null) {
                        throw new RuntimeException("No <requires> detected for plugin fragment in: " + srcURL.toExternalForm());
                    }
                    if (requires.getImport().size() != 1) {
                        throw new RuntimeException("There should be only one import for plugin fragment in: " + srcURL.toExternalForm());
                    }
                    requires.getImport().get(0).setPluginId(destPluginId);
                    requires.getImport().get(0).setPluginVersion(destPluginVersion);
                    String pluginFragmentManifestXML = RepositoryMetadata.getPluginFragmentManifest(pluginManifestFragment);
                    FileUtils.writeStringToFile(pluginFragmentManifestFile, pluginFragmentManifestXML);
                }
                String destDirname = commandLine.getOptionValue(CMD_LINE_DEST_DIR_OPTION);
                File destDir = new File(destDirname);
                File destZip = new File(destDir, destPluginId + "-" + destPluginVersion + ".zip");
                destDir.mkdirs();
                TolvenZip.zip(newPluginDir, destZip);
            } finally {
                if (newPluginDir != null) {
                    FileUtils.deleteDirectory(newPluginDir);
                }
            }
        } catch (ParseException ex) {
            HelpFormatter formatter = new HelpFormatter();
            formatter.printHelp(getClass().getName(), cmdLineOptions);
            throw new RuntimeException("Could not parse command line for: " + getClass().getName(), ex);
        }
    }
} </s>
<s>class temp {    private static void readAndRewrite(File inFile, File outFile) throws IOException {
        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));
        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);
        Dataset ds = DcmObjectFactory.getInstance().newDataset();
        dcmParser.setDcmHandler(ds.getDcmHandler());
        dcmParser.parseDcmFile(null, Tags.PixelData);
        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        System.out.println("reading " + inFile + "...");
        pdReader.readPixelData(false);
        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));
        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;
        ds.writeDataset(out, dcmEncParam);
        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());
        System.out.println("writing " + outFile + "...");
        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        pdWriter.writePixelData();
        out.flush();
        out.close();
        System.out.println("done!");
    }
} </s>
<s>class temp {    void bubbleSort(int[] a) {
        int i = 0;
        int j = a.length - 1;
        int aux = 0;
        int stop = 0;
        while (stop == 0) {
            stop = 1;
            i = 0;
            while (i < j) {
                if (a[i] > a[i + 1]) {
                    aux = a[i];
                    a[i] = a[i + 1];
                    a[i + 1] = aux;
                    stop = 0;
                }
                i = i + 1;
            }
            j = j - 1;
        }
    }
} </s>
<s>class temp {    public static final void main(String[] args) throws Exception {
        final HttpHost target = new HttpHost("issues.apache.org", 443, "https");
        final HttpHost proxy = new HttpHost("127.0.0.1", 8666, "http");
        setup();
        HttpClient client = createHttpClient();
        client.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, proxy);
        HttpRequest req = createRequest();
        System.out.println("executing request to " + target + " via " + proxy);
        HttpEntity entity = null;
        try {
            HttpResponse rsp = client.execute(target, req);
            entity = rsp.getEntity();
            System.out.println("----------------------------------------");
            System.out.println(rsp.getStatusLine());
            Header[] headers = rsp.getAllHeaders();
            for (int i = 0; i < headers.length; i++) {
                System.out.println(headers[i]);
            }
            System.out.println("----------------------------------------");
            if (rsp.getEntity() != null) {
                System.out.println(EntityUtils.toString(rsp.getEntity()));
            }
        } finally {
            if (entity != null) entity.consumeContent();
        }
    }
} </s>
<s>class temp {    private ArrayList<String> getFiles(String date) {
        ArrayList<String> files = new ArrayList<String>();
        String info = "";
        try {
            obtainServerFilesView.setLblProcessText(java.util.ResourceBundle.getBundle("bgpanalyzer/resources/Bundle").getString("ObtainServerFilesView.Label.Progress.Obtaining_Data"));
            URL url = new URL(URL_ROUTE_VIEWS + date + "/");
            URLConnection conn = url.openConnection();
            conn.setDoOutput(false);
            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));
            String line;
            while ((line = rd.readLine()) != null) {
                if (!line.equals("")) info += line + "%";
            }
            obtainServerFilesView.setLblProcessText(java.util.ResourceBundle.getBundle("bgpanalyzer/resources/Bundle").getString("ObtainServerFilesView.Label.Progress.Processing_Data"));
            info = Patterns.removeTags(info);
            StringTokenizer st = new StringTokenizer(info, "%");
            info = "";
            boolean alternador = false;
            int index = 1;
            while (st.hasMoreTokens()) {
                String token = st.nextToken();
                if (!token.trim().equals("")) {
                    int pos = token.indexOf(".bz2");
                    if (pos != -1) {
                        token = token.substring(1, pos + 4);
                        files.add(token);
                    }
                }
            }
            rd.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return files;
    }
} </s>
<s>class temp {    private ArrayList<String> getYearsAndMonths() {
        String info = "";
        ArrayList<String> items = new ArrayList<String>();
        try {
            obtainServerFilesView.setLblProcessText(java.util.ResourceBundle.getBundle("bgpanalyzer/resources/Bundle").getString("ObtainServerFilesView.Label.Progress.Obtaining_Data"));
            URL url = new URL(URL_ROUTE_VIEWS);
            URLConnection conn = url.openConnection();
            conn.setDoOutput(false);
            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));
            String line;
            while ((line = rd.readLine()) != null) {
                if (!line.equals("")) info += line + "%";
            }
            obtainServerFilesView.setLblProcessText(java.util.ResourceBundle.getBundle("bgpanalyzer/resources/Bundle").getString("ObtainServerFilesView.Label.Progress.Processing_Data"));
            info = Patterns.removeTags(info);
            StringTokenizer st = new StringTokenizer(info, "%");
            info = "";
            boolean alternador = false;
            int index = 1;
            while (st.hasMoreTokens()) {
                String token = st.nextToken();
                if (!token.trim().equals("")) {
                    int pos = token.indexOf("/");
                    if (pos != -1) {
                        token = token.substring(1, pos);
                        if (Patterns.hasFormatYYYYdotMM(token)) {
                            items.add(token);
                        }
                    }
                }
            }
            rd.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return items;
    }
} </s>
<s>class temp {    private void copyFile(String file) {
        FileChannel inChannel = null;
        FileChannel outChannel = null;
        try {
            Date dt = new Date();
            SimpleDateFormat df = new SimpleDateFormat("yyyyMMdd HHmmss ");
            File in = new File(file);
            String[] name = file.split("\\\\");
            File out = new File(".\\xml_archiv\\" + df.format(dt) + name[name.length - 1]);
            inChannel = new FileInputStream(in).getChannel();
            outChannel = new FileOutputStream(out).getChannel();
            inChannel.transferTo(0, inChannel.size(), outChannel);
        } catch (IOException e) {
            System.err.println("Copy error!");
            System.err.println("Error: " + e.getMessage());
        } finally {
            if (inChannel != null) {
                try {
                    inChannel.close();
                } catch (IOException ex) {
                    Logger.getLogger(ImportIntoDb.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
            if (outChannel != null) {
                try {
                    outChannel.close();
                } catch (IOException ex) {
                    Logger.getLogger(ImportIntoDb.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
        }
    }
} </s>
<s>class temp {    public static void streamCopyFile(File srcFile, File destFile) {
        try {
            FileInputStream fi = new FileInputStream(srcFile);
            FileOutputStream fo = new FileOutputStream(destFile);
            byte[] buf = new byte[1024];
            int readLength = 0;
            while (readLength != -1) {
                readLength = fi.read(buf);
                if (readLength != -1) {
                    fo.write(buf, 0, readLength);
                }
            }
            fo.close();
            fi.close();
        } catch (Exception e) {
        }
    }
} </s>
<s>class temp {    public Document retrieveDefinition(String uri) throws IOException, UnvalidResponseException {
        if (!isADbPediaURI(uri)) throw new IllegalArgumentException("Not a DbPedia Resource URI");
        String rawDataUri = fromResourceToRawDataUri(uri);
        URL url = new URL(rawDataUri);
        URLConnection conn = url.openConnection();
        logger.debug(".conn open");
        conn.setDoOutput(true);
        BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));
        logger.debug(".resp obtained");
        StringBuffer responseBuffer = new StringBuffer();
        String line;
        while ((line = rd.readLine()) != null) {
            responseBuffer.append(line);
            responseBuffer.append(NEWLINE);
        }
        rd.close();
        logger.debug(".done");
        try {
            return documentParser.parse(responseBuffer.toString());
        } catch (SAXException e) {
            throw new UnvalidResponseException("Incorrect XML document", e);
        }
    }
} </s>
<s>class temp {    public void getLyricsFromMAWebSite(TrackMABean tb) throws Exception {
        URL fileURL = new URL("http://www.metal-archives.com/viewlyrics.php?id=" + tb.getMaid());
        URLConnection urlConnection = fileURL.openConnection();
        InputStream httpStream = urlConnection.getInputStream();
        BufferedReader br = new BufferedReader(new InputStreamReader(httpStream, "ISO-8859-1"));
        String ligne;
        boolean chargerLyrics = false;
        StringBuffer sb = new StringBuffer("");
        String lyrics = null;
        while ((ligne = br.readLine()) != null) {
            log.debug("==> " + ligne);
            if (chargerLyrics && ligne.indexOf("<center>") != -1) {
                break;
            }
            if (chargerLyrics) {
                sb.append(ligne.trim());
            }
            if (!chargerLyrics && ligne.indexOf("<center>") != -1) {
                chargerLyrics = true;
            }
        }
        lyrics = sb.toString();
        lyrics = lyrics.replaceAll("<br>", "\n").trim();
        log.debug("Parole : " + lyrics);
        tb.setLyrics(lyrics);
        br.close();
        httpStream.close();
    }
} </s>
<s>class temp {    public List<DemandeChargement> getArtistToLoadFromWiki() throws Exception {
        URL fileURL = new URL("http://beastchild.free.fr/wiki/doku.php?id=music");
        URLConnection urlConnection = fileURL.openConnection();
        InputStream httpStream = urlConnection.getInputStream();
        BufferedReader br = new BufferedReader(new InputStreamReader(httpStream, "ISO-8859-1"));
        String ligne;
        List<DemandeChargement> dem = new ArrayList<DemandeChargement>();
        while ((ligne = br.readLine()) != null) {
            if (ligne.indexOf("&lt;@@@&gt;") != -1) {
                String maidS = ligne.substring(ligne.indexOf("&lt;@@@&gt;") + 11, ligne.indexOf("&lt;/@@@&gt;")).trim();
                try {
                    long maid = Long.parseLong(maidS);
                    log.info("MAID to load : " + maid);
                    dem.add(new DemandeChargement(maid));
                } catch (Exception e) {
                    log.error("Impossible de recuperer le MAID : " + maidS);
                }
            }
        }
        br.close();
        httpStream.close();
        return dem;
    }
} </s>
<s>class temp {    private String getLatestVersion(URL url) throws IOException {
        HttpURLConnection con = (HttpURLConnection) url.openConnection();
        con.connect();
        BufferedReader br = new BufferedReader(new InputStreamReader(new BufferedInputStream(con.getInputStream())));
        String lines = "";
        String line = null;
        while ((line = br.readLine()) != null) {
            lines += line;
        }
        con.disconnect();
        return lines;
    }
} </s>
<s>class temp {    public static boolean sendPostRequest(String path, Map<String, String> params, String encoding) throws Exception {
        StringBuilder sb = new StringBuilder("");
        if (params != null && !params.isEmpty()) {
            for (Map.Entry<String, String> entry : params.entrySet()) {
                sb.append(entry.getKey()).append('=').append(URLEncoder.encode(entry.getValue(), encoding)).append('&');
            }
            sb.deleteCharAt(sb.length() - 1);
        }
        byte[] data = sb.toString().getBytes();
        URL url = new URL(path);
        HttpURLConnection conn = (HttpURLConnection) url.openConnection();
        conn.setRequestMethod("POST");
        conn.setConnectTimeout(5 * 1000);
        conn.setDoOutput(true);
        conn.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");
        conn.setRequestProperty("Content-Length", String.valueOf(data.length));
        OutputStream outStream = conn.getOutputStream();
        outStream.write(data);
        outStream.flush();
        outStream.close();
        if (conn.getResponseCode() == 200) {
            InputStream inputStream = conn.getInputStream();
            return ResponseResult.parseXML(inputStream);
        }
        return false;
    }
} </s>
<s>class temp {    public void run() {
        String s, s2;
        s = "";
        s2 = "";
        try {
            URL url = new URL("http://www.m-w.com/dictionary/" + Word);
            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));
            String str;
            while (((str = in.readLine()) != null) && (!stopped)) {
                s = s + str;
            }
            in.close();
        } catch (MalformedURLException e) {
        } catch (IOException e) {
        }
        Pattern pattern = Pattern.compile("popWin\\('/cgi-bin/(.+?)'", Pattern.CASE_INSENSITIVE | Pattern.DOTALL);
        Matcher matcher = pattern.matcher(s);
        if ((!stopped) && (matcher.find())) {
            String newurl = "http://m-w.com/cgi-bin/" + matcher.group(1);
            try {
                URL url2 = new URL(newurl);
                BufferedReader in2 = new BufferedReader(new InputStreamReader(url2.openStream()));
                String str;
                while (((str = in2.readLine()) != null) && (!stopped)) {
                    s2 = s2 + str;
                }
                in2.close();
            } catch (MalformedURLException e) {
            } catch (IOException e) {
            }
            Pattern pattern2 = Pattern.compile("<A HREF=\"http://(.+?)\">Click here to listen with your default audio player", Pattern.CASE_INSENSITIVE | Pattern.DOTALL);
            Matcher matcher2 = pattern2.matcher(s2);
            if ((!stopped) && (matcher2.find())) {
                if (getWave("http://" + matcher2.group(1))) label.setEnabled(true);
            }
        }
        button.setEnabled(true);
    }
} </s>
<s>class temp {    public static String[] parsePLS(String strURL, Context c) {
        URL url;
        URLConnection urlConn = null;
        String TAG = "parsePLS";
        Vector<String> radio = new Vector<String>();
        final String filetoken = "file";
        final String SPLITTER = "=";
        try {
            url = new URL(strURL);
            urlConn = url.openConnection();
            Log.d(TAG, "Got data");
        } catch (IOException ioe) {
            Log.e(TAG, "Could not connect to " + strURL);
        }
        try {
            DataInputStream in = new DataInputStream(urlConn.getInputStream());
            BufferedReader br = new BufferedReader(new InputStreamReader(in));
            String strLine;
            while ((strLine = br.readLine()) != null) {
                String temp = strLine.toLowerCase();
                Log.d(TAG, strLine);
                if (temp.startsWith(filetoken)) {
                    String[] s = Pattern.compile(SPLITTER).split(temp);
                    radio.add(s[1]);
                    Log.d(TAG, "Found audio " + s[1]);
                }
            }
            br.close();
            in.close();
        } catch (Exception e) {
            Log.e(TAG, "Trouble reading file: " + e.getMessage());
        }
        String[] t = new String[0];
        String[] r = null;
        if (radio.size() != 0) {
            r = (String[]) radio.toArray(t);
            Log.d(TAG, "Found total: " + String.valueOf(r.length));
        }
        return r;
    }
} </s>
<s>class temp {    public static String[] parseM3U(String strURL, Context c) {
        URL url;
        URLConnection urlConn = null;
        String TAG = "parseM3U";
        Vector<String> radio = new Vector<String>();
        final String filetoken = "http";
        try {
            url = new URL(strURL);
            urlConn = url.openConnection();
            Log.d(TAG, "Got data");
        } catch (IOException ioe) {
            Log.e(TAG, "Could not connect to " + strURL);
        }
        try {
            DataInputStream in = new DataInputStream(urlConn.getInputStream());
            BufferedReader br = new BufferedReader(new InputStreamReader(in));
            String strLine;
            while ((strLine = br.readLine()) != null) {
                String temp = strLine.toLowerCase();
                Log.d(TAG, strLine);
                if (temp.startsWith(filetoken)) {
                    radio.add(temp);
                    Log.d(TAG, "Found audio " + temp);
                }
            }
            br.close();
            in.close();
        } catch (Exception e) {
            Log.e(TAG, "Trouble reading file: " + e.getMessage());
        }
        String[] t = new String[0];
        String[] r = null;
        if (radio.size() != 0) {
            r = (String[]) radio.toArray(t);
            Log.d(TAG, "Found total: " + String.valueOf(r.length));
        }
        return r;
    }
} </s>
<s>class temp {    public static Object GET(String url, String[][] props) throws IOException {
        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();
        conn.setRequestMethod("GET");
        for (int i = 0; i < props.length; ++i) {
            conn.addRequestProperty(props[i][0], URLEncoder.encode(props[i][1], "UTF-8"));
        }
        conn.connect();
        try {
            return conn.getContent();
        } finally {
            conn.disconnect();
        }
    }
} </s>
<s>class temp {    public static String POST(String url, String[][] props) throws IOException {
        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();
        conn.setRequestMethod("POST");
        for (int i = 0; i < props.length; ++i) {
            conn.addRequestProperty(props[i][0], props[i][1]);
        }
        conn.connect();
        try {
            return new String((byte[]) conn.getContent());
        } finally {
            conn.disconnect();
        }
    }
} </s>
<s>class temp {    public static long getLastModified(URL url) throws IOException {
        if ("file".equals(url.getProtocol())) {
            String externalForm = url.toExternalForm();
            File file = new File(externalForm.substring(5));
            return file.lastModified();
        } else {
            URLConnection connection = url.openConnection();
            long modified = connection.getLastModified();
            try {
                InputStream is = connection.getInputStream();
                if (is != null) is.close();
            } catch (UnknownServiceException use) {
            } catch (IOException ioe) {
            }
            return modified;
        }
    }
} </s>
<s>class temp {    public void test(TestHarness harness) {
        harness.checkPoint("TestOfMD4");
        try {
            Security.addProvider(new JarsyncProvider());
            algorithm = MessageDigest.getInstance("MD4", "JARSYNC");
        } catch (Exception x) {
            harness.debug(x);
            harness.fail("TestOfMD4.provider");
            throw new Error(x);
        }
        try {
            for (int i = 0; i < 64; i++) algorithm.update((byte) 'a');
            byte[] md = algorithm.digest();
            String exp = "52f5076fabd22680234a3fa9f9dc5732";
            harness.check(exp.equals(Util.toHexString(md)), "testSixtyFourA");
        } catch (Exception x) {
            harness.debug(x);
            harness.fail("TestOfMD4.provider");
        }
        try {
            harness.verbose("NOTE: This test may take a while.");
            for (int i = 0; i < 536870913; i++) algorithm.update((byte) 'a');
            byte[] md = algorithm.digest();
            String exp = "47d01fa6657f903280232d30b98da482";
            harness.check(exp.equals(Util.toHexString(md)), "test536870913A");
        } catch (Exception x) {
            harness.debug(x);
            harness.fail("TestOfMD4.provider");
        }
        try {
            byte[] md = algorithm.digest("a".getBytes());
            String exp = "bde52cb31de33e46245e05fbdbd6fb24";
            harness.check(exp.equals(Util.toHexString(md)), "testA");
        } catch (Exception x) {
            harness.debug(x);
            harness.fail("TestOfMD4.testA");
        }
        try {
            byte[] md = algorithm.digest("abc".getBytes());
            String exp = "a448017aaf21d8525fc10ae87aa6729d";
            harness.check(exp.equals(Util.toHexString(md)), "testABC");
        } catch (Exception x) {
            harness.debug(x);
            harness.fail("TestOfMD4.testABC");
        }
        try {
            byte[] md = algorithm.digest("message digest".getBytes());
            String exp = "d9130a8164549fe818874806e1c7014b";
            harness.check(exp.equals(Util.toHexString(md)), "testMessageDigest");
        } catch (Exception x) {
            harness.debug(x);
            harness.fail("TestOfMD4.testMessageDigest");
        }
        try {
            byte[] md = algorithm.digest("abcdefghijklmnopqrstuvwxyz".getBytes());
            String exp = "d79e1c308aa5bbcdeea8ed63df412da9";
            harness.check(exp.equals(Util.toHexString(md)), "testAlphabet");
        } catch (Exception x) {
            harness.debug(x);
            harness.fail("TestOfMD4.testAlphabet");
        }
        try {
            byte[] md = algorithm.digest("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".getBytes());
            String exp = "043f8582f241db351ce627e153e7f0e4";
            harness.check(exp.equals(Util.toHexString(md)), "testAsciiSubset");
        } catch (Exception x) {
            harness.debug(x);
            harness.fail("TestOfMD4.testAsciiSubset");
        }
        try {
            byte[] md = algorithm.digest("12345678901234567890123456789012345678901234567890123456789012345678901234567890".getBytes());
            String exp = "e33b4ddc9c38f2199c3e7b164fcc0536";
            harness.check(exp.equals(Util.toHexString(md)), "testEightyNumerics");
        } catch (Exception x) {
            harness.debug(x);
            harness.fail("TestOfMD4.testEightyNumerics");
        }
        try {
            algorithm.update("a".getBytes(), 0, 1);
            clone = (MessageDigest) algorithm.clone();
            byte[] md = algorithm.digest();
            String exp = "bde52cb31de33e46245e05fbdbd6fb24";
            harness.check(exp.equals(Util.toHexString(md)), "testCloning #1");
            clone.update("bc".getBytes(), 0, 2);
            md = clone.digest();
            exp = "a448017aaf21d8525fc10ae87aa6729d";
            harness.check(exp.equals(Util.toHexString(md)), "testCloning #2");
        } catch (Exception x) {
            harness.debug(x);
            harness.fail("TestOfMD4.testCloning");
        }
    }
} </s>
<s>class temp {    private static void readAndRewrite(File inFile, File outFile) throws IOException {
        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));
        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);
        Dataset ds = DcmObjectFactory.getInstance().newDataset();
        dcmParser.setDcmHandler(ds.getDcmHandler());
        dcmParser.parseDcmFile(null, Tags.PixelData);
        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        System.out.println("reading " + inFile + "...");
        pdReader.readPixelData(false);
        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));
        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;
        ds.writeDataset(out, dcmEncParam);
        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());
        System.out.println("writing " + outFile + "...");
        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        pdWriter.writePixelData();
        out.flush();
        out.close();
        System.out.println("done!");
    }
} </s>
<s>class temp {    public static String calcolaMd5(String messaggio) {
        MessageDigest md;
        try {
            md = MessageDigest.getInstance("MD5");
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        }
        md.reset();
        md.update(messaggio.getBytes());
        byte[] impronta = md.digest();
        return new String(impronta);
    }
} </s>
<s>class temp {    private static byte[] createMD5(String seed) throws UnsupportedEncodingException, NoSuchAlgorithmException {
        MessageDigest md5 = MessageDigest.getInstance("MD5");
        md5.reset();
        md5.update(seed.getBytes("UTF-8"));
        return md5.digest();
    }
} </s>
<s>class temp {    public static final String hash(String data) {
        if (digest == null) {
            synchronized (StringUtils.class) {
                if (digest == null) {
                    try {
                        digest = MessageDigest.getInstance("MD5");
                    } catch (NoSuchAlgorithmException nsae) {
                    }
                }
            }
        }
        digest.update(data.getBytes());
        return toHex(digest.digest());
    }
} </s>
<s>class temp {    public static String SHAEncrypt(String originalString) {
        String encryptedString = new String("");
        try {
            MessageDigest md = MessageDigest.getInstance("SHA-1");
            md.update(originalString.getBytes());
            byte b[] = md.digest();
            for (int i = 0; i < b.length; i++) {
                char[] digit = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
                char[] ob = new char[2];
                ob[0] = digit[(b[i] >>> 4) & 0X0F];
                ob[1] = digit[b[i] & 0X0F];
                encryptedString += new String(ob);
            }
        } catch (NoSuchAlgorithmException nsae) {
            System.out.println("the algorithm doesn't exist");
        }
        return encryptedString;
    }
} </s>
<s>class temp {    public static String MD5Encrypt(String OriginalString) {
        String encryptedString = new String("");
        try {
            MessageDigest md = MessageDigest.getInstance("MD5");
            md.update(OriginalString.getBytes());
            byte b[] = md.digest();
            for (int i = 0; i < b.length; i++) {
                char[] digit = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
                char[] ob = new char[2];
                ob[0] = digit[(b[i] >>> 4) & 0X0F];
                ob[1] = digit[b[i] & 0X0F];
                encryptedString += new String(ob);
            }
        } catch (NoSuchAlgorithmException nsae) {
            System.out.println("the algorithm doesn't exist");
        }
        return encryptedString;
    }
} </s>
<s>class temp {    public void convert(File src, File dest) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(src));
        DcmParser p = pfact.newDcmParser(in);
        Dataset ds = fact.newDataset();
        p.setDcmHandler(ds.getDcmHandler());
        try {
            FileFormat format = p.detectFileFormat();
            if (format != FileFormat.ACRNEMA_STREAM) {
                System.out.println("\n" + src + ": not an ACRNEMA stream!");
                return;
            }
            p.parseDcmFile(format, Tags.PixelData);
            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {
                System.out.println("\n" + src + ": contains UIDs!" + " => probable already DICOM - do not convert");
                return;
            }
            boolean hasPixelData = p.getReadTag() == Tags.PixelData;
            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;
            int pxlen = p.getReadLength();
            if (hasPixelData) {
                if (inflate) {
                    ds.putUS(Tags.BitsAllocated, 16);
                    pxlen = pxlen * 4 / 3;
                }
                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {
                    System.out.println("\n" + src + ": mismatch pixel data length!" + " => do not convert");
                    return;
                }
            }
            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));
            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));
            ds.putUI(Tags.SOPInstanceUID, uid(instUID));
            ds.putUI(Tags.SOPClassUID, classUID);
            if (!ds.contains(Tags.NumberOfSamples)) {
                ds.putUS(Tags.NumberOfSamples, 1);
            }
            if (!ds.contains(Tags.PhotometricInterpretation)) {
                ds.putCS(Tags.PhotometricInterpretation, "MONOCHROME2");
            }
            if (fmi) {
                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));
            }
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
            try {
            } finally {
                ds.writeFile(out, encodeParam());
                if (hasPixelData) {
                    if (!skipGroupLen) {
                        out.write(PXDATA_GROUPLEN);
                        int grlen = pxlen + 8;
                        out.write((byte) grlen);
                        out.write((byte) (grlen >> 8));
                        out.write((byte) (grlen >> 16));
                        out.write((byte) (grlen >> 24));
                    }
                    out.write(PXDATA_TAG);
                    out.write((byte) pxlen);
                    out.write((byte) (pxlen >> 8));
                    out.write((byte) (pxlen >> 16));
                    out.write((byte) (pxlen >> 24));
                }
                if (inflate) {
                    int b2, b3;
                    for (; pxlen > 0; pxlen -= 3) {
                        out.write(in.read());
                        b2 = in.read();
                        b3 = in.read();
                        out.write(b2 & 0x0f);
                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));
                        out.write(b3 >> 4);
                    }
                } else {
                    for (; pxlen > 0; --pxlen) {
                        out.write(in.read());
                    }
                }
                out.close();
            }
            System.out.print('.');
        } finally {
            in.close();
        }
    }
} </s>
<s>class temp {    public static String generateHashSE(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException, DigestException {
        MessageDigest md;
        md = MessageDigest.getInstance("SHA-256");
        byte[] hashSHA256 = new byte[32];
        md.update(text.getBytes("iso-8859-1"), 0, text.length());
        md.digest(hashSHA256, 0, text.length());
        return convertToHex(hashSHA256);
    }
} </s>
<s>class temp {    public static String generateHash(String message) throws NoSuchAlgorithmException, UnsupportedEncodingException, DigestException {
        MessageDigest digest;
        digest = MessageDigest.getInstance("SHA-1");
        digest.reset();
        digest.update(message.getBytes("iso-8859-1"), 0, message.length());
        byte[] output = new byte[20];
        digest.digest(output, 0, output.length);
        return convertToHex(output);
    }
} </s>
<s>class temp {    private void zipFiles(File file, File[] fa) throws Exception {
        File f = new File(file, ALL_FILES_NAME);
        if (f.exists()) {
            f.delete();
            f = new File(file, ALL_FILES_NAME);
        }
        ZipOutputStream zoutstrm = new ZipOutputStream(new FileOutputStream(f));
        for (int i = 0; i < fa.length; i++) {
            ZipEntry zipEntry = new ZipEntry(fa[i].getName());
            zoutstrm.putNextEntry(zipEntry);
            FileInputStream fr = new FileInputStream(fa[i]);
            byte[] buffer = new byte[1024];
            int readCount = 0;
            while ((readCount = fr.read(buffer)) > 0) {
                zoutstrm.write(buffer, 0, readCount);
            }
            fr.close();
            zoutstrm.closeEntry();
        }
        zoutstrm.close();
        log("created zip file: " + file.getName() + "/" + ALL_FILES_NAME);
    }
} </s>
<s>class temp {    public Gif(URL url) throws BadElementException, IOException {
        super(url);
        type = GIF;
        InputStream is = null;
        try {
            is = url.openStream();
            if (is.read() != 'G' || is.read() != 'I' || is.read() != 'F') {
                throw new BadElementException(url.toString() + " is not a valid GIF-file.");
            }
            skip(is, 3);
            scaledWidth = is.read() + (is.read() << 8);
            setRight((int) scaledWidth);
            scaledHeight = is.read() + (is.read() << 8);
            setTop((int) scaledHeight);
        } finally {
            if (is != null) {
                is.close();
            }
            plainWidth = width();
            plainHeight = height();
        }
    }
} </s>
<s>class temp {    private String getStreamUrl(String adress) throws MalformedURLException, IOException, ParserConfigurationException, SAXException {
        URL url = new URL(adress);
        InputStream is = url.openStream();
        DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
        org.w3c.dom.Document doc = builder.parse(is);
        Node linkTag = doc.getElementsByTagName(LINK_TAG_NAME).item(0);
        String StreamUrl = linkTag.getAttributes().getNamedItem(LINK_ATTR_NAME).getNodeValue();
        return StreamUrl;
    }
} </s>
<s>class temp {    private static byte[] readBytes(URL url) throws IOException {
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        byte[] buf = new byte[8192];
        InputStream in = url.openStream();
        try {
            int readlen;
            while ((readlen = in.read(buf)) > 0) bos.write(buf, 0, readlen);
        } finally {
            in.close();
        }
        return bos.toByteArray();
    }
} </s>
<s>class temp {    public static void parse(URL url, ContentHandler handler) {
        InputStream input = null;
        try {
            input = url.openStream();
            SAXParser parser = createSaxParser();
            XMLReader reader = parser.getXMLReader();
            reader.setContentHandler(handler);
            reader.parse(new InputSource(input));
        } catch (SAXException e) {
            throw new XmlException("Could not parse xml", e);
        } catch (IOException e) {
            throw new XmlException("Could not parse xml", e);
        } finally {
            if (input != null) {
                try {
                    input.close();
                } catch (IOException e) {
                }
            }
        }
    }
} </s>
<s>class temp {    public void setTableBraille(String tableBraille, boolean sys) {
        fiConf.setProperty(OptNames.fi_braille_table, tableBraille);
        fiConf.setProperty(OptNames.fi_is_sys_braille_table, Boolean.toString(sys));
        FileChannel in = null;
        FileChannel out = null;
        try {
            String fichTable;
            if (!(tableBraille.endsWith(".ent"))) {
                tableBraille = tableBraille + ".ent";
            }
            if (sys) {
                fichTable = ConfigNat.getInstallFolder() + "xsl/tablesBraille/" + tableBraille;
            } else {
                fichTable = ConfigNat.getUserBrailleTableFolder() + tableBraille;
            }
            in = new FileInputStream(fichTable).getChannel();
            out = new FileOutputStream(getUserBrailleTableFolder() + "Brltab.ent").getChannel();
            in.transferTo(0, in.size(), out);
            in.close();
            out.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
} </s>
<s>class temp {    @Override
    public DataTable generateDataTable(Query query, HttpServletRequest request) throws DataSourceException {
        String url = request.getParameter(URL_PARAM_NAME);
        if (StringUtils.isEmpty(url)) {
            log.error("url parameter not provided.");
            throw new DataSourceException(ReasonType.INVALID_REQUEST, "url parameter not provided");
        }
        Reader reader;
        try {
            reader = new BufferedReader(new InputStreamReader(new URL(url).openStream()));
        } catch (MalformedURLException e) {
            log.error("url is malformed: " + url);
            throw new DataSourceException(ReasonType.INVALID_REQUEST, "url is malformed: " + url);
        } catch (IOException e) {
            log.error("Couldn't read from url: " + url, e);
            throw new DataSourceException(ReasonType.INVALID_REQUEST, "Couldn't read from url: " + url);
        }
        DataTable dataTable = null;
        ULocale requestLocale = DataSourceHelper.getLocaleFromRequest(request);
        try {
            dataTable = CsvDataSourceHelper.read(reader, null, true, requestLocale);
        } catch (IOException e) {
            log.error("Couldn't read from url: " + url, e);
            throw new DataSourceException(ReasonType.INVALID_REQUEST, "Couldn't read from url: " + url);
        }
        return dataTable;
    }
} </s>
<s>class temp {    public String get(String url) {
        String buf = null;
        StringBuilder resultBuffer = new StringBuilder(512);
        if (debug.DEBUG) debug.logger("gov.llnl.tox.util.href", "get(url)>> " + url);
        try {
            URL theURL = new URL(url);
            URLConnection urlConn = theURL.openConnection();
            urlConn.setDoOutput(true);
            urlConn.setReadTimeout(timeOut);
            BufferedReader urlReader = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));
            do {
                buf = urlReader.readLine();
                if (buf != null) {
                    resultBuffer.append(buf);
                    resultBuffer.append("\n");
                }
            } while (buf != null);
            urlReader.close();
            if (debug.DEBUG) debug.logger("gov.llnl.tox.util.href", "get(output)>> " + resultBuffer.toString());
            int xmlNdx = resultBuffer.lastIndexOf("?>");
            if (xmlNdx == -1) result = resultBuffer.toString(); else result = resultBuffer.substring(xmlNdx + 2);
        } catch (Exception e) {
            result = debug.logger("gov.llnl.tox.util.href", "error: get >> ", e);
        }
        return (result);
    }
} </s>
<s>class temp {    public String excute(String targetUrl, String params, String type) {
        URL url;
        HttpURLConnection connection = null;
        try {
            url = new URL(targetUrl);
            connection = (HttpURLConnection) url.openConnection();
            connection.setRequestMethod(type);
            connection.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");
            connection.setRequestProperty("Content-Length", "" + Integer.toString(params.getBytes().length));
            connection.setRequestProperty("Content-Language", CHAR_SET);
            connection.setRequestProperty("Connection", "close");
            connection.setUseCaches(false);
            connection.setDoInput(true);
            connection.setDoOutput(true);
            if (params != null) {
                if (params.length() > 0) {
                    DataOutputStream wr;
                    wr = new DataOutputStream(connection.getOutputStream());
                    wr.writeBytes(params);
                    wr.flush();
                    wr.close();
                }
            }
            InputStream is = connection.getInputStream();
            BufferedReader rd = new BufferedReader(new InputStreamReader(is, CHAR_SET));
            String line;
            StringBuffer response = new StringBuffer();
            while ((line = rd.readLine()) != null) {
                response.append(line);
                response.append("\r\n");
            }
            rd.close();
            return response.toString();
        } catch (MalformedURLException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }
} </s>
<s>class temp {    public synchronized void deleteDocument(final String file) throws IOException {
        SQLException ex = null;
        try {
            PreparedStatement findFileStmt = con.prepareStatement("SELECT ID AS \"ID\" FROM File_ WHERE Name = ?");
            findFileStmt.setString(1, file);
            ResultSet rs = findFileStmt.executeQuery();
            if (null != rs && rs.next()) {
                int fileId = rs.getInt("ID");
                rs.close();
                rs = null;
                PreparedStatement deleteTokensStmt = con.prepareStatement("DELETE FROM Token_ WHERE FieldID IN ( SELECT ID FROM Field_ WHERE FileID = ? )");
                deleteTokensStmt.setInt(1, fileId);
                deleteTokensStmt.executeUpdate();
                PreparedStatement deleteFieldsStmt = con.prepareStatement("DELETE FROM Field_ WHERE FileID = ?");
                deleteFieldsStmt.setInt(1, fileId);
                deleteFieldsStmt.executeUpdate();
                PreparedStatement deleteFileStmt = con.prepareStatement("DELETE FROM File_ WHERE ID = ?");
                deleteFileStmt.setInt(1, fileId);
                deleteFileStmt.executeUpdate();
                deleteFileStmt.close();
                deleteFileStmt = null;
                deleteFieldsStmt.close();
                deleteFieldsStmt = null;
                deleteTokensStmt.close();
                deleteTokensStmt = null;
            }
            findFileStmt.close();
            findFileStmt = null;
        } catch (SQLException e) {
            e.printStackTrace();
            ex = e;
            try {
                this.con.rollback();
            } catch (SQLException e2) {
            }
        } finally {
            try {
                this.con.setAutoCommit(true);
            } catch (SQLException e2) {
            }
        }
        if (null != ex) throw new IOException(ex.getMessage());
    }
} </s>
<s>class temp {    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String zOntoJsonApiUrl = getInitParameter("zOntoJsonApiServletUrl");
        URL url = new URL(zOntoJsonApiUrl + "?" + req.getQueryString());
        resp.setContentType("text/html");
        InputStreamReader bf = new InputStreamReader(url.openStream());
        BufferedReader bbf = new BufferedReader(bf);
        String response = "";
        String line = bbf.readLine();
        PrintWriter out = resp.getWriter();
        while (line != null) {
            response += line;
            line = bbf.readLine();
        }
        out.print(response);
        out.close();
    }
} </s>
<s>class temp {    public String[] list() {
        if (isURL) {
            if (!isDirectory()) return null;
            try {
                URLConnection c = url.openConnection();
                InputStream is = c.getInputStream();
                boolean foundEnd = false;
                Vector files = new Vector();
                while (!foundEnd) {
                    byte[] b = new byte[is.available()];
                    String s = new String(b);
                    if (s.toLowerCase().indexOf("</html>") != -1) foundEnd = true;
                    while (s.indexOf("a href") != -1) {
                        int ndx = s.indexOf("a href") + 8;
                        String f = s.substring(ndx, s.indexOf("\"", ndx));
                        s = s.substring(s.indexOf("\"", ndx) + 1);
                        Location check = new Location(getAbsolutePath(), f);
                        if (check.exists()) {
                            files.add(check.getName());
                        }
                    }
                }
                return (String[]) files.toArray(new String[0]);
            } catch (IOException e) {
                return null;
            }
        }
        return file.list();
    }
} </s>
<s>class temp {    public static void zipFile(String file, String entry) throws IOException {
        FileInputStream in = new FileInputStream(file);
        ZipOutputStream out = new ZipOutputStream(new FileOutputStream(file + ".zip"));
        out.putNextEntry(new ZipEntry(entry));
        byte[] buffer = new byte[4096];
        int bytes_read;
        while ((bytes_read = in.read(buffer)) != -1) out.write(buffer, 0, bytes_read);
        in.close();
        out.closeEntry();
        out.close();
        File fin = new File(file);
        fin.delete();
    }
} </s>
<s>class temp {    public static InputStream getResourceAsStream(final String fileName) {
        if ((fileName.indexOf("file:") >= 0) || (fileName.indexOf(":/") > 0)) {
            try {
                URL url = new URL(fileName);
                return new BufferedInputStream(url.openStream());
            } catch (Exception e) {
                return null;
            }
        }
        return new ByteArrayInputStream(getResource(fileName).getData());
    }
} </s>
<s>class temp {    public static InputStream getNotCacheResourceAsStream(final String fileName) {
        if ((fileName.indexOf("file:") >= 0) || (fileName.indexOf(":/") > 0)) {
            try {
                URL url = new URL(fileName);
                return new BufferedInputStream(url.openStream());
            } catch (Exception e) {
                return null;
            }
        }
        return new ByteArrayInputStream(getNotCacheResource(fileName).getData());
    }
} </s>
<s>class temp {    public static final byte[] getHttpStream(final String uri) {
        URL url;
        try {
            url = new URL(uri);
        } catch (Exception e) {
            return null;
        }
        InputStream is = null;
        try {
            is = url.openStream();
        } catch (Exception e) {
            return null;
        }
        ByteArrayOutputStream os = new ByteArrayOutputStream();
        byte[] arrayByte = null;
        try {
            arrayByte = new byte[4096];
            int read;
            while ((read = is.read(arrayByte)) >= 0) {
                os.write(arrayByte, 0, read);
            }
            arrayByte = os.toByteArray();
        } catch (IOException e) {
            return null;
        } finally {
            try {
                if (os != null) {
                    os.close();
                    os = null;
                }
                if (is != null) {
                    is.close();
                    is = null;
                }
            } catch (IOException e) {
            }
        }
        return arrayByte;
    }
} </s>
<s>class temp {    private JSONObject executeHttpGet(String uri) throws Exception {
        HttpGet req = new HttpGet(uri);
        HttpClient client = new DefaultHttpClient();
        HttpResponse resLogin = client.execute(req);
        BufferedReader r = new BufferedReader(new InputStreamReader(resLogin.getEntity().getContent()));
        StringBuilder sb = new StringBuilder();
        String s = null;
        while ((s = r.readLine()) != null) {
            sb.append(s);
        }
        return new JSONObject(sb.toString());
    }
} </s>
<s>class temp {    @Override
    public DataTable generateDataTable(Query query, HttpServletRequest request) throws DataSourceException {
        String url = request.getParameter(URL_PARAM_NAME);
        if (StringUtils.isEmpty(url)) {
            log.error("url parameter not provided.");
            throw new DataSourceException(ReasonType.INVALID_REQUEST, "url parameter not provided");
        }
        Reader reader;
        try {
            reader = new BufferedReader(new InputStreamReader(new URL(url).openStream()));
        } catch (MalformedURLException e) {
            log.error("url is malformed: " + url);
            throw new DataSourceException(ReasonType.INVALID_REQUEST, "url is malformed: " + url);
        } catch (IOException e) {
            log.error("Couldn't read from url: " + url, e);
            throw new DataSourceException(ReasonType.INVALID_REQUEST, "Couldn't read from url: " + url);
        }
        DataTable dataTable = null;
        ULocale requestLocale = DataSourceHelper.getLocaleFromRequest(request);
        try {
            dataTable = CsvDataSourceHelper.read(reader, null, true, requestLocale);
        } catch (IOException e) {
            log.error("Couldn't read from url: " + url, e);
            throw new DataSourceException(ReasonType.INVALID_REQUEST, "Couldn't read from url: " + url);
        }
        return dataTable;
    }
} </s>
<s>class temp {            protected final String H(String data) throws NoSuchAlgorithmException, UnsupportedEncodingException {
                MessageDigest digest = MessageDigest.getInstance("MD5");
                digest.update(data.getBytes("UTF8"));
                byte[] bytes = digest.digest();
                StringBuffer sb = new StringBuffer();
                for (int i = 0; i < bytes.length; i++) {
                    int aByte = bytes[i];
                    if (aByte < 0) aByte += 256;
                    if (aByte < 16) sb.append('0');
                    sb.append(Integer.toHexString(aByte));
                }
                return sb.toString();
            }
} </s>
<s>class temp {    private void bubbleSort(int values[]) {
        int len = values.length - 1;
        for (int i = 0; i < len; i++) {
            for (int j = 0; j < len - i; j++) {
                if (values[j] > values[j + 1]) {
                    int tmp = values[j];
                    values[j] = values[j + 1];
                    values[j + 1] = tmp;
                }
            }
        }
    }
} </s>
<s>class temp {    public String getNextSequence(Integer id) throws ApplicationException {
        java.sql.PreparedStatement preStat = null;
        java.sql.ResultSet rs = null;
        boolean noRecordMatch = false;
        String prefix = "";
        String suffix = "";
        Long startID = null;
        Integer length = null;
        Long currID = null;
        Integer increment = null;
        int nextID;
        String formReferenceID = null;
        synchronized (lock) {
            synchronized (dbConn) {
                try {
                    preStat = dbConn.prepareStatement("SELECT PREFIX,SUFFIX,START_NO,LENGTH,CURRENT_NO,INCREMENT FROM FORM_RECORD WHERE ID=?");
                    setPrepareStatement(preStat, 1, id);
                    rs = preStat.executeQuery();
                    if (rs.next()) {
                        prefix = rs.getString(1);
                        suffix = rs.getString(2);
                        startID = new Long(rs.getLong(3));
                        length = new Integer(rs.getInt(4));
                        currID = new Long(rs.getLong(5));
                        increment = new Integer(rs.getInt(6));
                        if (Utility.isEmpty(startID) || Utility.isEmpty(length) || Utility.isEmpty(currID) || Utility.isEmpty(increment) || startID.intValue() < 0 || length.intValue() < startID.toString().length() || currID.intValue() < startID.intValue() || increment.intValue() < 1 || new Integer(increment.intValue() + currID.intValue()).toString().length() > length.intValue()) {
                            noRecordMatch = true;
                        } else {
                            if (!Utility.isEmpty(prefix)) {
                                formReferenceID = prefix;
                            }
                            String strCurrID = currID.toString();
                            for (int i = 0; i < length.intValue() - strCurrID.length(); i++) {
                                formReferenceID += "0";
                            }
                            formReferenceID += strCurrID;
                            if (!Utility.isEmpty(suffix)) {
                                formReferenceID += suffix;
                            }
                        }
                    } else {
                        noRecordMatch = true;
                    }
                } catch (Exception e) {
                    log.error(e, e);
                    try {
                        dbConn.close();
                    } catch (Exception ignore) {
                    } finally {
                        dbConn = null;
                    }
                    throw new ApplicationException("errors.framework.get_next_seq", e);
                } finally {
                    try {
                        rs.close();
                    } catch (Exception ignore) {
                    } finally {
                        rs = null;
                    }
                    try {
                        preStat.close();
                    } catch (Exception ignore) {
                    } finally {
                        preStat = null;
                    }
                }
                if (!noRecordMatch && formReferenceID != null) {
                    try {
                        int updateCnt = 0;
                        nextID = currID.intValue() + increment.intValue();
                        do {
                            preStat = dbConn.prepareStatement("UPDATE FORM_RECORD SET CURRENT_NO=? WHERE ID=?");
                            setPrepareStatement(preStat, 1, new Integer(nextID));
                            setPrepareStatement(preStat, 2, id);
                            updateCnt = preStat.executeUpdate();
                            if (updateCnt == 0) {
                                Thread.sleep(50);
                            }
                        } while (updateCnt == 0);
                        dbConn.commit();
                    } catch (Exception e) {
                        log.error(e, e);
                        try {
                            dbConn.rollback();
                        } catch (Exception ignore) {
                        }
                        throw new ApplicationException("errors.framework.get_next_seq", e);
                    } finally {
                        try {
                            preStat.close();
                        } catch (Exception ignore) {
                        } finally {
                            preStat = null;
                        }
                        try {
                            dbConn.close();
                        } catch (Exception ignore) {
                        } finally {
                            dbConn = null;
                        }
                    }
                }
                return formReferenceID;
            }
        }
    }
} </s>
<s>class temp {    public void bubbleSort(int[] arr) {
        boolean swapped = true;
        int j = 0;
        int tmp;
        while (swapped) {
            swapped = false;
            j++;
            for (int i = 0; i < arr.length - j; i++) {
                if (arr[i] > arr[i + 1]) {
                    tmp = arr[i];
                    arr[i] = arr[i + 1];
                    arr[i + 1] = tmp;
                    swapped = true;
                }
            }
        }
    }
} </s>
<s>class temp {    public void convert(File src, File dest) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(src));
        DcmParser p = pfact.newDcmParser(in);
        Dataset ds = fact.newDataset();
        p.setDcmHandler(ds.getDcmHandler());
        try {
            FileFormat format = p.detectFileFormat();
            if (format != FileFormat.ACRNEMA_STREAM) {
                System.out.println("\n" + src + ": not an ACRNEMA stream!");
                return;
            }
            p.parseDcmFile(format, Tags.PixelData);
            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {
                System.out.println("\n" + src + ": contains UIDs!" + " => probable already DICOM - do not convert");
                return;
            }
            boolean hasPixelData = p.getReadTag() == Tags.PixelData;
            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;
            int pxlen = p.getReadLength();
            if (hasPixelData) {
                if (inflate) {
                    ds.putUS(Tags.BitsAllocated, 16);
                    pxlen = pxlen * 4 / 3;
                }
                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {
                    System.out.println("\n" + src + ": mismatch pixel data length!" + " => do not convert");
                    return;
                }
            }
            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));
            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));
            ds.putUI(Tags.SOPInstanceUID, uid(instUID));
            ds.putUI(Tags.SOPClassUID, classUID);
            if (!ds.contains(Tags.NumberOfSamples)) {
                ds.putUS(Tags.NumberOfSamples, 1);
            }
            if (!ds.contains(Tags.PhotometricInterpretation)) {
                ds.putCS(Tags.PhotometricInterpretation, "MONOCHROME2");
            }
            if (fmi) {
                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));
            }
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
            try {
            } finally {
                ds.writeFile(out, encodeParam());
                if (hasPixelData) {
                    if (!skipGroupLen) {
                        out.write(PXDATA_GROUPLEN);
                        int grlen = pxlen + 8;
                        out.write((byte) grlen);
                        out.write((byte) (grlen >> 8));
                        out.write((byte) (grlen >> 16));
                        out.write((byte) (grlen >> 24));
                    }
                    out.write(PXDATA_TAG);
                    out.write((byte) pxlen);
                    out.write((byte) (pxlen >> 8));
                    out.write((byte) (pxlen >> 16));
                    out.write((byte) (pxlen >> 24));
                }
                if (inflate) {
                    int b2, b3;
                    for (; pxlen > 0; pxlen -= 3) {
                        out.write(in.read());
                        b2 = in.read();
                        b3 = in.read();
                        out.write(b2 & 0x0f);
                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));
                        out.write(b3 >> 4);
                    }
                } else {
                    for (; pxlen > 0; --pxlen) {
                        out.write(in.read());
                    }
                }
                out.close();
            }
            System.out.print('.');
        } finally {
            in.close();
        }
    }
} </s>
<s>class temp {    public static void doVersionCheck(View view) {
        view.showWaitCursor();
        try {
            URL url = new URL(jEdit.getProperty("version-check.url"));
            InputStream in = url.openStream();
            BufferedReader bin = new BufferedReader(new InputStreamReader(in));
            String line;
            String develBuild = null;
            String stableBuild = null;
            while ((line = bin.readLine()) != null) {
                if (line.startsWith(".build")) develBuild = line.substring(6).trim(); else if (line.startsWith(".stablebuild")) stableBuild = line.substring(12).trim();
            }
            bin.close();
            if (develBuild != null && stableBuild != null) {
                doVersionCheck(view, stableBuild, develBuild);
            }
        } catch (IOException e) {
            String[] args = { jEdit.getProperty("version-check.url"), e.toString() };
            GUIUtilities.error(view, "read-error", args);
        }
        view.hideWaitCursor();
    }
} </s>
<s>class temp {    @BeforeClass
    public static void setUpOnce() throws OWLOntologyCreationException {
        dbManager = (OWLDBOntologyManager) OWLDBManager.createOWLOntologyManager(OWLDataFactoryImpl.getInstance());
        dbIRI = IRI.create(ontoUri);
        System.out.println("copying ontology to work folder...");
        try {
            final File directory = new File("./resources/LUBM10-DB-forUpdate/");
            final File[] filesToDelete = directory.listFiles();
            if (filesToDelete != null && filesToDelete.length > 0) {
                for (final File file : filesToDelete) {
                    if (!file.getName().endsWith(".svn")) Assert.assertTrue(file.delete());
                }
            }
            final File original = new File("./resources/LUBM10-DB/LUBM10.h2.db");
            final File copy = new File("./resources/LUBM10-DB-forUpdate/LUBM10.h2.db");
            final FileChannel inChannel = new FileInputStream(original).getChannel();
            final FileChannel outChannel = new FileOutputStream(copy).getChannel();
            inChannel.transferTo(0, inChannel.size(), outChannel);
        } catch (final IOException ioe) {
            System.err.println(ioe.getMessage());
            Assert.fail();
        }
        onto = (OWLMutableOntology) dbManager.loadOntology(dbIRI);
        factory = dbManager.getOWLDataFactory();
    }
} </s>
<s>class temp {    public static void testString(String string, String expected) {
        MessageDigest md = null;
        try {
            md = MessageDigest.getInstance("MD5");
            md.update(string.getBytes(), 0, string.length());
            String result = toString(md.digest());
            System.out.println(expected);
            System.out.println(result);
            if (!expected.equals(result)) System.out.println("NOT EQUAL!");
        } catch (Exception x) {
            x.printStackTrace();
        }
    }
} </s>
<s>class temp {    public void convert(File src, File dest) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(src));
        DcmParser p = pfact.newDcmParser(in);
        Dataset ds = fact.newDataset();
        p.setDcmHandler(ds.getDcmHandler());
        try {
            FileFormat format = p.detectFileFormat();
            if (format != FileFormat.ACRNEMA_STREAM) {
                System.out.println("\n" + src + ": not an ACRNEMA stream!");
                return;
            }
            p.parseDcmFile(format, Tags.PixelData);
            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {
                System.out.println("\n" + src + ": contains UIDs!" + " => probable already DICOM - do not convert");
                return;
            }
            boolean hasPixelData = p.getReadTag() == Tags.PixelData;
            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;
            int pxlen = p.getReadLength();
            if (hasPixelData) {
                if (inflate) {
                    ds.putUS(Tags.BitsAllocated, 16);
                    pxlen = pxlen * 4 / 3;
                }
                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {
                    System.out.println("\n" + src + ": mismatch pixel data length!" + " => do not convert");
                    return;
                }
            }
            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));
            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));
            ds.putUI(Tags.SOPInstanceUID, uid(instUID));
            ds.putUI(Tags.SOPClassUID, classUID);
            if (!ds.contains(Tags.NumberOfSamples)) {
                ds.putUS(Tags.NumberOfSamples, 1);
            }
            if (!ds.contains(Tags.PhotometricInterpretation)) {
                ds.putCS(Tags.PhotometricInterpretation, "MONOCHROME2");
            }
            if (fmi) {
                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));
            }
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
            try {
            } finally {
                ds.writeFile(out, encodeParam());
                if (hasPixelData) {
                    if (!skipGroupLen) {
                        out.write(PXDATA_GROUPLEN);
                        int grlen = pxlen + 8;
                        out.write((byte) grlen);
                        out.write((byte) (grlen >> 8));
                        out.write((byte) (grlen >> 16));
                        out.write((byte) (grlen >> 24));
                    }
                    out.write(PXDATA_TAG);
                    out.write((byte) pxlen);
                    out.write((byte) (pxlen >> 8));
                    out.write((byte) (pxlen >> 16));
                    out.write((byte) (pxlen >> 24));
                }
                if (inflate) {
                    int b2, b3;
                    for (; pxlen > 0; pxlen -= 3) {
                        out.write(in.read());
                        b2 = in.read();
                        b3 = in.read();
                        out.write(b2 & 0x0f);
                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));
                        out.write(b3 >> 4);
                    }
                } else {
                    for (; pxlen > 0; --pxlen) {
                        out.write(in.read());
                    }
                }
                out.close();
            }
            System.out.print('.');
        } finally {
            in.close();
        }
    }
} </s>
<s>class temp {    public String download(String urlStr) {
        StringBuffer sb = new StringBuffer();
        String line = null;
        BufferedReader buffer = null;
        try {
            url = new URL(urlStr);
            HttpURLConnection urlConn = (HttpURLConnection) url.openConnection();
            buffer = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));
            System.out.println(buffer);
            while ((line = buffer.readLine()) != null) {
                sb.append(line);
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                buffer.close();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return sb.toString();
    }
} </s>
<s>class temp {    public static void copy(String sourceName, String destName) throws IOException {
        File src = new File(sourceName);
        File dest = new File(destName);
        BufferedInputStream source = null;
        BufferedOutputStream destination = null;
        byte[] buffer;
        int bytes_read;
        long byteCount = 0;
        if (!src.exists()) throw new IOException("Source not found: " + src);
        if (!src.canRead()) throw new IOException("Source is unreadable: " + src);
        if (src.isFile()) {
            if (!dest.exists()) {
                File parentdir = parent(dest);
                if (!parentdir.exists()) parentdir.mkdir();
            } else if (dest.isDirectory()) {
                if (src.isDirectory()) dest = new File(dest + File.separator + src); else dest = new File(dest + File.separator + src.getName());
            }
        } else if (src.isDirectory()) {
            if (dest.isFile()) throw new IOException("Cannot copy directory " + src + " to file " + dest);
            if (!dest.exists()) dest.mkdir();
        }
        if ((!dest.canWrite()) && (dest.exists())) throw new IOException("Destination is unwriteable: " + dest);
        if (src.isFile()) {
            try {
                source = new BufferedInputStream(new FileInputStream(src));
                destination = new BufferedOutputStream(new FileOutputStream(dest));
                buffer = new byte[4096];
                byteCount = 0;
                while (true) {
                    bytes_read = source.read(buffer);
                    if (bytes_read == -1) break;
                    destination.write(buffer, 0, bytes_read);
                    byteCount = byteCount + bytes_read;
                }
            } finally {
                if (source != null) source.close();
                if (destination != null) destination.close();
            }
        } else if (src.isDirectory()) {
            String targetfile, target, targetdest;
            String[] files = src.list();
            for (int i = 0; i < files.length; i++) {
                targetfile = files[i];
                target = src + File.separator + targetfile;
                targetdest = dest + File.separator + targetfile;
                if ((new File(target)).isDirectory()) {
                    copy(new File(target).getCanonicalPath(), new File(targetdest).getCanonicalPath());
                } else {
                    try {
                        byteCount = 0;
                        source = new BufferedInputStream(new FileInputStream(target));
                        destination = new BufferedOutputStream(new FileOutputStream(targetdest));
                        buffer = new byte[4096];
                        while (true) {
                            bytes_read = source.read(buffer);
                            if (bytes_read == -1) break;
                            destination.write(buffer, 0, bytes_read);
                            byteCount = byteCount + bytes_read;
                        }
                    } finally {
                        if (source != null) source.close();
                        if (destination != null) destination.close();
                    }
                }
            }
        }
    }
} </s>
<s>class temp {    public synchronized String encrypt(String plaintext) throws Exception {
        MessageDigest md = null;
        try {
            md = MessageDigest.getInstance("SHA");
        } catch (NoSuchAlgorithmException e) {
            throw new MyException(e.getMessage());
        }
        try {
            md.update(plaintext.getBytes("UTF-8"));
        } catch (UnsupportedEncodingException e) {
            throw new Exception(e.getMessage());
        }
        byte raw[] = md.digest();
        String hash = (new BASE64Encoder()).encode(raw);
        return hash;
    }
} </s>
<s>class temp {    public SCFFile(URL url) throws IOException {
        URLConnection connection = url.openConnection();
        byte[] content = new byte[connection.getContentLength()];
        DataInputStream dis = new DataInputStream(connection.getInputStream());
        dis.readFully(content);
        dis.close();
        dis = new DataInputStream(new ByteArrayInputStream(content));
        header = new SCFHeader(dis);
        if (!header.magicNumber.equals(".scf")) throw new RuntimeException(url + " is not an SCF file");
        A = new int[header.samples];
        C = new int[header.samples];
        G = new int[header.samples];
        T = new int[header.samples];
        max = Integer.MIN_VALUE;
        dis.reset();
        dis.skipBytes(header.samplesOffset);
        if (header.sampleSize == 1) {
            if (header.version < 3.00) {
                for (int i = 0; i < header.samples; ++i) {
                    A[i] = dis.readUnsignedByte();
                    if (A[i] > max) max = A[i];
                    C[i] = dis.readUnsignedByte();
                    if (C[i] > max) max = C[i];
                    G[i] = dis.readUnsignedByte();
                    if (G[i] > max) max = G[i];
                    T[i] = dis.readUnsignedByte();
                    if (T[i] > max) max = T[i];
                }
            } else {
                for (int i = 0; i < header.samples; ++i) {
                    A[i] = dis.readUnsignedByte();
                    if (A[i] > max) max = A[i];
                }
                for (int i = 0; i < header.samples; ++i) {
                    C[i] = dis.readUnsignedByte();
                    if (C[i] > max) max = C[i];
                }
                for (int i = 0; i < header.samples; ++i) {
                    G[i] = dis.readUnsignedByte();
                    if (G[i] > max) max = G[i];
                }
                for (int i = 0; i < header.samples; ++i) {
                    T[i] = dis.readUnsignedByte();
                    if (T[i] > max) max = T[i];
                }
            }
        } else if (header.sampleSize == 2) {
            if (header.version < 3.00) {
                for (int i = 0; i < header.samples; ++i) {
                    A[i] = dis.readUnsignedShort();
                    if (A[i] > max) max = A[i];
                    C[i] = dis.readUnsignedShort();
                    if (C[i] > max) max = C[i];
                    G[i] = dis.readUnsignedShort();
                    if (G[i] > max) max = G[i];
                    T[i] = dis.readUnsignedShort();
                    if (T[i] > max) max = T[i];
                }
            } else {
                for (int i = 0; i < header.samples; ++i) {
                    A[i] = dis.readUnsignedShort();
                    if (A[i] > max) max = A[i];
                }
                for (int i = 0; i < header.samples; ++i) {
                    C[i] = dis.readUnsignedShort();
                    if (C[i] > max) max = C[i];
                }
                for (int i = 0; i < header.samples; ++i) {
                    G[i] = dis.readUnsignedShort();
                    if (G[i] > max) max = G[i];
                }
                for (int i = 0; i < header.samples; ++i) {
                    T[i] = dis.readUnsignedShort();
                    if (T[i] > max) max = T[i];
                }
            }
        }
        centers = new int[header.bases];
        byte[] buf = new byte[header.bases];
        dis.reset();
        dis.skipBytes(header.basesOffset);
        if (header.version < 3.00) {
            for (int i = 0; i < header.bases; ++i) {
                centers[i] = dis.readInt();
                dis.skipBytes(4);
                buf[i] = dis.readByte();
                dis.skipBytes(3);
            }
        } else {
            for (int i = 0; i < header.bases; ++i) centers[i] = dis.readInt();
            dis.skipBytes(4 * header.bases);
            dis.readFully(buf);
        }
        sequence = new String(buf);
        dis.close();
    }
} </s>
<s>class temp {    public void convert(File src, File dest) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(src));
        DcmParser p = pfact.newDcmParser(in);
        Dataset ds = fact.newDataset();
        p.setDcmHandler(ds.getDcmHandler());
        try {
            FileFormat format = p.detectFileFormat();
            if (format != FileFormat.ACRNEMA_STREAM) {
                System.out.println("\n" + src + ": not an ACRNEMA stream!");
                return;
            }
            p.parseDcmFile(format, Tags.PixelData);
            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {
                System.out.println("\n" + src + ": contains UIDs!" + " => probable already DICOM - do not convert");
                return;
            }
            boolean hasPixelData = p.getReadTag() == Tags.PixelData;
            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;
            int pxlen = p.getReadLength();
            if (hasPixelData) {
                if (inflate) {
                    ds.putUS(Tags.BitsAllocated, 16);
                    pxlen = pxlen * 4 / 3;
                }
                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {
                    System.out.println("\n" + src + ": mismatch pixel data length!" + " => do not convert");
                    return;
                }
            }
            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));
            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));
            ds.putUI(Tags.SOPInstanceUID, uid(instUID));
            ds.putUI(Tags.SOPClassUID, classUID);
            if (!ds.contains(Tags.NumberOfSamples)) {
                ds.putUS(Tags.NumberOfSamples, 1);
            }
            if (!ds.contains(Tags.PhotometricInterpretation)) {
                ds.putCS(Tags.PhotometricInterpretation, "MONOCHROME2");
            }
            if (fmi) {
                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));
            }
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
            try {
            } finally {
                ds.writeFile(out, encodeParam());
                if (hasPixelData) {
                    if (!skipGroupLen) {
                        out.write(PXDATA_GROUPLEN);
                        int grlen = pxlen + 8;
                        out.write((byte) grlen);
                        out.write((byte) (grlen >> 8));
                        out.write((byte) (grlen >> 16));
                        out.write((byte) (grlen >> 24));
                    }
                    out.write(PXDATA_TAG);
                    out.write((byte) pxlen);
                    out.write((byte) (pxlen >> 8));
                    out.write((byte) (pxlen >> 16));
                    out.write((byte) (pxlen >> 24));
                }
                if (inflate) {
                    int b2, b3;
                    for (; pxlen > 0; pxlen -= 3) {
                        out.write(in.read());
                        b2 = in.read();
                        b3 = in.read();
                        out.write(b2 & 0x0f);
                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));
                        out.write(b3 >> 4);
                    }
                } else {
                    for (; pxlen > 0; --pxlen) {
                        out.write(in.read());
                    }
                }
                out.close();
            }
            System.out.print('.');
        } finally {
            in.close();
        }
    }
} </s>
<s>class temp {    public void insertStringInFile(String file, String textToInsert, long fromByte, long toByte) throws Exception {
        String tmpFile = file + ".tmp";
        BufferedInputStream in = null;
        BufferedOutputStream out = null;
        long byteCount = 0;
        try {
            in = new BufferedInputStream(new FileInputStream(new File(file)));
            out = new BufferedOutputStream(new FileOutputStream(tmpFile));
            long size = fromByte;
            byte[] buf = null;
            if (size == 0) {
            } else {
                buf = new byte[(int) size];
                int length = -1;
                if ((length = in.read(buf)) != -1) {
                    out.write(buf, 0, length);
                    byteCount = byteCount + length;
                } else {
                    String msg = "Failed to read the first '" + size + "' bytes of file '" + file + "'. This might be a programming error.";
                    logger.warning(msg);
                    throw new Exception(msg);
                }
            }
            buf = textToInsert.getBytes();
            int length = buf.length;
            out.write(buf, 0, length);
            byteCount = byteCount + length;
            long skipLength = toByte - fromByte;
            long skippedBytes = in.skip(skipLength);
            if (skippedBytes == -1) {
            } else {
                buf = new byte[4096];
                length = -1;
                while ((length = in.read(buf)) != -1) {
                    out.write(buf, 0, length);
                    byteCount = byteCount + length;
                }
            }
            in.close();
            in = null;
            out.close();
            out = null;
            File fileToDelete = new File(file);
            boolean wasDeleted = fileToDelete.delete();
            if (!wasDeleted) {
                String msg = "Failed to delete the original file '" + file + "' to replace it with the modified file after text insertion.";
                logger.warning(msg);
                throw new Exception(msg);
            }
            File fileToRename = new File(tmpFile);
            boolean wasRenamed = fileToRename.renameTo(fileToDelete);
            if (!wasRenamed) {
                String msg = "Failed to rename tmp file '" + tmpFile + "' to the name of the original file '" + file + "'";
                logger.warning(msg);
                throw new Exception(msg);
            }
        } catch (Exception e) {
            logger.log(Level.WARNING, "Failed to read/write file '" + file + "'.", e);
            throw e;
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException e) {
                    logger.log(Level.FINEST, "Ignoring error closing input file '" + file + "'.", e);
                }
            }
            if (out != null) {
                try {
                    out.close();
                } catch (IOException e) {
                    logger.log(Level.FINEST, "Ignoring error closing output file '" + tmpFile + "'.", e);
                }
            }
        }
    }
} </s>
<s>class temp {    @Override
    public Object execute(ExecutionEvent event) throws ExecutionException {
        URL url;
        try {
            url = new URL("platform:/plugin/de.vogella.rcp.plugin.filereader/files/test.txt");
            InputStream inputStream = url.openConnection().getInputStream();
            BufferedReader in = new BufferedReader(new InputStreamReader(inputStream));
            String inputLine;
            while ((inputLine = in.readLine()) != null) {
                System.out.println(inputLine);
            }
            in.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }
} </s>
<s>class temp {    private void refresh(String val) {
        HttpHost targetHost = new HttpHost("localhost", 8080, "http");
        DefaultHttpClient httpclient = new DefaultHttpClient();
        BasicHttpContext localcontext = new BasicHttpContext();
        String searchString = val.trim().replaceAll("\\s+", "+");
        HttpGet httpget = new HttpGet("/geoserver/rest/gazetteer-search/result.json?q=" + searchString);
        try {
            HttpResponse response = httpclient.execute(targetHost, httpget, localcontext);
            HttpEntity entity = response.getEntity();
            String responseText = "";
            if (entity != null) {
                responseText = new String(EntityUtils.toByteArray(entity));
            } else {
                responseText = "Fail";
            }
            JSONObject responseJson = JSONObject.fromObject(responseText);
            JSONObject search = responseJson.getJSONObject("org.ala.rest.GazetteerSearch");
            JSONArray results = search.getJSONObject("results").getJSONArray("org.ala.rest.SearchResultItem");
            Iterator it = getItems().iterator();
            for (int i = 0; i < results.size(); i++) {
                String itemString = (String) results.getJSONObject(i).get("name");
                if (it != null && it.hasNext()) {
                    ((Comboitem) it.next()).setLabel(itemString);
                } else {
                    it = null;
                    new Comboitem(itemString).setParent(this);
                }
            }
            while (it != null && it.hasNext()) {
                it.next();
                it.remove();
            }
        } catch (Exception e) {
        }
    }
} </s>
<s>class temp {    public void removeExifTag(File jpegImageFile, File dst) throws IOException, ImageReadException, ImageWriteException {
        OutputStream os = null;
        try {
            TiffOutputSet outputSet = null;
            IImageMetadata metadata = Sanselan.getMetadata(jpegImageFile);
            JpegImageMetadata jpegMetadata = (JpegImageMetadata) metadata;
            if (null != jpegMetadata) {
                TiffImageMetadata exif = jpegMetadata.getExif();
                if (null != exif) {
                    outputSet = exif.getOutputSet();
                }
            }
            if (null == outputSet) {
                IOUtils.copyFileNio(jpegImageFile, dst);
                return;
            }
            {
                outputSet.removeField(TiffConstants.EXIF_TAG_APERTURE_VALUE);
                TiffOutputDirectory exifDirectory = outputSet.getExifDirectory();
                if (null != exifDirectory) exifDirectory.removeField(TiffConstants.EXIF_TAG_APERTURE_VALUE);
            }
            os = new FileOutputStream(dst);
            os = new BufferedOutputStream(os);
            new ExifRewriter().updateExifMetadataLossless(jpegImageFile, os, outputSet);
            os.close();
            os = null;
        } finally {
            if (os != null) try {
                os.close();
            } catch (IOException e) {
            }
        }
    }
} </s>
<s>class temp {    protected void copyFile(File sourceFile, File targetFile) throws FileNotFoundException, IOException {
        FileChannel inChannel = null;
        FileChannel outChannel = null;
        try {
            inChannel = new FileInputStream(sourceFile).getChannel();
            outChannel = new FileOutputStream(targetFile).getChannel();
            inChannel.transferTo(0, inChannel.size(), outChannel);
        } finally {
            try {
                if (inChannel != null) {
                    inChannel.close();
                }
                if (outChannel != null) {
                    outChannel.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
} </s>
<s>class temp {        static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {
            MessageDigest md;
            md = MessageDigest.getInstance("MD5");
            byte[] md5hash = new byte[32];
            md.update(text.getBytes("iso-8859-1"), 0, text.length());
            md5hash = md.digest();
            return convertToHex(md5hash);
        }
} </s>
<s>class temp {    public void extractProfile(String parentDir, String fileName, String profileName) {
        try {
            byte[] buf = new byte[1024];
            ZipInputStream zipinputstream = null;
            ZipEntry zipentry;
            if (createProfileDirectory(profileName, parentDir)) {
                debug("the profile directory created .starting the profile extraction");
                String profilePath = parentDir + File.separator + fileName;
                zipinputstream = new ZipInputStream(new FileInputStream(profilePath));
                zipentry = zipinputstream.getNextEntry();
                while (zipentry != null) {
                    String entryName = zipentry.getName();
                    int n;
                    FileOutputStream fileoutputstream;
                    File newFile = new File(entryName);
                    String directory = newFile.getParent();
                    if (directory == null) {
                        if (newFile.isDirectory()) break;
                    }
                    fileoutputstream = new FileOutputStream(parentDir + File.separator + profileName + File.separator + newFile.getName());
                    while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);
                    fileoutputstream.close();
                    zipinputstream.closeEntry();
                    zipentry = zipinputstream.getNextEntry();
                }
                zipinputstream.close();
                debug("deleting the profile.zip file");
                File newFile = new File(profilePath);
                if (newFile.delete()) {
                    debug("the " + "[" + profilePath + "]" + " deleted successfully");
                } else {
                    debug("profile" + "[" + profilePath + "]" + "deletion fail");
                    throw new IllegalArgumentException("Error: deletion error!");
                }
            } else {
                debug("error creating the profile directory");
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
} </s>
<s>class temp {    @org.junit.Test
    public void testReadWrite() throws Exception {
        final String reference = "testString";
        final Reader reader = new StringReader(reference);
        final StringWriter osString = new StringWriter();
        final Reader teeStream = new TeeReaderWriter(reader, osString);
        IOUtils.copy(teeStream, new NullWriter());
        teeStream.close();
        osString.toString();
    }
} </s>
<s>class temp {    public static void copyFile(String oldPathFile, String newPathFile) {
        try {
            int bytesum = 0;
            int byteread = 0;
            File oldfile = new File(oldPathFile);
            if (oldfile.exists()) {
                InputStream inStream = new FileInputStream(oldPathFile);
                FileOutputStream fs = new FileOutputStream(newPathFile);
                byte[] buffer = new byte[2048];
                while ((byteread = inStream.read(buffer)) != -1) {
                    bytesum += byteread;
                    fs.write(buffer, 0, byteread);
                }
                inStream.close();
            } else {
                System.err.println(FileUtil.class.toString() + ":不存在file" + oldPathFile);
            }
        } catch (Exception e) {
            System.err.println(FileUtil.class.toString() + ":复制file" + oldPathFile + "到" + newPathFile + "出错!");
        }
    }
} </s>
<s>class temp {    public static void copyFile(File oldPathFile, File newPathFile) throws IOException {
        InputStream in = null;
        OutputStream out = null;
        try {
            in = new BufferedInputStream(new FileInputStream(oldPathFile));
            out = new BufferedOutputStream(new FileOutputStream(newPathFile));
            int bufferSize = 1024;
            byte[] buffer = new byte[bufferSize];
            while (in.read(buffer) > 0) out.write(buffer);
        } finally {
            if (null != in) in.close();
            if (null != out) out.close();
        }
    }
} </s>
<s>class temp {    public static void doVersionCheck(View view) {
        view.showWaitCursor();
        try {
            URL url = new URL(jEdit.getProperty("version-check.url"));
            InputStream in = url.openStream();
            BufferedReader bin = new BufferedReader(new InputStreamReader(in));
            String line;
            String develBuild = null;
            String stableBuild = null;
            while ((line = bin.readLine()) != null) {
                if (line.startsWith(".build")) develBuild = line.substring(6).trim(); else if (line.startsWith(".stablebuild")) stableBuild = line.substring(12).trim();
            }
            bin.close();
            if (develBuild != null && stableBuild != null) {
                doVersionCheck(view, stableBuild, develBuild);
            }
        } catch (IOException e) {
            String[] args = { jEdit.getProperty("version-check.url"), e.toString() };
            GUIUtilities.error(view, "read-error", args);
        }
        view.hideWaitCursor();
    }
} </s>
<s>class temp {    public synchronized int insertMessage(FrostMessageObject mo) {
        AttachmentList files = mo.getAttachmentsOfType(Attachment.FILE);
        AttachmentList boards = mo.getAttachmentsOfType(Attachment.BOARD);
        Connection conn = AppLayerDatabase.getInstance().getPooledConnection();
        try {
            conn.setAutoCommit(false);
            PreparedStatement ps = conn.prepareStatement("INSERT INTO " + getMessageTableName() + " (" + "primkey,messageid,inreplyto,isvalid,invalidreason,msgdatetime,msgindex,board,fromname,subject,recipient,signature," + "signaturestatus,publickey,isdeleted,isnew,isreplied,isjunk,isflagged,isstarred,hasfileattachment,hasboardattachment,idlinepos,idlinelen" + ") VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)");
            Long identity = null;
            Statement stmt = AppLayerDatabase.getInstance().createStatement();
            ResultSet rs = stmt.executeQuery("select UNIQUEKEY('" + getMessageTableName() + "')");
            if (rs.next()) {
                identity = new Long(rs.getLong(1));
            } else {
                logger.log(Level.SEVERE, "Could not retrieve a new unique key!");
            }
            rs.close();
            stmt.close();
            int i = 1;
            ps.setLong(i++, identity.longValue());
            ps.setString(i++, mo.getMessageId());
            ps.setString(i++, mo.getInReplyTo());
            ps.setBoolean(i++, mo.isValid());
            ps.setString(i++, mo.getInvalidReason());
            ps.setLong(i++, mo.getDateAndTime().getMillis());
            ps.setInt(i++, mo.getIndex());
            ps.setInt(i++, mo.getBoard().getPrimaryKey().intValue());
            ps.setString(i++, mo.getFromName());
            ps.setString(i++, mo.getSubject());
            ps.setString(i++, ((mo.getRecipientName() != null && mo.getRecipientName().length() == 0) ? null : mo.getRecipientName()));
            if (mo.getSignatureV2() == null || mo.getSignatureV2().length() == 0) {
                ps.setString(i++, mo.getSignatureV1());
            } else {
                ps.setString(i++, mo.getSignatureV2());
            }
            ps.setInt(i++, mo.getSignatureStatus());
            ps.setString(i++, mo.getPublicKey());
            ps.setBoolean(i++, mo.isDeleted());
            ps.setBoolean(i++, mo.isNew());
            ps.setBoolean(i++, mo.isReplied());
            ps.setBoolean(i++, mo.isJunk());
            ps.setBoolean(i++, mo.isFlagged());
            ps.setBoolean(i++, mo.isStarred());
            ps.setBoolean(i++, (files.size() > 0));
            ps.setBoolean(i++, (boards.size() > 0));
            ps.setInt(i++, mo.getIdLinePos());
            ps.setInt(i++, mo.getIdLineLen());
            int inserted;
            try {
                inserted = ps.executeUpdate();
            } finally {
                ps.close();
            }
            if (inserted == 0) {
                logger.log(Level.SEVERE, "message insert returned 0 !!!");
                throw new Exception("message insert returned 0 !!!");
            }
            mo.setMsgIdentity(identity.longValue());
            PreparedStatement pc = conn.prepareStatement("INSERT INTO " + getContentTableName() + " (msgref,msgcontent) VALUES (?,?)");
            pc.setLong(1, mo.getMsgIdentity());
            pc.setString(2, mo.getContent());
            try {
                inserted = pc.executeUpdate();
            } finally {
                pc.close();
            }
            if (inserted == 0) {
                logger.log(Level.SEVERE, "message content insert returned 0 !!!");
                throw new Exception("message content insert returned 0 !!!");
            }
            if (files.size() > 0) {
                PreparedStatement p = conn.prepareStatement("INSERT INTO " + getFileAttachmentsTableName() + " (msgref,filename,filesize,filekey)" + " VALUES (?,?,?,?)");
                try {
                    for (Iterator it = files.iterator(); it.hasNext(); ) {
                        FileAttachment fa = (FileAttachment) it.next();
                        int ix = 1;
                        p.setLong(ix++, mo.getMsgIdentity());
                        p.setString(ix++, fa.getFilename());
                        p.setLong(ix++, fa.getFileSize());
                        p.setString(ix++, fa.getKey());
                        int ins = p.executeUpdate();
                        if (ins == 0) {
                            logger.log(Level.SEVERE, "fileattachment insert returned 0 !!!");
                            throw new Exception("fileattachment insert returned 0 !!!");
                        }
                    }
                } finally {
                    p.close();
                }
            }
            if (boards.size() > 0) {
                PreparedStatement p = conn.prepareStatement("INSERT INTO " + getBoardAttachmentsTableName() + " (msgref,boardname,boardpublickey,boardprivatekey,boarddescription)" + " VALUES (?,?,?,?,?)");
                try {
                    for (Iterator it = boards.iterator(); it.hasNext(); ) {
                        BoardAttachment ba = (BoardAttachment) it.next();
                        Board b = ba.getBoardObj();
                        int ix = 1;
                        p.setLong(ix++, mo.getMsgIdentity());
                        p.setString(ix++, b.getNameLowerCase());
                        p.setString(ix++, b.getPublicKey());
                        p.setString(ix++, b.getPrivateKey());
                        p.setString(ix++, b.getDescription());
                        int ins = p.executeUpdate();
                        if (ins == 0) {
                            logger.log(Level.SEVERE, "boardattachment insert returned 0 !!!");
                            throw new Exception("boardattachment insert returned 0 !!!");
                        }
                    }
                } finally {
                    p.close();
                }
            }
            conn.commit();
            conn.setAutoCommit(true);
            return INSERT_OK;
        } catch (Throwable t) {
            boolean isDuplicate;
            if (t.getMessage().indexOf("constraint violation") > 0 && t.getMessage().indexOf("MSG_ID_UNIQUE_ONLY") > 0) {
                isDuplicate = true;
                logger.warning("Duplicate message id, not added to database table: msgid='" + mo.getMessageId() + "', board=" + mo.getBoard().getName() + ", date='" + mo.getDateAndTimeString() + "', index=" + mo.getIndex());
            } else if (t.getMessage().indexOf("constraint violation") > 0 && t.getMessage().indexOf("MSG_UNIQUE_ONLY") > 0) {
                isDuplicate = true;
                logger.warning("Duplicate msgdatetime,index,board, not added to database table: msgid='" + mo.getMessageId() + "', board=" + mo.getBoard().getName() + ", date='" + mo.getDateAndTimeString() + "', index=" + mo.getIndex());
            } else {
                isDuplicate = false;
                logger.log(Level.SEVERE, "Exception during insert of message: msgid='" + mo.getMessageId() + "', board=" + mo.getBoard().getName() + ", date='" + mo.getDateAndTimeString() + "', index=" + mo.getIndex(), t);
                try {
                    conn.rollback();
                } catch (Throwable t1) {
                    logger.log(Level.SEVERE, "Exception during rollback", t1);
                }
            }
            try {
                conn.setAutoCommit(true);
            } catch (Throwable t1) {
            }
            if (isDuplicate) {
                return INSERT_DUPLICATE;
            } else {
                return INSERT_ERROR;
            }
        } finally {
            AppLayerDatabase.getInstance().givePooledConnection(conn);
        }
    }
} </s>
<s>class temp {    public void deleteGroupInstruction(int id, int rank) throws FidoDatabaseException, InstructionNotFoundException {
        try {
            Connection conn = null;
            Statement stmt = null;
            try {
                conn = fido.util.FidoDataSource.getConnection();
                conn.setAutoCommit(false);
                stmt = conn.createStatement();
                String sql = "delete from InstructionGroups " + "where InstructionId = " + id + " and Rank = " + rank;
                stmt.executeUpdate(sql);
                bumpAllRowsUp(stmt, id, rank);
                conn.commit();
            } catch (SQLException e) {
                if (conn != null) conn.rollback();
                throw e;
            } finally {
                if (stmt != null) stmt.close();
                if (conn != null) conn.close();
            }
        } catch (SQLException e) {
            throw new FidoDatabaseException(e);
        }
    }
} </s>
<s>class temp {    public void moveRowUp(int id, int row) throws FidoDatabaseException {
        try {
            Connection conn = null;
            Statement stmt = null;
            try {
                conn = fido.util.FidoDataSource.getConnection();
                conn.setAutoCommit(false);
                stmt = conn.createStatement();
                int max = findMaxRank(stmt, id);
                if ((row < 2) || (row > max)) throw new IllegalArgumentException("Row number not between 2 and " + max);
                stmt.executeUpdate("update InstructionGroups set Rank = -1 where InstructionId = '" + id + "' and Rank = " + row);
                stmt.executeUpdate("update InstructionGroups set Rank = " + row + " where InstructionId = '" + id + "' and Rank = " + (row - 1));
                stmt.executeUpdate("update InstructionGroups set Rank = " + (row - 1) + " where InstructionId = '" + id + "' and Rank = -1");
                conn.commit();
            } catch (SQLException e) {
                if (conn != null) conn.rollback();
                throw e;
            } finally {
                if (stmt != null) stmt.close();
                if (conn != null) conn.close();
            }
        } catch (SQLException e) {
            throw new FidoDatabaseException(e);
        }
    }
} </s>
<s>class temp {    public void moveRowDown(int id, int row) throws FidoDatabaseException {
        try {
            Connection conn = null;
            Statement stmt = null;
            try {
                conn = fido.util.FidoDataSource.getConnection();
                conn.setAutoCommit(false);
                stmt = conn.createStatement();
                int max = findMaxRank(stmt, id);
                if ((row < 1) || (row > (max - 1))) throw new IllegalArgumentException("Row number not between 1 and " + (max - 1));
                stmt.executeUpdate("update InstructionGroups set Rank = -1 where InstructionId = '" + id + "' and Rank = " + row);
                stmt.executeUpdate("update InstructionGroups set Rank = " + row + " where InstructionId = '" + id + "' and Rank = " + (row + 1));
                stmt.executeUpdate("update InstructionGroups set Rank = " + (row + 1) + " where InstructionId = '" + id + "' and Rank = -1");
                conn.commit();
            } catch (SQLException e) {
                if (conn != null) conn.rollback();
                throw e;
            } finally {
                if (stmt != null) stmt.close();
                if (conn != null) conn.close();
            }
        } catch (SQLException e) {
            throw new FidoDatabaseException(e);
        }
    }
} </s>
<s>class temp {    private static void copyFile(File source, File dest, boolean visibleFilesOnly) throws IOException {
        if (visibleFilesOnly && isHiddenOrDotFile(source)) {
            return;
        }
        if (dest.exists()) {
            System.err.println("Destination File Already Exists: " + dest);
        }
        FileChannel in = null, out = null;
        try {
            in = new FileInputStream(source).getChannel();
            out = new FileOutputStream(dest).getChannel();
            in.transferTo(0, in.size(), out);
        } finally {
            if (in != null) {
                in.close();
            }
            if (out != null) {
                out.close();
            }
        }
    }
} </s>
<s>class temp {    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {
        int k_blockSize = 1024;
        int byteCount;
        char[] buf = new char[k_blockSize];
        File ofp = new File(outFile);
        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));
        zos.setMethod(ZipOutputStream.DEFLATED);
        OutputStreamWriter osw = new OutputStreamWriter(zos, "ISO-8859-1");
        BufferedWriter bw = new BufferedWriter(osw);
        ZipEntry zot = null;
        File ifp = new File(inFile);
        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));
        InputStreamReader isr = new InputStreamReader(zis, "ISO-8859-1");
        BufferedReader br = new BufferedReader(isr);
        ZipEntry zit = null;
        while ((zit = zis.getNextEntry()) != null) {
            if (zit.getName().equals("content.xml")) {
                continue;
            }
            zot = new ZipEntry(zit.getName());
            zos.putNextEntry(zot);
            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);
            bw.flush();
            zos.closeEntry();
        }
        zos.putNextEntry(new ZipEntry("content.xml"));
        bw.flush();
        osw = new OutputStreamWriter(zos, "UTF8");
        bw = new BufferedWriter(osw);
        return bw;
    }
} </s>
<s>class temp {    protected static StringBuffer doRESTOp(String urlString) throws Exception {
        StringBuffer result = new StringBuffer();
        String restUrl = urlString;
        int p = restUrl.indexOf("://");
        if (p < 0) restUrl = System.getProperty("fedoragsearch.protocol") + "://" + System.getProperty("fedoragsearch.hostport") + "/" + System.getProperty("fedoragsearch.path") + restUrl;
        URL url = null;
        url = new URL(restUrl);
        URLConnection conn = null;
        conn = url.openConnection();
        conn.setRequestProperty("Authorization", "Basic " + (new BASE64Encoder()).encode((System.getProperty("fedoragsearch.fgsUserName") + ":" + System.getProperty("fedoragsearch.fgsPassword")).getBytes()));
        conn.connect();
        content = null;
        content = conn.getContent();
        String line;
        BufferedReader br = new BufferedReader(new InputStreamReader((InputStream) content));
        while ((line = br.readLine()) != null) result.append(line);
        return result;
    }
} </s>
<s>class temp {    public static Vector<Person> parseFriends(Worker me, SmEngine sme, Person resource) throws IOException {
        URL url = new URL(resource.getUrl());
        long fid;
        if (sme.getProxy() == null) me.conn = (HttpURLConnection) url.openConnection(); else me.conn = (HttpURLConnection) url.openConnection(sme.getProxy());
        me.conn.setReadTimeout(20 * 1000);
        Vector<Person> result;
        org.htmlparser.Parser parser;
        NodeList nl;
        NodeFilter[] filters1 = new NodeFilter[2];
        filters1[0] = new TagNameFilter("a");
        filters1[1] = new HasAttributeFilter("class", "signup_btn uiButton uiButtonSpecial uiButtonLarge");
        NodeFilter[] filters2 = new NodeFilter[3];
        filters2[0] = new TagNameFilter("a");
        filters2[1] = new HasAttributeFilter("class", "title");
        filters2[2] = new HasParentFilter(new HasAttributeFilter("class", "UIPortrait_Text"));
        try {
            parser = new org.htmlparser.Parser(me.conn);
        } catch (ParserException e) {
            System.err.println(e.getMessage());
            return null;
        }
        try {
            nl = parser.parse(new AndFilter(filters1));
            fid = Long.parseLong(((LinkTag) nl.elementAt(0)).getLink().split("(fid=|&amp)")[2]);
        } catch (ParserException e) {
            e.printStackTrace();
            return null;
        }
        result = new Vector<Person>();
        try {
            nl = parser.parse(new AndFilter(filters2));
        } catch (ParserException e) {
            e.printStackTrace();
            return null;
        }
        Person p;
        for (int i = 0; i < nl.size(); i++) {
            p = sme.getPerson(fid, ((TagNode) nl.elementAt(i)).getAttribute("title"), ((TagNode) nl.elementAt(i)).getAttribute("href"));
            resource.addFriend(p);
            p.addFriend(resource);
            synchronized (p) {
                if (!p.isInQueue()) {
                    p.setInQueue(true);
                    sme.addResource(p);
                }
            }
        }
        return result;
    }
} </s>
<s>class temp {    public static void doVersionCheck(View view) {
        view.showWaitCursor();
        try {
            URL url = new URL(jEdit.getProperty("version-check.url"));
            InputStream in = url.openStream();
            BufferedReader bin = new BufferedReader(new InputStreamReader(in));
            String line;
            String version = null;
            String build = null;
            while ((line = bin.readLine()) != null) {
                if (line.startsWith(".version")) version = line.substring(8).trim(); else if (line.startsWith(".build")) build = line.substring(6).trim();
            }
            bin.close();
            if (version != null && build != null) {
                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {
                    GUIUtilities.message(view, "version-check" + ".up-to-date", new String[0]);
                }
            }
        } catch (IOException e) {
            String[] args = { jEdit.getProperty("version-check.url"), e.toString() };
            GUIUtilities.error(view, "read-error", args);
        }
        view.hideWaitCursor();
    }
} </s>
<s>class temp {    public void write(URL exportUrl, OutputStream output) throws Exception {
        if (exportUrl == null || output == null) {
            throw new DocumentListException("null passed in for required parameters");
        }
        MediaContent mc = new MediaContent();
        mc.setUri(exportUrl.toString());
        MediaSource ms = service.getMedia(mc);
        InputStream input = ms.getInputStream();
        IOUtils.copy(input, output);
    }
} </s>
<s>class temp {    protected static String readUrl(URL url) throws IOException {
        BufferedReader in = null;
        StringBuffer buf = new StringBuffer();
        try {
            in = new BufferedReader(new InputStreamReader(url.openStream()));
            final char[] charBuf = new char[1024];
            int len = 0;
            while ((len = in.read(charBuf)) != -1) buf.append(charBuf, 0, len);
        } finally {
            if (in != null) in.close();
        }
        return buf.toString();
    }
} </s>
<s>class temp {    public static void createOutputStructure(String templatePath) throws InterruptedException {
        try {
            templatePath = new File(templatePath).getCanonicalPath();
            templatePath = templatePath.replace('\\', '/');
            File file = null;
            Paths paths = (Paths) GragGenerator.getObjectsFromTree(Paths.class).get(0);
            Config config = (Config) GragGenerator.getObjectsFromTree(Config.class).get(0);
            DirectoryIterator iterator = new DirectoryIterator(templatePath, true, true);
            while ((file = iterator.getNext()) != null) {
                boolean copyFile = false;
                String fullFilename = file.getCanonicalPath();
                int lastDirPos = fullFilename.lastIndexOf(System.getProperty("file.separator"));
                if (CVS_DIR.equals(file.getCanonicalPath().substring(fullFilename.length() - CVS_DIR.length(), fullFilename.length())) || CVS_DIR.equals(fullFilename.substring(lastDirPos - CVS_DIR.length(), lastDirPos))) {
                    continue;
                }
                if ("readme.txt".equals(file.getName())) {
                    continue;
                }
                String fileOut = outputDir.replace('\\', '/');
                String path = file.getCanonicalPath().replace('\\', '/');
                if (path.indexOf(templatePath) == 0) {
                    path = path.substring(templatePath.length());
                    if (path.startsWith(Paths.CONF_GENERAL_DIR)) {
                        path = paths.getConfigOutput() + path.substring(Paths.CONF_GENERAL_DIR.length());
                        copyFile = true;
                    } else if (path.startsWith(Paths.CONF_STRUTS_DIR)) {
                        path = paths.getConfigOutput() + path.substring(Paths.CONF_STRUTS_DIR.length());
                        copyFile = true;
                    } else if (path.startsWith(Paths.CONF_TAPESTRY4_DIR)) {
                        path = paths.getConfigOutput() + path.substring(Paths.CONF_TAPESTRY4_DIR.length());
                        copyFile = true;
                    } else if (path.startsWith(Paths.CONF_SWING_DIR)) {
                        path = paths.getConfigOutput() + path.substring(Paths.CONF_SWING_DIR.length());
                        copyFile = true;
                    } else if (path.startsWith(Paths.JAVA_WEB_STRUTS_DIR)) {
                        path = paths.getJspOutput() + path.substring(Paths.JAVA_WEB_STRUTS_DIR.length());
                        if (config.matchWebTier("struts").booleanValue()) {
                            copyFile = true;
                        }
                    } else if (path.startsWith(Paths.JAVA_WEB_TAPESTRY4_DIR)) {
                        path = paths.getJspOutput() + path.substring(Paths.JAVA_WEB_TAPESTRY4_DIR.length());
                        if (config.matchWebTier("tapestry").booleanValue()) {
                            copyFile = true;
                        }
                    } else if (path.startsWith(Paths.JAVA_SWING_DIR)) {
                        path = paths.getSwingOutput() + path.substring(Paths.JAVA_SWING_DIR.length());
                        if (config.matchWebTier("swing").booleanValue()) {
                            copyFile = true;
                        }
                    } else if (path.startsWith(Paths.JAVA_STRUTS_DIR)) {
                        path = paths.getWebOutput() + path.substring(Paths.JAVA_STRUTS_DIR.length());
                        if (config.matchWebTier("struts").booleanValue()) {
                            copyFile = true;
                        }
                    } else if (path.startsWith(Paths.JAVA_TAPESTRY4_DIR)) {
                        path = paths.getWebOutput() + path.substring(Paths.JAVA_TAPESTRY4_DIR.length());
                        if (config.matchWebTier("tapestry").booleanValue()) {
                            copyFile = true;
                        }
                    } else if (path.startsWith(Paths.JAVA_EJB2_DIR)) {
                        path = paths.getEjbOutput() + path.substring(Paths.JAVA_EJB2_DIR.length());
                        if (config.matchBusinessTier("ejb 2").booleanValue()) {
                            copyFile = true;
                        }
                    } else if (path.startsWith(Paths.JAVA_EJB3_DIR)) {
                        path = paths.getEjbOutput() + path.substring(Paths.JAVA_EJB3_DIR.length());
                        if (config.matchBusinessTier("ejb 3").booleanValue()) {
                            copyFile = true;
                        }
                    } else if (path.startsWith(Paths.JAVA_HIBERNATE2_DIR)) {
                        path = paths.getHibernateOutput() + path.substring(Paths.JAVA_HIBERNATE2_DIR.length());
                        if (config.matchBusinessTier("hibernate 2").booleanValue()) {
                            copyFile = true;
                        }
                    } else if (path.startsWith(Paths.JAVA_HIBERNATE3_DIR)) {
                        path = paths.getHibernateOutput() + path.substring(Paths.JAVA_HIBERNATE3_DIR.length());
                        if (config.matchBusinessTier("hibernate 3").booleanValue()) {
                            copyFile = true;
                        }
                    } else if (path.startsWith(Paths.JAVA_MOCK_DIR)) {
                        path = paths.getMockOutput() + path.substring(Paths.JAVA_MOCK_DIR.length());
                        if (config.useMock().booleanValue()) {
                            copyFile = true;
                        }
                    } else if (path.startsWith(Paths.JAVA_SERVICE_DIR)) {
                        path = paths.getServiceOutput() + path.substring(Paths.JAVA_SERVICE_DIR.length());
                        copyFile = true;
                    } else if (path.startsWith(Paths.JAVA_TEST_DIR)) {
                        path = paths.getTestOutput() + path.substring(Paths.JAVA_TEST_DIR.length());
                        copyFile = true;
                    } else if ((path.indexOf("build.bat") != -1) || ((path.indexOf("deploy.bat") != -1))) {
                        copyFile = true;
                    }
                }
                if (!path.startsWith("/")) {
                    path = "/" + path;
                }
                if (copyFile) {
                    fileOut += path;
                    path = outputDir + path;
                    if (!file.isDirectory()) {
                        String name = file.getName();
                        path = path.substring(0, (path.length() - name.length()));
                    }
                    new File(path).mkdirs();
                    if (!file.isDirectory()) {
                        byte array[] = new byte[1024];
                        int size = 0;
                        try {
                            BufferedInputStream in = new BufferedInputStream(new FileInputStream(file));
                            BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(fileOut));
                            while ((size = in.read(array)) != -1) out.write(array, 0, size);
                            in.close();
                            out.flush();
                            out.close();
                        } catch (Exception exc) {
                            log("[Error] Copy output file failed : " + fileOut);
                            log(exc.getMessage());
                        }
                    }
                }
            }
        } catch (Exception exc) {
            log.error("Error while copying files: ", exc);
            log(exc.getMessage());
        }
    }
} </s>
<s>class temp {    public void appendFetch(IProgress progress, PrintWriter pw, String list, int from, int to) throws IOException {
        progress.start();
        try {
            File storage = new File(cacheDirectory.getValue(), "mboxes");
            storage.mkdirs();
            File mbox = new File(storage, list + "-" + from + "-" + to + ".mbox");
            if (mbox.exists()) {
                BufferedReader in = new BufferedReader(new InputStreamReader(new ProgressInputStream(new FileInputStream(mbox), progress, 10000)));
                String line;
                while ((line = in.readLine()) != null) {
                    pw.write(line);
                    pw.write('\n');
                }
                in.close();
                return;
            }
            progress.setScale(100);
            IProgress subProgress1 = progress.getSub(75);
            URL url = getGmaneURL(list, from, to);
            BufferedReader in = new BufferedReader(new InputStreamReader(new ProgressInputStream(url.openStream(), subProgress1, 10000)));
            PrintWriter writeToMbox = new PrintWriter(mbox);
            int lines = 0;
            String line;
            while ((line = in.readLine()) != null) {
                lines++;
                if (line.matches("^From .*$") && !line.matches("^From .*? .*[0-9][0-9]:[0-9][0-9]:[0-9][0-9].*$")) {
                    line = ">" + line;
                }
                writeToMbox.write(line);
                writeToMbox.write('\n');
            }
            in.close();
            writeToMbox.close();
            appendFetch(progress.getSub(25), pw, list, from, to);
        } finally {
            progress.done();
        }
    }
} </s>
<s>class temp {        public boolean check(String credentials) throws IOException {
            if (credentials == null) return true;
            try {
                MessageDigest md = MessageDigest.getInstance("MD5");
                md.reset();
                md.update(method.getBytes("ISO-8859-1"));
                md.update((byte) ':');
                md.update(uri.getBytes("ISO-8859-1"));
                byte[] ha2 = md.digest();
                md.update(credentials.getBytes("ISO-8859-1"));
                md.update((byte) ':');
                md.update(nonce.getBytes("ISO-8859-1"));
                md.update((byte) ':');
                md.update(MessageDigester.byteArrayToHex(ha2).getBytes("ISO-8859-1"));
                byte[] digest = md.digest();
                return (MessageDigester.byteArrayToHex(digest).equalsIgnoreCase(response));
            } catch (NoSuchAlgorithmException e) {
                throw new RuntimeException("MD5 not supported");
            } catch (UnsupportedEncodingException e) {
                throw new RuntimeException("Encoding not supported");
            }
        }
} </s>
<s>class temp {    private void loadProperties() {
        if (properties == null) {
            properties = new Properties();
            try {
                URL url = getClass().getResource(propsFile);
                properties.load(url.openStream());
            } catch (IOException ioe) {
                ioe.printStackTrace();
            }
        }
    }
} </s>

<s>class temp {    public static byte[] SHA1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        MessageDigest md;
        md = MessageDigest.getInstance("SHA-1");
        byte[] sha1hash = new byte[40];
        md.update(text.getBytes("iso-8859-1"), 0, text.length());
        sha1hash = md.digest();
        return sha1hash;
    }
} </s>
<s>class temp {    public synchronized String encrypt(String password) {
        try {
            MessageDigest md = null;
            md = MessageDigest.getInstance("SHA-1");
            md.update(password.getBytes("UTF-8"));
            byte raw[] = md.digest();
            byte[] hash = (new Base64()).encode(raw);
            return new String(hash);
        } catch (NoSuchAlgorithmException e) {
            System.out.println("Algorithm SHA-1 is not supported");
            return null;
        } catch (UnsupportedEncodingException e) {
            System.out.println("UTF-8 encoding is not supported");
            return null;
        }
    }
} </s>
<s>class temp {    public void upload() throws UnknownHostException, SocketException, FTPConnectionClosedException, LoginFailedException, DirectoryChangeFailedException, CopyStreamException, RefusedConnectionException, IOException {
        final int NUM_XML_FILES = 2;
        final String META_XML_SUFFIX = "_meta.xml";
        final String FILES_XML_SUFFIX = "_files.xml";
        final String username = getUsername();
        final String password = getPassword();
        if (getFtpServer() == null) {
            throw new IllegalStateException("ftp server not set");
        }
        if (getFtpPath() == null) {
            throw new IllegalStateException("ftp path not set");
        }
        if (username == null) {
            throw new IllegalStateException("username not set");
        }
        if (password == null) {
            throw new IllegalStateException("password not set");
        }
        final String metaXmlString = serializeDocument(getMetaDocument());
        final String filesXmlString = serializeDocument(getFilesDocument());
        final byte[] metaXmlBytes = metaXmlString.getBytes();
        final byte[] filesXmlBytes = filesXmlString.getBytes();
        final int metaXmlLength = metaXmlBytes.length;
        final int filesXmlLength = filesXmlBytes.length;
        final Collection files = getFiles();
        final int totalFiles = NUM_XML_FILES + files.size();
        final String[] fileNames = new String[totalFiles];
        final long[] fileSizes = new long[totalFiles];
        final String metaXmlName = getIdentifier() + META_XML_SUFFIX;
        fileNames[0] = metaXmlName;
        fileSizes[0] = metaXmlLength;
        final String filesXmlName = getIdentifier() + FILES_XML_SUFFIX;
        fileNames[1] = filesXmlName;
        fileSizes[1] = filesXmlLength;
        int j = 2;
        for (Iterator i = files.iterator(); i.hasNext(); ) {
            final ArchiveFile f = (ArchiveFile) i.next();
            fileNames[j] = f.getRemoteFileName();
            fileSizes[j] = f.getFileSize();
            j++;
        }
        for (int i = 0; i < fileSizes.length; i++) {
            _fileNames2Progress.put(fileNames[i], new UploadFileProgress(fileSizes[i]));
            _totalUploadSize += fileSizes[i];
        }
        FTPClient ftp = new FTPClient();
        try {
            if (isCancelled()) {
                return;
            }
            ftp.enterLocalPassiveMode();
            if (isCancelled()) {
                return;
            }
            ftp.connect(getFtpServer());
            final int reply = ftp.getReplyCode();
            if (!FTPReply.isPositiveCompletion(reply)) {
                throw new RefusedConnectionException(getFtpServer() + "refused FTP connection");
            }
            if (isCancelled()) {
                return;
            }
            if (!ftp.login(username, password)) {
                throw new LoginFailedException();
            }
            try {
                if (!ftp.changeWorkingDirectory(getFtpPath())) {
                    if (!isFtpDirPreMade() && !ftp.makeDirectory(getFtpPath())) {
                        throw new DirectoryChangeFailedException();
                    }
                    if (isCancelled()) {
                        return;
                    }
                    if (!ftp.changeWorkingDirectory(getFtpPath())) {
                        throw new DirectoryChangeFailedException();
                    }
                }
                if (isCancelled()) {
                    return;
                }
                connected();
                uploadFile(metaXmlName, new ByteArrayInputStream(metaXmlBytes), ftp);
                uploadFile(filesXmlName, new ByteArrayInputStream(filesXmlBytes), ftp);
                if (isCancelled()) {
                    return;
                }
                ftp.setFileType(FTP.BINARY_FILE_TYPE);
                for (final Iterator i = files.iterator(); i.hasNext(); ) {
                    final ArchiveFile f = (ArchiveFile) i.next();
                    uploadFile(f.getRemoteFileName(), new FileInputStream(f.getIOFile()), ftp);
                }
            } catch (InterruptedIOException ioe) {
                return;
            } finally {
                ftp.logout();
            }
        } finally {
            try {
                ftp.disconnect();
            } catch (IOException e) {
            }
        }
        if (isCancelled()) {
            return;
        }
        checkinStarted();
        if (isCancelled()) {
            return;
        }
        checkin();
        if (isCancelled()) {
            return;
        }
        checkinCompleted();
    }
} </s>
<s>class temp {    @Override
    public String encode(String password) {
        String hash = null;
        MessageDigest m;
        try {
            m = MessageDigest.getInstance("MD5");
            m.update(password.getBytes(), 0, password.length());
            hash = String.format("%1$032X", new BigInteger(1, m.digest()));
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        return hash;
    }
} </s>
<s>class temp {    private static File copyFileTo(File file, File directory) throws IOException {
        File newFile = new File(directory, file.getName());
        FileInputStream fis = null;
        FileOutputStream fos = null;
        try {
            fis = new FileInputStream(file);
            fos = new FileOutputStream(newFile);
            byte buff[] = new byte[1024];
            int val;
            while ((val = fis.read(buff)) > 0) fos.write(buff, 0, val);
        } finally {
            if (fis != null) fis.close();
            if (fos != null) fos.close();
        }
        return newFile;
    }
} </s>
<s>class temp {    private ArrayList loadResults(String text, String index, int from) {
        loadingMore = true;
        JSONObject job = new JSONObject();
        ArrayList al = new ArrayList();
        try {
            String req = job.put("OperationId", "2").toString();
            InputStream is = null;
            String result = "";
            JSONObject jArray = null;
            try {
                HttpClient httpclient = new DefaultHttpClient();
                HttpPost httppost = new HttpPost("http://192.168.1.4:8080/newgenlibctxt/CarbonServlet");
                List<NameValuePair> nameValuePairs = new ArrayList<NameValuePair>(2);
                nameValuePairs.add(new BasicNameValuePair("OperationId", "2"));
                nameValuePairs.add(new BasicNameValuePair("Text", text));
                nameValuePairs.add(new BasicNameValuePair("Index", index));
                nameValuePairs.add(new BasicNameValuePair("From", from + ""));
                httppost.setEntity(new UrlEncodedFormEntity(nameValuePairs));
                HttpResponse response = httpclient.execute(httppost);
                HttpEntity entity = response.getEntity();
                is = entity.getContent();
            } catch (Exception e) {
                e.printStackTrace();
            }
            try {
                BufferedReader reader = new BufferedReader(new InputStreamReader(is, "UTF-8"), 8);
                StringBuilder sb = new StringBuilder();
                String line = null;
                while ((line = reader.readLine()) != null) {
                    sb.append(line + "\n");
                }
                is.close();
                result = sb.toString();
            } catch (Exception e) {
                e.printStackTrace();
            }
            try {
                JSONObject jobres = new JSONObject(result);
                JSONArray jarr = jobres.getJSONArray("Records");
                for (int i = 0; i < jarr.length(); i++) {
                    String title = jarr.getJSONObject(i).getString("title");
                    String author = jarr.getJSONObject(i).getString("author");
                    String[] id = new String[2];
                    id[0] = jarr.getJSONObject(i).getString("cataloguerecordid");
                    id[1] = jarr.getJSONObject(i).getString("ownerlibraryid");
                    alOnlyIds.add(id);
                    al.add(Html.fromHtml("<html><body><b>" + title + "</b><br>by " + author + "</body></html>"));
                }
            } catch (JSONException e) {
                e.printStackTrace();
            }
        } catch (Exception exp) {
            exp.printStackTrace();
        }
        loadingMore = false;
        return al;
    }
} </s>
<s>class temp {    public static String hash(String in, String algorithm) {
        if (StringUtils.isBlank(algorithm)) algorithm = DEFAULT_ALGORITHM;
        try {
            md = MessageDigest.getInstance(algorithm);
        } catch (NoSuchAlgorithmException nsae) {
            logger.error("No such algorithm exception", nsae);
        }
        md.reset();
        md.update(in.getBytes());
        String out = null;
        try {
            out = Base64Encoder.encode(md.digest());
        } catch (IOException e) {
            logger.error("Error converting to Base64 ", e);
        }
        if (out.endsWith("\n")) out = out.substring(0, out.length() - 1);
        return out;
    }
} </s>
<s>class temp {    private void testURL(String urlStr) throws MalformedURLException, IOException {
        HttpURLConnection conn = null;
        try {
            URL url = new URL(urlStr);
            conn = (HttpURLConnection) url.openConnection();
            int code = conn.getResponseCode();
            assertEquals(HttpURLConnection.HTTP_OK, code);
        } finally {
            if (conn != null) {
                conn.disconnect();
            }
        }
    }
} </s>
<s>class temp {    public static String generate(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        MessageDigest md;
        md = MessageDigest.getInstance("SHA-1");
        byte[] sha1hash = new byte[40];
        md.update(text.getBytes("iso-8859-1"), 0, text.length());
        sha1hash = md.digest();
        return convertToHex(sha1hash);
    }
} </s>
<s>class temp {    private String calculateHash(String s) {
        if (s == null) {
            return null;
        }
        MessageDigest messageDigest;
        try {
            messageDigest = MessageDigest.getInstance("SHA");
        } catch (NoSuchAlgorithmException e) {
            logger.error("Could not find a message digest algorithm.");
            return null;
        }
        messageDigest.update(s.getBytes());
        byte[] hash = messageDigest.digest();
        StringBuilder sb = new StringBuilder();
        for (byte b : hash) {
            sb.append(String.format("%02x", b));
        }
        return sb.toString();
    }
} </s>
<s>class temp {    private String createHash() {
        String hash = "";
        try {
            final java.util.Calendar c = java.util.Calendar.getInstance();
            String day = "" + c.get(java.util.Calendar.DATE);
            day = (day.length() == 1) ? '0' + day : day;
            String month = "" + (c.get(java.util.Calendar.MONTH) + 1);
            month = (month.length() == 1) ? '0' + month : month;
            final String hashString = getStringProperty("hashkey") + day + "." + month + "." + c.get(java.util.Calendar.YEAR);
            final MessageDigest md = MessageDigest.getInstance("MD5");
            md.update(hashString.getBytes());
            final byte digest[] = md.digest();
            hash = "";
            for (int i = 0; i < digest.length; i++) {
                final String s = Integer.toHexString(digest[i] & 0xFF);
                hash += ((s.length() == 1) ? "0" + s : s);
            }
        } catch (final NoSuchAlgorithmException e) {
            bot.getLogger().log(e);
        }
        return hash;
    }
} </s>
<s>class temp {    public void testAuthentication() throws Exception {
        String host = "localhost";
        int port = DEFAULT_PORT;
        URL url = new URL("http://" + host + ":" + port + "/");
        URLConnection connection = url.openConnection();
        InputStream in = connection.getInputStream();
        in.close();
        waitToStop();
        server.setAttribute(name, new Attribute("AuthenticationMethod", "basic"));
        server.invoke(name, "addAuthorization", new Object[] { "mx4j", "mx4j" }, new String[] { "java.lang.String", "java.lang.String" });
        server.invoke(name, "start", null, null);
        url = new URL("http://" + host + ":" + port + "/");
        connection = url.openConnection();
        try {
            in = connection.getInputStream();
        } catch (Exception e) {
        } finally {
            in.close();
        }
        assertEquals(((HttpURLConnection) connection).getResponseCode(), 401);
        url = new URL("http://" + host + ":" + port + "/");
        connection = url.openConnection();
        connection.setRequestProperty("Authorization", "basic bXg0ajpteDRq");
        in = connection.getInputStream();
        in.close();
        waitToStop();
        server.setAttribute(name, new Attribute("AuthenticationMethod", "none"));
    }
} </s>
<s>class temp {    public void testAddCommandProcessor() throws Exception {
        String host = "localhost";
        int port = DEFAULT_PORT;
        URLConnection connection = null;
        URL url = new URL("http://" + host + ":" + port + "/nonexistant");
        server.invoke(name, "addCommandProcessor", new Object[] { "nonexistant", new DummyCommandProcessor() }, new String[] { "java.lang.String", "mx4j.tools.adaptor.http.HttpCommandProcessor" });
        connection = url.openConnection();
        assertEquals(200, ((HttpURLConnection) connection).getResponseCode());
        server.invoke(name, "removeCommandProcessor", new Object[] { "nonexistant" }, new String[] { "java.lang.String" });
        connection = url.openConnection();
        assertEquals(404, ((HttpURLConnection) connection).getResponseCode());
        server.invoke(name, "addCommandProcessor", new Object[] { "nonexistant", "test.mx4j.tools.adaptor.http.HttpAdaptorTest$DummyCommandProcessor" }, new String[] { "java.lang.String", "java.lang.String" });
        connection = url.openConnection();
        assertEquals(200, ((HttpURLConnection) connection).getResponseCode());
    }
} </s>
<s>class temp {    public void parse(Project project, Object source, RootHandler handler) {
        AntXMLContext context = (AntXMLContext) Reflect.getField(handler, "context");
        File buildFile = null;
        URL url = null;
        String buildFileName = null;
        if (source instanceof File) {
            buildFile = (File) source;
            buildFile = fu.normalize(buildFile.getAbsolutePath());
            context.setBuildFile(buildFile);
            buildFileName = buildFile.toString();
        } else if (source instanceof URL) {
            url = (URL) source;
            buildFileName = url.toString();
        } else {
            throw new BuildException("Source " + source.getClass().getName() + " not supported by this plugin");
        }
        InputStream inputStream = null;
        InputSource inputSource = null;
        try {
            XMLReader parser = JAXPUtils.getNamespaceXMLReader();
            String uri = null;
            if (buildFile != null) {
                uri = fu.toURI(buildFile.getAbsolutePath());
                inputStream = new FileInputStream(buildFile);
            } else {
                inputStream = url.openStream();
                uri = url.toString();
            }
            inputSource = new InputSource(inputStream);
            if (uri != null) {
                inputSource.setSystemId(uri);
            }
            project.log("parsing buildfile " + buildFileName + " with URI = " + uri, Project.MSG_VERBOSE);
            DefaultHandler hb = handler;
            parser.setContentHandler(hb);
            parser.setEntityResolver(hb);
            parser.setErrorHandler(hb);
            parser.setDTDHandler(hb);
            parser.parse(inputSource);
        } catch (SAXParseException exc) {
            Location location = new Location(exc.getSystemId(), exc.getLineNumber(), exc.getColumnNumber());
            Throwable t = exc.getException();
            if (t instanceof BuildException) {
                BuildException be = (BuildException) t;
                if (be.getLocation() == Location.UNKNOWN_LOCATION) {
                    be.setLocation(location);
                }
                throw be;
            }
            throw new BuildException(exc.getMessage(), t, location);
        } catch (SAXException exc) {
            Throwable t = exc.getException();
            if (t instanceof BuildException) {
                throw (BuildException) t;
            }
            throw new BuildException(exc.getMessage(), t);
        } catch (FileNotFoundException exc) {
            throw new BuildException(exc);
        } catch (UnsupportedEncodingException exc) {
            throw new BuildException("Encoding of project file " + buildFileName + " is invalid.", exc);
        } catch (IOException exc) {
            throw new BuildException("Error reading project file " + buildFileName + ": " + exc.getMessage(), exc);
        } finally {
            if (inputStream != null) {
                try {
                    inputStream.close();
                } catch (IOException ioe) {
                }
            }
        }
    }
} </s>
<s>class temp {    private static void initMimeTypes() {
        InputStream is = null;
        extMimeTypes = new Properties();
        try {
            try {
                is = MimeUtil.class.getClassLoader().getResourceAsStream("eu/medsea/mimeutil/mime-types.properties");
                if (is != null) {
                    ((Properties) extMimeTypes).load(is);
                }
            } catch (Exception e) {
                log.error("Error loading internal mime-types.properties", e);
            } finally {
                is = closeStream(is);
            }
            try {
                File f = new File(System.getProperty("user.home") + File.separator + ".mime-types.properties");
                if (f.exists()) {
                    is = new FileInputStream(f);
                    if (is != null) {
                        log.debug("Found a custom .mime-types.properties file in the users home directory.");
                        Properties props = new Properties();
                        props.load(is);
                        if (props.size() > 0) {
                            extMimeTypes.putAll(props);
                        }
                        log.debug("Successfully parsed .mime-types.properties from users home directory.");
                    }
                }
            } catch (Exception e) {
                log.error("Failed to parse .magic.mime file from users home directory. File will be ignored.", e);
            } finally {
                is = closeStream(is);
            }
            try {
                Enumeration e = MimeUtil.class.getClassLoader().getResources("mime-types.properties");
                while (e.hasMoreElements()) {
                    URL url = (URL) e.nextElement();
                    if (log.isDebugEnabled()) {
                        log.debug("Found custom mime-types.properties file on the classpath [" + url + "].");
                    }
                    Properties props = new Properties();
                    try {
                        is = url.openStream();
                        if (is != null) {
                            props.load(is);
                            if (props.size() > 0) {
                                extMimeTypes.putAll(props);
                                if (log.isDebugEnabled()) {
                                    log.debug("Successfully loaded custome mime-type.properties file [" + url + "] from classpath.");
                                }
                            }
                        }
                    } catch (Exception ex) {
                        log.error("Failed while loading custom mime-type.properties file [" + url + "] from classpath. File will be ignored.");
                    }
                }
            } catch (Exception e) {
                log.error("Problem while processing mime-types.properties files(s) from classpath. Files will be ignored.", e);
            } finally {
                is = closeStream(is);
            }
            try {
                String fname = System.getProperty("mime-mappings");
                if (fname != null && fname.length() != 0) {
                    is = new FileInputStream(fname);
                    if (is != null) {
                        if (log.isDebugEnabled()) {
                            log.debug("Found a custom mime-mappings property defined by the property -Dmime-mappings [" + System.getProperty("mime-mappings") + "].");
                        }
                        Properties props = new Properties();
                        props.load(is);
                        if (props.size() > 0) {
                            extMimeTypes.putAll(props);
                        }
                        log.debug("Successfully loaded the mime mappings file from property -Dmime-mappings [" + System.getProperty("mime-mappings") + "].");
                    }
                }
            } catch (Exception ex) {
                log.error("Failed to load the mime-mappings file defined by the property -Dmime-mappings [" + System.getProperty("mime-mappings") + "].");
            } finally {
                is = closeStream(is);
            }
        } finally {
            Iterator it = extMimeTypes.values().iterator();
            while (it.hasNext()) {
                String[] types = ((String) it.next()).split(",");
                for (int i = 0; i < types.length; i++) {
                    MimeUtil.addKnownMimeType(types[i]);
                }
            }
        }
    }
} </s>
<s>class temp {    public static String ReadURL(URL url, boolean textonly) {
        try {
            URLConnection uconn = url.openConnection();
            Object ucont = uconn.getContent();
            if (ucont instanceof InputStream) return ReadInputStream((java.io.InputStream) ucont, textonly); else return "" + ucont;
        } catch (java.io.IOException e) {
            e.printStackTrace();
        }
        return null;
    }
} </s>
<s>class temp {    private void storeConfigurationPropertiesFile(java.net.URL url, String comp) {
        java.util.Properties p;
        try {
            p = new java.util.Properties();
            p.load(url.openStream());
        } catch (java.io.IOException ie) {
            System.err.println("error opening: " + url.getPath() + ": " + ie.getMessage());
            return;
        }
        storeConfiguration(p, comp);
        return;
    }
} </s>
<s>class temp {    public List<String> loadList(String name) {
        List<String> ret = new ArrayList<String>();
        try {
            URL url = getClass().getClassLoader().getResource("lists/" + name + ".utf-8");
            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream(), "UTF-8"));
            String line;
            while ((line = reader.readLine()) != null) {
                ret.add(line);
            }
            reader.close();
        } catch (IOException e) {
            showError("No se puede cargar la lista de valores: " + name, e);
        }
        return ret;
    }
} </s>
<s>class temp {    @Override
    public VocabularyLocation next() {
        try {
            if (!urls.isEmpty()) {
                final URL url = urls.poll();
                return new VocabularyLocation(url.toExternalForm(), VocabularyFormat.RDFXML, 0, url.openStream());
            }
            if (!files.isEmpty()) {
                File file = files.poll();
                return new VocabularyLocation(file.getCanonicalPath(), file.getName().endsWith(".ntriples") ? VocabularyFormat.NTRIPLES : VocabularyFormat.RDFXML, file.lastModified(), new FileInputStream(file));
            }
            if (nextZipEntry != null) {
                String zipEntryAsString = IOUtils.toString(new CloseShieldInputStream(in), "UTF-8");
                VocabularyLocation location = new VocabularyLocation(nextZipEntry.getName(), nextZipEntry.getName().endsWith(".rdf") ? VocabularyFormat.RDFXML : null, nextZipEntry.getTime(), IOUtils.toInputStream(zipEntryAsString, "UTF-8"));
                findNextZipEntry();
                return location;
            }
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        throw new NoSuchElementException();
    }
} </s>
<s>class temp {    @Override
    protected svm_model loadModel(InputStream inputStream) throws IOException {
        File tmpFile = File.createTempFile("tmp", ".mdl");
        FileOutputStream output = new FileOutputStream(tmpFile);
        try {
            IOUtils.copy(inputStream, output);
            return libsvm.svm.svm_load_model(tmpFile.getPath());
        } finally {
            output.close();
            tmpFile.delete();
        }
    }
} </s>
<s>class temp {    public static void writeToFile(final File file, final InputStream in) throws IOException {
        IOUtils.createFile(file);
        FileOutputStream fos = null;
        try {
            fos = new FileOutputStream(file);
            IOUtils.copyStream(in, fos);
        } finally {
            IOUtils.closeIO(fos);
        }
    }
} </s>
<s>class temp {    public static void copyFile(final File sourceFile, final File destFile) throws IOException {
        if (!destFile.exists()) {
            destFile.createNewFile();
        }
        FileInputStream inStream = null;
        FileOutputStream outStream = null;
        FileChannel source = null;
        FileChannel destination = null;
        try {
            source = (inStream = new FileInputStream(sourceFile)).getChannel();
            destination = (outStream = new FileOutputStream(destFile)).getChannel();
            destination.transferFrom(source, 0, source.size());
        } finally {
            closeIO(source);
            closeIO(inStream);
            closeIO(destination);
            closeIO(outStream);
        }
    }
} </s>
<s>class temp {    public static InputStream obterConteudoArquivo(String u) {
        URL url;
        try {
            url = new URL(u);
            URLConnection conn = null;
            if (proxy != null) conn = url.openConnection(proxy.getProxy()); else conn = url.openConnection();
            return new DataInputStream(conn.getInputStream());
        } catch (MalformedURLException e) {
            throw new AlfredException(e);
        } catch (IOException e) {
            throw new AlfredException(e);
        }
    }
} </s>
<s>class temp {    public static String obterConteudoSite(String u) {
        URL url;
        try {
            url = new URL(u);
            URLConnection conn = null;
            if (proxy != null) conn = url.openConnection(proxy.getProxy()); else conn = url.openConnection();
            conn.setDoOutput(true);
            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream(), Charset.forName("UTF-8")));
            String line;
            StringBuilder resultado = new StringBuilder();
            while ((line = rd.readLine()) != null) {
                resultado.append(line);
                resultado.append("\n");
            }
            rd.close();
            return resultado.toString();
        } catch (MalformedURLException e) {
            throw new AlfredException("Não foi possível obter contato com o site " + u, e);
        } catch (IOException e) {
            throw new AlfredException("Não foi possível obter contato com o site " + u, e);
        }
    }
} </s>
<s>class temp {    protected byte[] getTSAResponse(byte[] requestBytes) throws Exception {
        URL url = new URL(tsaURL);
        URLConnection tsaConnection;
        tsaConnection = (URLConnection) url.openConnection();
        tsaConnection.setDoInput(true);
        tsaConnection.setDoOutput(true);
        tsaConnection.setUseCaches(false);
        tsaConnection.setRequestProperty("Content-Type", "application/timestamp-query");
        tsaConnection.setRequestProperty("Content-Transfer-Encoding", "binary");
        if ((tsaUsername != null) && !tsaUsername.equals("")) {
            String userPassword = tsaUsername + ":" + tsaPassword;
            tsaConnection.setRequestProperty("Authorization", "Basic " + Base64.encodeBytes(userPassword.getBytes()));
        }
        OutputStream out = tsaConnection.getOutputStream();
        out.write(requestBytes);
        out.close();
        InputStream inp = tsaConnection.getInputStream();
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        byte[] buffer = new byte[1024];
        int bytesRead = 0;
        while ((bytesRead = inp.read(buffer, 0, buffer.length)) >= 0) {
            baos.write(buffer, 0, bytesRead);
        }
        byte[] respBytes = baos.toByteArray();
        String encoding = tsaConnection.getContentEncoding();
        if (encoding != null && encoding.equalsIgnoreCase("base64")) {
            respBytes = Base64.decode(new String(respBytes));
        }
        return respBytes;
    }
} </s>
<s>class temp {    public void logout(String cookieString) throws NetworkException {
        HttpClient client = HttpConfig.newInstance();
        HttpGet get = new HttpGet(HttpConfig.bbsURL() + HttpConfig.BBS_LOGOUT);
        if (cookieString != null && cookieString.length() != 0) get.setHeader("Cookie", cookieString);
        try {
            HttpResponse response = client.execute(get);
            if (response != null && response.getEntity() != null) {
                HTTPUtil.consume(response.getEntity());
            }
        } catch (Exception e) {
            e.printStackTrace();
            throw new NetworkException(e);
        }
    }
} </s>
<s>class temp {    public List<BoardObject> favBoard() throws NetworkException, ContentException {
        HttpClient client = HttpConfig.newInstance();
        HttpGet get = new HttpGet(HttpConfig.bbsURL() + HttpConfig.BBS_FAV);
        try {
            HttpResponse response = client.execute(get);
            HttpEntity entity = response.getEntity();
            if (HTTPUtil.isHttp200(response) && HTTPUtil.isXmlContentType(response)) {
                Document doc = XmlOperator.readDocument(entity.getContent());
                return BBSBodyParseHelper.parseFavBoardList(doc);
            } else {
                String msg = BBSBodyParseHelper.parseFailMsg(entity);
                throw new ContentException(msg);
            }
        } catch (ClientProtocolException e) {
            e.printStackTrace();
            throw new NetworkException(e);
        } catch (IOException e) {
            e.printStackTrace();
            throw new NetworkException(e);
        }
    }
} </s>
<s>class temp {    public boolean addFavBoard(BoardObject board) throws NetworkException, ContentException {
        String url = HttpConfig.bbsURL() + HttpConfig.BBS_FAV_ADD + board.getId();
        HttpClient client = HttpConfig.newInstance();
        HttpGet get = new HttpGet(url);
        try {
            HttpResponse response = client.execute(get);
            HttpEntity entity = response.getEntity();
            if (HTTPUtil.isHttp200(response) && HTTPUtil.isXmlContentType(response)) {
                HTTPUtil.consume(response.getEntity());
                return true;
            } else {
                String msg = BBSBodyParseHelper.parseFailMsg(entity);
                throw new ContentException(msg);
            }
        } catch (ClientProtocolException e) {
            e.printStackTrace();
            throw new NetworkException(e);
        } catch (IOException e) {
            e.printStackTrace();
            throw new NetworkException(e);
        }
    }
} </s>
<s>class temp {    public boolean setFavBoard(List<BoardObject> list) throws NetworkException, ContentException {
        HttpClient client = HttpConfig.newInstance();
        HttpPost post = new HttpPost(HttpConfig.bbsURL() + HttpConfig.BBS_FAV_SETTING);
        List<NameValuePair> nvps = new ArrayList<NameValuePair>();
        for (BoardObject board : list) nvps.add(new BasicNameValuePair(board.getId(), "on"));
        try {
            post.setEntity(new UrlEncodedFormEntity(nvps, BBSBodyParseHelper.BBS_CHARSET));
            HttpResponse response = client.execute(post);
            HttpEntity entity = response.getEntity();
            if (HTTPUtil.isHttp200(response) && HTTPUtil.isXmlContentType(response)) {
                HTTPUtil.consume(response.getEntity());
                return true;
            } else {
                String msg = BBSBodyParseHelper.parseFailMsg(entity);
                throw new ContentException(msg);
            }
        } catch (ClientProtocolException e) {
            e.printStackTrace();
            throw new NetworkException(e);
        } catch (IOException e) {
            e.printStackTrace();
            throw new NetworkException(e);
        }
    }
} </s>
<s>class temp {    public static String digest(String algorithm, String text) {
        MessageDigest mDigest = null;
        try {
            mDigest = MessageDigest.getInstance(algorithm);
            mDigest.update(text.getBytes(ENCODING));
        } catch (NoSuchAlgorithmException nsae) {
            Logger.error(Encryptor.class, nsae.getMessage(), nsae);
        } catch (UnsupportedEncodingException uee) {
            Logger.error(Encryptor.class, uee.getMessage(), uee);
        }
        byte raw[] = mDigest.digest();
        return (new BASE64Encoder()).encode(raw);
    }
} </s>
<s>class temp {    public static String getMd5Hash(String text) {
        StringBuffer result = new StringBuffer(32);
        try {
            MessageDigest md5 = MessageDigest.getInstance("MD5");
            md5.update(text.getBytes());
            Formatter f = new Formatter(result);
            byte[] digest = md5.digest();
            for (int i = 0; i < digest.length; i++) {
                f.format("%02x", new Object[] { new Byte(digest[i]) });
            }
        } catch (NoSuchAlgorithmException ex) {
            ex.printStackTrace();
        }
        return result.toString();
    }
} </s>
<s>class temp {    public DataSet guessAtUnknowns(String filename) {
        TasselFileType guess = TasselFileType.Sequence;
        DataSet tds = null;
        try {
            BufferedReader br = null;
            if (filename.startsWith("http")) {
                URL url = new URL(filename);
                br = new BufferedReader(new InputStreamReader(url.openStream()));
            } else {
                br = new BufferedReader(new FileReader(filename));
            }
            String line1 = br.readLine().trim();
            String[] sval1 = line1.split("\\s");
            String line2 = br.readLine().trim();
            String[] sval2 = line2.split("\\s");
            boolean lociMatchNumber = false;
            if (!sval1[0].startsWith("<") && (sval1.length == 2) && (line1.indexOf(':') < 0)) {
                int countLoci = Integer.parseInt(sval1[1]);
                if (countLoci == sval2.length) {
                    lociMatchNumber = true;
                }
            }
            if (sval1[0].equalsIgnoreCase("<Annotated>")) {
                guess = TasselFileType.Annotated;
            } else if (line1.startsWith("<") || line1.startsWith("#")) {
                boolean isTrait = false;
                boolean isMarker = false;
                boolean isNumeric = false;
                boolean isMap = false;
                Pattern tagPattern = Pattern.compile("[<>\\s]+");
                String[] info1 = tagPattern.split(line1);
                String[] info2 = tagPattern.split(line2);
                if (info1.length > 1) {
                    if (info1[1].toUpperCase().startsWith("MARKER")) {
                        isMarker = true;
                    } else if (info1[1].toUpperCase().startsWith("TRAIT")) {
                        isTrait = true;
                    } else if (info1[1].toUpperCase().startsWith("NUMER")) {
                        isNumeric = true;
                    } else if (info1[1].toUpperCase().startsWith("MAP")) {
                        isMap = true;
                    }
                }
                if (info2.length > 1) {
                    if (info2[1].toUpperCase().startsWith("MARKER")) {
                        isMarker = true;
                    } else if (info2[1].toUpperCase().startsWith("TRAIT")) {
                        isTrait = true;
                    } else if (info2[1].toUpperCase().startsWith("NUMER")) {
                        isNumeric = true;
                    } else if (info2[1].toUpperCase().startsWith("MAP")) {
                        isMap = true;
                    }
                } else {
                    guess = null;
                    String inline = br.readLine();
                    while (guess == null && inline != null && (inline.startsWith("#") || inline.startsWith("<"))) {
                        if (inline.startsWith("<")) {
                            String[] info = tagPattern.split(inline);
                            if (info[1].toUpperCase().startsWith("MARKER")) {
                                isMarker = true;
                            } else if (info[1].toUpperCase().startsWith("TRAIT")) {
                                isTrait = true;
                            } else if (info[1].toUpperCase().startsWith("NUMER")) {
                                isNumeric = true;
                            } else if (info[1].toUpperCase().startsWith("MAP")) {
                                isMap = true;
                            }
                        }
                    }
                }
                if (isTrait || (isMarker && isNumeric)) {
                    guess = TasselFileType.Phenotype;
                } else if (isMarker) {
                    guess = TasselFileType.Polymorphism;
                } else if (isMap) {
                    guess = TasselFileType.GeneticMap;
                } else {
                    throw new IOException("Improperly formatted header. Data will not be imported.");
                }
            } else if ((line1.startsWith(">")) || (line1.startsWith(";"))) {
                guess = TasselFileType.Fasta;
            } else if (sval1.length == 1) {
                guess = TasselFileType.SqrMatrix;
            } else if (line1.indexOf(':') > 0) {
                guess = TasselFileType.Polymorphism;
            } else if ((sval1.length == 2) && (lociMatchNumber)) {
                guess = TasselFileType.Polymorphism;
            } else if ((line1.startsWith("#Nexus")) || (line1.startsWith("#NEXUS")) || (line1.startsWith("CLUSTAL")) || ((sval1.length == 2) && (sval2.length == 2))) {
                guess = TasselFileType.Sequence;
            } else if (sval1.length == 3) {
                guess = TasselFileType.Numerical;
            }
            myLogger.info("guessAtUnknowns: type: " + guess);
            tds = processDatum(filename, guess);
            br.close();
        } catch (Exception e) {
        }
        return tds;
    }
} </s>
<s>class temp {    public static void main(String args[]) throws IOException {
        String inFileName = args[0];
        String outFileName = args[1];
        long position = 0L;
        try {
            position = Long.parseLong(args[2]);
        } catch (NumberFormatException nfex1) {
            try {
                position = Long.parseLong(args[2], 16);
            } catch (NumberFormatException nfex2) {
                System.err.println("Wrong offset");
                System.exit(0);
            }
        }
        if (position < 1L) {
            System.err.println("Wrong offset. Must be more than 0");
            System.exit(0);
        }
        System.out.println("Copying  input: " + inFileName);
        System.out.println("        output: " + outFileName);
        System.out.println("          from: " + position);
        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(inFileName));
        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(outFileName));
        bis.skip(position);
        for (byte[] b = new byte[1]; bis.read(b) > 0; bos.write(b)) ;
        bis.close();
        bos.close();
    }
} </s>
<s>class temp {    public boolean isValid(WizardContext context) {
        if (serviceSelection < 0) {
            return false;
        }
        ServiceReference selection = (ServiceReference) serviceList.getElementAt(serviceSelection);
        if (selection == null) {
            return false;
        }
        String function = (String) context.getAttribute(ServiceWizard.ATTRIBUTE_FUNCTION);
        context.setAttribute(ServiceWizard.ATTRIBUTE_SERVICE_REFERENCE, selection);
        URL url = selection.getResourceURL();
        InputStream inputStream = null;
        try {
            inputStream = url.openStream();
            InputSource inputSource = new InputSource(inputStream);
            JdbcService service = ServiceDigester.parseService(inputSource, IsqlToolkit.getSharedEntityResolver());
            context.setAttribute(ServiceWizard.ATTRIBUTE_SERVICE, service);
            return true;
        } catch (IOException error) {
            if (!ServiceWizard.FUNCTION_DELETE.equals(function)) {
                String loc = url.toExternalForm();
                String message = messages.format("SelectServiceStep.failed_to_load_service_from_url", loc);
                context.showErrorDialog(error, message);
            } else {
                return true;
            }
        } catch (Exception error) {
            String message = messages.format("SelectServiceStep.service_load_error", url.toExternalForm());
            context.showErrorDialog(error, message);
        }
        return false;
    }
} </s>
<s>class temp {    private boolean extract(File archive, File dir, IProgressMonitor monitor) {
        monitor.subTask("Extract : " + archive.getName());
        if (!dir.exists()) {
            dir.mkdirs();
        } else {
            File[] files = dir.listFiles();
            for (int j = 0; j < files.length; j++) {
                files[j].delete();
            }
        }
        ZipInputStream zis = null;
        try {
            zis = new ZipInputStream(new FileInputStream(archive));
            ZipEntry entry;
            while ((entry = zis.getNextEntry()) != null) {
                File indexFile = new File(dir, entry.getName());
                FileOutputStream fos = null;
                try {
                    fos = new FileOutputStream(indexFile);
                    IOUtils.copy(zis, fos);
                } finally {
                    IOUtils.closeQuietly(fos);
                }
            }
            return true;
        } catch (Exception ex) {
            M4EclipsePlugin.log(new Status(IStatus.ERROR, M4EclipsePlugin.PLUGIN_ID, -1, "For index '" + dir.getName() + "' Unable to initialize indexes", ex));
        } finally {
            IOUtils.closeQuietly(zis);
        }
        return false;
    }
} </s>
<s>class temp {    private void download(File archive, File timestamp, URL url, IProgressMonitor monitor) throws IOException {
        monitor.subTask("download " + url.toString());
        InputStream in = null;
        FileOutputStream out = null;
        URLConnection conn = null;
        try {
            conn = url.openConnection();
            Writer writer = null;
            try {
                Date date = new Date(conn.getLastModified());
                writer = new FileWriter(timestamp);
                writer.write(this.FORMAT.format(date));
            } catch (IOException e) {
                timestamp.delete();
            } finally {
                IOUtils.closeQuietly(writer);
            }
            in = conn.getInputStream();
            out = new FileOutputStream(archive);
            IOUtils.copy(in, out);
        } finally {
            IOUtils.closeQuietly(in);
            IOUtils.closeQuietly(out);
        }
    }
} </s>
<s>class temp {    private boolean checkTimestamp(File timestamp, URL url) {
        try {
            if (timestamp.exists()) {
                FileReader reader = null;
                Date dateLocal = null;
                try {
                    reader = new FileReader(timestamp);
                    StringWriter tmp = new StringWriter();
                    IOUtils.copy(reader, tmp);
                    dateLocal = this.FORMAT.parse(tmp.toString());
                } catch (ParseException e) {
                    timestamp.delete();
                } catch (IOException e) {
                } finally {
                    IOUtils.closeQuietly(reader);
                }
                if (dateLocal != null) {
                    try {
                        URLConnection conn = url.openConnection();
                        Date date = this.FORMAT.parse(this.FORMAT.format(new Date(conn.getLastModified())));
                        return (date.compareTo(dateLocal) == 0);
                    } catch (IOException e) {
                    }
                }
            }
        } catch (Throwable t) {
        }
        return false;
    }
} </s>
<s>class temp {    static Object loadPersistentRepresentationFromFile(URL url) throws PersistenceException {
        PersistenceManager.persistenceURL.get().addFirst(url);
        ObjectInputStream ois = null;
        HierarchicalStreamReader reader = null;
        XStream xstream = null;
        try {
            Reader inputReader = new java.io.InputStreamReader(url.openStream());
            try {
                XMLInputFactory inputFactory = XMLInputFactory.newInstance();
                XMLStreamReader xsr = inputFactory.createXMLStreamReader(url.toExternalForm(), inputReader);
                reader = new StaxReader(new QNameMap(), xsr);
            } catch (XMLStreamException xse) {
                throw new PersistenceException("Error creating reader", xse);
            }
            xstream = new XStream(new StaxDriver());
            xstream.setClassLoader(Gate.getClassLoader());
            ois = xstream.createObjectInputStream(reader);
            Object res = null;
            Iterator urlIter = ((Collection) PersistenceManager.getTransientRepresentation(ois.readObject())).iterator();
            while (urlIter.hasNext()) {
                URL anUrl = (URL) urlIter.next();
                try {
                    Gate.getCreoleRegister().registerDirectories(anUrl);
                } catch (GateException ge) {
                    Err.prln("Could not reload creole directory " + anUrl.toExternalForm());
                }
            }
            res = ois.readObject();
            ois.close();
            return res;
        } catch (PersistenceException pe) {
            throw pe;
        } catch (Exception e) {
            throw new PersistenceException("Error loading GAPP file", e);
        } finally {
            PersistenceManager.persistenceURL.get().removeFirst();
            if (PersistenceManager.persistenceURL.get().isEmpty()) {
                PersistenceManager.persistenceURL.remove();
            }
        }
    }
} </s>
<s>class temp {    public static boolean isImageLinkReachable(WebImage image) {
        if (image.getUrl() == null) return false;
        try {
            URL url = new URL(image.getUrl());
            url.openStream().close();
        } catch (MalformedURLException e) {
            return false;
        } catch (IOException e) {
            return false;
        }
        return true;
    }
} </s>
<s>class temp {    private File copyFile(File source, File destiny) {
        try {
            FileInputStream fileinputstream = new FileInputStream(source);
            FileOutputStream fileoutputstream = new FileOutputStream(destiny);
            byte abyte0[] = new byte[4096];
            int i;
            while ((i = fileinputstream.read(abyte0)) != -1) fileoutputstream.write(abyte0, 0, i);
            fileinputstream.close();
            fileoutputstream.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
            LOGGER.error(e.getMessage());
        } catch (IOException e) {
            e.printStackTrace();
            LOGGER.error(e.getMessage());
        }
        return destiny;
    }
} </s>
<s>class temp {    public static boolean copyFile(File src, File dest) throws IOException {
        if (src == null) {
            throw new IllegalArgumentException("src == null");
        }
        if (dest == null) {
            throw new IllegalArgumentException("dest == null");
        }
        if (!src.isFile()) {
            return false;
        }
        FileChannel in = new FileInputStream(src).getChannel();
        FileChannel out = new FileOutputStream(dest).getChannel();
        try {
            in.transferTo(0, in.size(), out);
            return true;
        } catch (IOException e) {
            throw e;
        } finally {
            if (in != null) {
                in.close();
            }
            if (out != null) {
                out.close();
            }
        }
    }
} </s>
<s>class temp {    public ProgramProfilingSymbol deleteProfilingSymbol(int id) throws AdaptationException {
        ProgramProfilingSymbol profilingSymbol = null;
        Connection connection = null;
        Statement statement = null;
        ResultSet resultSet = null;
        try {
            String query = "SELECT * FROM ProgramProfilingSymbols " + "WHERE id = " + id;
            connection = DriverManager.getConnection(CONN_STR);
            statement = connection.createStatement();
            resultSet = statement.executeQuery(query);
            if (!resultSet.next()) {
                connection.rollback();
                String msg = "Attempt to delete program profiling " + "symbol failed.";
                log.error(msg);
                throw new AdaptationException(msg);
            }
            profilingSymbol = getProfilingSymbol(resultSet);
            query = "DELETE FROM ProgramProfilingSymbols " + "WHERE id = " + id;
            statement.executeUpdate(query);
            connection.commit();
        } catch (SQLException ex) {
            try {
                connection.rollback();
            } catch (Exception e) {
            }
            String msg = "SQLException in deleteProfilingSymbol";
            log.error(msg, ex);
            throw new AdaptationException(msg, ex);
        } finally {
            try {
                resultSet.close();
            } catch (Exception ex) {
            }
            try {
                statement.close();
            } catch (Exception ex) {
            }
            try {
                connection.close();
            } catch (Exception ex) {
            }
        }
        return profilingSymbol;
    }
} </s>
<s>class temp {    public ProgramProfilingSymbol updateProgramProfilingSymbol(int id, int configID, int programSymbolID) throws AdaptationException {
        ProgramProfilingSymbol pps = null;
        Connection connection = null;
        Statement statement = null;
        ResultSet resultSet = null;
        try {
            String query = "UPDATE ProgramProfilingSymbols SET " + "projectDeploymentConfigurationID = " + configID + ", " + "programSymbolID                  = " + programSymbolID + ", " + "WHERE id = " + id;
            connection = DriverManager.getConnection(CONN_STR);
            statement = connection.createStatement();
            statement.executeUpdate(query);
            query = "SELECT * from ProgramProfilingSymbols WHERE " + "id = " + id;
            resultSet = statement.executeQuery(query);
            if (!resultSet.next()) {
                connection.rollback();
                String msg = "Attempt to update program profiling " + "symbol failed.";
                log.error(msg);
                throw new AdaptationException(msg);
            }
            pps = getProfilingSymbol(resultSet);
            connection.commit();
        } catch (SQLException ex) {
            try {
                connection.rollback();
            } catch (Exception e) {
            }
            String msg = "SQLException in updateProgramProfilingSymbol";
            log.error(msg, ex);
            throw new AdaptationException(msg, ex);
        } finally {
            try {
                resultSet.close();
            } catch (Exception ex) {
            }
            try {
                statement.close();
            } catch (Exception ex) {
            }
            try {
                connection.close();
            } catch (Exception ex) {
            }
        }
        return pps;
    }
} </s>
<s>class temp {    public ProgramSymbol createNewProgramSymbol(int programID, String module, String symbol, int address, int size) throws AdaptationException {
        ProgramSymbol programSymbol = null;
        Connection connection = null;
        Statement statement = null;
        ResultSet resultSet = null;
        try {
            String query = "INSERT INTO ProgramSymbols " + "(programID, module, symbol, address, size)" + " VALUES (" + programID + ", '" + module + "',  '" + symbol + "', " + address + ", " + size + ")";
            connection = DriverManager.getConnection(CONN_STR);
            statement = connection.createStatement();
            statement.executeUpdate(query);
            query = "SELECT * FROM ProgramSymbols WHERE  " + "programID =  " + programID + "  AND " + "module    = '" + module + "' AND " + "symbol    = '" + symbol + "'";
            resultSet = statement.executeQuery(query);
            if (!resultSet.next()) {
                connection.rollback();
                String msg = "Attempt to create program symbol failed.";
                log.error(msg);
                throw new AdaptationException(msg);
            }
            programSymbol = getProgramSymbol(resultSet);
            connection.commit();
        } catch (SQLException ex) {
            try {
                connection.rollback();
            } catch (Exception e) {
            }
            String msg = "SQLException in createNewProgramSymbol";
            log.error(msg, ex);
            throw new AdaptationException(msg, ex);
        } finally {
            try {
                resultSet.close();
            } catch (Exception ex) {
            }
            try {
                statement.close();
            } catch (Exception ex) {
            }
            try {
                connection.close();
            } catch (Exception ex) {
            }
        }
        return programSymbol;
    }
} </s>
<s>class temp {    public ProgramSymbol deleteProgramSymbol(int id) throws AdaptationException {
        ProgramSymbol programSymbol = null;
        Connection connection = null;
        Statement statement = null;
        ResultSet resultSet = null;
        try {
            String query = "SELECT * FROM ProgramSymbols " + "WHERE id = " + id;
            connection = DriverManager.getConnection(CONN_STR);
            statement = connection.createStatement();
            resultSet = statement.executeQuery(query);
            if (!resultSet.next()) {
                connection.rollback();
                String msg = "Attempt to delete program symbol failed.";
                log.error(msg);
                throw new AdaptationException(msg);
            }
            programSymbol = getProgramSymbol(resultSet);
            query = "DELETE FROM ProgramSymbols " + "WHERE id = " + id;
            statement.executeUpdate(query);
            connection.commit();
        } catch (SQLException ex) {
            try {
                connection.rollback();
            } catch (Exception e) {
            }
            String msg = "SQLException in deleteProgramSymbol";
            log.error(msg, ex);
            throw new AdaptationException(msg, ex);
        } finally {
            try {
                resultSet.close();
            } catch (Exception ex) {
            }
            try {
                statement.close();
            } catch (Exception ex) {
            }
            try {
                connection.close();
            } catch (Exception ex) {
            }
        }
        return programSymbol;
    }
} </s>
<s>class temp {    public static void copyFile(File srcFile, File destFile) throws IOException {
        if (!(srcFile.exists() && srcFile.isFile())) throw new IllegalArgumentException("Source file doesn't exist: " + srcFile.getAbsolutePath());
        if (destFile.exists() && destFile.isDirectory()) throw new IllegalArgumentException("Destination file is directory: " + destFile.getAbsolutePath());
        FileInputStream in = new FileInputStream(srcFile);
        FileOutputStream out = new FileOutputStream(destFile);
        byte[] buffer = new byte[4096];
        int no = 0;
        try {
            while ((no = in.read(buffer)) != -1) out.write(buffer, 0, no);
        } finally {
            in.close();
            out.close();
        }
    }
} </s>
<s>class temp {    public static void transfer(FileInputStream fileInStream, FileOutputStream fileOutStream) throws IOException {
        FileChannel fileInChannel = fileInStream.getChannel();
        FileChannel fileOutChannel = fileOutStream.getChannel();
        long fileInSize = fileInChannel.size();
        try {
            long transferred = fileInChannel.transferTo(0, fileInSize, fileOutChannel);
            if (transferred != fileInSize) {
                throw new IOException("transfer() did not complete");
            }
        } finally {
            ensureClose(fileInChannel, fileOutChannel);
        }
    }
} </s>
<s>class temp {    public ArrayList parseFile(File newfile) throws IOException {
        String s;
        String firstName;
        String header;
        String name = null;
        Integer PVLoggerID = new Integer(0);
        String[] tokens;
        int nvalues = 0;
        double num1, num2, num3;
        double xoffset = 1.0;
        double xdelta = 1.0;
        double yoffset = 1.0;
        double ydelta = 1.0;
        double zoffset = 1.0;
        double zdelta = 1.0;
        boolean readfit = false;
        boolean readraw = false;
        boolean zerodata = false;
        boolean baddata = false;
        boolean harpdata = false;
        ArrayList fitparams = new ArrayList();
        ArrayList xraw = new ArrayList();
        ArrayList yraw = new ArrayList();
        ArrayList zraw = new ArrayList();
        ArrayList sraw = new ArrayList();
        ArrayList sxraw = new ArrayList();
        ArrayList syraw = new ArrayList();
        ArrayList szraw = new ArrayList();
        URL url = newfile.toURI().toURL();
        InputStream is = url.openStream();
        InputStreamReader isr = new InputStreamReader(is);
        BufferedReader br = new BufferedReader(isr);
        while ((s = br.readLine()) != null) {
            tokens = s.split("\\s+");
            nvalues = tokens.length;
            firstName = (String) tokens[0];
            if (((String) tokens[0]).length() == 0) {
                readraw = false;
                readfit = false;
                continue;
            }
            if ((nvalues == 4) && (!firstName.startsWith("---"))) {
                if ((Double.parseDouble(tokens[1]) == 0.) && (Double.parseDouble(tokens[2]) == 0.) && (Double.parseDouble(tokens[3]) == 0.)) {
                    zerodata = true;
                } else {
                    zerodata = false;
                }
                if (tokens[1].equals("NaN") || tokens[2].equals("NaN") || tokens[3].equals("NaN")) {
                    baddata = true;
                } else {
                    baddata = false;
                }
            }
            if (firstName.startsWith("start")) {
                header = s;
            }
            if (firstName.indexOf("WS") > 0) {
                if (name != null) {
                    dumpData(name, fitparams, sraw, sxraw, syraw, szraw, yraw, zraw, xraw);
                }
                name = tokens[0];
                readraw = false;
                readfit = false;
                zerodata = false;
                baddata = false;
                harpdata = false;
                fitparams.clear();
                xraw.clear();
                yraw.clear();
                zraw.clear();
                sraw.clear();
                sxraw.clear();
                syraw.clear();
                szraw.clear();
            }
            if (firstName.startsWith("Area")) ;
            if (firstName.startsWith("Ampl")) ;
            if (firstName.startsWith("Mean")) ;
            if (firstName.startsWith("Sigma")) {
                fitparams.add(new Double(Double.parseDouble(tokens[3])));
                fitparams.add(new Double(Double.parseDouble(tokens[1])));
                fitparams.add(new Double(Double.parseDouble(tokens[5])));
            }
            if (firstName.startsWith("Offset")) ;
            if (firstName.startsWith("Slope")) ;
            if ((firstName.equals("Position")) && (((String) tokens[2]).equals("Raw"))) {
                readraw = true;
                continue;
            }
            if ((firstName.equals("Position")) && (((String) tokens[2]).equals("Fit"))) {
                readfit = true;
                continue;
            }
            if ((firstName.contains("Harp"))) {
                xraw.clear();
                yraw.clear();
                zraw.clear();
                sraw.clear();
                sxraw.clear();
                syraw.clear();
                szraw.clear();
                harpdata = true;
                readraw = true;
                name = tokens[0];
                continue;
            }
            if (firstName.startsWith("---")) continue;
            if (harpdata == true) {
                if (((String) tokens[0]).length() != 0) {
                    if (firstName.startsWith("PVLogger")) {
                        try {
                            PVLoggerID = new Integer(Integer.parseInt(tokens[2]));
                        } catch (NumberFormatException e) {
                        }
                    } else {
                        sxraw.add(new Double(Double.parseDouble(tokens[0])));
                        xraw.add(new Double(Double.parseDouble(tokens[1])));
                        syraw.add(new Double(Double.parseDouble(tokens[2])));
                        yraw.add(new Double(Double.parseDouble(tokens[3])));
                        szraw.add(new Double(Double.parseDouble(tokens[4])));
                        zraw.add(new Double(Double.parseDouble(tokens[5])));
                    }
                }
                continue;
            }
            if (readraw && (!zerodata) && (!baddata)) {
                sraw.add(new Double(Double.parseDouble(tokens[0]) / Math.sqrt(2.0)));
                sxraw.add(new Double(Double.parseDouble(tokens[0]) / Math.sqrt(2.0)));
                syraw.add(new Double(Double.parseDouble(tokens[0]) / Math.sqrt(2.0)));
                szraw.add(new Double(Double.parseDouble(tokens[0])));
                yraw.add(new Double(Double.parseDouble(tokens[1])));
                zraw.add(new Double(Double.parseDouble(tokens[2])));
                xraw.add(new Double(Double.parseDouble(tokens[3])));
            }
            if (firstName.startsWith("PVLogger")) {
                try {
                    PVLoggerID = new Integer(Integer.parseInt(tokens[2]));
                } catch (NumberFormatException e) {
                }
            }
        }
        dumpData(name, fitparams, sraw, sxraw, syraw, szraw, yraw, zraw, xraw);
        wiredata.add((Integer) PVLoggerID);
        return wiredata;
    }
} </s>
<s>class temp {    public static void main(String[] args) throws NoSuchAlgorithmException {
        String password = "root";
        MessageDigest messageDigest = MessageDigest.getInstance("MD5");
        messageDigest.update(password.getBytes());
        final byte[] digest = messageDigest.digest();
        final StringBuilder buf = new StringBuilder(digest.length * 2);
        for (int j = 0; j < digest.length; j++) {
            buf.append(HEX_DIGITS[(digest[j] >> 4) & 0x0f]);
            buf.append(HEX_DIGITS[digest[j] & 0x0f]);
        }
        String pwd = buf.toString();
        System.out.println(pwd);
    }
} </s>
<s>class temp {    private void doPost(String request) throws IOException {
        URL url = new URL("http://localhost:8080/exist/rest" + DBBroker.ROOT_COLLECTION);
        HttpURLConnection connect = (HttpURLConnection) url.openConnection();
        connect.setRequestMethod("POST");
        connect.setDoOutput(true);
        OutputStream os = connect.getOutputStream();
        os.write(request.getBytes("UTF-8"));
        connect.connect();
        BufferedReader is = new BufferedReader(new InputStreamReader(connect.getInputStream()));
        String line;
        while ((line = is.readLine()) != null) System.out.println(line);
    }
} </s>
<s>class temp {    private String calculateMD5(String value) {
        String finalString;
        try {
            MessageDigest md5Alg = MessageDigest.getInstance("MD5");
            md5Alg.reset();
            md5Alg.update(value.getBytes());
            byte messageDigest[] = md5Alg.digest();
            StringBuilder hexString = new StringBuilder(256);
            for (int i = 0; i < messageDigest.length; i++) {
                String hex = Integer.toHexString(0xFF & messageDigest[i]);
                if (hex.length() == 1) {
                    hexString.append('0');
                }
                hexString.append(hex);
            }
            finalString = hexString.toString();
        } catch (NoSuchAlgorithmException exc) {
            throw new RuntimeException("Hashing error happened:", exc);
        }
        return finalString;
    }
} </s>
<s>class temp {    private void update() {
        if (VERSION.contains("dev")) return;
        System.out.println(updateURL_s);
        try {
            URL updateURL = new URL(updateURL_s);
            InputStream uis = updateURL.openStream();
            InputStreamReader uisr = new InputStreamReader(uis);
            BufferedReader ubr = new BufferedReader(uisr);
            String header = ubr.readLine();
            if (header.equals("GENREMANUPDATEPAGE")) {
                String cver = ubr.readLine();
                String cdl = ubr.readLine();
                if (!cver.equals(VERSION)) {
                    System.out.println("Update available!");
                    int i = JOptionPane.showConfirmDialog(this, Language.get("UPDATE_AVAILABLE_MSG").replaceAll("%o", VERSION).replaceAll("%c", cver), Language.get("UPDATE_AVAILABLE_TITLE"), JOptionPane.YES_NO_OPTION);
                    if (i == 0) {
                        URL url = new URL(cdl);
                        HttpURLConnection connection = (HttpURLConnection) url.openConnection();
                        connection.connect();
                        if (connection.getResponseCode() / 100 != 2) {
                            throw new Exception("Server error! Response code: " + connection.getResponseCode());
                        }
                        int contentLength = connection.getContentLength();
                        if (contentLength < 1) {
                            throw new Exception("Invalid content length!");
                        }
                        int size = contentLength;
                        File tempfile = File.createTempFile("genreman_update", ".zip");
                        tempfile.deleteOnExit();
                        RandomAccessFile file = new RandomAccessFile(tempfile, "rw");
                        InputStream stream = connection.getInputStream();
                        int downloaded = 0;
                        ProgressWindow pwin = new ProgressWindow(this, "Downloading");
                        pwin.setVisible(true);
                        pwin.setProgress(0);
                        pwin.setText("Connecting...");
                        while (downloaded < size) {
                            byte buffer[];
                            if (size - downloaded > 1024) {
                                buffer = new byte[1024];
                            } else {
                                buffer = new byte[size - downloaded];
                            }
                            int read = stream.read(buffer);
                            if (read == -1) break;
                            file.write(buffer, 0, read);
                            downloaded += read;
                            pwin.setProgress(downloaded / size);
                        }
                        file.close();
                        System.out.println("Downloaded file to " + tempfile.getAbsolutePath());
                        pwin.setVisible(false);
                        pwin.dispose();
                        pwin = null;
                        ZipInputStream zin = new ZipInputStream(new FileInputStream(tempfile));
                        ZipEntry entry;
                        while ((entry = zin.getNextEntry()) != null) {
                            File outf = new File(entry.getName());
                            System.out.println(outf.getAbsoluteFile());
                            if (outf.exists()) outf.delete();
                            OutputStream out = new FileOutputStream(outf);
                            byte[] buf = new byte[1024];
                            int len;
                            while ((len = zin.read(buf)) > 0) {
                                out.write(buf, 0, len);
                            }
                            out.close();
                        }
                        JOptionPane.showMessageDialog(this, Language.get("UPDATE_SUCCESS_MSG"), Language.get("UPDATE_SUCCESS_TITLE"), JOptionPane.INFORMATION_MESSAGE);
                        setVisible(false);
                        if (System.getProperty("os.name").indexOf("Windows") != -1) {
                            Runtime.getRuntime().exec("iTunesGenreArtManager.exe");
                        } else {
                            Runtime.getRuntime().exec("java -jar \"iTunes Genre Art Manager.app/Contents/Resources/Java/iTunes_Genre_Art_Manager.jar\"");
                        }
                        System.exit(0);
                    } else {
                    }
                }
                ubr.close();
                uisr.close();
                uis.close();
            } else {
                while (ubr.ready()) {
                    System.out.println(ubr.readLine());
                }
                ubr.close();
                uisr.close();
                uis.close();
                throw new Exception("Update page had invalid header: " + header);
            }
        } catch (Exception ex) {
            JOptionPane.showMessageDialog(this, Language.get("UPDATE_ERROR_MSG"), Language.get("UPDATE_ERROR_TITLE"), JOptionPane.ERROR_MESSAGE);
            ex.printStackTrace();
        }
    }
} </s>
<s>class temp {    public static void copyFile(File in, File out) throws IOException {
        FileChannel inChannel = new FileInputStream(in).getChannel();
        FileChannel outChannel = new FileOutputStream(out).getChannel();
        try {
            inChannel.transferTo(0, inChannel.size(), outChannel);
        } catch (IOException e) {
            throw e;
        } finally {
            if (inChannel != null) inChannel.close();
            if (outChannel != null) outChannel.close();
        }
    }
} </s>
<s>class temp {    private String sendQuery(String query) {
        File xmlServerResponse = null;
        String serverResponse = "";
        try {
            long start = Calendar.getInstance().getTimeInMillis();
            System.out.println("\n\n++++++++++++++++++++++++++++++++++++++++++++++++++++");
            System.out.println("    consulta de busqueda -> " + query);
            URL url = new URL(query);
            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));
            String line = "";
            while ((line = in.readLine()) != null) {
                serverResponse += line;
            }
            long ahora = (Calendar.getInstance().getTimeInMillis() - start);
            System.out.println(" Tiempo transcurrido en la consulta (en milesimas) -> " + ahora);
            System.out.println("++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n");
        } catch (IOException e) {
            e.printStackTrace();
        }
        return serverResponse;
    }
} </s>
<s>class temp {    @Override
    protected String doWget(final URL url, final boolean post, final boolean ignore, final String... post_data) throws Exception {
        String msg = "";
        InputStream in = null;
        OutputStream out = null;
        String data = null;
        try {
            final URLConnection urlcon = url.openConnection();
            if (post) {
                boolean key = false;
                for (final String s : post_data) {
                    msg += URLEncoder.encode(s, "UTF-8");
                    if (key = !key) {
                        msg += "=";
                    } else {
                        msg += "&";
                    }
                }
                urlcon.setDoOutput(true);
                out = urlcon.getOutputStream();
                out.write(msg.getBytes());
            }
            in = urlcon.getInputStream();
            data = ignore ? null : "";
            int len;
            final byte[] buffer = new byte[1023];
            while ((len = in.read(buffer)) >= 0) {
                if (!ignore) {
                    data += new String(buffer, 0, len);
                }
            }
            if (LogHelper.isLogLevelEnabled(LogLevel.DEBUG, DefaultCommunicationHelper.class)) {
                LogHelper.log(DefaultCommunicationHelper.class, LogLevel.DEBUG, "WGET= URL[" + url.toString() + "?" + msg + "] RETURN[" + data + "]");
            }
            return data;
        } catch (final Exception ex) {
            LogHelper.log(DefaultCommunicationHelper.class, LogLevel.WARN, "An error occurred while submitting " + msg + " request to " + url.toString() + " with the following data: " + data, ex);
            throw ex;
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (final Exception e) {
                    LogHelper.log(DefaultCommunicationHelper.class, LogLevel.DEBUG, "An error occurred while closing an input stream", e);
                }
            }
            if (out != null) {
                try {
                    out.close();
                } catch (final Exception e) {
                    LogHelper.log(DefaultCommunicationHelper.class, LogLevel.DEBUG, "An error occurred while closing an output stream", e);
                }
            }
        }
    }
} </s>
<s>class temp {    public static void main(String[] args) throws Exception {
        if (args.length != 2) {
            System.out.println("Usage:  URLDumper <URL> <file>");
            System.exit(1);
        }
        String location = args[0];
        String file = args[1];
        URL url = new URL(location);
        FileOutputStream fos = new FileOutputStream(file);
        byte[] bytes = new byte[4096];
        InputStream is = url.openStream();
        int read;
        while ((read = is.read(bytes)) != -1) {
            fos.write(bytes, 0, read);
        }
        is.close();
        fos.close();
    }
} </s>
<s>class temp {    public static String getMD5(String value) {
        if (StringUtils.isBlank(value)) return null;
        try {
            MessageDigest md = MessageDigest.getInstance("MD5");
            md.update(value.getBytes("UTF-8"));
            return toHexString(md.digest());
        } catch (Throwable e) {
            return null;
        }
    }
} </s>
<s>class temp {    private InputStream getInputStream(String item) {
        InputStream is = null;
        URLConnection urlc = null;
        try {
            URL url = new URL(item);
            urlc = url.openConnection();
            is = urlc.getInputStream();
            current_source = url.getProtocol() + "://" + url.getHost() + ":" + url.getPort() + url.getFile();
        } catch (Exception ee) {
            System.err.println(ee);
        }
        int i = 0;
        udp_port = -1;
        udp_baddress = null;
        while (urlc != null) {
            String s = urlc.getHeaderField(i);
            String t = urlc.getHeaderFieldKey(i);
            if (s == null) {
                break;
            }
            i++;
            if ("udp-port".equals(t)) {
                try {
                    udp_port = Integer.parseInt(s);
                } catch (Exception e) {
                }
            } else if ("udp-broadcast-address".equals(t)) {
                udp_baddress = s;
            }
        }
        return is;
    }
} </s>
<s>class temp {    @Override
    public void aggregate() {
        Connection connection = null;
        PreparedStatement prestm = null;
        try {
            if (logger.isInfoEnabled()) logger.info("aggregate table <" + origin + "> start...");
            Class.forName(driver);
            connection = DriverManager.getConnection(url, username, password);
            String tableExistsResult = "";
            prestm = connection.prepareStatement("show tables from " + schema + " like '" + getDestination() + "';");
            ResultSet rs = prestm.executeQuery();
            if (rs.next()) tableExistsResult = rs.getString(1);
            rs.close();
            prestm.close();
            if (StringUtils.isBlank(tableExistsResult)) {
                String createTableSql = "";
                prestm = connection.prepareStatement("show create table " + getOrigin() + ";");
                rs = prestm.executeQuery();
                if (rs.next()) createTableSql = rs.getString(2);
                rs.close();
                prestm.close();
                createTableSql = createTableSql.replaceAll("`" + getOrigin() + "`", "`" + getDestination() + "`");
                createTableSql = createTableSql.replaceAll("auto_increment", "");
                createTableSql = createTableSql.replaceAll("AUTO_INCREMENT", "");
                Matcher matcher = stripRelationTablePattern.matcher(createTableSql);
                if (matcher.find()) createTableSql = matcher.replaceAll("");
                matcher = normalizePattern.matcher(createTableSql);
                if (matcher.find()) createTableSql = matcher.replaceAll("\n )");
                Statement stm = connection.createStatement();
                stm.execute(createTableSql);
                if (logger.isDebugEnabled()) logger.debug("table '" + getDestination() + "' created!");
            } else if (logger.isDebugEnabled()) logger.debug("table '" + getDestination() + "' already exists");
            long currentRows = 0L;
            prestm = connection.prepareStatement("select count(*) from " + origin);
            rs = prestm.executeQuery();
            if (rs.next()) currentRows = rs.getLong(1);
            rs.close();
            prestm.close();
            if (logger.isInfoEnabled()) logger.info("found " + currentRows + " record");
            prestm = connection.prepareStatement("select max(d_insDate) from " + destination);
            rs = prestm.executeQuery();
            Date from = null;
            if (rs.next()) from = rs.getTimestamp(1);
            rs.close();
            prestm.close();
            SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
            String fromStr = null;
            if (from != null) fromStr = sdf.format(from);
            if (logger.isInfoEnabled()) logger.info("last record date:" + fromStr);
            if (currentRows > 0) {
                connection.setAutoCommit(false);
                if (from != null && fromStr != null) {
                    prestm = connection.prepareStatement("INSERT INTO " + destination + " SELECT * FROM " + origin + " WHERE d_insDate > '" + fromStr + "'");
                    if (logger.isDebugEnabled()) logger.debug("Query: INSERT INTO " + destination + " SELECT * FROM " + origin + " WHERE d_insDate > '" + fromStr + "'");
                } else {
                    prestm = connection.prepareStatement("INSERT INTO " + destination + " SELECT * FROM " + origin);
                    if (logger.isDebugEnabled()) logger.debug("Query: INSERT INTO " + destination + " SELECT * FROM " + origin);
                }
                int rows = prestm.executeUpdate();
                prestm.close();
                if (logger.isInfoEnabled()) logger.info(" > " + rows + " rows aggregated");
                connection.commit();
            } else if (logger.isInfoEnabled()) logger.info("no aggregation need");
            if (logger.isInfoEnabled()) logger.info("aggregate table " + origin + " end");
        } catch (SQLException e) {
            logger.error(e, e);
            if (applicationContext != null) applicationContext.publishEvent(new TrapEvent(this, "dbcon", "Errore SQL durante l'aggregazione dei dati della tabella " + origin, e));
            try {
                connection.rollback();
            } catch (SQLException e1) {
            }
        } catch (Throwable e) {
            logger.error(e, e);
            if (applicationContext != null) applicationContext.publishEvent(new TrapEvent(this, "generic", "Errore generico durante l'aggregazione dei dati della tabella " + origin, e));
            try {
                connection.rollback();
            } catch (SQLException e1) {
            }
        } finally {
            try {
                if (prestm != null) prestm.close();
            } catch (SQLException e) {
            }
            try {
                if (connection != null) connection.close();
            } catch (SQLException e) {
            }
        }
    }
} </s>
<s>class temp {    private ImageReader findImageReader(URL url) {
        ImageInputStream input = null;
        try {
            input = ImageIO.createImageInputStream(url.openStream());
        } catch (IOException e) {
            logger.log(Level.WARNING, "zly adres URL obrazka " + url, e);
        }
        ImageReader reader = null;
        if (input != null) {
            Iterator readers = ImageIO.getImageReaders(input);
            while ((reader == null) && (readers != null) && readers.hasNext()) {
                reader = (ImageReader) readers.next();
            }
            reader.setInput(input);
        }
        return reader;
    }
} </s>
<s>class temp {    public static void TestDBStore() throws PDException, Exception {
        StoreDDBB StDB = new StoreDDBB("jdbc:derby://localhost:1527/Prodoc", "Prodoc", "Prodoc", "org.apache.derby.jdbc.ClientDriver;STBLOB");
        System.out.println("Driver[" + StDB.getDriver() + "] Tabla  [" + StDB.getTable() + "]");
        StDB.Connect();
        FileInputStream in = new FileInputStream("/tmp/readme.htm");
        StDB.Insert("12345678-1", "1.0", in);
        int TAMBUFF = 1024 * 64;
        byte Buffer[] = new byte[TAMBUFF];
        InputStream Bytes;
        Bytes = StDB.Retrieve("12345678-1", "1.0");
        FileOutputStream fo = new FileOutputStream("/tmp/12345679.htm");
        int readed = Bytes.read(Buffer);
        while (readed != -1) {
            fo.write(Buffer, 0, readed);
            readed = Bytes.read(Buffer);
        }
        Bytes.close();
        fo.close();
        StDB.Delete("12345678-1", "1.0");
        StDB.Disconnect();
    }
} </s>
<s>class temp {    public Object send(URL url, Object params) throws Exception {
        params = processRequest(params);
        String response = "";
        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));
        response += in.readLine();
        while (response != null) response += in.readLine();
        in.close();
        return processResponse(response);
    }
} </s>
<s>class temp {    public int batchTransactionUpdate(List<String> queryStrLisyt, Connection con) throws Exception {
        int ret = 0;
        Statement stmt;
        if (con != null) {
            con.setAutoCommit(false);
            stmt = con.createStatement();
            try {
                stmt.executeUpdate("START TRANSACTION;");
                for (int i = 0; i < queryStrLisyt.size(); i++) {
                    stmt.addBatch(queryStrLisyt.get(i));
                }
                int[] updateCounts = stmt.executeBatch();
                for (int i = 0; i < updateCounts.length; i++) {
                    FileLogger.debug("batch update result:" + updateCounts[i] + ", Statement.SUCCESS_NO_INFO" + Statement.SUCCESS_NO_INFO);
                    if (updateCounts[i] == Statement.SUCCESS_NO_INFO || updateCounts[i] > 0) {
                        ret++;
                    } else if (updateCounts[i] == Statement.EXECUTE_FAILED) ;
                    {
                        throw new Exception("query failed, while process batch update");
                    }
                }
                con.commit();
            } catch (Exception e) {
                ret = 0;
                FileLogger.debug(e.getMessage());
                con.rollback();
            } finally {
                con.setAutoCommit(true);
                stmt.close();
            }
        }
        return ret;
    }
} </s>
<s>class temp {    public static String generateSig(Map<String, String> params, String secret) {
        SortedSet<String> keys = new TreeSet<String>(params.keySet());
        keys.remove(FacebookParam.SIGNATURE.toString());
        String str = "";
        for (String key : keys) {
            str += key + "=" + params.get(key);
        }
        str += secret;
        try {
            MessageDigest md = MessageDigest.getInstance("MD5");
            md.update(str.getBytes("UTF-8"));
            StringBuilder result = new StringBuilder();
            for (byte b : md.digest()) {
                result.append(Integer.toHexString((b & 0xf0) >>> 4));
                result.append(Integer.toHexString(b & 0x0f));
            }
            return result.toString();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
} </s>
<s>class temp {    private void getRandomGUID(boolean secure) {
        MessageDigest md5 = null;
        StringBuffer sbValueBeforeMD5 = new StringBuffer();
        try {
            md5 = MessageDigest.getInstance("MD5");
        } catch (NoSuchAlgorithmException e) {
            System.out.println("Error: " + e);
        }
        try {
            long time = System.currentTimeMillis();
            long rand = 0;
            if (secure) {
                rand = mySecureRand.nextLong();
            } else {
                rand = myRand.nextLong();
            }
            sbValueBeforeMD5.append(s_id);
            sbValueBeforeMD5.append(":");
            sbValueBeforeMD5.append(Long.toString(time));
            sbValueBeforeMD5.append(":");
            sbValueBeforeMD5.append(Long.toString(rand));
            valueBeforeMD5 = sbValueBeforeMD5.toString();
            md5.update(valueBeforeMD5.getBytes());
            byte[] array = md5.digest();
            StringBuffer sb = new StringBuffer();
            for (int j = 0; j < array.length; ++j) {
                int b = array[j] & 0xFF;
                if (b < 0x10) sb.append('0');
                sb.append(Integer.toHexString(b));
            }
            valueAfterMD5 = sb.toString();
        } catch (Exception e) {
            System.out.println("Error:" + e);
        }
    }
} </s>
<s>class temp {private ArrayList execAtParentServer(ArrayList paramList) throws Exception {
        ArrayList outputList = null;
        String message = "";
        try {
            HashMap serverUrlMap = InitXml.getInstance().getServerMap();
            Iterator it = serverUrlMap.keySet().iterator();
            while (it.hasNext()) {
                String server = (String) it.next();
                String serverUrl = (String) serverUrlMap.get(server);
                serverUrl = serverUrl + Primer3Manager.servletName;
                URL url = new URL(serverUrl);
                URLConnection uc = url.openConnection();
                uc.setDoOutput(true);
                OutputStream os = uc.getOutputStream();
                StringBuffer buf = new StringBuffer();
                buf.append("actionType=designparent");
                for (int i = 0; i < paramList.size(); i++) {
                    Primer3Param param = (Primer3Param) paramList.get(i);
                    if (i == 0) {
                        buf.append("&sequence=" + param.getSequence());
                        buf.append("&upstream_size" + upstreamSize);
                        buf.append("&downstreamSize" + downstreamSize);
                        buf.append("&MARGIN_LENGTH=" + marginLength);
                        buf.append("&OVERLAP_LENGTH=" + overlapLength);
                        buf.append("&MUST_XLATE_PRODUCT_MIN_SIZE=" + param.getPrimerProductMinSize());
                        buf.append("&MUST_XLATE_PRODUCT_MAX_SIZE=" + param.getPrimerProductMaxSize());
                        buf.append("&PRIMER_PRODUCT_OPT_SIZE=" + param.getPrimerProductOptSize());
                        buf.append("&PRIMER_MAX_END_STABILITY=" + param.getPrimerMaxEndStability());
                        buf.append("&PRIMER_MAX_MISPRIMING=" + param.getPrimerMaxMispriming());
                        buf.append("&PRIMER_PAIR_MAX_MISPRIMING=" + param.getPrimerPairMaxMispriming());
                        buf.append("&PRIMER_MIN_SIZE=" + param.getPrimerMinSize());
                        buf.append("&PRIMER_OPT_SIZE=" + param.getPrimerOptSize());
                        buf.append("&PRIMER_MAX_SIZE=" + param.getPrimerMaxSize());
                        buf.append("&PRIMER_MIN_TM=" + param.getPrimerMinTm());
                        buf.append("&PRIMER_OPT_TM=" + param.getPrimerOptTm());
                        buf.append("&PRIMER_MAX_TM=" + param.getPrimerMaxTm());
                        buf.append("&PRIMER_MAX_DIFF_TM=" + param.getPrimerMaxDiffTm());
                        buf.append("&PRIMER_MIN_GC=" + param.getPrimerMinGc());
                        buf.append("&PRIMER_OPT_GC_PERCENT=" + param.getPrimerOptGcPercent());
                        buf.append("&PRIMER_MAX_GC=" + param.getPrimerMaxGc());
                        buf.append("&PRIMER_SELF_ANY=" + param.getPrimerSelfAny());
                        buf.append("&PRIMER_SELF_END=" + param.getPrimerSelfEnd());
                        buf.append("&PRIMER_NUM_NS_ACCEPTED=" + param.getPrimerNumNsAccepted());
                        buf.append("&PRIMER_MAX_POLY_X=" + param.getPrimerMaxPolyX());
                        buf.append("&PRIMER_GC_CLAMP=" + param.getPrimerGcClamp());
                    }
                    buf.append("&target=" + param.getPrimerSequenceId() + "," + (param.getTarget())[0] + "," + (param.getTarget())[1]);
                }
                PrintStream ps = new PrintStream(os);
                ps.print(buf.toString());
                ps.close();
                ObjectInputStream ois = new ObjectInputStream(uc.getInputStream());
                outputList = (ArrayList) ois.readObject();
                ois.close();
            }
        } catch (IOException e1) {
            e1.printStackTrace();
        }
        if ((outputList == null || outputList.size() == 0) && message != null && message.length() > 0) {
            throw new Exception(message);
        }
        return outputList;
    }} </s>
<s>class temp {    public DownloadThread call() throws UpdateModException {
        try {
            Thread.currentThread().setName("Download - " + modName);
            if (url != null) {
                URL urls = new URL(this.url);
                URLConnection connection = urls.openConnection();
                connection.setConnectTimeout(7500);
                InputStream is = urls.openStream();
                String filename = null;
                if (path == null || path.isEmpty()) {
                    String pattern = "[^a-z,A-Z,0-9, ,.]";
                    filename = this.url.substring(this.url.lastIndexOf("/") + 1).replace("%20", " ");
                    filename = filename.replaceAll(pattern, "");
                } else {
                    filename = path;
                }
                FileOutputStream fos = null;
                file = new File(System.getProperty("java.io.tmpdir") + File.separator + filename);
                fos = new FileOutputStream(file, false);
                FileUtils.copyInputStream(is, fos);
                is.close();
                fos.flush();
                fos.close();
            }
        } catch (MalformedURLException ex) {
            System.out.println(ex);
            file = null;
            throw new UpdateModException(null, ex);
        } catch (ConnectException ex) {
            System.out.println(ex);
            file = null;
            throw new UpdateModException(null, ex);
        } catch (NullPointerException ex) {
            System.out.println(ex);
            file = null;
            throw new UpdateModException(null, ex);
        } catch (InvalidParameterException ex) {
            System.out.println(ex);
            file = null;
            throw new UpdateModException(null, ex);
        } catch (FileNotFoundException ex) {
            System.out.println(ex);
            file = null;
            throw new UpdateModException(null, ex);
        } catch (IOException ex) {
            System.out.println(ex);
            file = null;
            throw new UpdateModException(null, ex);
        }
        return this;
    }
} </s>
<s>class temp {    @SuppressWarnings("static-access")
    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException {
        PrintWriter writer = null;
        InputStream is = null;
        FileOutputStream fos = null;
        try {
            writer = response.getWriter();
        } catch (IOException ex) {
            log(OctetStreamReader.class.getName() + "has thrown an exception: " + ex.getMessage());
        }
        String filename = request.getHeader("X-File-Name");
        try {
            filename = URLDecoder.decode(filename, "utf-8");
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
        try {
            is = request.getInputStream();
            File newFile = new File(realPath + filename);
            if (!newFile.exists()) {
                fos = new FileOutputStream(new File(realPath + filename));
                IOUtils.copy(is, fos);
                response.setStatus(response.SC_OK);
                writer.print("{success: true,detailMsg}");
            } else {
                response.setStatus(response.SC_INTERNAL_SERVER_ERROR);
                writer.print("{success: false,detailMsg:'文件已经存在！请重命名后上传！'}");
                log(OctetStreamReader.class.getName() + "has thrown an exception: " + filename + " has existed!");
            }
        } catch (FileNotFoundException ex) {
            response.setStatus(response.SC_INTERNAL_SERVER_ERROR);
            writer.print("{success: false}");
            log(OctetStreamReader.class.getName() + "has thrown an exception: " + ex.getMessage());
        } catch (IOException ex) {
            response.setStatus(response.SC_INTERNAL_SERVER_ERROR);
            writer.print("{success: false}");
            log(OctetStreamReader.class.getName() + "has thrown an exception: " + ex.getMessage());
        } finally {
            try {
                fos.close();
                is.close();
            } catch (IOException ignored) {
            }
        }
        writer.flush();
        writer.close();
    }
} </s>
<s>class temp {    @Override
    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        response.setContentType("text/html");
        PrintWriter out = response.getWriter();
        int i;
        String dicomURL = request.getParameter("datasetURL");
        String contentType = request.getParameter("contentType");
        String studyUID = request.getParameter("studyUID");
        String seriesUID = request.getParameter("seriesUID");
        String objectUID = request.getParameter("objectUID");
        dicomURL += "&contentType=" + contentType + "&studyUID=" + studyUID + "&seriesUID=" + seriesUID + "&objectUID=" + objectUID + "&transferSyntax=1.2.840.10008.1.2.1";
        dicomURL = dicomURL.replace("+", "%2B");
        InputStream is = null;
        DataInputStream dis = null;
        try {
            URL url = new URL(dicomURL);
            is = url.openStream();
            dis = new DataInputStream(is);
            for (i = 0; i < dicomData.length; i++) dicomData[i] = dis.readUnsignedByte();
            String windowCenter = getElementValue("00281050");
            String windowWidth = getElementValue("00281051");
            request.getSession(true).setAttribute(WINDOW_CENTER_PARAM, windowCenter == null ? null : windowCenter.trim());
            request.getSession(true).setAttribute(WINDOW_WIDTH_PARAM, windowWidth == null ? null : windowWidth.trim());
            dis.skipBytes(50000000);
            is.close();
            dis.close();
            out.println("Success");
            out.close();
        } catch (Exception e) {
            log.error("Unable to read and send the DICOM dataset page", e);
        }
    }
} </s>
<s>class temp {    protected static Parser buildParser(URL url) throws IOException, ParserException {
        Parser parser;
        URLConnection connection = openConnection(url);
        if (!(connection instanceof HttpURLConnection) || ((HttpURLConnection) connection).getResponseCode() == 200) {
            parser = new Parser(connection);
        } else {
            parser = null;
        }
        return parser;
    }
} </s>
<s>class temp {    private String load(URL url) {
        BufferedReader r = null;
        try {
            r = new BufferedReader(new InputStreamReader(url.openStream()));
            StringBuffer buf = new StringBuffer();
            while (r.ready()) {
                buf.append(r.readLine()).append('\n');
            }
            r.close();
            return buf.toString();
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }
} </s>
<s>class temp {    public InputStream getDaoConfig(String connectionType) throws IOException {
        URL url = null;
        if (connectionType.equals(SQL.ORACLE)) {
            url = com.apelon.dts.db.admin.config.MigrateConfig.class.getResource("oracle.xml");
        } else if (connectionType.equals(SQL.SQL2K)) {
            url = com.apelon.dts.db.admin.config.MigrateConfig.class.getResource("sql2k.xml");
        }
        return url.openStream();
    }
} </s>
<s>class temp {    public static void test2() throws Exception {
        int keySize = 1024;
        int dBlockSize = keySize / 8;
        int eBlockSize = dBlockSize - 8 - 3;
        CertAndKeyGen certAndKeyGen = new CertAndKeyGen("RSA", "MD5WithRSA");
        certAndKeyGen.generate(keySize);
        PublicKey publicKey = certAndKeyGen.getPublicKey();
        PrivateKey privateKey = certAndKeyGen.getPrivateKey();
        Cipher cipher1 = Cipher.getInstance("RSA/ECB/PKCS1Padding");
        cipher1.init(Cipher.ENCRYPT_MODE, publicKey);
        String fileA = "C:/temp/a.txt";
        String fileB = "C:/temp/b.txt";
        String fileC = "C:/temp/c.txt";
        FileInputStream fis = new FileInputStream(fileA);
        FileOutputStream fos = new FileOutputStream(fileB, false);
        CipherOutputStream eos = new CipherOutputStream(fos, cipher1, eBlockSize);
        byte[] b = new byte[128];
        int i = fis.read(b);
        while (i != -1) {
            eos.write(b, 0, i);
            i = fis.read(b);
        }
        eos.flush();
        eos.close();
        fos.close();
        Cipher cipher2 = Cipher.getInstance("RSA/ECB/PKCS1Padding");
        cipher2.init(Cipher.DECRYPT_MODE, privateKey);
        fis = new FileInputStream(fileB);
        CipherInputStream cis = new CipherInputStream(fis, cipher2, dBlockSize);
        FileOutputStream decodedFile = new FileOutputStream(fileC, false);
        int read = -1;
        while ((read = cis.read()) > -1) {
            decodedFile.write(read);
        }
        decodedFile.close();
        fis.close();
    }
} </s>
<s>class temp {    public static void copyFile(String inName, String otName) throws Exception {
        File inFile = null;
        File otFile = null;
        try {
            inFile = new File(inName);
            otFile = new File(otName);
        } catch (Exception e) {
            e.printStackTrace();
        }
        if (inFile == null || otFile == null) return;
        FileChannel sourceChannel = new FileInputStream(inFile).getChannel();
        FileChannel destinationChannel = new FileOutputStream(otFile).getChannel();
        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);
        sourceChannel.close();
        destinationChannel.close();
    }
} </s>
<s>class temp {    public void get(File fileToGet) throws IOException {
        String fileName = fileToGet.getName();
        URL url = new URL(this.endpointURL + fileName);
        URLConnection connection = url.openConnection();
        InputStream input = connection.getInputStream();
        log.debug("get: " + fileName);
        try {
            FileOutputStream fileStream = new FileOutputStream(fileToGet);
            byte[] bt = new byte[10000];
            int cnt = input.read(bt);
            log.debug("Read bytes: " + cnt);
            while (cnt != -1) {
                fileStream.write(bt, 0, cnt);
                cnt = input.read(bt);
            }
            input.close();
            fileStream.close();
        } catch (IOException e) {
            new File(fileName).delete();
            throw e;
        }
    }
} </s>
<s>class temp {    public void delete(String fileName) throws IOException {
        log.debug("deleting: " + fileName);
        URL url = new URL(this.endpointURL + "?operation=delete&filename=" + fileName);
        URLConnection connection = url.openConnection();
        connection.setDoOutput(false);
        connection.setDoInput(true);
        connection.setUseCaches(false);
        connection.getInputStream();
    }
} </s>
<s>class temp {    public static synchronized BufferedImage loadBufferedJPEGImage(URL url) {
        BufferedImage image = null;
        if (url != null) {
            InputStream in = null;
            try {
                in = url.openStream();
                JPEGImageDecoder decoder = JPEGCodec.createJPEGDecoder(in);
                image = decoder.decodeAsBufferedImage();
            } catch (Exception e) {
                log.severe("URL: " + url + " - " + e.getMessage());
                image = null;
            } finally {
                try {
                    if (in != null) in.close();
                } catch (IOException ioe) {
                    log.severe("URL: " + url + " - " + ioe.getMessage());
                }
            }
            if (image != null) {
                log.config("Image type : " + image.getType());
                if (image.getWidth() <= 0 || image.getHeight() <= 0) {
                    log.severe("URL: " + url + " =0");
                    image = null;
                }
            }
        }
        return image;
    }
} </s>
<s>class temp {    private void output(HttpServletResponse resp, InputStream is, long length, String fileName) throws Exception {
        resp.reset();
        String mimeType = "image/jpeg";
        resp.setContentType(mimeType);
        resp.setContentLength((int) length);
        resp.setHeader("Content-Disposition", "inline; filename=\"" + fileName + "\"");
        resp.setHeader("Cache-Control", "must-revalidate");
        ServletOutputStream sout = resp.getOutputStream();
        IOUtils.copy(is, sout);
        sout.flush();
        resp.flushBuffer();
    }
} </s>
<s>class temp {    public void writeConfigurationFile() throws IOException, ComponentException {
        SystemConfig config = parent.getParentSystem().getConfiguration();
        File original = config.getLocation();
        File backup = new File(original.getParentFile(), original.getName() + "." + System.currentTimeMillis());
        FileInputStream in = new FileInputStream(original);
        FileOutputStream out = new FileOutputStream(backup);
        byte[] buffer = new byte[2048];
        try {
            int bytesread = 0;
            while ((bytesread = in.read(buffer)) > 0) {
                out.write(buffer, 0, bytesread);
            }
        } catch (IOException e) {
            logger.warn("Failed to copy backup of configuration file");
            throw e;
        } finally {
            in.close();
            out.close();
        }
        FileWriter replace = new FileWriter(original);
        replace.write(config.toFileFormat());
        replace.close();
        logger.info("Re-wrote configuration file " + original.getPath());
    }
} </s>
<s>class temp {    protected String parseAction() throws ChangesOnServerException, ConnectionException, RequestCancelledException {
        GetPageRequest request = getHttpClient().createGetPageRequest();
        request.setUrl("http://www.zippyshare.com/index_old.jsp");
        HttpResponse response = executeRequest(request);
        try {
            Parser p = new Parser(response.getResponseBody());
            String action = p.parseOne("enctype=\"multipart/form-data\" action=\"(.*)\">");
            return action;
        } catch (ParsingException ex) {
            throw new ChangesOnServerException();
        } catch (IOException ex) {
            throw new ChangesOnServerException();
        }
    }
} </s>
<s>class temp {    public static void copy(File source, File dest) throws IOException {
        if (dest.isDirectory()) {
            dest = new File(dest + File.separator + source.getName());
        }
        FileChannel in = null, out = null;
        try {
            in = new FileInputStream(source).getChannel();
            out = new FileOutputStream(dest).getChannel();
            long size = in.size();
            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);
            out.write(buf);
        } finally {
            if (in != null) in.close();
            if (out != null) out.close();
        }
    }
} </s>
<s>class temp {    public void testDoubleNaN() {
        double value = 0;
        boolean wasEqual = false;
        String message = "DB operation completed";
        String ddl1 = "DROP TABLE t1 IF EXISTS;" + "CREATE TABLE t1 ( d DECIMAL, f DOUBLE, l BIGINT, i INTEGER, s SMALLINT, t TINYINT, " + "dt DATE DEFAULT CURRENT_DATE, ti TIME DEFAULT CURRENT_TIME, ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP );";
        try {
            stmnt.execute(ddl1);
            PreparedStatement ps = connection.prepareStatement("INSERT INTO t1 (d,f,l,i,s,t,dt,ti,ts) VALUES (?,?,?,?,?,?,?,?,?)");
            ps.setString(1, "0.2");
            ps.setDouble(2, 0.2);
            ps.setLong(3, java.lang.Long.MAX_VALUE);
            ps.setInt(4, Integer.MAX_VALUE);
            ps.setInt(5, Short.MAX_VALUE);
            ps.setInt(6, 0);
            ps.setDate(7, new java.sql.Date(System.currentTimeMillis()));
            ps.setTime(8, new java.sql.Time(System.currentTimeMillis()));
            ps.setTimestamp(9, new java.sql.Timestamp(System.currentTimeMillis()));
            ps.execute();
            ps.setInt(1, 0);
            ps.setDouble(2, java.lang.Double.NaN);
            ps.setLong(3, java.lang.Long.MIN_VALUE);
            ps.setInt(4, Integer.MIN_VALUE);
            ps.setInt(5, Short.MIN_VALUE);
            ps.setInt(6, 0);
            ps.setTimestamp(7, new java.sql.Timestamp(System.currentTimeMillis() + 1));
            ps.setTime(8, new java.sql.Time(System.currentTimeMillis() + 1));
            ps.setDate(9, new java.sql.Date(System.currentTimeMillis() + 1));
            ps.execute();
            ps.setInt(1, 0);
            ps.setDouble(2, java.lang.Double.POSITIVE_INFINITY);
            ps.setInt(4, Integer.MIN_VALUE);
            ps.setObject(5, Boolean.TRUE);
            ps.setBoolean(5, true);
            ps.setObject(5, new Short((short) 2), Types.SMALLINT);
            ps.setObject(6, new Integer(2), Types.TINYINT);
            ps.setObject(7, new java.sql.Date(System.currentTimeMillis() + 2));
            ps.setObject(8, new java.sql.Time(System.currentTimeMillis() + 2));
            ps.setObject(9, new java.sql.Timestamp(System.currentTimeMillis() + 2));
            ps.execute();
            ps.setObject(1, new Float(0), Types.INTEGER);
            ps.setObject(4, new Float(1), Types.INTEGER);
            ps.setDouble(2, java.lang.Double.NEGATIVE_INFINITY);
            ps.execute();
            ResultSet rs = stmnt.executeQuery("SELECT d, f, l, i, s*2, t FROM t1");
            boolean result = rs.next();
            value = rs.getDouble(2);
            int integerValue = rs.getInt(4);
            if (rs.next()) {
                value = rs.getDouble(2);
                wasEqual = Double.isNaN(value);
                integerValue = rs.getInt(4);
                integerValue = rs.getInt(1);
            }
            if (rs.next()) {
                value = rs.getDouble(2);
                wasEqual = wasEqual && value == Double.POSITIVE_INFINITY;
            }
            if (rs.next()) {
                value = rs.getDouble(2);
                wasEqual = wasEqual && value == Double.NEGATIVE_INFINITY;
            }
            rs = stmnt.executeQuery("SELECT MAX(i) FROM t1");
            if (rs.next()) {
                int max = rs.getInt(1);
                System.out.println("Max value for i: " + max);
            }
            {
                stmnt.execute("drop table CDTYPE if exists");
                rs = stmnt.executeQuery("CREATE TABLE cdType (ID INTEGER NOT NULL, name VARCHAR(50), PRIMARY KEY(ID))");
                rs = stmnt.executeQuery("SELECT MAX(ID) FROM cdType");
                if (rs.next()) {
                    int max = rs.getInt(1);
                    System.out.println("Max value for ID: " + max);
                } else {
                    System.out.println("Max value for ID not returned");
                }
                stmnt.executeUpdate("INSERT INTO cdType VALUES (10,'Test String');");
                stmnt.executeQuery("CALL IDENTITY();");
                try {
                    stmnt.executeUpdate("INSERT INTO cdType VALUES (10,'Test String');");
                } catch (SQLException e1) {
                    stmnt.execute("ROLLBACK");
                    connection.rollback();
                }
            }
        } catch (SQLException e) {
            fail(e.getMessage());
        }
        System.out.println("testDoubleNaN complete");
        assertEquals(true, wasEqual);
    }
} </s>
<s>class temp {    private String generateCode(String seed) {
        try {
            Security.addProvider(new FNVProvider());
            MessageDigest digest = MessageDigest.getInstance("FNV-1a");
            digest.update((seed + UUID.randomUUID().toString()).getBytes());
            byte[] hash1 = digest.digest();
            String sHash1 = "m" + (new String(LibraryBase64.encode(hash1))).replaceAll("=", "").replaceAll("-", "_");
            return sHash1;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return "";
    }
} </s>
<s>class temp {    private void copy(String inputPath, String outputPath, String name) {
        try {
            FileReader in = new FileReader(inputPath + name);
            FileWriter out = new FileWriter(outputPath + name);
            int c;
            while ((c = in.read()) != -1) out.write(c);
            in.close();
            out.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
} </s>
<s>class temp {    public void doIt() throws GlobalMapperTileTranslatorException {
        if (StringUtils.isEmpty(dstGuid)) throw new GlobalMapperTileTranslatorException("GUID of destination map is empty");
        if (srcDir == null || !srcDir.isDirectory() || !srcDir.exists()) throw new GlobalMapperTileTranslatorException("Source directory is invalid");
        try {
            int z;
            final XFile dstDir = new XFile(dstParentDir, dstGuid);
            dstDir.mkdir();
            int n = 1;
            if (srcDir.isDirectory() && srcDir.exists()) {
                for (int i = 0; i < 18; i++) {
                    XFile zDir = new XFile(srcDir, "z" + i);
                    if (!zDir.isDirectory() || !zDir.exists()) zDir = new XFile(srcDir, "Z" + i);
                    if (zDir.isDirectory() && zDir.exists()) {
                        for (String fileName : zDir.list()) {
                            XFile file = new XFile(zDir, fileName);
                            if (file.isFile() && file.exists() && file.canRead()) {
                                final String[] yx;
                                if (fileName.indexOf('.') > 0) {
                                    String[] fileExt = fileName.split("\\.");
                                    yx = fileExt[0].split("_");
                                } else yx = fileName.split("_");
                                if (yx.length > 1) {
                                    final int x = Integer.valueOf(yx[1]);
                                    final int y = Integer.valueOf(yx[0]);
                                    z = 17 - i;
                                    XFileOutputStream out = null;
                                    XFileInputStream in = null;
                                    try {
                                        final XFile outFile = new XFile(dstDir, x + "_" + y + "_" + z);
                                        if (override || !(isExist(outFile, file))) {
                                            out = new XFileOutputStream(outFile);
                                            in = new XFileInputStream(file);
                                            IOUtils.copy(in, out);
                                        }
                                        if (n % 999 == 0) {
                                            logger.info(i + " tiles were copied from 'incoming'");
                                            synchronized (GlobalMapperTileTranslator.class) {
                                                GlobalMapperTileTranslator.class.wait(300);
                                            }
                                        }
                                        n++;
                                    } finally {
                                        if (out != null) {
                                            out.flush();
                                            out.close();
                                        }
                                        if (in != null) {
                                            in.close();
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        } catch (Throwable e) {
            logger.error("map tile importing has failed: ", e);
            throw new GlobalMapperTileTranslatorException(e);
        }
    }
} </s>
<s>class temp {    private void httpDo(HttpUriRequest hr, String url, Map<String, String> headers, AjaxStatus status) throws ClientProtocolException, IOException {
        if (AGENT != null) {
            hr.addHeader("User-Agent", AGENT);
        }
        if (headers != null) {
            for (String name : headers.keySet()) {
                hr.addHeader(name, headers.get(name));
            }
        }
        if (GZIP && headers == null || !headers.containsKey("Accept-Encoding")) {
            hr.addHeader("Accept-Encoding", "gzip");
        }
        String cookie = makeCookie();
        if (cookie != null) {
            hr.addHeader("Cookie", cookie);
        }
        if (ah != null) {
            ah.applyToken(this, hr);
        }
        DefaultHttpClient client = getClient();
        HttpContext context = new BasicHttpContext();
        CookieStore cookieStore = new BasicCookieStore();
        context.setAttribute(ClientContext.COOKIE_STORE, cookieStore);
        HttpResponse response = client.execute(hr, context);
        byte[] data = null;
        String redirect = url;
        int code = response.getStatusLine().getStatusCode();
        String message = response.getStatusLine().getReasonPhrase();
        String error = null;
        if (code < 200 || code >= 300) {
            try {
                HttpEntity entity = response.getEntity();
                byte[] s = AQUtility.toBytes(entity.getContent());
                error = new String(s, "UTF-8");
                AQUtility.debug("error", error);
            } catch (Exception e) {
                AQUtility.debug(e);
            }
        } else {
            HttpEntity entity = response.getEntity();
            HttpHost currentHost = (HttpHost) context.getAttribute(ExecutionContext.HTTP_TARGET_HOST);
            HttpUriRequest currentReq = (HttpUriRequest) context.getAttribute(ExecutionContext.HTTP_REQUEST);
            redirect = currentHost.toURI() + currentReq.getURI();
            int size = Math.max(32, Math.min(1024 * 64, (int) entity.getContentLength()));
            PredefinedBAOS baos = new PredefinedBAOS(size);
            Header encoding = entity.getContentEncoding();
            if (encoding != null && encoding.getValue().equalsIgnoreCase("gzip")) {
                InputStream is = new GZIPInputStream(entity.getContent());
                AQUtility.copy(is, baos);
            } else {
                entity.writeTo(baos);
            }
            data = baos.toByteArray();
        }
        AQUtility.debug("response", code);
        if (data != null) {
            AQUtility.debug(data.length, url);
        }
        status.code(code).message(message).error(error).redirect(redirect).time(new Date()).data(data).client(client).context(context).headers(response.getAllHeaders());
    }
} </s>
<s>class temp {    public AudioInputStream getAudioInputStream(URL url) throws UnsupportedAudioFileException, IOException {
        InputStream urlStream = null;
        BufferedInputStream bis = null;
        AudioFileFormat fileFormat = null;
        urlStream = url.openStream();
        AudioInputStream result = null;
        try {
            bis = new BufferedInputStream(urlStream, bisBufferSize);
            result = getAudioInputStream((InputStream) bis);
        } finally {
            if (result == null) {
                urlStream.close();
            }
        }
        return result;
    }
} </s>
<s>class temp {    public Resultado procesar() {
        if (resultado != null) return resultado;
        int[] a = new int[elems.size()];
        Iterator iter = elems.iterator();
        int w = 0;
        while (iter.hasNext()) {
            a[w] = ((Integer) iter.next()).intValue();
            w++;
        }
        int n = a.length;
        long startTime = System.currentTimeMillis();
        int i, j, temp;
        for (i = 0; i < n - 1; i++) {
            for (j = i; j < n - 1; j++) {
                if (a[i] > a[j + 1]) {
                    temp = a[i];
                    a[i] = a[j + 1];
                    a[j + 1] = temp;
                    pasos++;
                }
            }
        }
        long endTime = System.currentTimeMillis();
        resultado = new Resultado((int) (endTime - startTime), pasos, a.length);
        System.out.println("Resultado BB: " + resultado);
        return resultado;
    }
} </s>
<s>class temp {    private String generate(String value) throws Exception {
        String resStr = null;
        try {
            MessageDigest md = MessageDigest.getInstance("MD5");
            md.update(value.getBytes("utf-8"), 0, value.length());
            byte[] result = md.digest();
            resStr = FTGenerate.convertToHex(result);
            md.reset();
        } catch (NoSuchAlgorithmException nae) {
            this.getLog().severe("Hash no funcionando");
            nae.printStackTrace();
            throw new Exception("Hash no funcionando");
        } catch (UnsupportedEncodingException ee) {
            this.getLog().severe("Encoding no funcionando");
            ee.printStackTrace();
            throw new Exception("Encoding no funcionando");
        }
        return resStr;
    }
} </s>
<s>class temp {    private void callbackWS(String xmlControl, String ws_results, long docId) {
        SimpleProvider config;
        Service service;
        Object ret;
        Call call;
        Object[] parameter;
        String method;
        String wsurl;
        URL url;
        NodeList delegateNodes;
        Node actualNode;
        InputSource xmlcontrolstream;
        try {
            xmlcontrolstream = new InputSource(new StringReader(xmlControl));
            delegateNodes = SimpleXMLParser.parseDocument(xmlcontrolstream, AgentBehaviour.XML_CALLBACK);
            actualNode = delegateNodes.item(0);
            wsurl = SimpleXMLParser.findChildEntry(actualNode, AgentBehaviour.XML_URL);
            method = SimpleXMLParser.findChildEntry(actualNode, AgentBehaviour.XML_METHOD);
            if (wsurl == null || method == null) {
                System.out.println("----- Did not get method or wsurl from the properties! -----");
                return;
            }
            url = new java.net.URL(wsurl);
            try {
                url.openConnection().connect();
            } catch (IOException ex) {
                System.out.println("----- Could not connect to the webservice! -----");
            }
            Vector v_param = new Vector();
            v_param.add(ws_results);
            v_param.add(new Long(docId));
            parameter = v_param.toArray();
            config = new SimpleProvider();
            config.deployTransport("http", new HTTPSender());
            service = new Service(config);
            call = (Call) service.createCall();
            call.setTargetEndpointAddress(url);
            call.setOperationName(new QName("http://schemas.xmlsoap.org/soap/encoding/", method));
            try {
                ret = call.invoke(parameter);
                if (ret == null) {
                    ret = new String("No response from callback function!");
                }
                System.out.println("Callback function returned: " + ret);
            } catch (RemoteException ex) {
                System.out.println("----- Could not invoke the method! -----");
            }
        } catch (Exception ex) {
            ex.printStackTrace(System.err);
        }
    }
} </s>
<s>class temp {    public static boolean encodeFileToFile(String infile, String outfile) {
        boolean success = false;
        java.io.InputStream in = null;
        java.io.OutputStream out = null;
        try {
            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            byte[] buffer = new byte[65536];
            int read = -1;
            while ((read = in.read(buffer)) >= 0) {
                out.write(buffer, 0, read);
            }
            success = true;
        } catch (java.io.IOException exc) {
            exc.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (Exception exc) {
            }
            try {
                out.close();
            } catch (Exception exc) {
            }
        }
        return success;
    }
} </s>
<s>class temp {    public static boolean decodeFileToFile(String infile, String outfile) {
        boolean success = false;
        java.io.InputStream in = null;
        java.io.OutputStream out = null;
        try {
            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            byte[] buffer = new byte[65536];
            int read = -1;
            while ((read = in.read(buffer)) >= 0) {
                out.write(buffer, 0, read);
            }
            success = true;
        } catch (java.io.IOException exc) {
            exc.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (Exception exc) {
            }
            try {
                out.close();
            } catch (Exception exc) {
            }
        }
        return success;
    }
} </s>
<s>class temp {    public void setUp() throws Exception {
        logger.finer("******************** set up ********************");
        Properties props;
        if (XMLDBTestSuite.propertiesFileName == null) {
            String defaultPropsFileLocation = "test/xmldb/XMLDBTestSuite.properties";
            URL url = this.getClass().getClassLoader().getResource(defaultPropsFileLocation);
            if (url == null) {
                throw new Exception("failed to find default props file at " + defaultPropsFileLocation);
            }
            props = loadProps(url.openConnection().getInputStream());
        } else {
            props = loadProps(XMLDBTestSuite.propertiesFileName);
        }
        String driver = props.getProperty("driverName");
        String collectionURI = props.getProperty("URI");
        Database database = (Database) Class.forName(driver).newInstance();
        collectionStorageHelper = new CollectionStorageHelper(collectionURI);
        rootCollectionName = collectionStorageHelper.getCollectionName();
        Collection root = database.getCollection(collectionURI, null, null);
        CollectionManagementService service = (CollectionManagementService) root.getService(CollectionManagementService.SERVICE_NAME, "1.0");
        String childCollection = "child";
        removeChildCollection(root, childCollection, service);
        col = service.createCollection(childCollection);
        assertNotNull("XMLDBTestCase.setUp() - Collection could not be created", col);
        logger.info("created child collection '" + col.getName() + "' parent is '" + col.getParentCollection().getName() + "'");
        assertEquals("Root collection name should match childs parent name", rootCollectionName, col.getParentCollection().getName());
        document = createXMLFile(xmlFileName);
        assertNotNull("XMLDBTestCase.setUp() - failed to create XML file", document);
    }
} </s>
<s>class temp {    @Override
    public void trainClassifier(File dir, String... args) throws Exception {
        String[] command = new String[args.length + 3];
        command[0] = this.getCommand();
        System.arraycopy(args, 0, command, 1, args.length);
        command[command.length - 2] = new File(dir, "training-data.libsvm").getPath();
        command[command.length - 1] = new File(dir, this.getModelName()).getPath();
        Process process = Runtime.getRuntime().exec(command);
        IOUtils.copy(process.getInputStream(), System.out);
        IOUtils.copy(process.getErrorStream(), System.err);
        process.waitFor();
    }
} </s>
<s>class temp {    public void copy(File source, File destination) {
        try {
            FileInputStream fileInputStream = new FileInputStream(source);
            FileOutputStream fileOutputStream = new FileOutputStream(destination);
            FileChannel inputChannel = fileInputStream.getChannel();
            FileChannel outputChannel = fileOutputStream.getChannel();
            transfer(inputChannel, outputChannel, source.length(), 1024 * 1024 * 32, true, true);
            fileInputStream.close();
            fileOutputStream.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
} </s>
<s>class temp {    private static void copyFile(File in, File out) throws Exception {
        final FileInputStream input = new FileInputStream(in);
        try {
            final FileOutputStream output = new FileOutputStream(out);
            try {
                final byte[] buf = new byte[4096];
                int readBytes = 0;
                while ((readBytes = input.read(buf)) != -1) {
                    output.write(buf, 0, readBytes);
                }
            } finally {
                output.close();
            }
        } finally {
            input.close();
        }
    }
} </s>
<s>class temp {    private static Image tryLoadImageFromFile(String filename, String path, int width, int height) {
        Image image = null;
        try {
            URL url;
            url = new URL("file:" + path + pathSeparator + fixFilename(filename));
            if (url.openStream() != null) {
                image = Toolkit.getDefaultToolkit().getImage(url);
            }
        } catch (MalformedURLException e) {
        } catch (IOException e) {
        }
        if (image != null) {
            return image.getScaledInstance(width, height, java.awt.Image.SCALE_SMOOTH);
        } else {
            return null;
        }
    }
} </s>
<s>class temp {    private static ImageIcon tryLoadImageIconFromResource(String filename, String path, int width, int height) {
        ImageIcon icon = null;
        try {
            URL url = cl.getResource(path + pathSeparator + fixFilename(filename));
            if (url != null && url.openStream() != null) {
                icon = new ImageIcon(url);
            }
        } catch (Exception e) {
        }
        if (icon == null) {
            return null;
        }
        if ((icon.getIconWidth() == width) && (icon.getIconHeight() == height)) {
            return icon;
        } else {
            return new ImageIcon(icon.getImage().getScaledInstance(width, height, java.awt.Image.SCALE_SMOOTH));
        }
    }
} </s>
<s>class temp {    public void actionPerformed(ActionEvent e) {
        if (path.compareTo("") != 0) {
            imageName = (path.substring(path.lastIndexOf(File.separator) + 1, path.length()));
            String name = imageName.substring(0, imageName.lastIndexOf('.'));
            String extension = imageName.substring(imageName.lastIndexOf('.') + 1, imageName.length());
            File imageFile = new File(path);
            directoryPath = "images" + File.separator + imageName.substring(0, 1).toUpperCase();
            File directory = new File(directoryPath);
            directory.mkdirs();
            imagePath = "." + File.separator + "images" + File.separator + imageName.substring(0, 1).toUpperCase() + File.separator + imageName;
            File newFile = new File(imagePath);
            if (myImagesBehaviour.equals(TLanguage.getString("TIGManageGalleryDialog.REPLACE_IMAGE"))) {
                Vector<Vector<String>> aux = TIGDataBase.imageSearchByName(name);
                if (aux.size() != 0) {
                    int idImage = TIGDataBase.imageKeySearchName(name);
                    TIGDataBase.deleteAsociatedOfImage(idImage);
                }
            }
            if (myImagesBehaviour.equals(TLanguage.getString("TIGManageGalleryDialog.ADD_IMAGE"))) {
                int i = 1;
                while (newFile.exists()) {
                    imagePath = "." + File.separator + "images" + File.separator + imageName.substring(0, 1).toUpperCase() + File.separator + imageName.substring(0, imageName.lastIndexOf('.')) + "_" + i + imageName.substring(imageName.lastIndexOf('.'), imageName.length());
                    name = name + "_" + i;
                    newFile = new File(imagePath);
                    i++;
                }
            }
            imagePathThumb = (imagePath.substring(0, imagePath.lastIndexOf("."))).concat("_th.jpg");
            imageName = name + "." + extension;
            try {
                FileChannel srcChannel = new FileInputStream(path).getChannel();
                FileChannel dstChannel = new FileOutputStream(imagePath).getChannel();
                dstChannel.transferFrom(srcChannel, 0, srcChannel.size());
                srcChannel.close();
                dstChannel.close();
            } catch (IOException exc) {
                System.out.println(exc.getMessage());
                System.out.println(exc.toString());
            }
            TIGDataBase.insertDB(theConcepts, imageName, imageName.substring(0, imageName.lastIndexOf('.')));
            image = null;
            if (imageFile != null) {
                if (TFileUtils.isJAIRequired(imageFile)) {
                    RenderedOp src = JAI.create("fileload", imageFile.getAbsolutePath());
                    BufferedImage bufferedImage = src.getAsBufferedImage();
                    image = new ImageIcon(bufferedImage);
                } else {
                    image = new ImageIcon(imageFile.getAbsolutePath());
                }
                if (image.getImageLoadStatus() == MediaTracker.ERRORED) {
                    int choosenOption = JOptionPane.NO_OPTION;
                    choosenOption = JOptionPane.showConfirmDialog(null, TLanguage.getString("TIGInsertImageAction.MESSAGE"), TLanguage.getString("TIGInsertImageAction.NAME"), JOptionPane.CLOSED_OPTION, JOptionPane.ERROR_MESSAGE);
                } else {
                    createThumbnail();
                }
            }
        }
    }
} </s>
<s>class temp {    private void addAuditDatastream() throws ObjectIntegrityException, StreamIOException {
        if (m_obj.getAuditRecords().size() == 0) {
            return;
        }
        String dsId = m_pid.toURI() + "/AUDIT";
        String dsvId = dsId + "/" + DateUtility.convertDateToString(m_obj.getCreateDate());
        Entry dsEntry = m_feed.addEntry();
        dsEntry.setId(dsId);
        dsEntry.setTitle("AUDIT");
        dsEntry.setUpdated(m_obj.getCreateDate());
        dsEntry.addCategory(MODEL.STATE.uri, "A", null);
        dsEntry.addCategory(MODEL.CONTROL_GROUP.uri, "X", null);
        dsEntry.addCategory(MODEL.VERSIONABLE.uri, "false", null);
        dsEntry.addLink(dsvId, Link.REL_ALTERNATE);
        Entry dsvEntry = m_feed.addEntry();
        dsvEntry.setId(dsvId);
        dsvEntry.setTitle("AUDIT.0");
        dsvEntry.setUpdated(m_obj.getCreateDate());
        ThreadHelper.addInReplyTo(dsvEntry, m_pid.toURI() + "/AUDIT");
        dsvEntry.addCategory(MODEL.FORMAT_URI.uri, AUDIT1_0.uri, null);
        dsvEntry.addCategory(MODEL.LABEL.uri, "Audit Trail for this object", null);
        if (m_format.equals(ATOM_ZIP1_1)) {
            String name = "AUDIT.0.xml";
            try {
                m_zout.putNextEntry(new ZipEntry(name));
                Reader r = new StringReader(DOTranslationUtility.getAuditTrail(m_obj));
                IOUtils.copy(r, m_zout, m_encoding);
                m_zout.closeEntry();
                r.close();
            } catch (IOException e) {
                throw new StreamIOException(e.getMessage(), e);
            }
            IRI iri = new IRI(name);
            dsvEntry.setSummary("AUDIT.0");
            dsvEntry.setContent(iri, "text/xml");
        } else {
            dsvEntry.setContent(DOTranslationUtility.getAuditTrail(m_obj), "text/xml");
        }
    }
} </s>

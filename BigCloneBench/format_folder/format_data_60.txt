<s>class temp {    private static Document getDocument(URL url, String applicationVersion, boolean addHeader, int timeOut) throws IOException, ParserConfigurationException, SAXException {
        HttpURLConnection huc = (HttpURLConnection) url.openConnection();
        huc.setConnectTimeout(1000 * timeOut);
        huc.setRequestMethod("GET");
        if (addHeader) {
            huc.setRequestProperty("JavaPEG-Version", applicationVersion);
        }
        huc.connect();
        int code = huc.getResponseCode();
        if (code != HttpURLConnection.HTTP_OK) {
            throw new IOException("Invaild HTTP response: " + code);
        }
        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
        DocumentBuilder db = dbf.newDocumentBuilder();
        return db.parse(huc.getInputStream());
    }
} </s>
<s>class temp {    public static void copyFile(File source, File destination) throws IOException {
        if (source == null) {
            String message = Logging.getMessage("nullValue.SourceIsNull");
            Logging.logger().severe(message);
            throw new IllegalArgumentException(message);
        }
        if (destination == null) {
            String message = Logging.getMessage("nullValue.DestinationIsNull");
            Logging.logger().severe(message);
            throw new IllegalArgumentException(message);
        }
        FileInputStream fis = null;
        FileOutputStream fos = null;
        FileChannel fic, foc;
        try {
            fis = new FileInputStream(source);
            fic = fis.getChannel();
            fos = new FileOutputStream(destination);
            foc = fos.getChannel();
            foc.transferFrom(fic, 0, fic.size());
            fos.flush();
            fis.close();
            fos.close();
        } finally {
            WWIO.closeStream(fis, source.getPath());
            WWIO.closeStream(fos, destination.getPath());
        }
    }
} </s>
<s>class temp {    private void loadProperties() {
        if (properties == null) {
            properties = new Properties();
            try {
                URL url = getClass().getResource(propsFile);
                properties.load(url.openStream());
            } catch (IOException ioe) {
                ioe.printStackTrace();
            }
        }
    }
} </s>
<s>class temp {    public static void write(File file, InputStream source) throws IOException {
        OutputStream outputStream = null;
        assert file != null : "file must not be null.";
        assert file.isFile() : "file must be a file.";
        assert file.canWrite() : "file must be writable.";
        assert source != null : "source must not be null.";
        try {
            outputStream = new BufferedOutputStream(new FileOutputStream(file));
            IOUtils.copy(source, outputStream);
            outputStream.flush();
        } finally {
            IOUtils.closeQuietly(outputStream);
        }
    }
} </s>
<s>class temp {    private void addConfigurationResource(final String fileName, final boolean ensureLoaded) {
        try {
            final ClassLoader cl = this.getClass().getClassLoader();
            final Properties p = new Properties();
            final URL url = cl.getResource(fileName);
            if (url == null) {
                throw new NakedObjectRuntimeException("Failed to load configuration resource: " + fileName);
            }
            p.load(url.openStream());
            configuration.add(p);
        } catch (Exception e) {
            if (ensureLoaded) {
                throw new NakedObjectRuntimeException(e);
            }
            LOG.debug("Resource: " + fileName + " not found, but not needed");
        }
    }
} </s>
<s>class temp {    public static void main(String[] args) {
        if (args.length != 2) {
            System.out.println("Usage: HashCalculator <Algorithm> <Input>");
            System.out.println("The preferred algorithm is SHA.");
        } else {
            MessageDigest md;
            try {
                md = MessageDigest.getInstance(args[0]);
                md.update(args[1].getBytes());
                System.out.print("Hashed value of " + args[1] + " is: ");
                System.out.println((new BASE64Encoder()).encode(md.digest()));
            } catch (NoSuchAlgorithmException e) {
                e.printStackTrace();
            }
        }
    }
} </s>
<s>class temp {    public void showGetStartedBox() {
        String message = new String("Error: Resource Not Found.");
        java.net.URL url = ClassLoader.getSystemResource("docs/get_started.html");
        if (url != null) {
            try {
                StringBuffer buf = new StringBuffer();
                BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));
                while (reader.ready()) {
                    buf.append(reader.readLine());
                }
                message = buf.toString();
            } catch (IOException ex) {
                message = new String("IO Error.");
            }
        }
        new HtmlDisplayDialog(this, "Get Started", message);
    }
} </s>
<s>class temp {    private void showAboutBox() {
        String message = new String("Error: Resource Not Found.");
        java.net.URL url = ClassLoader.getSystemResource("docs/about.html");
        if (url != null) {
            try {
                StringBuffer buf = new StringBuffer();
                BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));
                while (reader.ready()) {
                    buf.append(reader.readLine());
                }
                message = buf.toString();
            } catch (IOException ex) {
                message = new String("IO Error.");
            }
        }
        JOptionPane.showOptionDialog(this, message, "About jBudget", JOptionPane.DEFAULT_OPTION, JOptionPane.PLAIN_MESSAGE, null, null, null);
    }
} </s>
<s>class temp {    private void chopFileDisk() throws IOException {
        File tempFile = new File("" + logFile + ".tmp");
        BufferedInputStream bis = null;
        BufferedOutputStream bos = null;
        long startCopyPos;
        byte readBuffer[] = new byte[2048];
        int readCount;
        long totalBytesRead = 0;
        if (reductionRatio > 0 && logFile.length() > 0) {
            startCopyPos = logFile.length() / reductionRatio;
        } else {
            startCopyPos = 0;
        }
        try {
            bis = new BufferedInputStream(new FileInputStream(logFile));
            bos = new BufferedOutputStream(new FileOutputStream(tempFile));
            do {
                readCount = bis.read(readBuffer, 0, readBuffer.length);
                if (readCount > 0) {
                    totalBytesRead += readCount;
                    if (totalBytesRead > startCopyPos) {
                        bos.write(readBuffer, 0, readCount);
                    }
                }
            } while (readCount > 0);
        } finally {
            if (bos != null) {
                try {
                    bos.close();
                } catch (IOException ex) {
                }
            }
            if (bis != null) {
                try {
                    bis.close();
                } catch (IOException ex) {
                }
            }
        }
        if (tempFile.isFile()) {
            if (!logFile.delete()) {
                throw new IOException("Error when attempting to delete the " + logFile + " file.");
            }
            if (!tempFile.renameTo(logFile)) {
                throw new IOException("Error when renaming the " + tempFile + " to " + logFile + ".");
            }
        }
    }
} </s>
<s>class temp {    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        if (req.getParameter("i") != null) {
            String img = req.getParameter("i");
            if (img == null) {
                resp.sendError(404, "Image was null");
                return;
            }
            File f = null;
            if (img.startsWith("file")) {
                try {
                    f = new File(new URI(img));
                } catch (URISyntaxException e) {
                    resp.sendError(500, e.getMessage());
                    return;
                }
            } else {
                f = new File(img);
            }
            if (f.exists()) {
                f = f.getCanonicalFile();
                if (f.getName().endsWith(".jpg") || f.getName().endsWith(".png")) {
                    resp.setContentType("image/png");
                    FileInputStream fis = null;
                    OutputStream os = resp.getOutputStream();
                    try {
                        fis = new FileInputStream(f);
                        IOUtils.copy(fis, os);
                    } finally {
                        os.flush();
                        if (fis != null) fis.close();
                    }
                }
            }
            return;
        }
        String mediaUrl = "/media" + req.getPathInfo();
        String parts[] = mediaUrl.split("/");
        mediaHandler.handleRequest(parts, req, resp);
    }
} </s>
<s>class temp {    private void proxyMediaServlet(String url, HttpServletRequest req, HttpServletResponse resp) {
        try {
            URL u = new URL("http://mediaserver:8080/sagex" + url);
            log.debug("Proxy Media: " + u.toString());
            URLConnection c = u.openConnection();
            c.setRequestProperty("User-Agent", "Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.1) Gecko/2008072820 Firefox/3.0.1");
            OutputStream os = resp.getOutputStream();
            IOUtils.copy(c.getInputStream(), os);
            os.flush();
            resp.flushBuffer();
        } catch (Throwable t) {
            log.error("Failed to get url: " + url, t);
            try {
                resp.sendError(500, t.getMessage());
            } catch (IOException e) {
            }
        }
    }
} </s>
<s>class temp {    public static String get(String strUrl) {
        try {
            URL url = new URL(strUrl);
            URLConnection conn = url.openConnection();
            BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));
            String s = "";
            String sRet = "";
            while ((s = in.readLine()) != null) {
                sRet += s;
            }
            return sRet;
        } catch (MalformedURLException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return "";
    }
} </s>
<s>class temp {    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String url = request.getParameter("proxyurl");
        URLConnection conn = new URL(url).openConnection();
        Reader in = new InputStreamReader(conn.getInputStream(), response.getCharacterEncoding());
        response.setContentType(conn.getContentType());
        response.setContentLength(conn.getContentLength());
        Writer out = response.getWriter();
        char[] buf = new char[256];
        int len;
        while ((len = in.read(buf)) != -1) {
            out.write(buf, 0, len);
        }
        in.close();
        out.close();
        String log = request.getParameter("logging");
        if (log != null && log.toLowerCase().equals("true")) logRequest(request);
    }
} </s>
<s>class temp {    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String url = request.getParameter("proxyurl");
        URLConnection conn = new URL(url).openConnection();
        conn.setDoInput(true);
        conn.setDoOutput(true);
        conn.setUseCaches(false);
        conn.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");
        DataOutputStream dos = new DataOutputStream(conn.getOutputStream());
        Enumeration params = request.getParameterNames();
        boolean first = true;
        while (params.hasMoreElements()) {
            String param = (String) params.nextElement();
            if (!param.equals("proxyurl")) {
                if (first) {
                    first = false;
                } else {
                    dos.writeBytes("&");
                }
                dos.writeBytes(URLEncoder.encode(param));
                dos.writeBytes("=");
                dos.writeBytes(URLEncoder.encode(request.getParameter(param)));
            }
        }
        dos.close();
        Reader in = new InputStreamReader(conn.getInputStream(), response.getCharacterEncoding());
        response.setContentType(conn.getContentType());
        response.setContentLength(conn.getContentLength());
        Writer out = response.getWriter();
        char[] buf = new char[256];
        int len;
        while ((len = in.read(buf)) != -1) {
            out.write(buf, 0, len);
        }
        in.close();
        out.close();
        String log = request.getParameter("logging");
        if (log != null && log.toLowerCase().equals("true")) logRequest(request);
    }
} </s>
<s>class temp {    public FileParse(String fileStr, String type) throws MalformedURLException, IOException {
        this.inFile = fileStr;
        this.type = type;
        System.out.println("File str " + fileStr);
        if (fileStr.indexOf("http://") == 0) {
            URL url = new URL(fileStr);
            urlconn = url.openConnection();
            inStream = urlconn.getInputStream();
            bufReader = new BufferedReader(new InputStreamReader(inStream));
        } else if (type.equals("File")) {
            File inFile = new File(fileStr);
            size = inFile.length();
            inStream = new FileInputStream(inFile);
            bufReader = new BufferedReader(new InputStreamReader(inStream));
        } else if (type.equals("URL")) {
            URL url = new URL(fileStr);
            urlconn = url.openConnection();
            inStream = urlconn.getInputStream();
            bufReader = new BufferedReader(new InputStreamReader(inStream));
        } else if (type.equals("URLZip")) {
            URL url = new URL(fileStr);
            inStream = new GZIPInputStream(url.openStream(), 16384);
            InputStreamReader zis = new InputStreamReader(inStream);
            bufReader = new BufferedReader(zis, 16384);
        } else {
            System.out.println("Unknown FileParse inType " + type);
        }
    }
} </s>
<s>class temp {    public ArrayList<String> getData() {
        ArrayList<String> data = new ArrayList<String>();
        String line = null;
        URL address = null;
        try {
            address = new URL(url);
        } catch (MalformedURLException e) {
            e.printStackTrace();
        }
        URLConnection urlconn = null;
        if (useProxy) {
            SocketAddress addr = new InetSocketAddress(ip, Integer.parseInt(port));
            java.net.Proxy httpProxy = new java.net.Proxy(java.net.Proxy.Type.HTTP, addr);
            try {
                urlconn = address.openConnection(httpProxy);
            } catch (IOException e) {
                e.printStackTrace();
            }
        } else {
            try {
                urlconn = address.openConnection();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        try {
            urlconn.connect();
        } catch (IOException e) {
            return null;
        }
        BufferedReader buffreader = null;
        try {
            buffreader = new BufferedReader(new InputStreamReader(urlconn.getInputStream()));
        } catch (IOException e1) {
            e1.printStackTrace();
        }
        try {
            line = buffreader.readLine();
        } catch (IOException e) {
            e.printStackTrace();
        }
        while (line != null) {
            data.add(line);
            try {
                line = buffreader.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return data;
    }
} </s>
<s>class temp {    public JSONObject getSourceGraph(HttpSession session, JSONObject json) throws JSONException {
        StringBuffer out = new StringBuffer();
        Graph src = null;
        MappingManager manager = (MappingManager) session.getAttribute(RuncibleConstants.MAPPING_MANAGER.key());
        try {
            src = manager.getSourceGraph();
            if (src != null) {
                FlexGraphViewFactory factory = new FlexGraphViewFactory();
                factory.setColorScheme(ColorSchemes.BLUES);
                factory.visit(src);
                GraphView view = factory.getGraphView();
                GraphViewRenderer renderer = new FlexGraphViewRenderer();
                renderer.setGraphView(view);
                InputStream xmlStream = renderer.renderGraphView();
                StringWriter writer = new StringWriter();
                IOUtils.copy(xmlStream, writer);
                writer.close();
                System.out.println(writer.toString());
                out.append(writer.toString());
            } else {
                out.append("No source graph loaded.");
            }
        } catch (Exception e) {
            e.printStackTrace();
            return JSONUtils.SimpleJSONError("Cannot load source graph: " + e.getMessage());
        }
        return JSONUtils.SimpleJSONResponse(out.toString());
    }
} </s>
<s>class temp {    public JSONObject getTargetGraph(HttpSession session, JSONObject json) throws JSONException {
        StringBuffer out = new StringBuffer();
        Graph tgt = null;
        MappingManager manager = (MappingManager) session.getAttribute(RuncibleConstants.MAPPING_MANAGER.key());
        try {
            tgt = manager.getTargetGraph();
            if (tgt != null) {
                FlexGraphViewFactory factory = new FlexGraphViewFactory();
                factory.setColorScheme(ColorSchemes.ORANGES);
                factory.visit(tgt);
                GraphView view = factory.getGraphView();
                GraphViewRenderer renderer = new FlexGraphViewRenderer();
                renderer.setGraphView(view);
                InputStream xmlStream = renderer.renderGraphView();
                StringWriter writer = new StringWriter();
                IOUtils.copy(xmlStream, writer);
                writer.close();
                System.out.println(writer.toString());
                out.append(writer.toString());
            } else {
                out.append("No target graph loaded.");
            }
        } catch (Exception e) {
            return JSONUtils.SimpleJSONError("Cannot load target graph: " + e.getMessage());
        }
        return JSONUtils.SimpleJSONResponse(out.toString());
    }
} </s>
<s>class temp {    public static void main(String[] args) throws Exception {
        String urlString = "http://php.tech.sina.com.cn/download/d_load.php?d_id=7877&down_id=151542";
        urlString = EncodeUtils.encodeURL(urlString);
        URL url = new URL(urlString);
        System.out.println("第一次：" + url);
        HttpURLConnection conn = (HttpURLConnection) url.openConnection();
        HttpURLConnection.setFollowRedirects(true);
        Map req = conn.getRequestProperties();
        System.out.println("第一次请求头：");
        printMap(req);
        conn.connect();
        System.out.println("第一次响应：");
        System.out.println(conn.getResponseMessage());
        int code = conn.getResponseCode();
        System.out.println("第一次code:" + code);
        printMap(conn.getHeaderFields());
        System.out.println(conn.getURL().getFile());
        if (code == 404 && !(conn.getURL() + "").equals(urlString)) {
            System.out.println(conn.getURL());
            String tmp = URLEncoder.encode(conn.getURL().toString(), "gbk");
            System.out.println(URLEncoder.encode("在线音乐播放脚本", "GBK"));
            System.out.println(tmp);
            url = new URL(tmp);
            System.out.println("第二次：" + url);
            conn = (HttpURLConnection) url.openConnection();
            System.out.println("第二次响应：");
            System.out.println("code:" + code);
            printMap(conn.getHeaderFields());
        }
    }
} </s>
<s>class temp {    public void run() {
        StringBuffer xml;
        String tabName;
        Element guiElement;
        setBold(monitor.getReading());
        setBold(monitor.getReadingStatus());
        monitor.getReadingStatus().setText("      Working");
        HttpMethod method = null;
        xml = new StringBuffer();
        File tempfile = new File(url);
        if (tempfile.exists()) {
            try {
                InputStream in = new FileInputStream(tempfile);
                int temp;
                while ((temp = in.read()) != -1) {
                    xml.append((char) temp);
                }
                in.close();
            } catch (IOException e) {
                System.out.println("Loading Monitor Failed, error while reading XML file from local file");
                e.printStackTrace(System.err);
                return;
            }
        } else {
            try {
                HttpClient client = new HttpClient();
                method = new GetMethod(url);
                int response = client.executeMethod(method);
                if (response == 200) {
                    InputStream in = method.getResponseBodyAsStream();
                    int temp;
                    while ((temp = in.read()) != -1) {
                        xml.append((char) temp);
                    }
                    in.close();
                } else {
                    if (method != null) {
                        method.releaseConnection();
                    }
                    System.out.println("Loading Monitor Failed. Incorrect response from HTTP Server " + response);
                    return;
                }
            } catch (IOException e) {
                if (method != null) {
                    method.releaseConnection();
                }
                System.out.println("Loading Monitor Failed, error while reading XML file from HTTP Server");
                e.printStackTrace(System.err);
                return;
            }
        }
        setPlain(monitor.getReading());
        setPlain(monitor.getReadingStatus());
        monitor.getReadingStatus().setText("      Done");
        setBold(monitor.getValidating());
        setBold(monitor.getValidatingStatus());
        monitor.getValidatingStatus().setText("      Working");
        DocumentBuilderFactoryImpl factory = new DocumentBuilderFactoryImpl();
        try {
            DocumentBuilder parser = factory.newDocumentBuilder();
            Document document = parser.parse(new ByteArrayInputStream(xml.toString().getBytes()));
            if (method != null) {
                method.releaseConnection();
            }
            Element root = document.getDocumentElement();
            NodeList temp = root.getElementsByTagName("resource");
            for (int j = 0; j < temp.getLength(); j++) {
                Element resource = (Element) temp.item(j);
                resources.add(new URL(resource.getAttribute("url")));
            }
            NodeList connections = root.getElementsByTagName("jmxserver");
            for (int j = 0; j < connections.getLength(); j++) {
                Element connection = (Element) connections.item(j);
                String name = connection.getAttribute("name");
                String tempUrl = connection.getAttribute("url");
                String auth = connection.getAttribute("auth");
                if (tempUrl.indexOf("${host}") != -1) {
                    HostDialog dialog = new HostDialog(Config.getHosts());
                    String host = dialog.showDialog();
                    if (host == null) {
                        System.out.println("Host can not be null, unable to create panel.");
                        return;
                    }
                    tempUrl = tempUrl.replaceAll("\\$\\{host\\}", host);
                    Config.addHost(host);
                }
                JMXServiceURL jmxUrl = new JMXServiceURL(tempUrl);
                JmxServerGraph server = new JmxServerGraph(name, jmxUrl, new JmxWorker(false));
                if (auth != null && auth.equalsIgnoreCase("true")) {
                    LoginTrueService loginService = new LoginTrueService();
                    JXLoginPanel.Status status = JXLoginPanel.showLoginDialog(null, loginService);
                    if (status != JXLoginPanel.Status.SUCCEEDED) {
                        return;
                    }
                    server.setUsername(loginService.getName());
                    server.setPassword(loginService.getPassword());
                }
                servers.put(name, server);
                NodeList listeners = connection.getElementsByTagName("listener");
                for (int i = 0; i < listeners.getLength(); i++) {
                    Element attribute = (Element) listeners.item(i);
                    String taskname = attribute.getAttribute("taskname");
                    MBean mbean = new MBean(attribute.getAttribute("mbean"), null);
                    String filtertype = attribute.getAttribute("filterType");
                    TaskNotificationListener listener = new TaskNotificationListener();
                    NotificationFilterSupport filter = new NotificationFilterSupport();
                    if (filtertype == null || "".equals(filtertype)) {
                        filter = null;
                    } else {
                        filter.enableType(filtertype);
                    }
                    Task task = new Task(-1, Task.LISTEN, server);
                    task.setMbean(mbean);
                    task.setListener(listener);
                    task.setFilter(filter);
                    server.getWorker().addTask(task);
                    if (tasks.get(taskname) != null) {
                        System.out.println("Task " + taskname + " already exists.");
                        return;
                    }
                    List<Task> hashTempList = new ArrayList<Task>();
                    hashTempList.add(task);
                    tasks.put(taskname, hashTempList);
                }
                NodeList attributes = connection.getElementsByTagName("attribute");
                for (int i = 0; i < attributes.getLength(); i++) {
                    Element attribute = (Element) attributes.item(i);
                    String taskname = attribute.getAttribute("taskname");
                    MBean mbean = new MBean(attribute.getAttribute("mbean"), null);
                    String attributename = attribute.getAttribute("attributename");
                    String frequency = attribute.getAttribute("frequency");
                    String onEvent = attribute.getAttribute("onEvent");
                    if (frequency.equalsIgnoreCase("onchange")) {
                        TaskNotificationListener listener = new TaskNotificationListener();
                        AttributeChangeNotificationFilter filter = new AttributeChangeNotificationFilter();
                        filter.enableAttribute(attributename);
                        Task task = new Task(-1, Task.LISTEN, server);
                        MBeanAttribute att = new MBeanAttribute(mbean, attributename);
                        task.setAttribute(att);
                        task.setMbean(mbean);
                        task.setListener(listener);
                        task.setFilter(filter);
                        server.getWorker().addTask(task);
                        if (tasks.get(taskname) != null) {
                            System.out.println("Task " + taskname + " already exists.");
                            return;
                        }
                        Task task2 = new Task(-1, Task.GET_ATTRIBUTE, server);
                        task2.setAttribute(att);
                        task2.setMbean(mbean);
                        server.getWorker().addTask(task2);
                        List<Task> hashTempList = new ArrayList<Task>();
                        hashTempList.add(task);
                        hashTempList.add(task2);
                        tasks.put(taskname, hashTempList);
                    } else {
                        int frequency2 = Integer.parseInt(frequency);
                        Task task = new Task(frequency2, Task.GET_ATTRIBUTE, server);
                        MBeanAttribute att = new MBeanAttribute(mbean, attributename);
                        task.setAttribute(att);
                        task.setMbean(mbean);
                        if (tasks.get(taskname) != null) {
                            System.out.println("Task " + taskname + " already exists.");
                            return;
                        }
                        List<Task> hashTempList = new ArrayList<Task>();
                        hashTempList.add(task);
                        tasks.put(taskname, hashTempList);
                        TaskNotificationListener listener = null;
                        if (onEvent != null && !"".equals(onEvent)) {
                            Task tempTask = tasks.get(onEvent).get(0);
                            if (tempTask == null) {
                                System.out.println(onEvent + " was not found.");
                                return;
                            } else {
                                listener = (TaskNotificationListener) tempTask.getListener();
                            }
                        }
                        if (listener == null) {
                            server.getWorker().addTask(task);
                        } else {
                            listener.addTask(task);
                        }
                    }
                }
            }
            NodeList guiTemp = root.getElementsByTagName("gui");
            guiElement = (Element) guiTemp.item(0);
            tabName = guiElement.getAttribute("name");
            if (MonitorServer.contains(tabName)) {
                JOptionPane.showMessageDialog(null, "This panel is already open, stoping creating of panel.", "Panel already exists", JOptionPane.ERROR_MESSAGE);
                return;
            }
            for (int i = 0; i < monitor.getTab().getTabCount(); i++) {
                if (monitor.getTab().getComponent(i).equals(monitor)) {
                    monitor.getTab().setTitleAt(i, tabName);
                    break;
                }
            }
            NodeList tempBindings = root.getElementsByTagName("binding");
            for (int i = 0; i < tempBindings.getLength(); i++) {
                Element binding = (Element) tempBindings.item(i);
                String guiname = binding.getAttribute("guiname");
                String tmethod = binding.getAttribute("method");
                String taskname = binding.getAttribute("taskname");
                String formater = binding.getAttribute("formater");
                BindingContainer tempBinding;
                if (formater == null || (formater != null && formater.equals(""))) {
                    tempBinding = new BindingContainer(guiname, tmethod, taskname);
                } else {
                    tempBinding = new BindingContainer(guiname, tmethod, taskname, formater);
                }
                bindings.add(tempBinding);
            }
        } catch (Exception e) {
            System.err.println("Exception message: " + e.getMessage());
            System.out.println("Loading Monitor Failed, couldnt parse XML file.");
            e.printStackTrace(System.err);
            return;
        }
        setPlain(monitor.getValidating());
        setPlain(monitor.getValidatingStatus());
        monitor.getValidatingStatus().setText("      Done");
        setBold(monitor.getDownload());
        setBold(monitor.getDownloadStatus());
        monitor.getDownloadStatus().setText("      Working");
        List<File> jarFiles = new ArrayList<File>();
        File cacheDir = new File(Config.getCacheDir());
        if (!cacheDir.exists()) {
            cacheDir.mkdir();
        }
        for (URL resUrl : resources) {
            try {
                HttpClient client = new HttpClient();
                HttpMethod methodRes = new GetMethod(resUrl.toString());
                int response = client.executeMethod(methodRes);
                if (response == 200) {
                    int index = resUrl.toString().lastIndexOf("/") + 1;
                    File file = new File(Config.getCacheDir() + resUrl.toString().substring(index));
                    FileOutputStream out = new FileOutputStream(file);
                    InputStream in = methodRes.getResponseBodyAsStream();
                    int readTemp = 0;
                    while ((readTemp = in.read()) != -1) {
                        out.write(readTemp);
                    }
                    System.out.println(file.getName() + " downloaded.");
                    methodRes.releaseConnection();
                    if (file.getName().endsWith(".jar")) {
                        jarFiles.add(file);
                    }
                } else {
                    methodRes.releaseConnection();
                    System.out.println("Loading Monitor Failed. Unable to get resource " + url);
                    return;
                }
            } catch (IOException e) {
                System.out.println("Loading Monitor Failed, error while reading resource file " + "from HTTP Server");
                e.printStackTrace(System.err);
                return;
            }
        }
        URL[] urls = new URL[jarFiles.size()];
        try {
            for (int i = 0; i < jarFiles.size(); i++) {
                File file = jarFiles.get(i);
                File newFile = new File(Config.getCacheDir() + "/" + System.currentTimeMillis() + file.getName());
                FileInputStream in = new FileInputStream(file);
                FileOutputStream out = new FileOutputStream(newFile);
                int n = 0;
                byte[] buf = new byte[1024];
                while ((n = in.read(buf, 0, 1024)) > -1) {
                    out.write(buf, 0, n);
                }
                out.close();
                out.close();
                in.close();
                urls[i] = new URL("file:" + newFile.getAbsolutePath());
            }
        } catch (Exception e1) {
            System.out.println("Unable to load jar files.");
            e1.printStackTrace();
        }
        URLClassLoader loader = new URLClassLoader(urls);
        engine.setClassLoader(loader);
        setPlain(monitor.getDownload());
        setPlain(monitor.getDownloadStatus());
        monitor.getDownloadStatus().setText("      Done");
        setBold(monitor.getGui());
        setBold(monitor.getGuiStatus());
        monitor.getGuiStatus().setText("      Working");
        Container container;
        try {
            String tempXml = xml.toString();
            int start = tempXml.indexOf("<gui");
            start = tempXml.indexOf('>', start) + 1;
            int end = tempXml.indexOf("</gui>");
            container = engine.render(new StringReader(tempXml.substring(start, end)));
        } catch (Exception e) {
            e.printStackTrace(System.err);
            System.err.println("Exception msg: " + e.getMessage());
            System.out.println("Loading Monitor Failed, error creating gui.");
            return;
        }
        for (BindingContainer bcon : bindings) {
            List<Task> temp = tasks.get(bcon.getTask());
            if (temp == null) {
                System.out.println("Task with name " + bcon.getTask() + " doesnt exist.");
            } else {
                for (Task task : temp) {
                    if (task != null) {
                        Object comp = engine.find(bcon.getComponent());
                        if (comp != null) {
                            if (task.getTaskType() == Task.LISTEN && task.getFilter() instanceof AttributeChangeNotificationFilter) {
                                TaskNotificationListener listener = (TaskNotificationListener) task.getListener();
                                if (bcon.getFormater() == null) {
                                    listener.addResultListener(new Binding(comp, bcon.getMethod()));
                                } else {
                                    listener.addResultListener(new Binding(comp, bcon.getMethod(), bcon.getFormater(), loader));
                                }
                            } else {
                                if (bcon.getFormater() == null) {
                                    task.addResultListener(new Binding(comp, bcon.getMethod()));
                                } else {
                                    task.addResultListener(new Binding(comp, bcon.getMethod(), bcon.getFormater(), loader));
                                }
                            }
                        } else {
                            System.out.println("Refering to gui name, " + bcon.getComponent() + ", that doesnt exist. Unable to create monitor.");
                            return;
                        }
                    } else {
                        System.out.println("Refering to task name, " + bcon.getTask() + ", that doesnt exist. Unable to create monitor.");
                        return;
                    }
                }
            }
        }
        for (int i = 0; i < monitor.getTab().getTabCount(); i++) {
            if (monitor.getTab().getComponent(i).equals(monitor)) {
                monitor.getTab().setComponentAt(i, new MonitorContainerPanel(container, this));
                break;
            }
        }
        System.out.println("Connecting to server(s).");
        Enumeration e = servers.keys();
        List<JmxWorker> list = new ArrayList<JmxWorker>();
        while (e.hasMoreElements()) {
            JmxWorker worker = servers.get(e.nextElement()).getWorker();
            worker.setRunning(true);
            worker.start();
            list.add(worker);
        }
        MonitorServer.add(tabName, list);
        Config.addUrl(url);
    }
} </s>
<s>class temp {    private static String hashWithDigest(String in, String digest) {
        try {
            MessageDigest Digester = MessageDigest.getInstance(digest);
            Digester.update(in.getBytes("UTF-8"), 0, in.length());
            byte[] sha1Hash = Digester.digest();
            return toSimpleHexString(sha1Hash);
        } catch (NoSuchAlgorithmException ex) {
            throw new RuntimeException("Hashing the password failed", ex);
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException("Encoding the string failed", e);
        }
    }
} </s>
<s>class temp {    private static void readAndRewrite(File inFile, File outFile) throws IOException {
        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));
        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);
        Dataset ds = DcmObjectFactory.getInstance().newDataset();
        dcmParser.setDcmHandler(ds.getDcmHandler());
        dcmParser.parseDcmFile(null, Tags.PixelData);
        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        System.out.println("reading " + inFile + "...");
        pdReader.readPixelData(false);
        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));
        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;
        ds.writeDataset(out, dcmEncParam);
        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());
        System.out.println("writing " + outFile + "...");
        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        pdWriter.writePixelData();
        out.flush();
        out.close();
        System.out.println("done!");
    }
} </s>
<s>class temp {    public static void copyFile(File srcFile, File desFile) throws IOException {
        AssertUtility.notNull(srcFile);
        AssertUtility.notNull(desFile);
        FileInputStream fis = new FileInputStream(srcFile);
        FileOutputStream fos = new FileOutputStream(desFile);
        try {
            FileChannel srcChannel = fis.getChannel();
            FileChannel dstChannel = fos.getChannel();
            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());
            srcChannel.close();
            dstChannel.close();
        } finally {
            fis.close();
            fos.close();
        }
    }
} </s>
<s>class temp {    public static void main(String args[]) throws IOException, TrimmerException, DataStoreException {
        Options options = new Options();
        options.addOption(new CommandLineOptionBuilder("ace", "path to ace file").isRequired(true).build());
        options.addOption(new CommandLineOptionBuilder("phd", "path to phd file").isRequired(true).build());
        options.addOption(new CommandLineOptionBuilder("out", "path to new ace file").isRequired(true).build());
        options.addOption(new CommandLineOptionBuilder("min_sanger", "min sanger end coveage default =" + DEFAULT_MIN_SANGER_END_CLONE_CVG).build());
        options.addOption(new CommandLineOptionBuilder("min_biDriection", "min bi directional end coveage default =" + DEFAULT_MIN_BI_DIRECTIONAL_END_COVERAGE).build());
        options.addOption(new CommandLineOptionBuilder("ignore_threshold", "min end coveage threshold to stop trying to trim default =" + DEFAULT_IGNORE_END_CVG_THRESHOLD).build());
        CommandLine commandLine;
        PhdDataStore phdDataStore = null;
        AceContigDataStore datastore = null;
        try {
            commandLine = CommandLineUtils.parseCommandLine(options, args);
            int minSangerEndCloneCoverage = commandLine.hasOption("min_sanger") ? Integer.parseInt(commandLine.getOptionValue("min_sanger")) : DEFAULT_MIN_SANGER_END_CLONE_CVG;
            int minBiDirectionalEndCoverage = commandLine.hasOption("min_biDriection") ? Integer.parseInt(commandLine.getOptionValue("min_biDriection")) : DEFAULT_MIN_BI_DIRECTIONAL_END_COVERAGE;
            int ignoreThresholdEndCoverage = commandLine.hasOption("ignore_threshold") ? Integer.parseInt(commandLine.getOptionValue("ignore_threshold")) : DEFAULT_IGNORE_END_CVG_THRESHOLD;
            AceContigTrimmer trimmer = new NextGenClosureAceContigTrimmer(minSangerEndCloneCoverage, minBiDirectionalEndCoverage, ignoreThresholdEndCoverage);
            File aceFile = new File(commandLine.getOptionValue("ace"));
            File phdFile = new File(commandLine.getOptionValue("phd"));
            phdDataStore = new DefaultPhdFileDataStore(phdFile);
            datastore = new IndexedAceFileDataStore(aceFile);
            File tempFile = File.createTempFile("nextGenClosureAceTrimmer", ".ace");
            tempFile.deleteOnExit();
            OutputStream tempOut = new FileOutputStream(tempFile);
            int numberOfContigs = 0;
            int numberOfTotalReads = 0;
            for (AceContig contig : datastore) {
                AceContig trimmedAceContig = trimmer.trimContig(contig);
                if (trimmedAceContig != null) {
                    numberOfContigs++;
                    numberOfTotalReads += trimmedAceContig.getNumberOfReads();
                    AceFileWriter.writeAceFile(trimmedAceContig, phdDataStore, tempOut);
                }
            }
            IOUtil.closeAndIgnoreErrors(tempOut);
            OutputStream masterAceOut = new FileOutputStream(new File(commandLine.getOptionValue("out")));
            masterAceOut.write(String.format("AS %d %d%n", numberOfContigs, numberOfTotalReads).getBytes());
            InputStream tempInput = new FileInputStream(tempFile);
            IOUtils.copy(tempInput, masterAceOut);
        } catch (ParseException e) {
            System.err.println(e.getMessage());
            printHelp(options);
        } finally {
            IOUtil.closeAndIgnoreErrors(phdDataStore, datastore);
        }
    }
} </s>
<s>class temp {    public String FTPupload(String filepath) {
        String fileUrl = null;
        Long clicks = System.currentTimeMillis();
        String currentDateTimeString = clicks.toString();
        String[] tmpSplite = filepath.split("/");
        String filename = currentDateTimeString + tmpSplite[tmpSplite.length - 1];
        String host = "140.112.31.165:8080/sound/";
        Log.d("test", "get in");
        FTPClient ftp = new FTPClient();
        Log.d("test", "initial ftp");
        try {
            ftp.connect("140.112.31.165");
            ftp.enterLocalPassiveMode();
            Log.d("test", "we connected");
            if (!ftp.login("tacowu", "4565686")) {
                ftp.logout();
                return fileUrl;
            }
            int replyCode = ftp.getReplyCode();
            if (!FTPReply.isPositiveCompletion(replyCode)) {
                Log.d("test", "get in trouble");
                ftp.disconnect();
                return fileUrl;
            }
            Log.d("test", "we logged in");
            ftp.setFileType(ftp.BINARY_FILE_TYPE);
            ftp.enterLocalPassiveMode();
            File file = new File(filepath);
            if (file == null) Log.d("test", "file open faild"); else Log.d("test", "file open sucess");
            FileInputStream aInputStream = new FileInputStream(file);
            boolean aRtn = ftp.storeFile(filename, aInputStream);
            aInputStream.close();
            ftp.disconnect();
        } catch (Exception ex) {
        }
        fileUrl = host + filename;
        return fileUrl;
    }
} </s>
<s>class temp {    private String sendToServer(String request) throws IOException {
        Log.d("test", "request body " + request);
        String result = null;
        maybeCreateHttpClient();
        HttpPost post = new HttpPost(Config.APP_BASE_URI);
        post.addHeader("Content-Type", "text/vnd.aexp.json.req");
        post.setEntity(new StringEntity(request));
        HttpResponse resp = httpClient.execute(post);
        int status = resp.getStatusLine().getStatusCode();
        if (status != HttpStatus.SC_OK) throw new IOException("HTTP status: " + Integer.toString(status));
        DataInputStream is = new DataInputStream(resp.getEntity().getContent());
        result = is.readLine();
        return result;
    }
} </s>
<s>class temp {    @Override
    public List<String> transform(String urlString) {
        String result = "";
        InputStream inputStream = null;
        try {
            URL url = new URL(urlString);
            HttpURLConnection connection = (HttpURLConnection) url.openConnection();
            connection.setRequestProperty("User-agent", "finance news monitor");
            connection.setRequestProperty("From", "romilly.cocking@gmail.com");
            connection.setInstanceFollowRedirects(true);
            inputStream = connection.getInputStream();
            result = StringUtils.join(IOUtils.readLines(inputStream).toArray(), lineSeparator);
        } catch (MalformedURLException e) {
            log.warn("Malformed url " + urlString);
        } catch (IOException e) {
            log.warn("error reading from url " + urlString, e);
        }
        if (inputStream != null) {
            try {
                inputStream.close();
            } catch (IOException e) {
                log.warn("could not close url " + urlString, e);
            }
        }
        return enlist(result);
    }
} </s>
<s>class temp {    static String fetchURLComposeExternPackageList(String urlpath, String pkglisturlpath) {
        String link = pkglisturlpath + "package-list";
        try {
            boolean relative = isRelativePath(urlpath);
            readPackageList((new URL(link)).openStream(), urlpath, relative);
        } catch (MalformedURLException exc) {
            return getText("doclet.MalformedURL", link);
        } catch (IOException exc) {
            return getText("doclet.URL_error", link);
        }
        return null;
    }
} </s>
<s>class temp {    private Integer getInt(String sequence) throws NoSuchSequenceException {
        Connection conn = null;
        PreparedStatement read = null;
        PreparedStatement write = null;
        boolean success = false;
        try {
            conn = ds.getConnection();
            conn.setTransactionIsolation(conn.TRANSACTION_REPEATABLE_READ);
            conn.setAutoCommit(false);
            read = conn.prepareStatement(SELECT_SQL);
            read.setString(1, sequence);
            ResultSet readRs = read.executeQuery();
            if (!readRs.next()) {
                throw new NoSuchSequenceException();
            }
            int currentSequenceId = readRs.getInt(1);
            int currentSequenceValue = readRs.getInt(2);
            Integer currentSequenceValueInteger = new Integer(currentSequenceValue);
            write = conn.prepareStatement(UPDATE_SQL);
            write.setInt(1, currentSequenceValue + 1);
            write.setInt(2, currentSequenceId);
            int rowsAffected = write.executeUpdate();
            if (rowsAffected == 1) {
                success = true;
                return currentSequenceValueInteger;
            } else {
                logger.error("Something strange has happened.  The row count was not 1, but was " + rowsAffected);
                return currentSequenceValueInteger;
            }
        } catch (SQLException sqle) {
            logger.error("Table based id generation failed : ");
            logger.error(sqle.getMessage());
            return new Integer(0);
        } finally {
            if (read != null) {
                try {
                    read.close();
                } catch (Exception e) {
                }
            }
            if (write != null) {
                try {
                    write.close();
                } catch (Exception e) {
                }
            }
            if (conn != null) {
                try {
                    if (success) {
                        conn.commit();
                    } else {
                        conn.rollback();
                    }
                    conn.close();
                } catch (Exception e) {
                }
            }
        }
    }
} </s>
<s>class temp {    public static boolean isAnimated(Icon icon) {
        if (icon instanceof ImageIcon) {
            Image image = ((ImageIcon) icon).getImage();
            if (image != null) {
                Object comment = image.getProperty("comment", null);
                if (String.valueOf(comment).startsWith("GifBuilder")) return true;
                if (decoded.containsKey(image)) {
                    return Boolean.TRUE.equals(decoded.get(image));
                }
                InputStream is = null;
                try {
                    URL url = new URL(icon.toString());
                    is = url.openConnection().getInputStream();
                } catch (Exception e) {
                    e.printStackTrace();
                }
                if (is == null) {
                    try {
                        ImageProducer p = image.getSource();
                        if (p instanceof InputStreamImageSource) {
                            Method m = InputStreamImageSource.class.getDeclaredMethod("getDecoder", null);
                            m.setAccessible(true);
                            ImageDecoder d = (ImageDecoder) m.invoke(p, null);
                            if (d instanceof GifImageDecoder) {
                                GifImageDecoder gd = (GifImageDecoder) d;
                                Field input = ImageDecoder.class.getDeclaredField("input");
                                input.setAccessible(true);
                                is = (InputStream) input.get(gd);
                            }
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                if (is != null) {
                    GifDecoder decoder = new GifDecoder();
                    decoder.read(is);
                    boolean animated = decoder.getFrameCount() > 1;
                    decoded.put(image, Boolean.valueOf(animated));
                    return animated;
                }
            }
            return false;
        }
        return icon instanceof AnimatedIcon;
    }
} </s>
<s>class temp {    private static File copyFileTo(File file, File directory) throws IOException {
        File newFile = new File(directory, file.getName());
        FileInputStream fis = null;
        FileOutputStream fos = null;
        try {
            fis = new FileInputStream(file);
            fos = new FileOutputStream(newFile);
            byte buff[] = new byte[1024];
            int val;
            while ((val = fis.read(buff)) > 0) fos.write(buff, 0, val);
        } finally {
            if (fis != null) fis.close();
            if (fos != null) fos.close();
        }
        return newFile;
    }
} </s>
<s>class temp {    static HashSet<ScriptEngineFactory> lookup(ClassLoader loader, String name) {
        HashSet<ScriptEngineFactory> factories = new HashSet<ScriptEngineFactory>();
        try {
            Enumeration<URL> urls = loader.getResources(name);
            while (urls.hasMoreElements()) {
                URL url = urls.nextElement();
                BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream(), "UTF-8"));
                String line;
                while ((line = reader.readLine()) != null) {
                    if ((line = trim(line)) != null) {
                        try {
                            Class<ScriptEngineFactory> clazz = (Class<ScriptEngineFactory>) Class.forName(line, true, loader);
                            ScriptEngineFactory factory = clazz.newInstance();
                            factories.add(factory);
                        } catch (java.lang.UnsupportedClassVersionError error) {
                            if (DEBUG) {
                                System.err.println(line + ": version mismatch - ignore");
                            }
                        }
                    }
                }
            }
        } catch (IOException ex) {
            throw new ScriptException(ex);
        } finally {
            return factories;
        }
    }
} </s>
<s>class temp {    @Test
    public void testCopy_inputStreamToOutputStream() throws Exception {
        InputStream in = new ByteArrayInputStream(inData);
        in = new YellOnCloseInputStreamTest(in);
        ByteArrayOutputStream baout = new ByteArrayOutputStream();
        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);
        int count = IOUtils.copy(in, out);
        assertTrue("Not all bytes were read", in.available() == 0);
        assertEquals("Sizes differ", inData.length, baout.size());
        assertTrue("Content differs", Arrays.equals(inData, baout.toByteArray()));
    }
} </s>
<s>class temp {    @Test
    public void testCopy_inputStreamToOutputStream_IO84() throws Exception {
        long size = (long) Integer.MAX_VALUE + (long) 1;
        InputStream in = new NullInputStreamTest(size);
        OutputStream out = new OutputStream() {

            @Override
            public void write(int b) throws IOException {
            }

            @Override
            public void write(byte[] b) throws IOException {
            }

            @Override
            public void write(byte[] b, int off, int len) throws IOException {
            }
        };
        assertEquals(-1, IOUtils.copy(in, out));
        in.close();
        assertEquals("copyLarge()", size, IOUtils.copyLarge(in, out));
    }
} </s>
<s>class temp {    @Test
    public void testCopy_inputStreamToWriter() throws Exception {
        InputStream in = new ByteArrayInputStream(inData);
        in = new YellOnCloseInputStreamTest(in);
        ByteArrayOutputStream baout = new ByteArrayOutputStream();
        YellOnFlushAndCloseOutputStreamTest out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);
        Writer writer = new OutputStreamWriter(baout, "US-ASCII");
        IOUtils.copy(in, writer);
        out.off();
        writer.flush();
        assertTrue("Not all bytes were read", in.available() == 0);
        assertEquals("Sizes differ", inData.length, baout.size());
        assertTrue("Content differs", Arrays.equals(inData, baout.toByteArray()));
    }
} </s>
<s>class temp {    @Test
    public void testCopy_inputStreamToWriter_nullIn() throws Exception {
        ByteArrayOutputStream baout = new ByteArrayOutputStream();
        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);
        Writer writer = new OutputStreamWriter(baout, "US-ASCII");
        try {
            IOUtils.copy((InputStream) null, writer);
            fail();
        } catch (NullPointerException ex) {
        }
    }
} </s>
<s>class temp {    @Test
    public void testCopy_inputStreamToWriter_Encoding() throws Exception {
        InputStream in = new ByteArrayInputStream(inData);
        in = new YellOnCloseInputStreamTest(in);
        ByteArrayOutputStream baout = new ByteArrayOutputStream();
        YellOnFlushAndCloseOutputStreamTest out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);
        Writer writer = new OutputStreamWriter(baout, "US-ASCII");
        IOUtils.copy(in, writer, "UTF8");
        out.off();
        writer.flush();
        assertTrue("Not all bytes were read", in.available() == 0);
        byte[] bytes = baout.toByteArray();
        bytes = new String(bytes, "UTF8").getBytes("US-ASCII");
        assertTrue("Content differs", Arrays.equals(inData, bytes));
    }
} </s>
<s>class temp {    @Test
    public void testCopy_inputStreamToWriter_Encoding_nullIn() throws Exception {
        ByteArrayOutputStream baout = new ByteArrayOutputStream();
        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);
        Writer writer = new OutputStreamWriter(baout, "US-ASCII");
        try {
            IOUtils.copy((InputStream) null, writer, "UTF8");
            fail();
        } catch (NullPointerException ex) {
        }
    }
} </s>
<s>class temp {    @Test
    public void testCopy_inputStreamToWriter_Encoding_nullEncoding() throws Exception {
        InputStream in = new ByteArrayInputStream(inData);
        in = new YellOnCloseInputStreamTest(in);
        ByteArrayOutputStream baout = new ByteArrayOutputStream();
        YellOnFlushAndCloseOutputStreamTest out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);
        Writer writer = new OutputStreamWriter(baout, "US-ASCII");
        IOUtils.copy(in, writer, null);
        out.off();
        writer.flush();
        assertTrue("Not all bytes were read", in.available() == 0);
        assertEquals("Sizes differ", inData.length, baout.size());
        assertTrue("Content differs", Arrays.equals(inData, baout.toByteArray()));
    }
} </s>
<s>class temp {    @Test
    public void testCopy_readerToOutputStream() throws Exception {
        InputStream in = new ByteArrayInputStream(inData);
        in = new YellOnCloseInputStreamTest(in);
        Reader reader = new InputStreamReader(in, "US-ASCII");
        ByteArrayOutputStream baout = new ByteArrayOutputStream();
        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);
        IOUtils.copy(reader, out);
        assertEquals("Sizes differ", inData.length, baout.size());
        assertTrue("Content differs", Arrays.equals(inData, baout.toByteArray()));
    }
} </s>
<s>class temp {    @Test
    public void testCopy_readerToOutputStream_nullIn() throws Exception {
        ByteArrayOutputStream baout = new ByteArrayOutputStream();
        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);
        try {
            IOUtils.copy((Reader) null, out);
            fail();
        } catch (NullPointerException ex) {
        }
    }
} </s>
<s>class temp {    @Test
    public void testCopy_readerToOutputStream_nullOut() throws Exception {
        InputStream in = new ByteArrayInputStream(inData);
        in = new YellOnCloseInputStreamTest(in);
        Reader reader = new InputStreamReader(in, "US-ASCII");
        try {
            IOUtils.copy(reader, (OutputStream) null);
            fail();
        } catch (NullPointerException ex) {
        }
    }
} </s>
<s>class temp {    @Test
    public void testCopy_readerToOutputStream_Encoding() throws Exception {
        InputStream in = new ByteArrayInputStream(inData);
        in = new YellOnCloseInputStreamTest(in);
        Reader reader = new InputStreamReader(in, "US-ASCII");
        ByteArrayOutputStream baout = new ByteArrayOutputStream();
        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);
        IOUtils.copy(reader, out, "UTF16");
        byte[] bytes = baout.toByteArray();
        bytes = new String(bytes, "UTF16").getBytes("US-ASCII");
        assertTrue("Content differs", Arrays.equals(inData, bytes));
    }
} </s>
<s>class temp {    @Test
    public void testCopy_readerToOutputStream_Encoding_nullIn() throws Exception {
        ByteArrayOutputStream baout = new ByteArrayOutputStream();
        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);
        try {
            IOUtils.copy((Reader) null, out, "UTF16");
            fail();
        } catch (NullPointerException ex) {
        }
    }
} </s>
<s>class temp {    @Test
    public void testCopy_readerToOutputStream_Encoding_nullOut() throws Exception {
        InputStream in = new ByteArrayInputStream(inData);
        in = new YellOnCloseInputStreamTest(in);
        Reader reader = new InputStreamReader(in, "US-ASCII");
        try {
            IOUtils.copy(reader, (OutputStream) null, "UTF16");
            fail();
        } catch (NullPointerException ex) {
        }
    }
} </s>
<s>class temp {    @Test
    public void testCopy_readerToOutputStream_Encoding_nullEncoding() throws Exception {
        InputStream in = new ByteArrayInputStream(inData);
        in = new YellOnCloseInputStreamTest(in);
        Reader reader = new InputStreamReader(in, "US-ASCII");
        ByteArrayOutputStream baout = new ByteArrayOutputStream();
        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);
        IOUtils.copy(reader, out, null);
        assertEquals("Sizes differ", inData.length, baout.size());
        assertTrue("Content differs", Arrays.equals(inData, baout.toByteArray()));
    }
} </s>
<s>class temp {    @Test
    public void testCopy_readerToWriter_nullIn() throws Exception {
        ByteArrayOutputStream baout = new ByteArrayOutputStream();
        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);
        Writer writer = new OutputStreamWriter(baout, "US-ASCII");
        try {
            IOUtils.copy((Reader) null, writer);
            fail();
        } catch (NullPointerException ex) {
        }
    }
} </s>
<s>class temp {    @Test
    public void testCopy_readerToWriter_nullOut() throws Exception {
        InputStream in = new ByteArrayInputStream(inData);
        in = new YellOnCloseInputStreamTest(in);
        Reader reader = new InputStreamReader(in, "US-ASCII");
        try {
            IOUtils.copy(reader, (Writer) null);
            fail();
        } catch (NullPointerException ex) {
        }
    }
} </s>
<s>class temp {    private static void readAndRewrite(File inFile, File outFile) throws IOException {
        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));
        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);
        Dataset ds = DcmObjectFactory.getInstance().newDataset();
        dcmParser.setDcmHandler(ds.getDcmHandler());
        dcmParser.parseDcmFile(null, Tags.PixelData);
        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        System.out.println("reading " + inFile + "...");
        pdReader.readPixelData(false);
        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));
        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;
        ds.writeDataset(out, dcmEncParam);
        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());
        System.out.println("writing " + outFile + "...");
        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        pdWriter.writePixelData();
        out.flush();
        out.close();
        System.out.println("done!");
    }
} </s>
<s>class temp {    public MoteDeploymentConfiguration updateMoteDeploymentConfiguration(int mdConfigID, int programID, int radioPowerLevel) throws AdaptationException {
        MoteDeploymentConfiguration mdc = null;
        Connection connection = null;
        Statement statement = null;
        ResultSet resultSet = null;
        try {
            String query = "UPDATE MoteDeploymentConfigurations SET " + "programID       = " + programID + ", " + "radioPowerLevel = " + radioPowerLevel + "  " + "WHERE id = " + mdConfigID;
            connection = DriverManager.getConnection(CONN_STR);
            statement = connection.createStatement();
            statement.executeUpdate(query);
            query = "SELECT * from MoteDeploymentConfigurations WHERE " + "id = " + mdConfigID;
            resultSet = statement.executeQuery(query);
            if (!resultSet.next()) {
                connection.rollback();
                String msg = "Unable to select updated config.";
                log.error(msg);
                ;
                throw new AdaptationException(msg);
            }
            mdc = getMoteDeploymentConfiguration(resultSet);
            connection.commit();
        } catch (SQLException ex) {
            try {
                connection.rollback();
            } catch (Exception e) {
            }
            String msg = "SQLException in updateMoteDeploymentConfiguration";
            log.error(msg, ex);
            throw new AdaptationException(msg, ex);
        } finally {
            try {
                resultSet.close();
            } catch (Exception ex) {
            }
            try {
                statement.close();
            } catch (Exception ex) {
            }
            try {
                connection.close();
            } catch (Exception ex) {
            }
        }
        return mdc;
    }
} </s>
<s>class temp {    public MoteDeploymentConfiguration addMoteDeploymentConfiguration(int projectDepConfID, int moteID, int programID, int radioPowerLevel) throws AdaptationException {
        MoteDeploymentConfiguration mdc = null;
        Connection connection = null;
        Statement statement = null;
        ResultSet resultSet = null;
        try {
            String query = "INSERT INTO MoteDeploymentConfigurations(" + "projectDeploymentConfigurationID, " + "moteID, programID, radioPowerLevel) VALUES (" + projectDepConfID + ", " + moteID + ", " + programID + ", " + radioPowerLevel + ")";
            connection = DriverManager.getConnection(CONN_STR);
            statement = connection.createStatement();
            statement.executeUpdate(query);
            query = "SELECT * from MoteDeploymentConfigurations WHERE " + "projectDeploymentConfigurationID = " + projectDepConfID + " AND moteID = " + moteID;
            resultSet = statement.executeQuery(query);
            if (!resultSet.next()) {
                connection.rollback();
                String msg = "Unable to select newly added config.";
                log.error(msg);
                ;
                throw new AdaptationException(msg);
            }
            mdc = getMoteDeploymentConfiguration(resultSet);
            connection.commit();
        } catch (SQLException ex) {
            try {
                connection.rollback();
            } catch (Exception e) {
            }
            String msg = "SQLException in addMoteDeploymentConfiguration";
            log.error(msg, ex);
            throw new AdaptationException(msg, ex);
        } finally {
            try {
                resultSet.close();
            } catch (Exception ex) {
            }
            try {
                statement.close();
            } catch (Exception ex) {
            }
            try {
                connection.close();
            } catch (Exception ex) {
            }
        }
        return mdc;
    }
} </s>
<s>class temp {    public MoteDeploymentConfiguration deleteMoteDeploymentConfiguration(int id) throws AdaptationException {
        MoteDeploymentConfiguration mdc = null;
        Connection connection = null;
        Statement statement = null;
        ResultSet resultSet = null;
        try {
            String query = "SELECT * FROM MoteDeploymentConfigurations " + "WHERE id = " + id;
            connection = DriverManager.getConnection(CONN_STR);
            statement = connection.createStatement();
            resultSet = statement.executeQuery(query);
            if (!resultSet.next()) {
                String msg = "Unable to select config to delete.";
                log.error(msg);
                throw new AdaptationException(msg);
            }
            mdc = getMoteDeploymentConfiguration(resultSet);
            query = "DELETE FROM MoteDeploymentConfigurations " + "WHERE id = " + id;
            statement.executeUpdate(query);
            connection.commit();
        } catch (SQLException ex) {
            try {
                connection.rollback();
            } catch (Exception e) {
            }
            String msg = "SQLException in deleteMoteDeploymentConfiguration";
            log.error(msg, ex);
            throw new AdaptationException(msg, ex);
        } finally {
            try {
                resultSet.close();
            } catch (Exception ex) {
            }
            try {
                statement.close();
            } catch (Exception ex) {
            }
            try {
                connection.close();
            } catch (Exception ex) {
            }
        }
        return mdc;
    }
} </s>
<s>class temp {    static String fetchURLComposeExternPackageList(String urlpath, String pkglisturlpath) {
        String link = pkglisturlpath + "package-list";
        try {
            boolean relative = isRelativePath(urlpath);
            readPackageList((new URL(link)).openStream(), urlpath, relative);
        } catch (MalformedURLException exc) {
            return getText("doclet.MalformedURL", link);
        } catch (IOException exc) {
            return getText("doclet.URL_error", link);
        }
        return null;
    }
} </s>
<s>class temp {    public static void copy(String from_name, String to_name, boolean overwriteOk) throws IOException {
        File from_file = new File(from_name);
        File to_file = new File(to_name);
        if (!from_file.exists()) abort("FileCopy: no such source file: " + from_name);
        if (!from_file.isFile()) abort("FileCopy: can't copy directory: " + from_name);
        if (!from_file.canRead()) abort("FileCopy: source file is unreadable: " + from_name);
        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());
        if (to_file.exists()) {
            if (!to_file.canWrite()) abort("FileCopy: destination file is unwriteable: " + to_name);
            if (!overwriteOk) {
                System.out.print("Overwrite existing file " + to_name + "? (Y/N): ");
                System.out.flush();
                BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
                String response = in.readLine();
                if (!response.equals("Y") && !response.equals("y")) abort("FileCopy: existing file was not overwritten.");
            }
        } else {
            String parent = to_file.getParent();
            if (parent == null) parent = System.getProperty("user.dir");
            File dir = new File(parent);
            if (!dir.exists()) abort("FileCopy: destination directory doesn't exist: " + parent);
            if (dir.isFile()) abort("FileCopy: destination is not a directory: " + parent);
            if (!dir.canWrite()) abort("FileCopy: destination directory is unwriteable: " + parent);
        }
        FileInputStream from = null;
        FileOutputStream to = null;
        try {
            from = new FileInputStream(from_file);
            to = new FileOutputStream(to_file);
            byte[] buffer = new byte[4096];
            int bytes_read;
            while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read);
        } finally {
            if (from != null) try {
                from.close();
            } catch (IOException e) {
                ;
            }
            if (to != null) try {
                to.close();
            } catch (IOException e) {
                ;
            }
        }
    }
} </s>
<s>class temp {    private static void main(String[] args) {
        try {
            File f = new File("test.txt");
            if (f.exists()) {
                throw new IOException(f + " already exists.  I don't want to overwrite it.");
            }
            StraightStreamReader in;
            char[] cbuf = new char[0x1000];
            int read;
            int totRead;
            FileOutputStream out = new FileOutputStream(f);
            for (int i = 0x00; i < 0x100; i++) {
                out.write(i);
            }
            out.close();
            in = new StraightStreamReader(new FileInputStream(f));
            for (int i = 0x00; i < 0x100; i++) {
                read = in.read();
                if (read != i) {
                    System.err.println("Error: " + i + " read as " + read);
                }
            }
            in.close();
            in = new StraightStreamReader(new FileInputStream(f));
            totRead = in.read(cbuf);
            if (totRead != 0x100) {
                System.err.println("Simple buffered read did not read the full amount: 0x" + Integer.toHexString(totRead));
            }
            for (int i = 0x00; i < totRead; i++) {
                if (cbuf[i] != i) {
                    System.err.println("Error: 0x" + i + " read as 0x" + cbuf[i]);
                }
            }
            in.close();
            in = new StraightStreamReader(new FileInputStream(f));
            totRead = 0;
            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {
                totRead += read;
            }
            if (totRead != 0x100) {
                System.err.println("Not enough read. Bytes read: " + Integer.toHexString(totRead));
            }
            for (int i = 0x00; i < totRead; i++) {
                if (cbuf[i] != i) {
                    System.err.println("Error: 0x" + i + " read as 0x" + cbuf[i]);
                }
            }
            in.close();
            in = new StraightStreamReader(new FileInputStream(f));
            totRead = 0;
            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {
                totRead += read;
            }
            if (totRead != 0x100) {
                System.err.println("Not enough read. Bytes read: " + Integer.toHexString(totRead));
            }
            for (int i = 0x00; i < totRead; i++) {
                if (cbuf[i + 0x123] != i) {
                    System.err.println("Error: 0x" + i + " read as 0x" + cbuf[i + 0x123]);
                }
            }
            in.close();
            in = new StraightStreamReader(new FileInputStream(f));
            totRead = 0;
            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {
                totRead += read;
            }
            if (totRead != 0x100) {
                System.err.println("Not enough read. Bytes read: " + Integer.toHexString(totRead));
            }
            for (int i = 0x00; i < totRead; i++) {
                if (cbuf[i + 0x123] != i) {
                    System.err.println("Error: 0x" + i + " read as 0x" + cbuf[i + 0x123]);
                }
            }
            in.close();
            f.delete();
        } catch (IOException x) {
            System.err.println(x.getMessage());
        }
    }
} </s>
<s>class temp {    private static void readAndRewrite(File inFile, File outFile) throws IOException {
        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));
        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);
        Dataset ds = DcmObjectFactory.getInstance().newDataset();
        dcmParser.setDcmHandler(ds.getDcmHandler());
        dcmParser.parseDcmFile(null, Tags.PixelData);
        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        System.out.println("reading " + inFile + "...");
        pdReader.readPixelData(false);
        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));
        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;
        ds.writeDataset(out, dcmEncParam);
        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());
        System.out.println("writing " + outFile + "...");
        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        pdWriter.writePixelData();
        out.flush();
        out.close();
        System.out.println("done!");
    }
} </s>
<s>class temp {    protected void initFilter(URL url) {
        initFilterCommon();
        try {
            String xmlText = PApplet.join(PApplet.loadStrings(url.openStream()), "\n");
            XMLElement xml = new XMLElement(xmlText);
            loadXML(xml);
        } catch (IOException e) {
            System.err.println("Error loading filter: " + e.getMessage());
        }
        initShader(url.toString(), true);
    }
} </s>
<s>class temp {    public Song(String s) {
        StringTokenizer tokenizer = new StringTokenizer(s, ";");
        free = false;
        title = tokenizer.nextToken();
        artist = tokenizer.nextToken();
        location = tokenizer.nextToken();
        rating = Integer.parseInt(tokenizer.nextToken());
        overplay = Integer.parseInt(tokenizer.nextToken());
        String temp = tokenizer.nextToken();
        tokenizer = new StringTokenizer(temp, ",[] ");
        tags = new ArrayList<String>();
        while (tokenizer.hasMoreTokens()) {
            tags.add(tokenizer.nextToken());
        }
        byte[] bytes = new byte[40];
        try {
            MessageDigest hasher = MessageDigest.getInstance("SHA-1");
            hasher.update(title.getBytes());
            hasher.update(artist.getBytes());
            bytes = hasher.digest();
        } catch (Exception e) {
            System.out.println(e);
        }
    }
} </s>
<s>class temp {    public GGUser findByUsername(String userName) throws IllegalStateException, GGException, Exception {
        List<NameValuePair> qparams = new ArrayList<NameValuePair>();
        qparams.add(new BasicNameValuePair("method", "gg.people.findByUsername"));
        qparams.add(new BasicNameValuePair("key", this.key));
        qparams.add(new BasicNameValuePair("username", userName));
        String url = REST_URL + "?" + URLEncodedUtils.format(qparams, "UTF-8");
        URI uri = new URI(url);
        HttpGet httpget = new HttpGet(uri);
        HttpResponse response = httpClient.execute(httpget);
        int status = response.getStatusLine().getStatusCode();
        errorCheck(response, status);
        InputStream content = response.getEntity().getContent();
        GGUser user = JAXB.unmarshal(content, GGUser.class);
        return user;
    }
} </s>
<s>class temp {    public GGLicenses getLicensesInfo() throws IllegalStateException, GGException, Exception {
        List<NameValuePair> qparams = new ArrayList<NameValuePair>();
        qparams.add(new BasicNameValuePair("method", "gg.photos.licenses.getInfo"));
        qparams.add(new BasicNameValuePair("key", this.key));
        String url = REST_URL + "?" + URLEncodedUtils.format(qparams, "UTF-8");
        URI uri = new URI(url);
        HttpGet httpget = new HttpGet(uri);
        HttpResponse response = httpClient.execute(httpget);
        int status = response.getStatusLine().getStatusCode();
        errorCheck(response, status);
        InputStream content = response.getEntity().getContent();
        GGLicenses licenses = JAXB.unmarshal(content, GGLicenses.class);
        return licenses;
    }
} </s>
<s>class temp {    public GGMunicipalities getListMunicipalities() throws IllegalStateException, GGException, Exception {
        List<NameValuePair> qparams = new ArrayList<NameValuePair>();
        qparams.add(new BasicNameValuePair("method", "gg.photos.geo.getListMunicipality"));
        qparams.add(new BasicNameValuePair("key", this.key));
        String url = REST_URL + "?" + URLEncodedUtils.format(qparams, "UTF-8");
        URI uri = new URI(url);
        HttpGet httpget = new HttpGet(uri);
        HttpResponse response = httpClient.execute(httpget);
        int status = response.getStatusLine().getStatusCode();
        errorCheck(response, status);
        InputStream content = response.getEntity().getContent();
        GGMunicipalities municipalities = JAXB.unmarshal(content, GGMunicipalities.class);
        return municipalities;
    }
} </s>
<s>class temp {    public GGProvinces getListProvinces() throws IllegalStateException, GGException, Exception {
        List<NameValuePair> qparams = new ArrayList<NameValuePair>();
        qparams.add(new BasicNameValuePair("method", "gg.photos.geo.getListProvinces"));
        qparams.add(new BasicNameValuePair("key", this.key));
        String url = REST_URL + "?" + URLEncodedUtils.format(qparams, "UTF-8");
        URI uri = new URI(url);
        HttpGet httpget = new HttpGet(uri);
        HttpResponse response = httpClient.execute(httpget);
        int status = response.getStatusLine().getStatusCode();
        errorCheck(response, status);
        InputStream content = response.getEntity().getContent();
        GGProvinces provinces = JAXB.unmarshal(content, GGProvinces.class);
        return provinces;
    }
} </s>
<s>class temp {    public GGPhotoInfo getPhotoInfo(String photoId, String language) throws IllegalStateException, GGException, Exception {
        List<NameValuePair> qparams = new ArrayList<NameValuePair>();
        qparams.add(new BasicNameValuePair("method", "gg.photos.getInfo"));
        qparams.add(new BasicNameValuePair("key", this.key));
        qparams.add(new BasicNameValuePair("photo_id", photoId));
        if (null != language) {
            qparams.add(new BasicNameValuePair("language", language));
        }
        String url = REST_URL + "?" + URLEncodedUtils.format(qparams, "UTF-8");
        URI uri = new URI(url);
        HttpGet httpget = new HttpGet(uri);
        HttpResponse response = httpClient.execute(httpget);
        int status = response.getStatusLine().getStatusCode();
        errorCheck(response, status);
        InputStream content = response.getEntity().getContent();
        GGPhotoInfo photo = JAXB.unmarshal(content, GGPhotoInfo.class);
        return photo;
    }
} </s>
<s>class temp {    private void copyFileToPhotoFolder(File photo, String personId) {
        try {
            FileChannel in = new FileInputStream(photo).getChannel();
            File dirServer = new File(Constants.PHOTO_DIR);
            if (!dirServer.exists()) {
                dirServer.mkdirs();
            }
            File fileServer = new File(Constants.PHOTO_DIR + personId + ".jpg");
            if (!fileServer.exists()) {
                fileServer.createNewFile();
            }
            in.transferTo(0, in.size(), new FileOutputStream(fileServer).getChannel());
            in.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
} </s>
<s>class temp {    public static String encryptPasswd(String pass) {
        try {
            if (pass == null || pass.length() == 0) return pass;
            MessageDigest sha = MessageDigest.getInstance("SHA-1");
            sha.reset();
            sha.update(pass.getBytes("UTF-8"));
            return Base64OutputStream.encode(sha.digest());
        } catch (Throwable t) {
            throw new SystemException(t);
        }
    }
} </s>
<s>class temp {    public static void main(String[] args) throws Exception {
        FileChannel fc = new FileOutputStream("data2.txt").getChannel();
        fc.write(ByteBuffer.wrap("Some text".getBytes()));
        fc.close();
        fc = new FileInputStream("data2.txt").getChannel();
        ByteBuffer buff = ByteBuffer.allocate(BSIZE);
        fc.read(buff);
        buff.flip();
        System.out.println(buff.asCharBuffer());
        buff.rewind();
        String encoding = System.getProperty("file.encoding");
        System.out.println("Decoded using " + encoding + ": " + Charset.forName(encoding).decode(buff));
        fc = new FileOutputStream("data2.txt").getChannel();
        fc.write(ByteBuffer.wrap("Some text".getBytes("UTF-16BE")));
        fc.close();
        fc = new FileInputStream("data2.txt").getChannel();
        buff.clear();
        fc.read(buff);
        buff.flip();
        System.out.println(buff.asCharBuffer());
        fc = new FileOutputStream("data2.txt").getChannel();
        buff = ByteBuffer.allocate(24);
        buff.asCharBuffer().put("Some text");
        fc.write(buff);
        fc.close();
        fc = new FileInputStream("data2.txt").getChannel();
        buff.clear();
        fc.read(buff);
        buff.flip();
        System.out.println(buff.asCharBuffer());
    }
} </s>
<s>class temp {    private void generateArchetype(final IProject project, final IDataModel model, final IProgressMonitor monitor, final boolean offline) throws CoreException, InterruptedException, IOException {
        if (getArchetypeArtifactId(model) != null) {
            final Properties properties = new Properties();
            properties.put("archetypeArtifactId", getArchetypeArtifactId(model));
            properties.put("archetypeGroupId", getArchetypeGroupId(model));
            properties.put("archetypeVersion", getArchetypeVersion(model));
            String artifact = (String) model.getProperty(IMavenFacetInstallDataModelProperties.PROJECT_ARTIFACT_ID);
            if (artifact == null || artifact.trim().length() == 0) {
                artifact = project.getName();
            }
            properties.put("artifactId", artifact);
            String group = (String) model.getProperty(IMavenFacetInstallDataModelProperties.PROJECT_GROUP_ID);
            if (group == null || group.trim().length() == 0) {
                group = project.getName();
            }
            properties.put("groupId", group);
            properties.put("version", model.getProperty(IMavenFacetInstallDataModelProperties.PROJECT_VERSION));
            final StringBuffer sb = new StringBuffer(System.getProperty("user.home")).append(File.separator);
            sb.append(".m2").append(File.separator).append("repository");
            final String local = sb.toString();
            Logger.getLog().debug("Local Maven2 repository :: " + local);
            properties.put("localRepository", local);
            if (!offline) {
                final String sbRepos = getRepositories();
                properties.put("remoteRepositories", sbRepos);
            }
            final ILaunchManager launchManager = DebugPlugin.getDefault().getLaunchManager();
            final ILaunchConfigurationType launchConfigurationType = launchManager.getLaunchConfigurationType(LAUNCH_CONFIGURATION_TYPE_ID);
            final ILaunchConfigurationWorkingCopy workingCopy = launchConfigurationType.newInstance(null, "Creating project using Apache Maven archetype");
            File archetypePomDirectory = getDefaultArchetypePomDirectory();
            try {
                String dfPom = getPomFile(group, artifact);
                ByteArrayInputStream bais = new ByteArrayInputStream(dfPom.getBytes());
                File f = new File(archetypePomDirectory, "pom.xml");
                OutputStream fous = null;
                try {
                    fous = new FileOutputStream(f);
                    IOUtils.copy(bais, fous);
                } finally {
                    try {
                        if (fous != null) {
                            fous.close();
                        }
                        if (bais != null) {
                            bais.close();
                        }
                    } catch (IOException e) {
                    }
                }
                if (SiteManager.isHttpProxyEnable()) {
                    addProxySettings(properties);
                }
                workingCopy.setAttribute(ATTR_POM_DIR, archetypePomDirectory.getAbsolutePath());
                workingCopy.setAttribute(ATTR_PROPERTIES, convertPropertiesToList(properties));
                String goalName = "archetype:create";
                if (offline) {
                    goalName = new StringBuffer(goalName).append(" -o").toString();
                }
                goalName = updateGoal(goalName);
                workingCopy.setAttribute(ATTR_GOALS, goalName);
                final long timeout = org.maven.ide.eclipse.ext.Maven2Plugin.getTimeout();
                TimeoutLaunchConfiguration.launchWithTimeout(monitor, workingCopy, project, timeout);
                monitor.setTaskName("Moving to workspace");
                FileUtils.copyDirectoryStructure(new File(archetypePomDirectory, project.getName()), ArchetypePOMHelper.getProjectDirectory(project));
                monitor.worked(1);
                performMavenInstall(monitor, project, offline);
                project.refreshLocal(2, monitor);
            } catch (final IOException ioe) {
                Logger.log(Logger.ERROR, "I/O exception. One probably solution is absence " + "of mvn2 archetypes or not the correct version, " + "in your local repository. Please, check existence " + "of this archetype.");
                Logger.getLog().error("I/O Exception arised creating mvn2 archetype", ioe);
                throw ioe;
            } finally {
                FileUtils.deleteDirectory(archetypePomDirectory);
                Logger.log(Logger.INFO, "Invoked removing of archetype POM directory");
            }
        }
        monitor.worked(1);
    }
} </s>
<s>class temp {    public static void encryptFile(String input, String output, String pwd) throws Exception {
        CipherOutputStream out;
        InputStream in;
        Cipher cipher;
        SecretKey key;
        byte[] byteBuffer;
        cipher = Cipher.getInstance("DES");
        key = new SecretKeySpec(pwd.getBytes(), "DES");
        cipher.init(Cipher.ENCRYPT_MODE, key);
        in = new FileInputStream(input);
        out = new CipherOutputStream(new FileOutputStream(output), cipher);
        byteBuffer = new byte[1024];
        for (int n; (n = in.read(byteBuffer)) != -1; out.write(byteBuffer, 0, n)) ;
        in.close();
        out.close();
    }
} </s>
<s>class temp {    public static void decryptFile(String input, String output, String pwd) throws Exception {
        CipherInputStream in;
        OutputStream out;
        Cipher cipher;
        SecretKey key;
        byte[] byteBuffer;
        cipher = Cipher.getInstance("DES");
        key = new SecretKeySpec(pwd.getBytes(), "DES");
        cipher.init(Cipher.DECRYPT_MODE, key);
        in = new CipherInputStream(new FileInputStream(input), cipher);
        out = new FileOutputStream(output);
        byteBuffer = new byte[1024];
        for (int n; (n = in.read(byteBuffer)) != -1; out.write(byteBuffer, 0, n)) ;
        in.close();
        out.close();
    }
} </s>
<s>class temp {    private static void readAndRewrite(File inFile, File outFile) throws IOException {
        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));
        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);
        Dataset ds = DcmObjectFactory.getInstance().newDataset();
        dcmParser.setDcmHandler(ds.getDcmHandler());
        dcmParser.parseDcmFile(null, Tags.PixelData);
        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        System.out.println("reading " + inFile + "...");
        pdReader.readPixelData(false);
        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));
        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;
        ds.writeDataset(out, dcmEncParam);
        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());
        System.out.println("writing " + outFile + "...");
        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        pdWriter.writePixelData();
        out.flush();
        out.close();
        System.out.println("done!");
    }
} </s>
<s>class temp {    public static String sendScripts(Session session) {
        Channel channel = null;
        String tempDirectory = "";
        Logger.getLogger(RsyncHelper.class.getName()).log(Level.INFO, "Start sendScripts.");
        try {
            {
                channel = session.openChannel("exec");
                final String command = "mktemp -d /tmp/scipionXXXXXXXX";
                ((ChannelExec) channel).setCommand(command);
                InputStream in = channel.getInputStream();
                channel.connect();
                String[] result = inputStreamToString(in, channel);
                tempDirectory = result[1];
                tempDirectory = tempDirectory.replaceAll("\n", "");
                Logger.getLogger(RsyncHelper.class.getName()).log(Level.INFO, "status:" + result[0] + "-command:" + command + "-result:" + tempDirectory);
                IOUtils.closeQuietly(in);
                channel.disconnect();
            }
            {
                channel = session.openChannel("exec");
                final String command = "chmod 700 " + tempDirectory;
                ((ChannelExec) channel).setCommand(command);
                InputStream in = channel.getInputStream();
                channel.connect();
                String[] result = inputStreamToString(in, channel);
                Logger.getLogger(RsyncHelper.class.getName()).log(Level.INFO, "status:" + result[0] + "-command:" + command + "-result:" + result[1]);
                IOUtils.closeQuietly(in);
                channel.disconnect();
            }
            {
                InputStream rsyncHelperContentInput = Thread.currentThread().getContextClassLoader().getResourceAsStream("scripts/" + RSYNC_HELPER_SCRIPT);
                channel = session.openChannel("exec");
                final String command = "cat > " + tempDirectory + "/" + RSYNC_HELPER_SCRIPT;
                ((ChannelExec) channel).setCommand(command);
                OutputStream out = channel.getOutputStream();
                channel.connect();
                IOUtils.copy(rsyncHelperContentInput, out);
                IOUtils.closeQuietly(out);
                channel.disconnect();
            }
            {
                channel = session.openChannel("exec");
                final String command = "chmod 700 " + tempDirectory + "/" + RSYNC_HELPER_SCRIPT;
                ((ChannelExec) channel).setCommand(command);
                InputStream in = channel.getInputStream();
                channel.connect();
                String[] result = inputStreamToString(in, channel);
                Logger.getLogger(RsyncHelper.class.getName()).log(Level.INFO, "status:" + result[0] + "-command:" + command + "-result:" + result[1]);
                IOUtils.closeQuietly(in);
                channel.disconnect();
            }
            {
                InputStream askPassContentInput = Thread.currentThread().getContextClassLoader().getResourceAsStream("scripts/" + RSYNC_ASKPASS_SCRIPT);
                channel = session.openChannel("exec");
                final String command = "cat > " + tempDirectory + "/" + RSYNC_ASKPASS_SCRIPT;
                ((ChannelExec) channel).setCommand(command);
                OutputStream out = channel.getOutputStream();
                channel.connect();
                IOUtils.copy(askPassContentInput, out);
                IOUtils.closeQuietly(out);
                channel.disconnect();
            }
            {
                channel = session.openChannel("exec");
                final String command = "chmod 700 " + tempDirectory + "/" + RSYNC_ASKPASS_SCRIPT;
                ((ChannelExec) channel).setCommand(command);
                InputStream in = channel.getInputStream();
                channel.connect();
                String[] result = inputStreamToString(in, channel);
                Logger.getLogger(RsyncHelper.class.getName()).log(Level.INFO, "status:" + result[0] + "-command:" + command + "-result:" + result[1]);
                IOUtils.closeQuietly(in);
                channel.disconnect();
            }
        } catch (IOException ex) {
            Logger.getLogger(RsyncHelper.class.getName()).log(Level.SEVERE, null, ex);
        } catch (JSchException ex) {
            Logger.getLogger(RsyncHelper.class.getName()).log(Level.SEVERE, null, ex);
        }
        Logger.getLogger(RsyncHelper.class.getName()).log(Level.INFO, "End sendScripts.");
        return tempDirectory;
    }
} </s>
<s>class temp {    public CacheServiceFactoryImpl() {
        @SuppressWarnings("static-access") URL url = this.getClass().getClassLoader().getResource("mwt/xml/xdbforms/configuration/ehcache.xml");
        InputStream is;
        try {
            is = url.openStream();
            cacheManager = CacheManager.create(is);
        } catch (IOException ex) {
            System.err.println("NOn riesco ad aprire il file di configurazione ehcache.xml");
        }
    }
} </s>
<s>class temp {    private String hashMD5(String strToHash) throws Exception {
        try {
            byte[] bHash = new byte[strToHash.length() * 2];
            MessageDigest md = MessageDigest.getInstance("MD5");
            md.update(strToHash.getBytes("UTF-16LE"));
            bHash = md.digest();
            StringBuffer hexString = new StringBuffer();
            for (byte element : bHash) {
                String strTemp = Integer.toHexString(element);
                hexString.append(strTemp.replaceAll("f", ""));
            }
            return hexString.toString();
        } catch (NoSuchAlgorithmException duu) {
            throw new Exception("NoSuchAlgorithmException: " + duu.getMessage());
        }
    }
} </s>
<s>class temp {    public void lookupAllFactories() throws IOException {
        Enumeration setOfFactories = null;
        ClassLoader classLoader = null;
        InputStream inputStream = null;
        classLoader = (ClassLoader) AccessController.doPrivileged(new PrivilegedAction() {

            public Object run() {
                ClassLoader cl = Thread.currentThread().getContextClassLoader();
                if (cl == null) {
                    cl = ClassLoader.getSystemClassLoader();
                }
                return cl;
            }
        });
        if (classLoader == null) {
            return;
        }
        try {
            setOfFactories = classLoader.getResources("META-INF/services/javax.print.StreamPrintServiceFactory");
        } catch (IOException e) {
            e.printStackTrace();
            throw new IOException("IOException during resource finding");
        }
        try {
            while (setOfFactories.hasMoreElements()) {
                URL url = (URL) setOfFactories.nextElement();
                inputStream = url.openStream();
                getFactoryClasses(inputStream);
            }
        } catch (IOException e1) {
            e1.printStackTrace();
            throw new IOException("IOException during resource reading");
        }
    }
} </s>
<s>class temp {    public static byte[] SHA1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        MessageDigest md;
        md = MessageDigest.getInstance("SHA-1");
        byte[] sha1hash = new byte[40];
        md.update(text.getBytes("iso-8859-1"), 0, text.length());
        sha1hash = md.digest();
        return sha1hash;
    }
} </s>
<s>class temp {        public void handle() {
            FileChannel srcChannel, destChannel;
            String destOutFile = databaseName + ".script." + System.currentTimeMillis();
            String destOutFileCompressed = databaseName + ".script." + System.currentTimeMillis() + ".gz";
            if (rotateDest != null) {
                (new File(rotateDest)).mkdirs();
                if (destOutFile.indexOf("/") != -1) {
                    destOutFile = rotateDest + "/" + destOutFile.substring(destOutFile.lastIndexOf("/") + 1);
                }
                if (destOutFileCompressed.indexOf("/") != -1) {
                    destOutFileCompressed = rotateDest + "/" + destOutFileCompressed.substring(destOutFileCompressed.lastIndexOf("/") + 1);
                }
            }
            if (rotateCompress) {
                try {
                    GZIPOutputStream out = new GZIPOutputStream(new FileOutputStream(destOutFileCompressed));
                    FileInputStream in = new FileInputStream(databaseName + ".script");
                    byte buf[] = new byte[1024];
                    int len;
                    while ((len = in.read(buf)) > 0) {
                        out.write(buf, 0, len);
                    }
                    in.close();
                    out.finish();
                    out.close();
                    buf = null;
                    in = null;
                    out = null;
                    Debug.debug("Rotated database file '" + databaseName + ".script' to '" + destOutFileCompressed + "'");
                } catch (Exception e) {
                    Debug.debug("Unable to rotate database file '" + databaseName + ".script': " + e);
                }
            } else {
                try {
                    srcChannel = new FileInputStream(databaseName + ".script").getChannel();
                } catch (IOException e) {
                    Debug.debug("Unable to read file '" + databaseName + ".script' for database rotation.");
                    return;
                }
                try {
                    destChannel = new FileOutputStream(destOutFile).getChannel();
                } catch (IOException e) {
                    Debug.debug("Unable to rotate file to '" + destOutFile + "': " + e.getMessage());
                    return;
                }
                try {
                    destChannel.transferFrom(srcChannel, 0, srcChannel.size());
                    srcChannel.close();
                    destChannel.close();
                    srcChannel = null;
                    destChannel = null;
                } catch (IOException e) {
                    Debug.debug("Unable to copy data for file rotation: " + e.getMessage());
                    return;
                }
                Debug.debug("Rotated database file '" + databaseName + ".script' to '" + destOutFile + "'");
            }
            if (rotateDest != null) {
                long comparisonTime = rotateDays * (60 * 60 * 24 * 1000);
                long currentTime = System.currentTimeMillis();
                File fileList[] = (new File(rotateDest)).listFiles();
                DateFormat format1 = new SimpleDateFormat("yyyy-MM-dd");
                java.util.Date date = new java.util.Date(currentTime);
                String archiveFile = format1.format(date).toString() + ".zip";
                if (rotateArchive != null) {
                    archiveFile = rotateArchive + "/" + archiveFile;
                    (new File(rotateArchive)).mkdirs();
                }
                Archive archive = new Archive(archiveFile);
                for (int i = 0; i < fileList.length; i++) {
                    String currentFilename = fileList[i].getName();
                    long timeDifference = (currentTime - fileList[i].lastModified());
                    if ((rotateCompress && currentFilename.endsWith(".gz")) || (!rotateCompress && currentFilename.indexOf(".script.") != -1)) {
                        if (rotateDest != null) {
                            currentFilename = rotateDest + "/" + currentFilename;
                        }
                        if (timeDifference > comparisonTime) {
                            archive.addFile(fileList[i].getName(), currentFilename);
                            fileList[i].delete();
                        }
                    }
                }
                archive = null;
                fileList = null;
                format1 = null;
                date = null;
            }
        }
} </s>
<s>class temp {    public static void copyFile(File source, File dest) throws IOException {
        FileChannel in = null, out = null;
        try {
            in = new FileInputStream(source).getChannel();
            out = new FileOutputStream(dest).getChannel();
            in.transferTo(0, in.size(), out);
        } catch (FileNotFoundException fnfe) {
            Log.debug(fnfe);
        } finally {
            if (in != null) in.close();
            if (out != null) out.close();
        }
    }
} </s>
<s>class temp {    public void convert(File src, File dest) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(src));
        DcmParser p = pfact.newDcmParser(in);
        Dataset ds = fact.newDataset();
        p.setDcmHandler(ds.getDcmHandler());
        try {
            FileFormat format = p.detectFileFormat();
            if (format != FileFormat.ACRNEMA_STREAM) {
                System.out.println("\n" + src + ": not an ACRNEMA stream!");
                return;
            }
            p.parseDcmFile(format, Tags.PixelData);
            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {
                System.out.println("\n" + src + ": contains UIDs!" + " => probable already DICOM - do not convert");
                return;
            }
            boolean hasPixelData = p.getReadTag() == Tags.PixelData;
            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;
            int pxlen = p.getReadLength();
            if (hasPixelData) {
                if (inflate) {
                    ds.putUS(Tags.BitsAllocated, 16);
                    pxlen = pxlen * 4 / 3;
                }
                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {
                    System.out.println("\n" + src + ": mismatch pixel data length!" + " => do not convert");
                    return;
                }
            }
            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));
            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));
            ds.putUI(Tags.SOPInstanceUID, uid(instUID));
            ds.putUI(Tags.SOPClassUID, classUID);
            if (!ds.contains(Tags.NumberOfSamples)) {
                ds.putUS(Tags.NumberOfSamples, 1);
            }
            if (!ds.contains(Tags.PhotometricInterpretation)) {
                ds.putCS(Tags.PhotometricInterpretation, "MONOCHROME2");
            }
            if (fmi) {
                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));
            }
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
            try {
            } finally {
                ds.writeFile(out, encodeParam());
                if (hasPixelData) {
                    if (!skipGroupLen) {
                        out.write(PXDATA_GROUPLEN);
                        int grlen = pxlen + 8;
                        out.write((byte) grlen);
                        out.write((byte) (grlen >> 8));
                        out.write((byte) (grlen >> 16));
                        out.write((byte) (grlen >> 24));
                    }
                    out.write(PXDATA_TAG);
                    out.write((byte) pxlen);
                    out.write((byte) (pxlen >> 8));
                    out.write((byte) (pxlen >> 16));
                    out.write((byte) (pxlen >> 24));
                }
                if (inflate) {
                    int b2, b3;
                    for (; pxlen > 0; pxlen -= 3) {
                        out.write(in.read());
                        b2 = in.read();
                        b3 = in.read();
                        out.write(b2 & 0x0f);
                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));
                        out.write(b3 >> 4);
                    }
                } else {
                    for (; pxlen > 0; --pxlen) {
                        out.write(in.read());
                    }
                }
                out.close();
            }
            System.out.print('.');
        } finally {
            in.close();
        }
    }
} </s>
<s>class temp {    protected Icon newIcon(String iconName) {
        URL url = Utils.getResource(getFullPath(iconName, "/"), getClass());
        if (url == null) {
            if (getParent() != null) return getParent().getIcon(iconName);
            return null;
        }
        try {
            MethodCall getImage = new MethodCaller("org.apache.sanselan.Sanselan", null, "getBufferedImage", new Object[] { InputStream.class }).getMethodCall();
            getImage.setArgumentValue(0, url.openStream());
            return new ImageIcon((BufferedImage) getImage.call());
        } catch (Throwable e) {
            return new ImageIcon(url);
        }
    }
} </s>
<s>class temp {    public static String toPWD(String pwd) {
        MessageDigest messageDigest = null;
        try {
            messageDigest = MessageDigest.getInstance("MD5");
            messageDigest.reset();
            messageDigest.update(pwd.getBytes("UTF-8"));
        } catch (NoSuchAlgorithmException e) {
            System.out.println("NoSuchAlgorithmException caught!");
            System.exit(-1);
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
        byte[] byteArray = messageDigest.digest();
        StringBuffer md5StrBuff = new StringBuffer();
        for (int i = 0; i < byteArray.length; i++) {
            if (Integer.toHexString(0xFF & byteArray[i]).length() == 1) md5StrBuff.append("0").append(Integer.toHexString(0xFF & byteArray[i])); else md5StrBuff.append(Integer.toHexString(0xFF & byteArray[i]));
        }
        return md5StrBuff.toString();
    }
} </s>
<s>class temp {    public void run(IAction action) {
        int style = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell().getStyle();
        Shell shell = new Shell((style & SWT.MIRRORED) != 0 ? SWT.RIGHT_TO_LEFT : SWT.NONE);
        GraphicalViewer viewer = new ScrollingGraphicalViewer();
        viewer.createControl(shell);
        viewer.setEditDomain(new DefaultEditDomain(null));
        viewer.setRootEditPart(new ScalableFreeformRootEditPart());
        viewer.setEditPartFactory(new ProjectEditPartFactory());
        viewer.setContents(getContents());
        viewer.flush();
        int printMode = new PrintModeDialog(shell).open();
        if (printMode == -1) return;
        PrintDialog dialog = new PrintDialog(shell, SWT.NULL);
        PrinterData data = dialog.open();
        if (data != null) {
            PrintGraphicalViewerOperation op = new PrintGraphicalViewerOperation(new Printer(data), viewer);
            op.setPrintMode(printMode);
            op.run(selectedFile.getName());
        }
    }
} </s>
<s>class temp {    public static void perform(ChangeSet changes, ArchiveInputStream in, ArchiveOutputStream out) throws IOException {
        ArchiveEntry entry = null;
        while ((entry = in.getNextEntry()) != null) {
            System.out.println(entry.getName());
            boolean copy = true;
            for (Iterator it = changes.asSet().iterator(); it.hasNext(); ) {
                Change change = (Change) it.next();
                if (change.type() == ChangeSet.CHANGE_TYPE_DELETE) {
                    DeleteChange delete = ((DeleteChange) change);
                    if (entry.getName() != null && entry.getName().equals(delete.targetFile())) {
                        copy = false;
                    }
                }
            }
            if (copy) {
                System.out.println("Copy: " + entry.getName());
                long size = entry.getSize();
                out.putArchiveEntry(entry);
                IOUtils.copy((InputStream) in, out, (int) size);
                out.closeArchiveEntry();
            }
            System.out.println("---");
        }
        out.close();
    }
} </s>
<s>class temp {    private static void fileUpload() throws Exception {
        DefaultHttpClient httpclient = new DefaultHttpClient();
        HttpPost httppost = new HttpPost(postURL);
        file = new File("h:/Sakura haruno.jpg");
        MultipartEntity mpEntity = new MultipartEntity(HttpMultipartMode.BROWSER_COMPATIBLE);
        ContentBody cbFile = new FileBody(file);
        mpEntity.addPart("Filename", new StringBody(file.getName()));
        mpEntity.addPart("Filedata", cbFile);
        httppost.setEntity(mpEntity);
        System.out.println("executing request " + httppost.getRequestLine());
        System.out.println("Now uploading your file into ugotfile.com");
        HttpResponse response = httpclient.execute(httppost);
        System.out.println(response.getStatusLine());
        if (response != null) {
            uploadresponse = EntityUtils.toString(response.getEntity());
        }
        System.out.println("Upload Response : " + uploadresponse);
        downloadlink = parseResponse(uploadresponse, "[\"", "\"");
        downloadlink = downloadlink.replaceAll("\\\\/", "/");
        deletelink = parseResponse(uploadresponse, "\",\"", "\"");
        deletelink = deletelink.replaceAll("\\\\/", "/");
        System.out.println("Download Link : " + downloadlink);
        System.out.println("Delete Link : " + deletelink);
    }
} </s>
<s>class temp {    public void convert(File src, File dest) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(src));
        DcmParser p = pfact.newDcmParser(in);
        Dataset ds = fact.newDataset();
        p.setDcmHandler(ds.getDcmHandler());
        try {
            FileFormat format = p.detectFileFormat();
            if (format != FileFormat.ACRNEMA_STREAM) {
                System.out.println("\n" + src + ": not an ACRNEMA stream!");
                return;
            }
            p.parseDcmFile(format, Tags.PixelData);
            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {
                System.out.println("\n" + src + ": contains UIDs!" + " => probable already DICOM - do not convert");
                return;
            }
            boolean hasPixelData = p.getReadTag() == Tags.PixelData;
            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;
            int pxlen = p.getReadLength();
            if (hasPixelData) {
                if (inflate) {
                    ds.putUS(Tags.BitsAllocated, 16);
                    pxlen = pxlen * 4 / 3;
                }
                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {
                    System.out.println("\n" + src + ": mismatch pixel data length!" + " => do not convert");
                    return;
                }
            }
            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));
            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));
            ds.putUI(Tags.SOPInstanceUID, uid(instUID));
            ds.putUI(Tags.SOPClassUID, classUID);
            if (!ds.contains(Tags.NumberOfSamples)) {
                ds.putUS(Tags.NumberOfSamples, 1);
            }
            if (!ds.contains(Tags.PhotometricInterpretation)) {
                ds.putCS(Tags.PhotometricInterpretation, "MONOCHROME2");
            }
            if (fmi) {
                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));
            }
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
            try {
            } finally {
                ds.writeFile(out, encodeParam());
                if (hasPixelData) {
                    if (!skipGroupLen) {
                        out.write(PXDATA_GROUPLEN);
                        int grlen = pxlen + 8;
                        out.write((byte) grlen);
                        out.write((byte) (grlen >> 8));
                        out.write((byte) (grlen >> 16));
                        out.write((byte) (grlen >> 24));
                    }
                    out.write(PXDATA_TAG);
                    out.write((byte) pxlen);
                    out.write((byte) (pxlen >> 8));
                    out.write((byte) (pxlen >> 16));
                    out.write((byte) (pxlen >> 24));
                }
                if (inflate) {
                    int b2, b3;
                    for (; pxlen > 0; pxlen -= 3) {
                        out.write(in.read());
                        b2 = in.read();
                        b3 = in.read();
                        out.write(b2 & 0x0f);
                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));
                        out.write(b3 >> 4);
                    }
                } else {
                    for (; pxlen > 0; --pxlen) {
                        out.write(in.read());
                    }
                }
                out.close();
            }
            System.out.print('.');
        } finally {
            in.close();
        }
    }
} </s>
<s>class temp {    public Object resolveEntity(String publicID, String systemID, String baseURI, String namespace) throws XMLStreamException {
        URL url = configuration.get(publicID);
        try {
            if (url != null) return url.openStream();
        } catch (IOException ex) {
            throw new XMLStreamException(String.format("Unable to open stream for resource %s: %s", url, InternalUtils.toMessage(ex)), ex);
        }
        return null;
    }
} </s>
<s>class temp {    @Override
    public void writeTo(final TrackRepresentation t, final Class<?> type, final Type genericType, final Annotation[] annotations, final MediaType mediaType, final MultivaluedMap<String, Object> httpHeaders, final OutputStream entityStream) throws WebApplicationException {
        if (mediaType.isCompatible(MediaType.APPLICATION_OCTET_STREAM_TYPE)) {
            InputStream is = null;
            try {
                httpHeaders.add("Content-Type", "audio/mp3");
                IOUtils.copy(is = t.getInputStream(mediaType), entityStream);
            } catch (final IOException e) {
                LOG.warn("IOException : maybe remote client has disconnected");
            } finally {
                IOUtils.closeQuietly(is);
            }
        }
    }
} </s>
<s>class temp {    public void convert(File src, File dest) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(src));
        DcmParser p = pfact.newDcmParser(in);
        Dataset ds = fact.newDataset();
        p.setDcmHandler(ds.getDcmHandler());
        try {
            FileFormat format = p.detectFileFormat();
            if (format != FileFormat.ACRNEMA_STREAM) {
                System.out.println("\n" + src + ": not an ACRNEMA stream!");
                return;
            }
            p.parseDcmFile(format, Tags.PixelData);
            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {
                System.out.println("\n" + src + ": contains UIDs!" + " => probable already DICOM - do not convert");
                return;
            }
            boolean hasPixelData = p.getReadTag() == Tags.PixelData;
            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;
            int pxlen = p.getReadLength();
            if (hasPixelData) {
                if (inflate) {
                    ds.putUS(Tags.BitsAllocated, 16);
                    pxlen = pxlen * 4 / 3;
                }
                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {
                    System.out.println("\n" + src + ": mismatch pixel data length!" + " => do not convert");
                    return;
                }
            }
            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));
            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));
            ds.putUI(Tags.SOPInstanceUID, uid(instUID));
            ds.putUI(Tags.SOPClassUID, classUID);
            if (!ds.contains(Tags.NumberOfSamples)) {
                ds.putUS(Tags.NumberOfSamples, 1);
            }
            if (!ds.contains(Tags.PhotometricInterpretation)) {
                ds.putCS(Tags.PhotometricInterpretation, "MONOCHROME2");
            }
            if (fmi) {
                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));
            }
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
            try {
            } finally {
                ds.writeFile(out, encodeParam());
                if (hasPixelData) {
                    if (!skipGroupLen) {
                        out.write(PXDATA_GROUPLEN);
                        int grlen = pxlen + 8;
                        out.write((byte) grlen);
                        out.write((byte) (grlen >> 8));
                        out.write((byte) (grlen >> 16));
                        out.write((byte) (grlen >> 24));
                    }
                    out.write(PXDATA_TAG);
                    out.write((byte) pxlen);
                    out.write((byte) (pxlen >> 8));
                    out.write((byte) (pxlen >> 16));
                    out.write((byte) (pxlen >> 24));
                }
                if (inflate) {
                    int b2, b3;
                    for (; pxlen > 0; pxlen -= 3) {
                        out.write(in.read());
                        b2 = in.read();
                        b3 = in.read();
                        out.write(b2 & 0x0f);
                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));
                        out.write(b3 >> 4);
                    }
                } else {
                    for (; pxlen > 0; --pxlen) {
                        out.write(in.read());
                    }
                }
                out.close();
            }
            System.out.print('.');
        } finally {
            in.close();
        }
    }
} </s>
<s>class temp {    public static String contents(URL url) throws IOException {
        InputStream is = url.openStream();
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        byte[] buf = new byte[1024];
        while (true) {
            int len = is.read(buf);
            if (len < 0) {
                break;
            }
            baos.write(buf, 0, len);
        }
        is.close();
        String contents = new String(baos.toByteArray(), "iso8859_1");
        baos.close();
        return contents;
    }
} </s>
<s>class temp {    public static void copyFromFileToFileUsingNIO(File inputFile, File outputFile) throws FileNotFoundException, IOException {
        FileChannel inputChannel = new FileInputStream(inputFile).getChannel();
        FileChannel outputChannel = new FileOutputStream(outputFile).getChannel();
        try {
            inputChannel.transferTo(0, inputChannel.size(), outputChannel);
        } catch (IOException e) {
            throw e;
        } finally {
            if (inputChannel != null) inputChannel.close();
            if (outputChannel != null) outputChannel.close();
        }
    }
} </s>
<s>class temp {    private void copy(File parent) {
        System.out.println("parent---" + parent.getAbsolutePath());
        if (parent.isDirectory() && !".svn".equals(parent.getName())) {
            File cases = new File(parent, "cases");
            if (cases.exists()) {
                File answers = new File(parent, "answers");
                if (!answers.exists()) {
                    answers.mkdir();
                    File answers_linux = new File(parent, "answers_linux");
                    for (File file : answers_linux.listFiles()) {
                        if (file.isDirectory()) {
                            continue;
                        }
                        File target = new File(answers, file.getName());
                        try {
                            IOUtils.copy(new FileInputStream(file), new FileOutputStream(target));
                        } catch (Throwable t) {
                            t.printStackTrace();
                        }
                    }
                }
            } else {
                for (File son : parent.listFiles()) {
                    System.out.println("parent---" + son.getAbsolutePath());
                    copySon(son);
                }
            }
        }
    }
} </s>
<s>class temp {    private void copySon(File parent) {
        System.out.println("parent---" + parent.getAbsolutePath());
        if (parent.isDirectory() && !".svn".equals(parent.getName())) {
            File cases = new File(parent, "cases");
            if (cases.exists()) {
                File answers = new File(parent, "answers");
                if (!answers.exists()) {
                    answers.mkdir();
                    File answers_linux = new File(parent, "answers_linux");
                    for (File file : answers_linux.listFiles()) {
                        if (file.isDirectory()) {
                            continue;
                        }
                        File target = new File(answers, file.getName());
                        try {
                            IOUtils.copy(new FileInputStream(file), new FileOutputStream(target));
                        } catch (Throwable t) {
                            t.printStackTrace();
                        }
                    }
                }
            } else {
                for (File son : parent.listFiles()) {
                    System.out.println("parent---" + son.getAbsolutePath());
                    copySon(son);
                }
            }
        }
    }
} </s>
<s>class temp {    @SmallTest
    public void testSha1() throws Exception {
        MessageDigest digest = MessageDigest.getInstance("SHA-1");
        int numTests = mTestData.length;
        for (int i = 0; i < numTests; i++) {
            digest.update(mTestData[i].input.getBytes());
            byte[] hash = digest.digest();
            String encodedHash = encodeHex(hash);
            assertEquals(encodedHash, mTestData[i].result);
        }
    }
} </s>
<s>class temp {    private String clientLogin(AuthInfo authInfo) throws AuthoricationRequiredException {
        logger.fine("clientLogin.");
        try {
            String url = "https://www.google.com/accounts/ClientLogin";
            HttpPost httpPost = new HttpPost(url);
            ArrayList<NameValuePair> params = new ArrayList<NameValuePair>();
            params.add(new BasicNameValuePair("accountType", "HOSTED_OR_GOOGLE"));
            params.add(new BasicNameValuePair("Email", authInfo.getEmail()));
            params.add(new BasicNameValuePair("Passwd", new String(authInfo.getPassword())));
            params.add(new BasicNameValuePair("service", "ah"));
            params.add(new BasicNameValuePair("source", "client.kotan-server.appspot.com"));
            httpPost.setEntity(new UrlEncodedFormEntity(params, "UTF-8"));
            HttpResponse response = clientManager.httpClient.execute(httpPost);
            HttpEntity entity = response.getEntity();
            if (response.getStatusLine().getStatusCode() != HttpStatus.SC_OK) {
                entity.consumeContent();
                throw new AuthoricationRequiredException(EntityUtils.toString(entity));
            }
            BufferedReader reader = new BufferedReader(new InputStreamReader(entity.getContent()));
            while (true) {
                String line = reader.readLine();
                if (line == null) break;
                if (line.startsWith("Auth=")) {
                    return line.substring("Auth=".length());
                }
            }
            reader.close();
            throw new AuthoricationRequiredException("Login failure.");
        } catch (IOException e) {
            throw new AuthoricationRequiredException(e);
        }
    }
} </s>
<s>class temp {    @Override
    public InputStream getResourceAsStream(String path) {
        try {
            URL url = this.getResource(path);
            if (url == null) return null;
            return url.openStream();
        } catch (Exception e) {
            log(e.getMessage(), e);
            return null;
        }
    }
} </s>
<s>class temp {    public static void saveProperties(Properties props, String comment, URL url) throws IOException {
        if (props == null) throw new IllegalArgumentException();
        if (url == null) throw new IllegalArgumentException();
        OutputStream out = url.openConnection().getOutputStream();
        props.store(out, comment);
        out.close();
    }
} </s>
<s>class temp {    public static boolean validPassword(String password, String passwordInDb) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        byte[] pwdInDb = hexStringToByte(passwordInDb);
        byte[] salt = new byte[SALT_LENGTH];
        System.arraycopy(pwdInDb, 0, salt, 0, SALT_LENGTH);
        MessageDigest md = MessageDigest.getInstance("MD5");
        md.update(salt);
        md.update(password.getBytes("UTF-8"));
        byte[] digest = md.digest();
        byte[] digestInDb = new byte[pwdInDb.length - SALT_LENGTH];
        System.arraycopy(pwdInDb, SALT_LENGTH, digestInDb, 0, digestInDb.length);
        if (Arrays.equals(digest, digestInDb)) {
            return true;
        } else {
            return false;
        }
    }
} </s>
<s>class temp {    public static String getEncryptedPwd(String password) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        byte[] pwd = null;
        SecureRandom random = new SecureRandom();
        byte[] salt = new byte[SALT_LENGTH];
        random.nextBytes(salt);
        MessageDigest md = null;
        md = MessageDigest.getInstance("MD5");
        md.update(salt);
        md.update(password.getBytes("UTF-8"));
        byte[] digest = md.digest();
        pwd = new byte[digest.length + SALT_LENGTH];
        System.arraycopy(salt, 0, pwd, 0, SALT_LENGTH);
        System.arraycopy(digest, 0, pwd, SALT_LENGTH, digest.length);
        return byteToHexString(pwd);
    }
} </s>
<s>class temp {    public Configuration(URL url) {
        InputStream in = null;
        try {
            load(in = url.openStream());
        } catch (Exception e) {
            throw new RuntimeException("Could not load configuration from " + url, e);
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException ignore) {
                }
            }
        }
    }
} </s>
<s>class temp {    String readRss(URL url) {
        String html = "<html><body><h2>No data</h2></body></html>";
        try {
            mLogger.info("URL is:" + url.toString());
            BufferedReader inStream = new BufferedReader(new InputStreamReader(url.openStream()), 1024);
            String line;
            StringBuilder rssFeed = new StringBuilder();
            while ((line = inStream.readLine()) != null) {
                rssFeed.append(line);
            }
            html = rssFeed.toString();
        } catch (IOException ex) {
            mLogger.warning("Couldn't open an RSS stream");
        }
        return html;
    }
} </s>
<s>class temp {    public boolean connentServer() {
        boolean result = false;
        try {
            ftpClient = new FTPClient();
            ftpClient.setDefaultPort(port);
            ftpClient.setControlEncoding("GBK");
            strOut = strOut + "Connecting to host " + host + "\r\n";
            ftpClient.connect(host);
            if (!ftpClient.login(user, password)) return false;
            FTPClientConfig conf = new FTPClientConfig(getSystemKey(ftpClient.getSystemName()));
            conf.setServerLanguageCode("zh");
            ftpClient.configure(conf);
            strOut = strOut + "User " + user + " login OK.\r\n";
            if (!ftpClient.changeWorkingDirectory(sDir)) {
                ftpClient.makeDirectory(sDir);
                ftpClient.changeWorkingDirectory(sDir);
            }
            strOut = strOut + "Directory: " + sDir + "\r\n";
            ftpClient.setFileType(FTP.BINARY_FILE_TYPE);
            strOut = strOut + "Connect Success.\r\n";
            result = true;
        } catch (Exception e) {
            e.printStackTrace();
            result = false;
        }
        return result;
    }
} </s>

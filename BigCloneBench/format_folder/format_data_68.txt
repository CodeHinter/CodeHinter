<s>class temp {    private static void readAndRewrite(File inFile, File outFile) throws IOException {
        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));
        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);
        Dataset ds = DcmObjectFactory.getInstance().newDataset();
        dcmParser.setDcmHandler(ds.getDcmHandler());
        dcmParser.parseDcmFile(null, Tags.PixelData);
        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        System.out.println("reading " + inFile + "...");
        pdReader.readPixelData(false);
        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));
        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;
        ds.writeDataset(out, dcmEncParam);
        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());
        System.out.println("writing " + outFile + "...");
        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        pdWriter.writePixelData();
        out.flush();
        out.close();
        System.out.println("done!");
    }
} </s>
<s>class temp {    @Override
    public HttpResponse execute() throws IOException {
        if (this.method == HttpMethod.GET) {
            String url = this.toString();
            if (url.length() > this.cutoff) {
                if (log.isLoggable(Level.FINER)) log.finer("URL length " + url.length() + " too long, converting GET to POST: " + url);
                String rebase = this.baseURL + "?method=GET";
                return this.execute(HttpMethod.POST, rebase);
            }
        }
        return super.execute();
    }
} </s>
<s>class temp {    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        long t0 = System.currentTimeMillis();
        String id = request.getRequestURI().split("/")[3];
        Song song = manager.find(id);
        if (song != null) {
            if (song.getArtwork()) {
                if (log.isDebugEnabled()) log.debug("song has embedded artwork");
                try {
                    AudioFile af = AudioFileIO.read(new File(song.getFile()));
                    Tag tag = af.getTag();
                    Artwork aw = tag.getFirstArtwork();
                    byte[] bytes = aw.getBinaryData();
                    response.setStatus(HttpServletResponse.SC_OK);
                    response.setContentType(aw.getMimeType());
                    response.getOutputStream().write(bytes);
                } catch (Exception e) {
                    log.warn(e.getMessage());
                }
            } else {
                if (log.isDebugEnabled()) log.debug("search in directory");
                File directory = new File(song.getFile()).getParentFile();
                File[] files = directory.listFiles(filter);
                if (files != null && files.length > 0) {
                    File file = files[0];
                    String type = FilenameUtils.getExtension(file.getName()).toLowerCase();
                    if (type.startsWith("jp")) type = "jpeg";
                    String mime = "image/" + type;
                    response.setStatus(HttpServletResponse.SC_OK);
                    response.setContentType(mime);
                    FileInputStream stream = new FileInputStream(file);
                    try {
                        IOUtils.copy(stream, response.getOutputStream());
                    } catch (IOException e) {
                        log.warn(e.getMessage());
                    } finally {
                        IOUtils.closeQuietly(stream);
                    }
                } else {
                    if (log.isDebugEnabled()) log.debug("image not found: " + id + ", sending redirect: " + redirect);
                    response.sendRedirect(redirect);
                }
            }
        } else {
            log.info("song not found: " + id);
            response.setStatus(HttpServletResponse.SC_NOT_FOUND);
        }
        long t1 = System.currentTimeMillis();
        log.info("request: " + id + " duration: " + (t1 - t0) + "ms");
    }
} </s>
<s>class temp {    private String getFanFouMessage(int pageNo) throws IOException {
        URL url = new URL("http://api.fanfou.com/statuses/user_timeline.json?page=" + pageNo);
        HttpURLConnection request = (HttpURLConnection) url.openConnection();
        request.setDoOutput(true);
        request.setRequestMethod("GET");
        String basicAuth = Base64.encode((getUsername() + ":" + getPassword()).getBytes());
        request.addRequestProperty("Authorization", "Basic " + basicAuth);
        System.out.println("Sending request...");
        request.connect();
        System.out.println("Response: " + request.getResponseCode() + " " + request.getResponseMessage());
        BufferedReader reader = new BufferedReader(new InputStreamReader(request.getInputStream()));
        String b = null;
        StringBuffer sb = new StringBuffer();
        while ((b = reader.readLine()) != null) {
            sb.append(b);
        }
        return sb.toString();
    }
} </s>
<s>class temp {    public static void copyFile(File in, File out) throws Exception {
        FileChannel sourceChannel = new FileInputStream(in).getChannel();
        FileChannel destinationChannel = new FileOutputStream(out).getChannel();
        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);
        sourceChannel.close();
        destinationChannel.close();
    }
} </s>
<s>class temp {    public static void doVersionCheck(View view) {
        view.showWaitCursor();
        try {
            URL url = new URL(jEdit.getProperty("version-check.url"));
            InputStream in = url.openStream();
            BufferedReader bin = new BufferedReader(new InputStreamReader(in));
            String line;
            String version = null;
            String build = null;
            while ((line = bin.readLine()) != null) {
                if (line.startsWith(".version")) version = line.substring(8).trim(); else if (line.startsWith(".build")) build = line.substring(6).trim();
            }
            bin.close();
            if (version != null && build != null) {
                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {
                    GUIUtilities.message(view, "version-check" + ".up-to-date", new String[0]);
                }
            }
        } catch (IOException e) {
            String[] args = { jEdit.getProperty("version-check.url"), e.toString() };
            GUIUtilities.error(view, "read-error", args);
        }
        view.hideWaitCursor();
    }
} </s>
<s>class temp {    public Item doGiveCommentsOnFeedback(String itemId, String comments, boolean approved) throws UnsupportedEncodingException, IOException {
        log(INFO, "Give comments on feedback: Item id=" + itemId);
        String sessionId = (String) RuntimeAccess.getInstance().getSession().getAttribute("SESSION_ID");
        DefaultHttpClient httpclient = new DefaultHttpClient();
        GiveCommentsOnFeedbackRequest request = new GiveCommentsOnFeedbackRequest();
        request.setItemID(itemId);
        request.setSessionId(sessionId);
        request.setComments(comments);
        request.setApproved(approved);
        XStream writer = new XStream();
        writer.setMode(XStream.XPATH_ABSOLUTE_REFERENCES);
        writer.alias("GiveCommentsOnFeedbackRequest", GiveCommentsOnFeedbackRequest.class);
        XStream reader = new XStream();
        reader.setMode(XStream.XPATH_ABSOLUTE_REFERENCES);
        reader.alias("GiveCommentsOnFeedbackResponse", GiveCommentsOnFeedbackResponse.class);
        String strRequest = URLEncoder.encode(reader.toXML(request), "UTF-8");
        HttpPost httppost = new HttpPost(MewitProperties.getMewitUrl() + "/resources/giveCommentsOnFeedback?REQUEST=" + strRequest);
        HttpResponse response = httpclient.execute(httppost);
        HttpEntity entity = response.getEntity();
        if (entity != null) {
            String result = URLDecoder.decode(EntityUtils.toString(entity), "UTF-8");
            GiveCommentsOnFeedbackResponse oResponse = (GiveCommentsOnFeedbackResponse) reader.fromXML(result);
            return oResponse.getItem();
        }
        return null;
    }
} </s>
<s>class temp {    public static void doVersionCheck(View view) {
        view.showWaitCursor();
        try {
            URL url = new URL(jEdit.getProperty("version-check.url"));
            InputStream in = url.openStream();
            BufferedReader bin = new BufferedReader(new InputStreamReader(in));
            String line;
            String version = null;
            String build = null;
            while ((line = bin.readLine()) != null) {
                if (line.startsWith(".version")) version = line.substring(8).trim(); else if (line.startsWith(".build")) build = line.substring(6).trim();
            }
            bin.close();
            if (version != null && build != null) {
                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {
                    GUIUtilities.message(view, "version-check" + ".up-to-date", new String[0]);
                }
            }
        } catch (IOException e) {
            String[] args = { jEdit.getProperty("version-check.url"), e.toString() };
            GUIUtilities.error(view, "read-error", args);
        }
        view.hideWaitCursor();
    }
} </s>
<s>class temp {    public static void main(String[] args) throws Exception {
        String infile = "C:\\copy.sql";
        String outfile = "C:\\copy.txt";
        FileInputStream fin = new FileInputStream(infile);
        FileOutputStream fout = new FileOutputStream(outfile);
        FileChannel fcin = fin.getChannel();
        FileChannel fcout = fout.getChannel();
        ByteBuffer buffer = ByteBuffer.allocate(1024);
        while (true) {
            buffer.clear();
            int r = fcin.read(buffer);
            if (r == -1) {
                break;
            }
            buffer.flip();
            fcout.write(buffer);
        }
    }
} </s>
<s>class temp {    public static String encodePassword(String password) {
        try {
            MessageDigest messageDiegest = MessageDigest.getInstance("SHA-1");
            messageDiegest.update(password.getBytes("UTF-8"));
            return Base64.encodeToString(messageDiegest.digest(), false);
        } catch (NoSuchAlgorithmException e) {
            log.error("Exception while encoding password");
            throw new Error(e);
        } catch (UnsupportedEncodingException e) {
            log.error("Exception while encoding password");
            throw new Error(e);
        }
    }
} </s>
<s>class temp {    public static String[] findClassesInPackage(String packageName, List<String> included, List<String> excluded) throws IOException {
        String packageOnly = packageName;
        boolean recursive = false;
        if (packageName.endsWith(".*")) {
            packageOnly = packageName.substring(0, packageName.lastIndexOf(".*"));
            recursive = true;
        }
        List<String> vResult = new ArrayList<String>();
        String packageDirName = packageOnly.replace('.', '/');
        Enumeration<URL> dirs = Thread.currentThread().getContextClassLoader().getResources(packageDirName);
        while (dirs.hasMoreElements()) {
            URL url = dirs.nextElement();
            String protocol = url.getProtocol();
            if (!matchTestClasspath(url, packageDirName, recursive)) {
                continue;
            }
            if ("file".equals(protocol)) {
                findClassesInDirPackage(packageOnly, included, excluded, URLDecoder.decode(url.getFile(), "UTF-8"), recursive, vResult);
            } else if ("jar".equals(protocol)) {
                JarFile jar = ((JarURLConnection) url.openConnection()).getJarFile();
                Enumeration<JarEntry> entries = jar.entries();
                while (entries.hasMoreElements()) {
                    JarEntry entry = entries.nextElement();
                    String name = entry.getName();
                    if (name.charAt(0) == '/') {
                        name = name.substring(1);
                    }
                    if (name.startsWith(packageDirName)) {
                        int idx = name.lastIndexOf('/');
                        if (idx != -1) {
                            packageName = name.substring(0, idx).replace('/', '.');
                        }
                        Utils.log("PackageUtils", 4, "Package name is " + packageName);
                        if ((idx != -1) || recursive) {
                            if (name.endsWith(".class") && !entry.isDirectory()) {
                                String className = name.substring(packageName.length() + 1, name.length() - 6);
                                Utils.log("PackageUtils", 4, "Found class " + className + ", seeing it if it's included or excluded");
                                includeOrExcludeClass(packageName, className, included, excluded, vResult);
                            }
                        }
                    }
                }
            }
        }
        String[] result = vResult.toArray(new String[vResult.size()]);
        return result;
    }
} </s>
<s>class temp {    public void execute() throws MojoExecutionException, MojoFailureException {
        try {
            this.getLog().info("copy source web.xml - " + this.getWebXml() + " to build dir (source web.xml required if mergewebxml execution is enabled)");
            File destination = new File(this.getBuildDir(), "web.xml");
            if (!destination.exists()) {
                destination.getParentFile().mkdirs();
                destination.createNewFile();
            }
            FileIOUtils.copyFile(this.getWebXml(), destination);
            for (int i = 0; i < this.getCompileTarget().length; i++) {
                File moduleFile = null;
                for (Iterator it = this.getProject().getCompileSourceRoots().iterator(); it.hasNext() && moduleFile == null; ) {
                    File check = new File(it.next().toString() + "/" + this.getCompileTarget()[i].replace('.', '/') + ".gwt.xml");
                    getLog().debug("Looking for file: " + check.getAbsolutePath());
                    if (check.exists()) {
                        moduleFile = check;
                    }
                }
                for (Iterator it = this.getProject().getResources().iterator(); it.hasNext(); ) {
                    Resource r = (Resource) it.next();
                    File check = new File(r.getDirectory() + "/" + this.getCompileTarget()[i].replace('.', '/') + ".gwt.xml");
                    getLog().debug("Looking for file: " + check.getAbsolutePath());
                    if (check.exists()) {
                        moduleFile = check;
                    }
                }
                ClassLoader loader = this.fixThreadClasspath();
                if (moduleFile == null) {
                    try {
                        String classpath = "/" + this.getCompileTarget()[i].replace('.', '/') + ".gwt.xml";
                        InputStream is = loader.getResourceAsStream(classpath);
                        System.out.println("Looking for classpath: " + classpath + "(" + (is != null) + ")");
                        if (is != null) {
                            File temp = new File(this.getBuildDir(), this.getCompileTarget()[i].concat(".gwt.xml"));
                            FileOutputStream fos = new FileOutputStream(temp);
                            FileIOUtils.copyStream(is, fos);
                            moduleFile = temp;
                        }
                    } catch (IOException e) {
                        this.getLog().info(e);
                    }
                }
                GwtWebInfProcessor processor = null;
                try {
                    if (moduleFile != null) {
                        getLog().info("Module file: " + moduleFile.getAbsolutePath());
                        processor = new GwtWebInfProcessor(this.getCompileTarget()[i], moduleFile, destination.getAbsolutePath(), destination.getAbsolutePath(), this.isWebXmlServletPathAsIs());
                        processor.process();
                    } else {
                        throw new MojoExecutionException("module file null");
                    }
                } catch (ExitException e) {
                    this.getLog().info(e.getMessage());
                }
            }
        } catch (Exception e) {
            throw new MojoExecutionException("Unable to merge web.xml", e);
        }
    }
} </s>
<s>class temp {    private static void readAndRewrite(File inFile, File outFile) throws IOException {
        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));
        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);
        Dataset ds = DcmObjectFactory.getInstance().newDataset();
        dcmParser.setDcmHandler(ds.getDcmHandler());
        dcmParser.parseDcmFile(null, Tags.PixelData);
        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        System.out.println("reading " + inFile + "...");
        pdReader.readPixelData(false);
        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));
        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;
        ds.writeDataset(out, dcmEncParam);
        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());
        System.out.println("writing " + outFile + "...");
        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        pdWriter.writePixelData();
        out.flush();
        out.close();
        System.out.println("done!");
    }
} </s>
<s>class temp {    public void convert(File src, File dest) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(src));
        DcmParser p = pfact.newDcmParser(in);
        Dataset ds = fact.newDataset();
        p.setDcmHandler(ds.getDcmHandler());
        try {
            FileFormat format = p.detectFileFormat();
            if (format != FileFormat.ACRNEMA_STREAM) {
                System.out.println("\n" + src + ": not an ACRNEMA stream!");
                return;
            }
            p.parseDcmFile(format, Tags.PixelData);
            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {
                System.out.println("\n" + src + ": contains UIDs!" + " => probable already DICOM - do not convert");
                return;
            }
            boolean hasPixelData = p.getReadTag() == Tags.PixelData;
            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;
            int pxlen = p.getReadLength();
            if (hasPixelData) {
                if (inflate) {
                    ds.putUS(Tags.BitsAllocated, 16);
                    pxlen = pxlen * 4 / 3;
                }
                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {
                    System.out.println("\n" + src + ": mismatch pixel data length!" + " => do not convert");
                    return;
                }
            }
            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));
            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));
            ds.putUI(Tags.SOPInstanceUID, uid(instUID));
            ds.putUI(Tags.SOPClassUID, classUID);
            if (!ds.contains(Tags.NumberOfSamples)) {
                ds.putUS(Tags.NumberOfSamples, 1);
            }
            if (!ds.contains(Tags.PhotometricInterpretation)) {
                ds.putCS(Tags.PhotometricInterpretation, "MONOCHROME2");
            }
            if (fmi) {
                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));
            }
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
            try {
            } finally {
                ds.writeFile(out, encodeParam());
                if (hasPixelData) {
                    if (!skipGroupLen) {
                        out.write(PXDATA_GROUPLEN);
                        int grlen = pxlen + 8;
                        out.write((byte) grlen);
                        out.write((byte) (grlen >> 8));
                        out.write((byte) (grlen >> 16));
                        out.write((byte) (grlen >> 24));
                    }
                    out.write(PXDATA_TAG);
                    out.write((byte) pxlen);
                    out.write((byte) (pxlen >> 8));
                    out.write((byte) (pxlen >> 16));
                    out.write((byte) (pxlen >> 24));
                }
                if (inflate) {
                    int b2, b3;
                    for (; pxlen > 0; pxlen -= 3) {
                        out.write(in.read());
                        b2 = in.read();
                        b3 = in.read();
                        out.write(b2 & 0x0f);
                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));
                        out.write(b3 >> 4);
                    }
                } else {
                    for (; pxlen > 0; --pxlen) {
                        out.write(in.read());
                    }
                }
                out.close();
            }
            System.out.print('.');
        } finally {
            in.close();
        }
    }
} </s>
<s>class temp {    @Override
    protected Void doInBackground(String... urls) {
        Log.d("ParseTask", "Getting URL " + urls[0]);
        try {
            XMLReader reader = SAXParserFactory.newInstance().newSAXParser().getXMLReader();
            reader.setContentHandler(mParser);
            reader.parse(new InputSource(new URL(urls[0]).openStream()));
        } catch (Exception e) {
            if (mCallback != null) mCallback.OnFailure(new ApiResponseObject(ApiResponse.RESPONSE_CRITICAL_FAILURE, e.getLocalizedMessage()));
        }
        return null;
    }
} </s>
<s>class temp {        public final int sendMetaData(FileInputStream fis) throws Exception {
            try {
                UUID uuid = UUID.randomUUID();
                HttpClient client = new SSLHttpClient();
                StringBuilder builder = new StringBuilder(mServer).append("?cmd=meta").append("&id=" + uuid);
                HttpPost method = new HttpPost(builder.toString());
                String fileName = uuid + ".metadata";
                FileInputStreamPart part = new FileInputStreamPart("data", fileName, fis);
                MultipartEntity requestContent = new MultipartEntity(new Part[] { part });
                method.setEntity(requestContent);
                HttpResponse response = client.execute(method);
                int code = response.getStatusLine().getStatusCode();
                if (code == HttpStatus.SC_OK) {
                    return 0;
                } else {
                    return -1;
                }
            } catch (Exception e) {
                throw new Exception("send meta data", e);
            }
        }
} </s>
<s>class temp {    public static XMLShowInfo NzbSearch(TVRageShowInfo tvrage, XMLShowInfo xmldata, int latestOrNext) {
        String newzbin_query = "", csvData = "", hellaQueueDir = "", newzbinUsr = "", newzbinPass = "";
        String[] tmp;
        DateFormat tvRageDateFormat = new SimpleDateFormat("MMM/dd/yyyy");
        DateFormat tvRageDateFormatFix = new SimpleDateFormat("yyyy-MM-dd");
        newzbin_query = "?q=" + xmldata.showName + "+";
        if (latestOrNext == 0) {
            if (xmldata.searchBy.equals("ShowName Season x Episode")) newzbin_query += tvrage.latestSeasonNum + "x" + tvrage.latestEpisodeNum; else if (xmldata.searchBy.equals("Showname SeriesNum")) newzbin_query += tvrage.latestSeriesNum; else if (xmldata.searchBy.equals("Showname YYYY-MM-DD")) {
                try {
                    Date airTime = tvRageDateFormat.parse(tvrage.latestAirDate);
                    newzbin_query += tvRageDateFormatFix.format(airTime);
                } catch (ParseException e) {
                    e.printStackTrace();
                }
            } else if (xmldata.searchBy.equals("Showname EpisodeTitle")) newzbin_query += tvrage.latestTitle;
        } else {
            if (xmldata.searchBy.equals("ShowName Season x Episode")) newzbin_query += tvrage.nextSeasonNum + "x" + tvrage.nextEpisodeNum; else if (xmldata.searchBy.equals("Showname SeriesNum")) newzbin_query += tvrage.nextSeriesNum; else if (xmldata.searchBy.equals("Showname YYYY-MM-DD")) {
                try {
                    Date airTime = tvRageDateFormat.parse(tvrage.nextAirDate);
                    newzbin_query += tvRageDateFormatFix.format(airTime);
                } catch (ParseException e) {
                    e.printStackTrace();
                }
            } else if (xmldata.searchBy.equals("Showname EpisodeTitle")) newzbin_query += tvrage.nextTitle;
        }
        newzbin_query += "&searchaction=Search";
        newzbin_query += "&fpn=p";
        newzbin_query += "&category=8category=11";
        newzbin_query += "&area=-1";
        newzbin_query += "&u_nfo_posts_only=0";
        newzbin_query += "&u_url_posts_only=0";
        newzbin_query += "&u_comment_posts_only=0";
        newzbin_query += "&u_v3_retention=1209600";
        newzbin_query += "&ps_rb_language=" + xmldata.language;
        newzbin_query += "&sort=ps_edit_date";
        newzbin_query += "&order=desc";
        newzbin_query += "&areadone=-1";
        newzbin_query += "&feed=csv";
        newzbin_query += "&ps_rb_video_format=" + xmldata.format;
        newzbin_query = newzbin_query.replaceAll(" ", "%20");
        System.out.println("http://v3.newzbin.com/search/" + newzbin_query);
        try {
            URL url = new URL("http://v3.newzbin.com/search/" + newzbin_query);
            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));
            csvData = in.readLine();
            if (csvData != null) {
                JavaNZB.searchCount++;
                if (searchCount == 6) {
                    searchCount = 0;
                    System.out.println("Sleeping for 60 seconds");
                    try {
                        Thread.sleep(60000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                tmp = csvData.split(",");
                tmp[2] = tmp[2].substring(1, tmp[2].length() - 1);
                tmp[3] = tmp[3].substring(1, tmp[3].length() - 1);
                Pattern p = Pattern.compile("[\\\\</:>?\\[|\\]\"]");
                Matcher matcher = p.matcher(tmp[3]);
                tmp[3] = matcher.replaceAll(" ");
                tmp[3] = tmp[3].replaceAll("&", "and");
                URLConnection urlConn;
                DataOutputStream printout;
                url = new URL("http://v3.newzbin.com/api/dnzb/");
                urlConn = url.openConnection();
                urlConn.setDoInput(true);
                urlConn.setDoOutput(true);
                urlConn.setUseCaches(false);
                urlConn.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");
                printout = new DataOutputStream(urlConn.getOutputStream());
                String content = "username=" + JavaNZB.newzbinUsr + "&password=" + JavaNZB.newzbinPass + "&reportid=" + tmp[2];
                printout.writeBytes(content);
                printout.flush();
                printout.close();
                BufferedReader nzbInput = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));
                File f = new File(JavaNZB.hellaQueueDir, tmp[3] + ".nzb");
                BufferedWriter out = new BufferedWriter(new FileWriter(f));
                String str;
                System.out.println("--Downloading " + tmp[3] + ".nzb" + " to queue directory--");
                while (null != ((str = nzbInput.readLine()))) out.write(str);
                nzbInput.close();
                out.close();
                if (latestOrNext == 0) {
                    xmldata.episode = tvrage.latestEpisodeNum;
                    xmldata.season = tvrage.latestSeasonNum;
                } else {
                    xmldata.episode = tvrage.nextEpisodeNum;
                    xmldata.season = tvrage.nextSeasonNum;
                }
            } else System.out.println("No new episode posted");
            System.out.println();
        } catch (MalformedURLException e) {
        } catch (IOException e) {
            System.out.println("IO Exception from NzbSearch");
        }
        return xmldata;
    }
} </s>
<s>class temp {    public TVRageShowInfo(String xmlShowName) {
        String[] tmp, tmp2;
        String line = "";
        this.usrShowName = xmlShowName;
        try {
            URL url = new URL("http://www.tvrage.com/quickinfo.php?show=" + xmlShowName.replaceAll(" ", "%20"));
            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));
            while ((line = in.readLine()) != null) {
                tmp = line.split("@");
                if (tmp[0].equals("Show Name")) showName = tmp[1];
                if (tmp[0].equals("Show URL")) showURL = tmp[1];
                if (tmp[0].equals("Latest Episode")) {
                    StringTokenizer st = new StringTokenizer(tmp[1], "^");
                    for (int i = 0; st.hasMoreTokens(); i++) {
                        if (i == 0) {
                            tmp2 = st.nextToken().split("x");
                            latestSeasonNum = tmp2[0];
                            latestEpisodeNum = tmp2[1];
                            if (latestSeasonNum.charAt(0) == '0') latestSeasonNum = latestSeasonNum.substring(1);
                        } else if (i == 1) latestTitle = st.nextToken().replaceAll("&", "and"); else latestAirDate = st.nextToken();
                    }
                }
                if (tmp[0].equals("Next Episode")) {
                    StringTokenizer st = new StringTokenizer(tmp[1], "^");
                    for (int i = 0; st.hasMoreTokens(); i++) {
                        if (i == 0) {
                            tmp2 = st.nextToken().split("x");
                            nextSeasonNum = tmp2[0];
                            nextEpisodeNum = tmp2[1];
                            if (nextSeasonNum.charAt(0) == '0') nextSeasonNum = nextSeasonNum.substring(1);
                        } else if (i == 1) nextTitle = st.nextToken().replaceAll("&", "and"); else nextAirDate = st.nextToken();
                    }
                }
                if (tmp[0].equals("Status")) status = tmp[1];
                if (tmp[0].equals("Airtime")) airTime = tmp[1];
            }
            in.close();
            url = new URL(showURL);
            in = new BufferedReader(new InputStreamReader(url.openStream()));
            while ((line = in.readLine()) != null) {
                if (line.indexOf("<b>Latest Episode: </b>") > -1) {
                    tmp = line.split("'>");
                    if (tmp[2].indexOf(':') > -1) {
                        tmp = tmp[2].split(":");
                        latestSeriesNum = tmp[0];
                    }
                } else if (line.indexOf("<b>Next Episode: </b>") > -1) {
                    tmp = line.split("'>");
                    if (tmp[2].indexOf(':') > -1) {
                        tmp = tmp[2].split(":");
                        nextSeriesNum = tmp[0];
                    }
                }
            }
            in.close();
        } catch (MalformedURLException e) {
        } catch (IOException e) {
        }
    }
} </s>
<s>class temp {    public void patch() throws IOException {
        if (mods.isEmpty()) {
            return;
        }
        IOUtils.copy(new FileInputStream(Paths.getMinecraftJarPath()), new FileOutputStream(new File(Paths.getMinecraftBackupPath())));
        JarFile mcjar = new JarFile(Paths.getMinecraftJarPath());
    }
} </s>
<s>class temp {    public ASDGrammarReader(String fileName, boolean includeCoords) throws IOException, MalformedURLException {
        includePixelCoords = includeCoords;
        fileName = fileName.trim();
        urlConnection = null;
        urlStream = null;
        if (fileName.substring(0, 5).equalsIgnoreCase("http:")) {
            URL fileURL = new URL(fileName);
            urlConnection = (HttpURLConnection) fileURL.openConnection();
            urlStream = urlConnection.getInputStream();
            reader = new ASDTokenReader(new BufferedReader(new InputStreamReader(urlStream)));
        } else reader = new ASDTokenReader(new FileReader(fileName));
    }
} </s>
<s>class temp {    public static boolean checkVersion(String vers) throws IOException {
        try {
            String tmp = "";
            URL url = new URL("http://rbmsoft.com.br/apis/ql/index.php?url=null&versao=" + vers);
            BufferedInputStream buf = new BufferedInputStream(url.openStream());
            int dado = 0;
            char letra;
            while ((dado = buf.read()) != -1) {
                letra = (char) dado;
                tmp += letra;
            }
            if (tmp.contains("FALSE")) {
                return false;
            } else if (tmp.contains("TRUE")) {
                new UpdateCheck().updateDialog();
                return true;
            }
        } catch (MalformedURLException e) {
            e.printStackTrace();
        }
        return false;
    }
} </s>
<s>class temp {    private static void readServicesFromUrl(Collection<String> list, URL url) throws IOException {
        InputStream in = url.openStream();
        try {
            if (in == null) return;
            BufferedReader r = new BufferedReader(new InputStreamReader(in, "UTF-8"));
            while (true) {
                String line = r.readLine();
                if (line == null) break;
                int idx = line.indexOf('#');
                if (idx != -1) line = line.substring(0, idx);
                line = line.trim();
                if (line.length() == 0) continue;
                list.add(line);
            }
        } finally {
            try {
                if (in != null) in.close();
            } catch (Throwable ignore) {
            }
        }
    }
} </s>
<s>class temp {    static String fetchURLComposeExternPackageList(String urlpath, String pkglisturlpath) {
        String link = pkglisturlpath + "package-list";
        try {
            boolean relative = isRelativePath(urlpath);
            readPackageList((new URL(link)).openStream(), urlpath, relative);
        } catch (MalformedURLException exc) {
            return getText("doclet.MalformedURL", link);
        } catch (IOException exc) {
            return getText("doclet.URL_error", link);
        }
        return null;
    }
} </s>
<s>class temp {    public void connect() throws IOException {
        try {
            URL url = new URL(pluginUrl);
            connection = (HttpURLConnection) url.openConnection();
            sendNotification(DownloadState.CONNECTION_ESTABLISHED);
            contentLength = connection.getContentLength();
            sendNotification(DownloadState.CONTENT_LENGTH_SET);
            downloadedBytes = 0;
        } catch (java.io.IOException e) {
            e.printStackTrace();
            throw e;
        }
    }
} </s>
<s>class temp {    private void copyFileToDir(MyFile file, MyFile to, wlPanel panel) throws IOException {
        Utilities.print("started copying " + file.getAbsolutePath() + "\n");
        FileOutputStream fos = new FileOutputStream(new File(to.getAbsolutePath()));
        FileChannel foc = fos.getChannel();
        FileInputStream fis = new FileInputStream(new File(file.getAbsolutePath()));
        FileChannel fic = fis.getChannel();
        Date d1 = new Date();
        long amount = foc.transferFrom(fic, rest, fic.size() - rest);
        fic.close();
        foc.force(false);
        foc.close();
        Date d2 = new Date();
        long time = d2.getTime() - d1.getTime();
        double secs = time / 1000.0;
        double rate = amount / secs;
        frame.getStatusArea().append(secs + "s " + "amount: " + Utilities.humanReadable(amount) + " rate: " + Utilities.humanReadable(rate) + "/s\n", "black");
        panel.updateView();
    }
} </s>
<s>class temp {    private static String processStr(String srcStr, String sign) throws NoSuchAlgorithmException, NullPointerException {
        if (null == srcStr) {
            throw new java.lang.NullPointerException("  Ҫ   ܵ  ַ ΪNull");
        }
        MessageDigest digest;
        String algorithm = "MD5";
        String result = "";
        digest = MessageDigest.getInstance(algorithm);
        digest.update(srcStr.getBytes());
        byte[] byteRes = digest.digest();
        int length = byteRes.length;
        for (int i = 0; i < length; i++) {
            result = result + byteHEX(byteRes[i], sign);
        }
        return result;
    }
} </s>
<s>class temp {    private void getRandomGUID(boolean secure) {
        MessageDigest md5 = null;
        StringBuffer sbValueBeforeMD5 = new StringBuffer();
        try {
            md5 = MessageDigest.getInstance("MD5");
        } catch (NoSuchAlgorithmException e) {
            System.out.println("Error: " + e);
        }
        try {
            long time = System.currentTimeMillis();
            long rand = 0;
            if (secure) {
                rand = mySecureRand.nextLong();
            } else {
                rand = myRand.nextLong();
            }
            sbValueBeforeMD5.append(s_id);
            sbValueBeforeMD5.append(":");
            sbValueBeforeMD5.append(Long.toString(time));
            sbValueBeforeMD5.append(":");
            sbValueBeforeMD5.append(Long.toString(rand));
            valueBeforeMD5 = sbValueBeforeMD5.toString();
            md5.update(valueBeforeMD5.getBytes());
            byte[] array = md5.digest();
            StringBuffer sb = new StringBuffer();
            for (int j = 0; j < array.length; ++j) {
                int b = array[j] & 0xFF;
                if (b < 0x10) sb.append('0');
                sb.append(Integer.toHexString(b));
            }
            valueAfterMD5 = sb.toString();
        } catch (Exception e) {
            System.out.println("Error:" + e);
        }
    }
} </s>
<s>class temp {    private void saveVideo(URL url, DownloadTask task) {
        if (url == null) {
            return;
        }
        FileOutputStream out = null;
        InputStream stream = null;
        BufferedInputStream bis = null;
        BufferedOutputStream bos = null;
        File file = new File(task.source.getPreferredVideoLocation("mp4"));
        publish("Starting download to file:" + file.getAbsolutePath());
        try {
            out = new FileOutputStream(file);
            URLConnection uc = url.openConnection();
            String contentType = uc.getContentType();
            int length = uc.getContentLength();
            StatisticsStorage.numberofdownloadedbytes += length;
            publish("Content type: " + contentType + " with a length of " + length);
            stream = uc.getInputStream();
            bis = new BufferedInputStream(stream);
            bos = new BufferedOutputStream(out);
            byte[] bytes = new byte[1024];
            int i = 0;
            long time = System.currentTimeMillis();
            int nextbyte;
            while ((nextbyte = bis.read()) != -1) {
                bos.write(nextbyte);
                i++;
                if (System.currentTimeMillis() - time >= 1000) {
                    publish("downloaded " + (i++) + " bytes of " + length + " bytes.");
                    time = System.currentTimeMillis();
                    int progress = (i - 1) / length;
                    if (progress <= 100 && progress >= 0) setProgress(progress);
                }
            }
            bos.write(bytes);
        } catch (IOException e) {
            System.err.println(url);
            e.printStackTrace();
        } finally {
            try {
                if (out != null) out.close();
                if (stream != null) stream.close();
                if (bis != null) bis.close();
                if (bos != null) bos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        System.out.println("done downloading video");
        task.source.setVideo(file.getAbsolutePath());
        if (task.source.hasLyrics()) {
            task.source.getLyrics().setTag("Video", file.getName());
        }
    }
} </s>
<s>class temp {    private final void reOrderFriendsListByOnlineStatus() {
        boolean flag = true;
        while (flag) {
            flag = false;
            for (int i = 0; i < friendsCount - 1; i++) if (friendsListOnlineStatus[i] < friendsListOnlineStatus[i + 1]) {
                int j = friendsListOnlineStatus[i];
                friendsListOnlineStatus[i] = friendsListOnlineStatus[i + 1];
                friendsListOnlineStatus[i + 1] = j;
                long l = friendsListLongs[i];
                friendsListLongs[i] = friendsListLongs[i + 1];
                friendsListLongs[i + 1] = l;
                flag = true;
            }
        }
    }
} </s>
<s>class temp {    public void zipDocsetFiles(SaxHandler theXmlHandler, int theEventId, Attributes theAtts) throws BpsProcessException {
        ZipOutputStream myZipOut = null;
        BufferedInputStream myDocumentInputStream = null;
        String myFinalFile = null;
        String myTargetPath = null;
        String myTargetFileName = null;
        String myInputFileName = null;
        byte[] myBytesBuffer = null;
        int myLength = 0;
        try {
            myZipOut = new ZipOutputStream(new FileOutputStream(myFinalFile));
            myZipOut.putNextEntry(new ZipEntry(myTargetPath + myTargetFileName));
            myDocumentInputStream = new BufferedInputStream(new FileInputStream(myInputFileName));
            while ((myLength = myDocumentInputStream.read(myBytesBuffer, 0, 4096)) != -1) myZipOut.write(myBytesBuffer, 0, myLength);
            myZipOut.closeEntry();
            myZipOut.close();
        } catch (FileNotFoundException e) {
            throw (new BpsProcessException(BpsProcessException.ERR_OPEN_FILE, "FileNotFoundException while building zip dest file"));
        } catch (IOException e) {
            throw (new BpsProcessException(BpsProcessException.ERR_OPEN_FILE, "IOException while building zip dest file"));
        }
    }
} </s>
<s>class temp {    protected synchronized String encryptThis(String seed, String text) throws EncryptionException {
        String encryptedValue = null;
        String textToEncrypt = text;
        if (seed != null) {
            textToEncrypt = seed.toLowerCase() + text;
        }
        try {
            MessageDigest md = MessageDigest.getInstance("SHA");
            md.update(textToEncrypt.getBytes("UTF-8"));
            encryptedValue = (new BASE64Encoder()).encode(md.digest());
        } catch (Exception e) {
            throw new EncryptionException(e);
        }
        return encryptedValue;
    }
} </s>
<s>class temp {    public void convert(File src, File dest) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(src));
        DcmParser p = pfact.newDcmParser(in);
        Dataset ds = fact.newDataset();
        p.setDcmHandler(ds.getDcmHandler());
        try {
            FileFormat format = p.detectFileFormat();
            if (format != FileFormat.ACRNEMA_STREAM) {
                System.out.println("\n" + src + ": not an ACRNEMA stream!");
                return;
            }
            p.parseDcmFile(format, Tags.PixelData);
            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {
                System.out.println("\n" + src + ": contains UIDs!" + " => probable already DICOM - do not convert");
                return;
            }
            boolean hasPixelData = p.getReadTag() == Tags.PixelData;
            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;
            int pxlen = p.getReadLength();
            if (hasPixelData) {
                if (inflate) {
                    ds.putUS(Tags.BitsAllocated, 16);
                    pxlen = pxlen * 4 / 3;
                }
                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {
                    System.out.println("\n" + src + ": mismatch pixel data length!" + " => do not convert");
                    return;
                }
            }
            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));
            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));
            ds.putUI(Tags.SOPInstanceUID, uid(instUID));
            ds.putUI(Tags.SOPClassUID, classUID);
            if (!ds.contains(Tags.NumberOfSamples)) {
                ds.putUS(Tags.NumberOfSamples, 1);
            }
            if (!ds.contains(Tags.PhotometricInterpretation)) {
                ds.putCS(Tags.PhotometricInterpretation, "MONOCHROME2");
            }
            if (fmi) {
                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));
            }
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
            try {
            } finally {
                ds.writeFile(out, encodeParam());
                if (hasPixelData) {
                    if (!skipGroupLen) {
                        out.write(PXDATA_GROUPLEN);
                        int grlen = pxlen + 8;
                        out.write((byte) grlen);
                        out.write((byte) (grlen >> 8));
                        out.write((byte) (grlen >> 16));
                        out.write((byte) (grlen >> 24));
                    }
                    out.write(PXDATA_TAG);
                    out.write((byte) pxlen);
                    out.write((byte) (pxlen >> 8));
                    out.write((byte) (pxlen >> 16));
                    out.write((byte) (pxlen >> 24));
                }
                if (inflate) {
                    int b2, b3;
                    for (; pxlen > 0; pxlen -= 3) {
                        out.write(in.read());
                        b2 = in.read();
                        b3 = in.read();
                        out.write(b2 & 0x0f);
                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));
                        out.write(b3 >> 4);
                    }
                } else {
                    for (; pxlen > 0; --pxlen) {
                        out.write(in.read());
                    }
                }
                out.close();
            }
            System.out.print('.');
        } finally {
            in.close();
        }
    }
} </s>
<s>class temp {        private void init(URL url) {
            frame = new JInternalFrame(name);
            frame.addInternalFrameListener(this);
            listModel.add(listModel.size(), this);
            area = new JTextArea();
            area.setMargin(new Insets(5, 5, 5, 5));
            try {
                BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));
                String in;
                while ((in = reader.readLine()) != null) {
                    area.append(in);
                    area.append("\n");
                }
                reader.close();
            } catch (Exception e) {
                e.printStackTrace();
                return;
            }
            th = area.getTransferHandler();
            area.setFont(new Font("monospaced", Font.PLAIN, 12));
            area.setCaretPosition(0);
            area.setDragEnabled(true);
            area.setDropMode(DropMode.INSERT);
            frame.getContentPane().add(new JScrollPane(area));
            dp.add(frame);
            frame.show();
            if (DEMO) {
                frame.setSize(300, 200);
            } else {
                frame.setSize(400, 300);
            }
            frame.setResizable(true);
            frame.setClosable(true);
            frame.setIconifiable(true);
            frame.setMaximizable(true);
            frame.setLocation(left, top);
            incr();
            SwingUtilities.invokeLater(new Runnable() {

                public void run() {
                    select();
                }
            });
            nullItem.addActionListener(this);
            setNullTH();
        }
} </s>
<s>class temp {    public static ByteBuffer join(ByteBuffer buffer1, ByteBuffer buffer2) {
        if (buffer2 == null || buffer2.remaining() == 0) return NIOUtils.copy(buffer1);
        if (buffer1 == null || buffer1.remaining() == 0) return NIOUtils.copy(buffer2);
        ByteBuffer buffer = ByteBuffer.allocate(buffer1.remaining() + buffer2.remaining());
        buffer.put(buffer1);
        buffer.put(buffer2);
        buffer.flip();
        return buffer;
    }
} </s>
<s>class temp {    private void loadProperties() {
        if (properties == null) {
            properties = new Properties();
            try {
                URL url = getClass().getResource(propsFile);
                properties.load(url.openStream());
            } catch (IOException ioe) {
                ioe.printStackTrace();
            }
        }
    }
} </s>
<s>class temp {    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String id = request.getRequestURI().split("/")[3];
        if (log.isDebugEnabled()) log.debug("request: " + id + " from: " + request.getRemoteHost());
        Song song = manager.find(id);
        if (song != null) {
            File file = new File(song.getFile());
            if (file.exists()) {
                response.setStatus(HttpServletResponse.SC_OK);
                response.setContentType("audio/" + song.getType());
                response.setContentLength((int) file.length());
                FileInputStream stream = new FileInputStream(file);
                try {
                    IOUtils.copy(stream, response.getOutputStream());
                } finally {
                    IOUtils.closeQuietly(stream);
                }
            } else {
                log.warn("file not found: " + file);
                response.setStatus(HttpServletResponse.SC_NOT_FOUND);
            }
        } else {
            log.info("song not found: " + id);
            response.setStatus(HttpServletResponse.SC_NOT_FOUND);
        }
    }
} </s>
<s>class temp {    public void myCheckCredHandler(View v) {
        Log.d("login_section", "entered handler");
        EditText Username = (EditText) findViewById(R.id.Username);
        EditText Password = (EditText) findViewById(R.id.user_pass);
        String username_S = Username.getText().toString();
        String pass_S = Password.getText().toString();
        TextView ltv = (TextView) findViewById(R.id.LoginPagetv);
        HttpClient httpclient = createHttpClient();
        HttpPost httppost = new HttpPost(authenticationURL);
        try {
            List<NameValuePair> nameValuePairs = new ArrayList<NameValuePair>(2);
            nameValuePairs.add(new BasicNameValuePair("login", username_S));
            nameValuePairs.add(new BasicNameValuePair("password", pass_S));
            httppost.setEntity(new UrlEncodedFormEntity(nameValuePairs));
            HttpResponse response = httpclient.execute(httppost);
            int status = response.getStatusLine().getStatusCode();
            String responseBody = EntityUtils.toString(response.getEntity());
            Log.d("login_section", responseBody);
            JSONObject jsonObject = new JSONObject(responseBody);
            if (status == this.statusOK && jsonObject.getBoolean("logged_in")) {
                ltv.setText("You have been logged in. :D");
                etracks.setLogged(true);
                etracks.setUserToken(jsonObject.getString("user_token"));
                Intent it = new Intent(Intent.ACTION_VIEW);
                it.setClassName(this, etracks.class.getName());
                this.finish();
                startActivity(it);
            } else if (status == this.statusUnprocessable && !jsonObject.getBoolean("logged_in")) {
                if (!jsonObject.isNull("errors")) ltv.setText(jsonObject.getString("errors")); else ltv.setText("login unsuccessful");
            } else Log.d("login_section", "what just happened?");
        } catch (ClientProtocolException e) {
        } catch (IOException e) {
        } catch (JSONException e) {
            e.printStackTrace();
        }
    }
} </s>
<s>class temp {    public FlatFileFrame() {
        super("Specify Your Flat File Data");
        try {
            Class transferAgentClass = this.getStorageTransferAgentClass();
            if (transferAgentClass == null) {
                throw new RuntimeException("Transfer agent class can not be null.");
            }
            Class[] parameterTypes = new Class[] { RepositoryStorage.class };
            Constructor constr = transferAgentClass.getConstructor(parameterTypes);
            Object[] actualValues = new Object[] { this };
            this.transferAgent = (RepositoryStorageTransferAgent) constr.newInstance(actualValues);
        } catch (Exception err) {
            throw new RuntimeException("Unable to instantiate transfer agent.", err);
        }
        this.fmtlistener = new FormatTableModelListener();
        this.map = new HashMap();
        this.NoCallbackChangeMode = false;
        this.setSize(new Dimension(1000, 400));
        this.setLayout(new GridLayout(1, 1));
        this.Config = new FlatFileToolsConfig();
        this.Config.initialize();
        this.connectionHandler = new RepositoryConnectionHandler(this.Config);
        this.Connection = (FlatFileStorageConnectivity) this.connectionHandler.getConnection("default");
        this.Prefs = new FlatFileToolsPrefs();
        this.Prefs.initialize();
        SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd");
        String formatted_date = formatter.format(new Date());
        this.createdOnText = new JTextField(formatted_date);
        this.createdByText = new JTextField(this.Prefs.getConfigValue("createdby"));
        this.reposListeners = new Vector();
        this.removeFormatButton = new JButton("Remove");
        this.previewPanel = new DataSetPanel(new DataSet());
        this.previewPanel.setEditable(false);
        this.chooser = new JFileChooser();
        this.chooser.setMultiSelectionEnabled(true);
        this.enabledRadio = new JRadioButton("Enabled:");
        this.enabledRadio.setSelected(true);
        this.editPrefsButton = new JButton("Preferences...");
        this.editPrefsButton.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent ev) {
                System.out.println("Making visible");
                prefsEditor.setVisible(true);
            }
        });
        this.commentTextArea = new JTextArea(20, 8);
        this.commentTextArea.setText("No comment.");
        this.commentTextArea.setToolTipText("A detailed (possibly formatted) description including guidance to future developers of this set.");
        this.iconServer = new IconServer();
        this.iconServer.setConfigFile(this.Prefs.getConfigValue("default", "iconmapfile"));
        this.nicknameText = new IconifiedDomainNameTextField(new FlatFileFindNameDialog(Config, iconServer), this.iconServer);
        this.nicknameText.setPreferredSize(new Dimension(200, 25));
        this.nicknameText.setText(this.Prefs.getConfigValue("default", "domainname") + ".");
        this.nicknameText.setNameTextToolTipText("Right click to search the database.");
        this.uploadButton = new JButton("Upload");
        this.uploadButton.setToolTipText("Uploads current state to repository.");
        this.uploadButton.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent ev) {
                System.out.println("Trying to upload flat file spec...");
                try {
                    String expname = getNickname();
                    int split = expname.lastIndexOf('.');
                    String domain = "";
                    String name = "";
                    String usersdomain = Prefs.getConfigValue("default", "domainname");
                    if (split > 0) {
                        domain = expname.substring(0, split);
                        name = expname.substring(split + 1, expname.length());
                    } else {
                        name = expname;
                    }
                    name = name.trim();
                    if (name.equals("")) {
                        JOptionPane.showMessageDialog(null, "Cowardly refusing to upload with an empty flat file name...");
                        return;
                    }
                    if (!domain.equals(usersdomain)) {
                        int s = JOptionPane.showConfirmDialog(null, "If you are not the original author, you may wish to switch the current domain name " + domain + " to \nyour domain name " + usersdomain + ".  Would you like to do this?\n (If you'll be using this domain often, you may want to set it in your preferences.)", "Potential WWW name-space clash!", JOptionPane.YES_NO_CANCEL_OPTION);
                        if (s == JOptionPane.YES_OPTION) {
                            setNickname(usersdomain + "." + name);
                            executeTransfer();
                        }
                        if (s == JOptionPane.NO_OPTION) {
                            executeTransfer();
                        }
                    } else {
                        executeTransfer();
                    }
                } catch (Exception err) {
                    throw new RuntimeException("Problem uploading storage.", err);
                }
            }
        });
        this.repositoryView = new JButton("default");
        this.repositoryView.addActionListener(new ActionListener() {

            public void actionPerformed(java.awt.event.ActionEvent e) {
                repositoryEditor.setCurrentRepository(repositoryView.getText());
                repositoryEditor.setVisible(true);
            }
        });
        this.prefsEditor = new PrefsConfigFrame(this.Prefs);
        this.prefsEditor.setVisible(false);
        this.prefsEditor.addCloseListener(new ActionListener() {

            public void actionPerformed(ActionEvent ev) {
                prefsEditor.setVisible(false);
            }
        });
        this.prefsEditor.addSelectListener(new ActionListener() {

            public void actionPerformed(ActionEvent ev) {
                prefsEditor.setVisible(false);
            }
        });
        this.repositoryEditor = new ReposConfigFrame(this.Config);
        this.repositoryEditor.setVisible(false);
        this.repositoryEditor.addSelectListener(new SelectListener());
        this.repositoryEditor.addCloseListener(new CloseListener());
        this.addSources = new JButton("Source from file...");
        this.preview = new JButton("Preview");
        this.leastcolumn = new JSpinner();
        this.columns2show = new JSpinner();
        this.leastrow = new JSpinner();
        this.rows2show = new JSpinner();
        int rowCount = 10;
        JLabel sourceLabel = new JLabel("File Source");
        this.flatfilesource = new JTextField();
        this.flatfilesource.setPreferredSize(new Dimension(200, 25));
        this.flatfilesource.setMinimumSize(new Dimension(200, 25));
        this.flatfilesource.setMaximumSize(new Dimension(200, 25));
        this.isURLButton = new JRadioButton("URL");
        Box scrollBox = Box.createVerticalBox();
        Box srcBox = Box.createHorizontalBox();
        srcBox.add(this.addSources);
        srcBox.add(sourceLabel);
        srcBox.add(this.flatfilesource);
        srcBox.add(this.isURLButton);
        srcBox.add(this.preview);
        scrollBox.add(srcBox);
        Box detailsPanel = Box.createVerticalBox();
        Box detailsBox = Box.createVerticalBox();
        JLabel label;
        Box jointBox;
        jointBox = Box.createHorizontalBox();
        label = new JLabel("Pre-Header Lines:");
        this.preheaderlines = new JSpinner();
        jointBox.add(label);
        jointBox.add(this.preheaderlines);
        detailsBox.add(jointBox);
        this.preheaderlines.addChangeListener(new ChangeListener() {

            public void stateChanged(ChangeEvent ev) {
                int selectedRow = fileselector.getSelectedRow();
                if (selectedRow >= 0) {
                    String fn = (String) sourcemodel.getValueAt(selectedRow, 0);
                    if (fn != null) {
                        updateDetailsFor(fn);
                    }
                }
            }
        });
        jointBox = Box.createHorizontalBox();
        label = new JLabel("Has Header Line:");
        this.hasHeaderLineBox = new JCheckBox();
        jointBox.add(label);
        jointBox.add(this.hasHeaderLineBox);
        detailsBox.add(jointBox);
        this.hasHeaderLineBox.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent ev) {
                int selectedRow = fileselector.getSelectedRow();
                if (selectedRow >= 0) {
                    String fn = (String) sourcemodel.getValueAt(selectedRow, 0);
                    if (fn != null) {
                        fn = fn.trim();
                        if ((fn != null) && (fn.length() > 0)) {
                            updateDetailsFor(fn);
                        }
                    }
                }
            }
        });
        jointBox = Box.createHorizontalBox();
        label = new JLabel("Post-Header Lines:");
        this.postheaderlines = new JSpinner();
        jointBox.add(label);
        jointBox.add(this.postheaderlines);
        detailsBox.add(jointBox);
        this.postheaderlines.addChangeListener(new ChangeListener() {

            public void stateChanged(ChangeEvent ev) {
                int selectedRow = fileselector.getSelectedRow();
                if (selectedRow >= 0) {
                    String fn = (String) sourcemodel.getValueAt(selectedRow, 0);
                    if (fn != null) {
                        fn = fn.trim();
                        if ((fn != null) && (fn.length() > 0)) {
                            updateDetailsFor(fn);
                        }
                    }
                }
            }
        });
        jointBox = Box.createHorizontalBox();
        label = new JLabel("Format:");
        jointBox.add(label);
        this.singleFormatText = new JTextField("%s");
        jointBox.add(this.singleFormatText);
        jointBox.add(new JLabel("Repeat"));
        this.repeatFormatNumber = new JSpinner();
        this.repeatFormatNumber.setValue(new Integer(1));
        jointBox.add(this.repeatFormatNumber);
        this.addFormatButton = new JButton("Add");
        jointBox.add(this.addFormatButton);
        this.removeFormatButton = new JButton("Remove");
        jointBox.add(this.removeFormatButton);
        detailsBox.add(jointBox);
        jointBox = Box.createHorizontalBox();
        label = new JLabel("Column Format:");
        this.formatmodel = new FormatTableModel();
        this.formatTable = new JTable(this.formatmodel);
        this.formatmodel.addTableModelListener(this.fmtlistener);
        JTable hdrTable = this.formatTable.getTableHeader().getTable();
        this.formatTable.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
        JScrollPane fsp = new JScrollPane(this.formatTable);
        fsp.setPreferredSize(new Dimension(200, 100));
        jointBox.add(label);
        jointBox.add(fsp);
        detailsBox.add(jointBox);
        jointBox = Box.createHorizontalBox();
        label = new JLabel("Field Delimiter:");
        this.fieldDelimiter = new JTextField("\\t");
        this.fieldDelimiter.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent ev) {
                int selectedRow = fileselector.getSelectedRow();
                if (selectedRow >= 0) {
                    String fn = (String) sourcemodel.getValueAt(selectedRow, 0);
                    if (fn != null) {
                        fn = fn.trim();
                        if ((fn != null) && (fn.length() > 0)) {
                            updateDetailsFor(fn);
                        }
                    }
                }
            }
        });
        jointBox.add(label);
        jointBox.add(this.fieldDelimiter);
        this.inferButton = new JButton("Infer");
        this.inferButton.setEnabled(false);
        jointBox.add(this.inferButton);
        detailsBox.add(jointBox);
        jointBox = Box.createHorizontalBox();
        label = new JLabel("Record Delimiter:");
        this.recordDelimiter = new JTextField("\\n");
        this.recordDelimiter.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent ev) {
                int selectedRow = fileselector.getSelectedRow();
                if (selectedRow >= 0) {
                    String fn = (String) sourcemodel.getValueAt(selectedRow, 0);
                    if (fn != null) {
                        fn = fn.trim();
                        if ((fn != null) && (fn.length() > 0)) {
                            updateDetailsFor(fn);
                        }
                    }
                }
            }
        });
        jointBox.add(label);
        jointBox.add(this.recordDelimiter);
        detailsBox.add(jointBox);
        detailsBox.add(Box.createVerticalGlue());
        detailsBox.add(Box.createVerticalGlue());
        detailsPanel.add(srcBox);
        detailsPanel.add(detailsBox);
        detailsPanel.add(previewPanel);
        this.addFormatButton.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent ev) {
                String fmt2rep = singleFormatText.getText();
                Integer rep = (Integer) repeatFormatNumber.getValue();
                Vector fmtparts = formatmodel.getFormatParts();
                int selectedCol = formatTable.getSelectedColumn();
                if (selectedCol < 0) {
                    selectedCol = formatTable.getColumnCount() - 1;
                }
                for (int r = 1; r <= rep.intValue(); r++) {
                    fmtparts.insertElementAt(fmt2rep, selectedCol);
                }
                formatmodel.setFormatParts(fmtparts);
                updateFormatTable();
                int selectedRow = fileselector.getSelectedRow();
                if ((selectedRow < sourcemodel.getRowCount()) && (selectedRow >= 0)) {
                    String fn = (String) sourcemodel.getValueAt(selectedRow, 0);
                    fn = fn.trim();
                    if (fn != null) {
                        fn = fn.trim();
                        if ((fn != null) && (fn.length() > 0)) {
                            updateDetailsFor(fn);
                        }
                    }
                }
            }
        });
        this.removeFormatButton.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent ev) {
                int selectedCol = formatTable.getSelectedColumn();
                if (selectedCol < 0) {
                    return;
                }
                Vector parts = formatmodel.getFormatParts();
                if (parts.size() == 1) {
                    throw new RuntimeException("At least one format column is required.");
                }
                parts.removeElementAt(selectedCol);
                formatmodel.setFormatParts(parts);
                updateFormatTable();
                int selectedRow = fileselector.getSelectedRow();
                if ((selectedRow < sourcemodel.getRowCount()) && (selectedRow >= 0)) {
                    String fn = (String) sourcemodel.getValueAt(selectedRow, 0);
                    fn = fn.trim();
                    if (fn != null) {
                        fn = fn.trim();
                        if ((fn != null) && (fn.length() > 0)) {
                            updateDetailsFor(fn);
                        }
                    }
                }
                System.out.println("The new Column count after remove is " + formatmodel.getColumnCount());
            }
        });
        this.inferButton.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent ev) {
                int row = fileselector.getSelectedRow();
                int col = 0;
                String filename = (String) sourcemodel.getValueAt(0, 0);
                Boolean isURL = (Boolean) sourcemodel.getValueAt(0, 1);
                BufferedReader br = null;
                File file = null;
                DataInputStream in = null;
                if (isURL.booleanValue()) {
                    try {
                        URL url2goto = new URL(filename);
                        in = new DataInputStream(url2goto.openStream());
                        System.out.println("READY TO READ FROM URL:" + url2goto);
                    } catch (Exception err) {
                        throw new RuntimeException("Problem constructing URI for " + filename + ".", err);
                    }
                } else {
                    file = new File(filename);
                    if (!file.exists()) {
                        throw new RuntimeException("The file named '" + filename + "' does not exist.");
                    }
                    FileInputStream fstream = null;
                    try {
                        fstream = new FileInputStream(filename);
                        in = new DataInputStream(fstream);
                    } catch (Exception err) {
                        throw new RuntimeException("Problem creating FileInputStream for " + filename + ".", err);
                    }
                }
                br = new BufferedReader(new InputStreamReader(in));
                JTable hdrTable = formatTable.getTableHeader().getTable();
                try {
                    String strLine;
                    int line = 0;
                    int ignorePreHdrLines = ((Integer) preheaderlines.getValue()).intValue();
                    int ignorePostHdrLines = ((Integer) postheaderlines.getValue()).intValue();
                    int numhdr = 0;
                    boolean hasHeaderLine = false;
                    if (hasHeaderLineBox.isSelected()) {
                        hasHeaderLine = true;
                    }
                    if (hasHeaderLine) {
                        numhdr = 1;
                    }
                    String FD = fieldDelimiter.getText();
                    while ((strLine = br.readLine()) != null) {
                        if (line <= (ignorePreHdrLines + numhdr + ignorePostHdrLines)) {
                            System.out.println(strLine);
                        } else {
                            String[] putative_cols = strLine.split(FD);
                            System.out.println("The number of potential columns is " + putative_cols.length);
                            String FMT = "";
                            while (formatTable.getColumnCount() > putative_cols.length) {
                                TableColumn tcol = formatTable.getColumnModel().getColumn(0);
                                formatTable.removeColumn(tcol);
                            }
                            for (int i = 0; i < putative_cols.length; i++) {
                                String fmt = "";
                                try {
                                    Double dummy = new Double(putative_cols[i]);
                                    fmt = "%f";
                                } catch (Exception err) {
                                    fmt = "%s";
                                }
                                FMT = FMT + fmt;
                                formatTable.setValueAt(fmt, 0, i);
                            }
                            System.out.println("The potential format is " + FMT);
                            formatmodel.setFormat(FMT);
                            break;
                        }
                        line++;
                    }
                    in.close();
                } catch (Exception err) {
                    throw new RuntimeException("Problem reading single line from file.", err);
                }
                for (int j = 0; j < formatTable.getColumnCount(); j++) {
                    hdrTable.getColumnModel().getColumn(j).setHeaderValue("" + (j + 1));
                }
                formatTable.repaint();
            }
        });
        Box topbox = Box.createHorizontalBox();
        topbox.add(detailsPanel);
        Box mainbox = Box.createVerticalBox();
        Box setBox = Box.createHorizontalBox();
        setBox.add(this.editPrefsButton);
        jointBox = Box.createHorizontalBox();
        label = new JLabel("Created On:");
        jointBox.add(label);
        this.createdOnText.setPreferredSize(new Dimension(50, 25));
        jointBox.add(this.createdOnText);
        setBox.add(jointBox);
        jointBox = Box.createHorizontalBox();
        label = new JLabel("Created By:");
        jointBox.add(label);
        this.createdByText.setPreferredSize(new Dimension(50, 25));
        jointBox.add(this.createdByText);
        setBox.add(jointBox);
        setBox.add(this.uploadButton);
        setBox.add(this.repositoryView);
        setBox.add(this.nicknameText);
        setBox.add(this.enabledRadio);
        mainbox.add(setBox);
        jointBox = Box.createHorizontalBox();
        label = new JLabel("Comment:");
        jointBox.add(label);
        jointBox.add(new JScrollPane(this.commentTextArea));
        mainbox.add(jointBox);
        mainbox.add(topbox);
        mainbox.add(previewPanel);
        this.add(mainbox);
        this.addSources.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent ev) {
                int option = chooser.showOpenDialog(null);
                File[] files = null;
                if (option == JFileChooser.APPROVE_OPTION) {
                    files = chooser.getSelectedFiles();
                    if (files.length > 10) {
                        ((DefaultTableModel) sourcemodel).setRowCount(files.length);
                    } else {
                        ((DefaultTableModel) sourcemodel).setRowCount(10);
                    }
                    for (int i = 0; i < files.length; i++) {
                        sourcemodel.setValueAt(files[i].getAbsolutePath(), i, 0);
                    }
                }
                if (anyNonEmptySources()) {
                    allowFormatParsing(true);
                } else {
                    allowFormatParsing(false);
                }
            }
        });
        this.preview.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent ev) {
                FlatFileDOM[] filespecs = new FlatFileDOM[map.size()];
                int k = 0;
                for (int j = 0; j < sourcemodel.getRowCount(); j++) {
                    String fn = (String) sourcemodel.getValueAt(j, 0);
                    if (map.containsKey(fn)) {
                        filespecs[k] = (FlatFileDOM) map.get(fn);
                        k++;
                    }
                }
                Vector hdrs = null;
                Vector types = null;
                for (int j = 0; j < filespecs.length; j++) {
                    DataSetReader rdr = new DataSetReader(filespecs[j]);
                    int rc = rdr.determineRowCount();
                    filespecs[j].setRowCount(rc);
                    if (j == 0) {
                        hdrs = rdr.getHeaders();
                        types = rdr.getTypes();
                    }
                    System.out.println("The number of rows is=" + rc);
                }
                System.out.println("Creating flatfileset");
                FlatFileSet dataset = new FlatFileSet(filespecs);
                System.out.println("Finished sorting!!!");
                for (int j = 0; j < hdrs.size(); j++) {
                    dataset.addColumn((String) hdrs.get(j), (Class) types.get(j));
                }
                System.out.println("Number of headers is=" + hdrs.size());
                System.out.println("The dataset rc is " + dataset.getRowCount());
                System.out.println("The dataset cc is " + dataset.getColumnCount());
                previewPanel.setDataSet(dataset);
                previewPanel.setVerticalScrollIntermittant(true);
                previewPanel.setHorizontalScrollIntermittant(true);
                previewPanel.setEditable(false);
                if (anyNonEmptySources()) {
                    allowFormatParsing(true);
                } else {
                    allowFormatParsing(false);
                }
            }
        });
        allowFormatParsing(false);
        this.formatTable.repaint();
    }
} </s>
<s>class temp {    public static void loadConfig(URL urlFile) throws CacheException {
        Document document;
        try {
            document = Utilities.getDocument(urlFile.openStream());
        } catch (IOException e) {
            throw new CacheException("Could not open '" + urlFile.getFile() + "'", e);
        } catch (JAnalyticsException e) {
            throw new CacheException("Could not open '" + urlFile.getFile() + "'", e);
        }
        Element element = (Element) document.getElementsByTagName(DOCUMENT_CACHE_ELEMENT_NAME).item(0);
        if (element != null) {
            String className = element.getAttribute(CLASSNAME_ATTRIBUTE_NAME);
            if (className != null) {
                Properties config = new Properties();
                NodeList nodes = element.getElementsByTagName(PARAM_ELEMENT_NAME);
                if (nodes != null) {
                    for (int i = 0, count = nodes.getLength(); i < count; i++) {
                        Node node = nodes.item(i);
                        if (node instanceof Element) {
                            Element n = (Element) node;
                            String name = n.getAttribute(NAME_ATTRIBUTE_NAME);
                            String value = n.getAttribute(VALUE_ATTRIBUTE_NAME);
                            config.put(name, value);
                        }
                    }
                }
                loadConfig(className, config);
            }
        }
    }
} </s>
<s>class temp {    private void openGSM() {
        try {
            GsmCellLocation gcl = (GsmCellLocation) tm.getCellLocation();
            int cid = gcl.getCid();
            int lac = gcl.getLac();
            int mcc = Integer.valueOf(tm.getNetworkOperator().substring(0, 3));
            int mnc = Integer.valueOf(tm.getNetworkOperator().substring(3, 5));
            JSONObject holder = new JSONObject();
            holder.put("version", "1.1.0");
            holder.put("host", "maps.google.com");
            holder.put("request_address", true);
            JSONArray array = new JSONArray();
            JSONObject data = new JSONObject();
            data.put("cell_id", cid);
            data.put("location_area_code", lac);
            data.put("mobile_country_code", mcc);
            data.put("mobile_network_code", mnc);
            array.put(data);
            holder.put("cell_towers", array);
            DefaultHttpClient client = new DefaultHttpClient();
            HttpPost post = new HttpPost("http://www.google.com/loc/json");
            StringEntity se = new StringEntity(holder.toString());
            post.setEntity(se);
            HttpResponse resp = client.execute(post);
            HttpEntity entity = resp.getEntity();
            BufferedReader br = new BufferedReader(new InputStreamReader(entity.getContent()));
            StringBuffer sb = new StringBuffer();
            String result = br.readLine();
            while (result != null) {
                sb.append(result);
                result = br.readLine();
            }
            mLat = Double.parseDouble(sb.toString().split(":")[2].split(",")[0]);
            mLon = Double.parseDouble(sb.toString().split(":")[3].split(",")[0]);
        } catch (Exception e) {
        }
        returnGeoLatLon();
    }
} </s>
<s>class temp {    public void connect() throws IOException {
        if (log.isDebugEnabled()) log.debug("Connecting to: " + HOST);
        ftpClient.connect(HOST);
        if (log.isDebugEnabled()) log.debug("\tReply: " + ftpClient.getReplyString());
        if (log.isDebugEnabled()) log.debug("Login as anonymous");
        ftpClient.login("anonymous", "");
        if (log.isDebugEnabled()) log.debug("\tReply: " + ftpClient.getReplyString());
        folder = INTACT_FOLDER;
    }
} </s>
<s>class temp {    public APIResponse delete(String id) throws Exception {
        APIResponse response = new APIResponse();
        connection = (HttpURLConnection) new URL(url + "/api/record/delete/" + id).openConnection();
        connection.setRequestMethod("DELETE");
        connection.setConnectTimeout(TIMEOUT);
        connection.connect();
        if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {
            response.setDone(true);
            response.setMessage("Record Deleted!");
        } else {
            response.setDone(false);
            response.setMessage("Delete Record Error Code: Http (" + connection.getResponseCode() + ")");
        }
        connection.disconnect();
        return response;
    }
} </s>
<s>class temp {    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
        in.defaultReadObject();
        OutputStream output = getOutputStream();
        if (cachedContent != null) {
            output.write(cachedContent);
        } else {
            FileInputStream input = new FileInputStream(dfosFile);
            IOUtils.copy(input, output);
            dfosFile.delete();
            dfosFile = null;
        }
        output.close();
        cachedContent = null;
    }
} </s>
<s>class temp {    public static String getDeclaredXMLEncoding(URL url) throws IOException {
        InputStream stream = url.openStream();
        BufferedReader buffReader = new BufferedReader(new InputStreamReader(stream));
        String firstLine = buffReader.readLine();
        if (firstLine == null) {
            return SYSTEM_ENCODING;
        }
        int piStart = firstLine.indexOf("<?xml version=\"1.0\"");
        if (piStart != -1) {
            int attributeStart = firstLine.indexOf("encoding=\"");
            if (attributeStart >= 0) {
                int nextQuote = firstLine.indexOf('"', attributeStart + 10);
                if (nextQuote >= 0) {
                    String encoding = firstLine.substring(attributeStart + 10, nextQuote);
                    return encoding.trim();
                }
            }
        }
        stream.close();
        return SYSTEM_ENCODING;
    }
} </s>
<s>class temp {    public void testGetContentInputStream() {
        URL url;
        try {
            url = new URL("http://www.wurzer.org/" + "Homepage/Publikationen/Eintrage/2009/10/7_Wissen_dynamisch_organisieren_files/" + "KnowTech%202009%20-%20Wissen%20dynamisch%20organisieren.pdf");
            InputStream in = url.openStream();
            Content c = provider.getContent(in);
            assertNotNull(c);
            assertTrue(!c.getFulltext().isEmpty());
            assertTrue(c.getModificationDate() < System.currentTimeMillis());
            assertTrue(c.getAttributes().size() > 0);
            assertEquals("KnowTech 2009 - Wissen dynamisch organisieren", c.getAttributeByName("Title").getValue());
            assertEquals("Joerg Wurzer", c.getAttributeByName("Author").getValue());
            assertEquals("Pages", c.getAttributeByName("Creator").getValue());
            assertNull(c.getAttributeByName("Keywords"));
            assertTrue(c.getFulltext().startsWith("Wissen dynamisch organisieren"));
            assertTrue(c.getAttributeByName("Author").isKey());
            assertTrue(!c.getAttributeByName("Producer").isKey());
        } catch (MalformedURLException e) {
            fail("Malformed url - " + e.getMessage());
        } catch (IOException e) {
            fail("Couldn't read file - " + e.getMessage());
        }
    }
} </s>
<s>class temp {    private String sendMessage(HttpURLConnection connection, String reqMessage) throws IOException {
        if (msgLog.isTraceEnabled()) msgLog.trace("Outgoing SOAPMessage\n" + reqMessage);
        BufferedOutputStream out = new BufferedOutputStream(connection.getOutputStream());
        out.write(reqMessage.getBytes("UTF-8"));
        out.close();
        InputStream inputStream = null;
        if (connection.getResponseCode() < 400) inputStream = connection.getInputStream(); else inputStream = connection.getErrorStream();
        ByteArrayOutputStream baos = new ByteArrayOutputStream(1024);
        IOUtils.copyStream(baos, inputStream);
        inputStream.close();
        String response = new String(baos.toByteArray(), "UTF-8");
        if (msgLog.isTraceEnabled()) msgLog.trace("Incoming Response SOAPMessage\n" + response);
        return response;
    }
} </s>
<s>class temp {    private void upgradeSchema() {
        Statement stmt = null;
        boolean updatedSchema = false;
        try {
            int i = getSchema();
            if (i < SCHEMA_VERSION) {
                conn.setAutoCommit(false);
                stmt = conn.createStatement();
                updatedSchema = true;
            }
            while (i < SCHEMA_VERSION) {
                String qry;
                switch(i) {
                    case 0:
                        qry = "CREATE TABLE settings (var VARCHAR(32) NOT NULL, val LONG VARCHAR)";
                        stmt.executeUpdate(qry);
                        qry = "INSERT INTO settings (var, val) VALUES ('schema', '1')";
                        stmt.executeUpdate(qry);
                        qry = "ALTER TABLE recordings ADD COLUMN exe LONG VARCHAR NOT NULL DEFAULT '%UNKNOWN%'";
                        stmt.executeUpdate(qry);
                        qry = "CREATE TABLE files (id INT NOT NULL, file LONG VARCHAR NOT NULL, finished INT NOT NULL)";
                        stmt.executeUpdate(qry);
                        updateFilesTable();
                        break;
                    case 1:
                        qry = "ALTER TABLE files ADD COLUMN type VARCHAR(32) NOT NULL DEFAULT '%UNKNOWN%'";
                        stmt.executeUpdate(qry);
                        qry = "UPDATE settings SET val = '2' WHERE var = 'schema'";
                        stmt.executeUpdate(qry);
                        break;
                    case 2:
                        qry = "CREATE UNIQUE INDEX IF NOT EXISTS recordings_history ON recordings(id,type)";
                        stmt.executeUpdate(qry);
                        qry = "CREATE INDEX IF NOT EXISTS files_history ON files(id,type)";
                        stmt.executeUpdate(qry);
                        qry = "UPDATE settings SET val = '3' WHERE var = 'schema'";
                        stmt.executeUpdate(qry);
                        break;
                    case 3:
                        qry = "CREATE TABLE log (id INTEGER PRIMARY KEY, context VARCHAR(16) NOT NULL, level VARCHAR(16) NOT NULL, time LONG INT NOT NULL, msg LONG VARCHAR NOT NULL, parent INT)";
                        stmt.executeUpdate(qry);
                        qry = "UPDATE settings SET val = '4' WHERE var = 'schema'";
                        stmt.executeUpdate(qry);
                        break;
                    case 4:
                        qry = "CREATE UNIQUE INDEX IF NOT EXISTS log_id ON log(id)";
                        stmt.executeUpdate(qry);
                        qry = "CREATE INDEX IF NOT EXISTS log_parent ON log(parent)";
                        stmt.executeUpdate(qry);
                        qry = "UPDATE settings SET val = '5' WHERE var = 'schema'";
                        stmt.executeUpdate(qry);
                        break;
                    case 5:
                        qry = "CREATE TABLE tmp_settings (var varchar(32) NOT NULL PRIMARY KEY, val varchar(128) NOT NULL)";
                        stmt.executeUpdate(qry);
                        qry = "INSERT INTO tmp_settings SELECT var,val FROM settings";
                        stmt.executeUpdate(qry);
                        qry = "DROP TABLE settings";
                        stmt.executeUpdate(qry);
                        qry = "ALTER TABLE tmp_settings RENAME TO settings";
                        stmt.executeUpdate(qry);
                        qry = "UPDATE settings SET val = '6' WHERE var = 'schema'";
                        stmt.executeUpdate(qry);
                        break;
                    case 6:
                        qry = "DROP TABLE log";
                        stmt.executeUpdate(qry);
                        qry = "CREATE TABLE log (id INTEGER PRIMARY KEY, mediaid varchar(32) NOT NULL, taskid varchar(32) NOT NULL, msg LONG VARCHAR NOT NULL)";
                        stmt.executeUpdate(qry);
                        qry = "UPDATE settings SET val = '7' WHERE var = 'schema'";
                        stmt.executeUpdate(qry);
                        break;
                    case 7:
                        qry = "CREATE TABLE client (host varchar(255) PRIMARY KEY, conf LONG VARCHAR)";
                        stmt.executeUpdate(qry);
                        qry = "UPDATE settings SET val = '8' WHERE var = 'schema'";
                        stmt.executeUpdate(qry);
                        break;
                    case 8:
                        qry = "DROP INDEX files_history";
                        stmt.executeUpdate(qry);
                        qry = "DROP INDEX recordings_history";
                        stmt.executeUpdate(qry);
                        qry = "DROP TABLE files";
                        stmt.executeUpdate(qry);
                        qry = "CREATE TABLE new_rec (id INT NOT NULL, type VARCHAR(32) NOT NULL, start INT NOT NULL DEFAULT 0, finish INT NOT NULL DEFAULT 0, state INT NOT NULL DEFAULT 1, PRIMARY KEY(id, type))";
                        stmt.executeUpdate(qry);
                        qry = "INSERT INTO new_rec SELECT id, type, 0, 0, 1 FROM recordings";
                        stmt.executeUpdate(qry);
                        qry = "DROP TABLE recordings";
                        stmt.executeUpdate(qry);
                        qry = "CREATE TABLE recordings (id INT NOT NULL, type VARCHAR(32) NOT NULL, start INT NOT NULL DEFAULT 0, finish INT NOT NULL DEFAULT 0, state INT NOT NULL DEFAULT 1, PRIMARY KEY(id, type))";
                        stmt.executeUpdate(qry);
                        qry = "INSERT INTO recordings SELECT * FROM new_rec";
                        stmt.executeUpdate(qry);
                        qry = "DROP TABLE new_rec";
                        stmt.executeUpdate(qry);
                        qry = "CREATE UNIQUE INDEX recordings_history on recordings(id,type)";
                        stmt.executeUpdate(qry);
                        qry = "UPDATE settings SET val = '9' WHERE var = 'schema'";
                        stmt.executeUpdate(qry);
                        break;
                    case 9:
                        qry = "ALTER TABLE recordings ADD COLUMN host VARCHAR(255) NOT NULL DEFAULT ''";
                        stmt.executeUpdate(qry);
                        qry = "UPDATE settings SET val = '10' WHERE var = 'schema'";
                        stmt.executeUpdate(qry);
                        break;
                    case 10:
                        qry = "ALTER TABLE recordings ADD COLUMN airing VARCHAR(64) NOT NULL DEFAULT '0'";
                        stmt.executeUpdate(qry);
                        qry = "UPDATE settings SET val = '11' WHERE var = 'schema'";
                        stmt.executeUpdate(qry);
                        break;
                    case 11:
                        PreparedStatement pstmt = null;
                        try {
                            MessageDigest msg = MessageDigest.getInstance("MD5");
                            msg.update("sjqadmin".getBytes());
                            String pwd = new String(msg.digest());
                            pstmt = conn.prepareStatement("REPLACE INTO settings (var, val) VALUES ('password', ?)");
                            pstmt.setString(1, pwd);
                            pstmt.executeUpdate();
                        } catch (NoSuchAlgorithmException e) {
                            throw new SQLException(e);
                        } finally {
                            if (pstmt != null) pstmt.close();
                        }
                        stmt.executeUpdate("UPDATE settings SET val = '12' WHERE var = 'schema'");
                        break;
                    case 12:
                        qry = "CREATE INDEX logs_for_tasks ON log(mediaid, taskid)";
                        stmt.executeUpdate(qry);
                        qry = "UPDATE settings SET val = '13' WHERE var = 'schema'";
                        stmt.executeUpdate(qry);
                        break;
                    case 13:
                        qry = "DELETE FROM log";
                        stmt.executeUpdate(qry);
                        qry = "UPDATE settings SET val = '14' WHERE var = 'schema'";
                        stmt.executeUpdate(qry);
                        break;
                    case 14:
                        qry = "DROP TABLE log";
                        stmt.executeUpdate(qry);
                        qry = "CREATE TABLE log (id INTEGER PRIMARY KEY, mediaid varchar(32) NOT NULL, taskid varchar(32) NOT NULL, msg LONG VARCHAR NOT NULL, ts INTEGER NOT NULL DEFAULT 0)";
                        stmt.executeUpdate(qry);
                        qry = "CREATE INDEX logs_by_date ON log(ts)";
                        stmt.executeUpdate(qry);
                        qry = "CREATE INDEX IF NOT EXISTS logs_for_tasks ON log(mediaid, taskid)";
                        stmt.executeUpdate(qry);
                        qry = "UPDATE settings SET val = '15' WHERE var = 'schema'";
                        stmt.executeUpdate(qry);
                        break;
                    case 15:
                        qry = "DELETE FROM log WHERE mediaid = 0 AND taskid = '0'";
                        stmt.executeUpdate(qry);
                        qry = "UPDATE settings SET val = '16' WHERE var = 'schema'";
                        stmt.executeUpdate(qry);
                        break;
                    case 16:
                        qry = "CREATE TEMPORARY TABLE rec_tmp (objtype varchar(64) NOT NULL DEFAULT 'media', id INT NOT NULL, type VARCHAR(32) NOT NULL, start INT NOT NULL DEFAULT 0, finish INT NOT NULL DEFAULT 0, state INT NOT NULL DEFAULT 1, host VARCHAR(255) NOT NULL DEFAULT '', airing VARCHAR(64) NOT NULL DEFAULT '0', PRIMARY KEY (objtype, id, type))";
                        stmt.executeUpdate(qry);
                        qry = "INSERT INTO rec_tmp SELECT 'media', id, type, start, finish, state, host, airing FROM recordings";
                        stmt.executeUpdate(qry);
                        qry = "DROP TABLE recordings";
                        stmt.executeUpdate(qry);
                        qry = "CREATE TABLE recordings (objtype varchar(64) NOT NULL DEFAULT 'media', id INT NOT NULL, type VARCHAR(32) NOT NULL, start INT NOT NULL DEFAULT 0, finish INT NOT NULL DEFAULT 0, state INT NOT NULL DEFAULT 1, host VARCHAR(255) NOT NULL DEFAULT '', airing VARCHAR(64) NOT NULL DEFAULT '0', PRIMARY KEY (objtype, id, type))";
                        stmt.executeUpdate(qry);
                        qry = "INSERT INTO recordings SELECT * FROM rec_tmp";
                        stmt.executeUpdate(qry);
                        qry = "DROP TABLE rec_tmp";
                        stmt.executeUpdate(qry);
                        qry = "ALTER TABLE log ADD COLUMN objtype varchar(64) NOT NULL DEFAULT 'media'";
                        stmt.executeUpdate(qry);
                        qry = "UPDATE settings SET val = '17' WHERE var = 'schema'";
                        stmt.executeUpdate(qry);
                        break;
                    case 17:
                        qry = "DROP INDEX logs_for_tasks";
                        stmt.executeUpdate(qry);
                        qry = "CREATE INDEX logs_for_tasks ON log(mediaid, taskid, objtype)";
                        stmt.executeUpdate(qry);
                        qry = "UPDATE settings SET val = '18' WHERE var = 'schema'";
                        stmt.executeUpdate(qry);
                        break;
                }
                i++;
            }
            if (updatedSchema) conn.commit();
        } catch (SQLException e) {
            try {
                if (updatedSchema) conn.rollback();
            } catch (SQLException x) {
                LOG.fatal("SQL error", x);
            }
            LOG.fatal("SQL error", e);
            throw new RuntimeException(e);
        } finally {
            try {
                if (stmt != null) stmt.close();
                if (updatedSchema) conn.setAutoCommit(true);
            } catch (SQLException e) {
                LOG.fatal("SQL error", e);
                throw new RuntimeException(e);
            }
        }
    }
} </s>
<s>class temp {    private void load() throws SQLException {
        Connection conn = null;
        Statement stmt = null;
        try {
            conn = FidoDataSource.getConnection();
            conn.setAutoCommit(false);
            stmt = conn.createStatement();
            ClearData.clearTables(stmt);
            stmt.executeUpdate("insert into Objects (ObjectId, Description) values (100, 'Person')");
            stmt.executeUpdate("insert into Objects (ObjectId, Description) values (101, 'john')");
            stmt.executeUpdate("insert into Objects (ObjectId, Description) values (200, 'Dog')");
            stmt.executeQuery("select setval('objects_objectid_seq', 1000)");
            stmt.executeUpdate("insert into ClassLinkTypes (LinkName, LinkType) values ('hasa', 2)");
            stmt.executeUpdate("insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (100, 'isa', 1)");
            stmt.executeUpdate("insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (101, 'instance', 100)");
            stmt.executeUpdate("insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (200, 'isa', 1)");
            stmt.executeUpdate("insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('LEFT-WALL', '1', 'AV+', 1)");
            stmt.executeUpdate("insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('john', '1', 'S+ | DO-', 1)");
            stmt.executeUpdate("insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('a', '1', 'D+', 1)");
            stmt.executeUpdate("insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('dog', '1', '[D-] & (S+ | DO-)', 200)");
            stmt.executeUpdate("insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('have', '1', 'S- & AV- & DO+', 1)");
            stmt.executeUpdate("insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values " + "                                 ('English', 'third singular', 1, 'have', 'has', TRUE)");
            stmt.executeUpdate("insert into GrammarLinks (LinkName, LinkType) values ('S', 1)");
            stmt.executeUpdate("insert into GrammarLinks (LinkName, LinkType) values ('DO', 3)");
            stmt.executeUpdate("insert into GrammarLinks (LinkName, LinkType) values ('AV', 7)");
            stmt.executeUpdate("insert into GrammarLinks (LinkName, LinkType) values ('D', 10)");
            stmt.executeUpdate("insert into Articles (ArticleName, Dereference) values ('a', 2)");
            stmt.executeUpdate("insert into FrameSlots (SlotName) values ('actor')");
            stmt.executeUpdate("insert into FrameSlots (SlotName) values ('object')");
            stmt.executeUpdate("insert into Verbs (VerbName, Type, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('have', 1, 'actor', '', 'object')");
            stmt.executeQuery("select setval('instructions_instructionid_seq', 1)");
            stmt.executeUpdate("insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) " + "values (3, 'link %actor hasa %object', null, 0, null, null, null)");
            stmt.executeQuery("select setval('transactions_transactionid_seq', 1)");
            stmt.executeUpdate("insert into Transactions (InstructionId, Description) values (2, 'have - link')");
            stmt.executeQuery("select setval('verbtransactions_verbid_seq', 1)");
            stmt.executeUpdate("insert into VerbTransactions (VerbString, MoodType, TransactionId) values ('have', 1, 2)");
            stmt.executeUpdate("insert into VerbConstraints (VerbId, FrameSlot, ObjectId) values (2, 'actor', 1)");
            stmt.executeUpdate("insert into VerbConstraints (VerbId, FrameSlot, ObjectId) values (2, 'object', 1)");
            stmt.executeUpdate("insert into ProperNouns (Noun, SenseNumber, ObjectId) values ('john', 1, 101)");
            stmt.executeUpdate("update SystemProperties set value = 'Tutorial 1 Data' where name = 'DB Data Version'");
            conn.commit();
        } catch (SQLException e) {
            if (conn != null) conn.rollback();
            throw e;
        } finally {
            if (stmt != null) stmt.close();
            if (conn != null) conn.close();
        }
    }
} </s>
<s>class temp {    public static synchronized String getSequenceNumber(String SequenceName) {
        String result = "0";
        Connection conn = null;
        Statement ps = null;
        ResultSet rs = null;
        try {
            conn = TPCW_Database.getConnection();
            conn.setAutoCommit(false);
            String sql = "select num from sequence where name='" + SequenceName + "'";
            ps = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);
            rs = ps.executeQuery(sql);
            long num = 0;
            while (rs.next()) {
                num = rs.getLong(1);
                result = new Long(num).toString();
            }
            num++;
            sql = "update sequence set num=" + num + " where name='" + SequenceName + "'";
            int res = ps.executeUpdate(sql);
            if (res == 1) {
                conn.commit();
            } else conn.rollback();
        } catch (Exception e) {
            System.out.println("Error Happens when trying to obtain the senquence number");
            e.printStackTrace();
        } finally {
            try {
                if (conn != null) conn.close();
                if (rs != null) rs.close();
                if (ps != null) ps.close();
            } catch (SQLException se) {
                se.printStackTrace();
            }
        }
        return result;
    }
} </s>
<s>class temp {    public HttpURLConnection execute(S3Bucket pBucket, S3Object pObject, S3OperationParameters pOpParams) throws S3Exception {
        S3OperationParameters opParams = pOpParams;
        if (opParams == null) opParams = new S3OperationParameters();
        HttpURLConnection result = null;
        URL url = getURL(pBucket, pObject, opParams.getQueryParameters());
        mLogger.log(Level.FINEST, "URL: " + url.toString());
        opParams.addDateHeader();
        switch(mStyle) {
            case Path:
                opParams.addHostHeader(BASE_DOMAIN);
                break;
            case Subdomain:
                if (pBucket == null) opParams.addHostHeader(BASE_DOMAIN); else opParams.addHostHeader(pBucket.getName() + "." + BASE_DOMAIN);
                break;
            case VirtualHost:
                if (pBucket == null) opParams.addHostHeader(BASE_DOMAIN); else opParams.addHostHeader(pBucket.getName());
                break;
        }
        if (opParams.isSign()) {
            StringBuilder sb = new StringBuilder();
            sb.append(opParams.getVerb().toString());
            sb.append(NEWLINE);
            sb.append(posHeader(MD5, opParams.getRequestHeaders()));
            sb.append(posHeader(TYPE, opParams.getRequestHeaders()));
            if (opParams.getQueryParameters().has(EXPIRES)) {
                sb.append(opParams.getQueryParameters().get(EXPIRES).getValue());
                sb.append(NEWLINE);
            } else {
                sb.append(posHeader(DATE, opParams.getRequestHeaders()));
            }
            sb.append(canonicalizeAmazonHeaders(opParams.getRequestHeaders()));
            try {
                sb.append("/");
                if (pBucket != null) {
                    sb.append(URLEncoder.encode(pBucket.getName(), URL_ENCODING));
                    sb.append("/");
                    if (pObject != null) {
                        sb.append(URLEncoder.encode(pObject.getKey(), URL_ENCODING));
                    }
                }
                sb.append(opParams.getQueryParameters().getAmazonSubresources().toQueryString());
                String signThis = sb.toString();
                mLogger.log(Level.FINEST, "String being signed: " + signThis);
                String sig = encode(mCredential.getMSecretAccessKey(), signThis, false);
                sb = new StringBuilder();
                sb.append("AWS ");
                sb.append(mCredential.getMAccessKeyID());
                sb.append(":");
                sb.append(sig);
                opParams.addAuthorizationHeader(sb.toString());
            } catch (UnsupportedEncodingException e) {
                throw new S3Exception("URL encoding not supported: " + URL_ENCODING, e);
            }
        }
        try {
            killHostVerifier();
            URLConnection urlConn = url.openConnection();
            if (!(urlConn instanceof HttpURLConnection)) throw new S3Exception("URLConnection is not instance of HttpURLConnection!");
            result = (HttpURLConnection) urlConn;
            result.setRequestMethod(opParams.getVerb().toString());
            mLogger.log(Level.FINEST, "HTTP Operation: " + opParams.getVerb().toString());
            if (opParams.getVerb() == HttpVerb.PUT) {
                result.setDoOutput(true);
            }
            result.setRequestProperty(TYPE, "");
            for (AWSParameter param : opParams.getRequestHeaders()) {
                result.setRequestProperty(param.getName(), param.getValue());
                mLogger.log(Level.FINEST, "Header " + param.getName() + ": " + param.getValue());
            }
        } catch (IOException e) {
            throw new S3Exception("Problem opening connection to URL: " + url.toString(), e);
        }
        return result;
    }
} </s>
<s>class temp {    public static void main(String[] args) {
        StringBuffer htmlPage;
        htmlPage = new StringBuffer();
        double min = 99999.99;
        double max = 0;
        double value = 0;
        try {
            URL url = new URL("http://search.ebay.com/" + args[0]);
            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));
            String line;
            while ((line = in.readLine()) != null) {
                htmlPage.append(line);
                htmlPage.append("\n");
            }
        } catch (Exception ex) {
            ex.printStackTrace();
        }
        Pattern p = Pattern.compile("\\$([\\d\\.]+)", Pattern.CASE_INSENSITIVE);
        Matcher m = p.matcher(htmlPage);
        while (m.find()) {
            if (m.start(0) < m.end(0)) {
                value = Double.parseDouble(m.group(1));
                if (value < min) {
                    min = value;
                }
                if (value > max) {
                    max = value;
                }
            }
        }
        if (min == 99999.99) {
            min = 0;
        }
        System.out.println(args[0] + "," + min + "," + max);
        System.exit(0);
    }
} </s>
<s>class temp {    public static String MD5(String source) {
        logger.info(source);
        String result = null;
        try {
            MessageDigest digest = MessageDigest.getInstance("MD5");
            digest.update(source.getBytes());
            byte[] bytes = digest.digest();
            result = EncodeUtils.hexEncode(bytes);
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        logger.info(result);
        return result;
    }
} </s>
<s>class temp {    public static String SHA256(String source) {
        logger.info(source);
        String result = null;
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            digest.update(source.getBytes());
            byte[] bytes = digest.digest();
            result = EncodeUtils.hexEncode(bytes);
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        logger.info(result);
        return result;
    }
} </s>
<s>class temp {    public static String SHA(String source) {
        logger.info(source);
        String result = null;
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA");
            digest.update(source.getBytes());
            byte[] bytes = digest.digest();
            result = EncodeUtils.hexEncode(bytes);
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        logger.info(result);
        return result;
    }
} </s>
<s>class temp {    public static void readProperties() throws IOException {
        URL url1 = cl.getResource("conf/soapuddi.config");
        Properties props = new Properties();
        if (url1 == null) throw new IOException("soapuddi.config not found");
        props.load(url1.openStream());
        className = props.getProperty("Class");
        url = props.getProperty("URL");
        user = props.getProperty("user");
        password = props.getProperty("passwd");
        operatorName = props.getProperty("operator");
        authorisedName = props.getProperty("authorisedName");
        isUpdated = true;
    }
} </s>
<s>class temp {    private void download(String groupId, String artifactId, String version, String type) throws ClientProtocolException, IOException {
        String finalName = artifactId + "-" + version;
        File file = new File(deployables, groupId + "/" + artifactId + "/" + version + "/" + finalName + "." + type);
        if (file.exists()) {
            log.warn("Won't download {} found at {}", finalName, file.getAbsolutePath());
            return;
        }
        String url = repository + groupId + "/" + artifactId + "/" + version + "/" + finalName + "." + type;
        HttpGet get = new HttpGet(url);
        HttpResponse response = httpclient.execute(get);
        if (response.getStatusLine().getStatusCode() == 200) writeContent(get, response.getEntity(), file); else throw new RuntimeException("Failed to download " + url + " due to error " + response.getStatusLine());
    }
} </s>
<s>class temp {    public void convert(File src, File dest) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(src));
        DcmParser p = pfact.newDcmParser(in);
        Dataset ds = fact.newDataset();
        p.setDcmHandler(ds.getDcmHandler());
        try {
            FileFormat format = p.detectFileFormat();
            if (format != FileFormat.ACRNEMA_STREAM) {
                System.out.println("\n" + src + ": not an ACRNEMA stream!");
                return;
            }
            p.parseDcmFile(format, Tags.PixelData);
            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {
                System.out.println("\n" + src + ": contains UIDs!" + " => probable already DICOM - do not convert");
                return;
            }
            boolean hasPixelData = p.getReadTag() == Tags.PixelData;
            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;
            int pxlen = p.getReadLength();
            if (hasPixelData) {
                if (inflate) {
                    ds.putUS(Tags.BitsAllocated, 16);
                    pxlen = pxlen * 4 / 3;
                }
                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {
                    System.out.println("\n" + src + ": mismatch pixel data length!" + " => do not convert");
                    return;
                }
            }
            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));
            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));
            ds.putUI(Tags.SOPInstanceUID, uid(instUID));
            ds.putUI(Tags.SOPClassUID, classUID);
            if (!ds.contains(Tags.NumberOfSamples)) {
                ds.putUS(Tags.NumberOfSamples, 1);
            }
            if (!ds.contains(Tags.PhotometricInterpretation)) {
                ds.putCS(Tags.PhotometricInterpretation, "MONOCHROME2");
            }
            if (fmi) {
                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));
            }
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
            try {
            } finally {
                ds.writeFile(out, encodeParam());
                if (hasPixelData) {
                    if (!skipGroupLen) {
                        out.write(PXDATA_GROUPLEN);
                        int grlen = pxlen + 8;
                        out.write((byte) grlen);
                        out.write((byte) (grlen >> 8));
                        out.write((byte) (grlen >> 16));
                        out.write((byte) (grlen >> 24));
                    }
                    out.write(PXDATA_TAG);
                    out.write((byte) pxlen);
                    out.write((byte) (pxlen >> 8));
                    out.write((byte) (pxlen >> 16));
                    out.write((byte) (pxlen >> 24));
                }
                if (inflate) {
                    int b2, b3;
                    for (; pxlen > 0; pxlen -= 3) {
                        out.write(in.read());
                        b2 = in.read();
                        b3 = in.read();
                        out.write(b2 & 0x0f);
                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));
                        out.write(b3 >> 4);
                    }
                } else {
                    for (; pxlen > 0; --pxlen) {
                        out.write(in.read());
                    }
                }
                out.close();
            }
            System.out.print('.');
        } finally {
            in.close();
        }
    }
} </s>
<s>class temp {    private void initFtp() throws IOException {
        ftpClient.setConnectTimeout(5000);
        ftpClient.connect(ftpHost);
        ftpClient.login(userName, password);
        if (workingDir != null) {
            ftpClient.changeWorkingDirectory(workingDir);
        }
        logger.info("Connection established.");
    }
} </s>
<s>class temp {    private void downloadFiles() {
        SwingWorker<Double, RaphPhotoGalleryPhoto> downloadFilesWorker = new SwingWorker<Double, RaphPhotoGalleryPhoto>() {

            Date startDownloadDate;

            @Override
            public Double doInBackground() {
                startDownloadDate = new Date();
                refreshSpeed = 0;
                lastDate = null;
                try {
                    int totalSizeRead = 0;
                    int totalNumberRead = 0;
                    for (RaphPhotoGalleryPhoto photo : photoList) {
                        URL url = new URL(getCodeBase().toString() + photo.getUrl());
                        HttpURLConnection connection = (HttpURLConnection) url.openConnection();
                        DataInputStream dis = new DataInputStream(connection.getInputStream());
                        FileOutputStream fos = new FileOutputStream(destinationDirectory.toString() + "/" + photo.getFileName());
                        byte[] b = new byte[65536];
                        int sizeRead;
                        photo.setProcessedSize(0);
                        totalNumberRead++;
                        while ((sizeRead = dis.read(b)) > -1) {
                            fos.write(b, 0, sizeRead);
                            totalSizeRead += sizeRead;
                            photo.addToProcessedSize(sizeRead);
                            photo.setTotalProcessedSize(totalSizeRead);
                            photo.setTotalProcessedNumber(totalNumberRead);
                            publish(photo);
                            try {
                            } catch (Exception ignore) {
                            }
                        }
                        fos.close();
                    }
                } catch (MalformedURLException e1) {
                    System.err.println("MalformedURLException: " + e1);
                } catch (IOException e2) {
                    System.err.println("IOException: " + e2);
                }
                long totalDiffTime = (new Date()).getTime() - startDownloadDate.getTime();
                double totalSpeed = photoListTotalSize / (totalDiffTime / 1000);
                return new Double(totalSpeed);
            }

            @Override
            protected void process(List<RaphPhotoGalleryPhoto> list) {
                RaphPhotoGalleryPhoto photo = list.get(list.size() - 1);
                progressBarTotal.setMaximum(photoListTotalSize);
                progressBarTotal.setValue(photo.getTotalProcessedSize());
                setProgressBarTotalLabels(photo.getTotalProcessedNumber(), photoList.size(), photoListTotalSize - photo.getTotalProcessedSize());
                progressBarCurrent.setMaximum(photo.getFileSize());
                progressBarCurrent.setValue(photo.getProcessedSize());
                progressBarCurrentLabel.setText(photo.getFileName());
                long diffTime = 0;
                if (lastDate == null) lastDate = new Date();
                diffTime = (new Date()).getTime() - lastDate.getTime();
                if (diffTime > 1000) {
                    double currentSpeed = (photo.getTotalProcessedSize() - lastTotalSize) / (diffTime / 1000.0);
                    if (currentSpeed > 0) lastSpeed.add(new Double(currentSpeed));
                    if (lastSpeed.size() == 10) lastSpeed.removeFirst();
                    double speed = 0;
                    for (Double d : lastSpeed) {
                        speed += d.doubleValue();
                    }
                    speed = Math.round(speed / lastSpeed.size());
                    if (refreshSpeed == 0) {
                        long totalDiffTime = (new Date()).getTime() - startDownloadDate.getTime();
                        double totalSpeed = (photo.getTotalProcessedSize()) / (totalDiffTime / 1000.0);
                        remainingTime = (photoListTotalSize - photo.getTotalProcessedSize()) / totalSpeed;
                        if (remainingTime < 8) refreshSpeed = 0; else refreshSpeed = 3;
                    } else {
                        refreshSpeed--;
                        remainingTime -= diffTime / 1000.0;
                    }
                    speedLabel.setText(String.format("%.0f", speed / 1024) + " " + getParameter("i18n_speedUnit") + " :  " + String.format("%.0f", remainingTime) + " s");
                    lastDate = new Date();
                    lastTotalSize = photo.getTotalProcessedSize();
                }
            }

            @Override
            protected void done() {
                try {
                    speedLabel.setText(String.format("%.0f", get().doubleValue() / 1024) + " " + getParameter("i18n_speedUnit"));
                    downloadButton.setText(getParameter("i18n_finished"));
                    downloadState = 2;
                } catch (Exception ignore) {
                }
            }
        };
        downloadFilesWorker.execute();
    }
} </s>
<s>class temp {    public void bubbleSort(int[] arr) {
        boolean swapped = true;
        int j = 0;
        int tmp;
        while (swapped) {
            swapped = false;
            j++;
            for (int i = 0; i < arr.length - j; i++) {
                if (arr[i] > arr[i + 1]) {
                    tmp = arr[i];
                    arr[i] = arr[i + 1];
                    arr[i + 1] = tmp;
                    swapped = true;
                }
            }
        }
    }
} </s>
<s>class temp {    public List<String[]> getCSV(String name) {
        return new ResourceLoader<List<String[]>>(name) {

            @Override
            protected List<String[]> get(URL url) throws Exception {
                CSVReader reader = null;
                try {
                    reader = new CSVReader(new InputStreamReader(url.openStream()));
                    return reader.readAll();
                } finally {
                    IOUtils.closeQuietly(reader);
                }
            }
        }.get();
    }
} </s>
<s>class temp {            @Override
            protected List<String[]> get(URL url) throws Exception {
                CSVReader reader = null;
                try {
                    reader = new CSVReader(new InputStreamReader(url.openStream()));
                    return reader.readAll();
                } finally {
                    IOUtils.closeQuietly(reader);
                }
            }
} </s>
<s>class temp {    public void convert(File src, File dest) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(src));
        DcmParser p = pfact.newDcmParser(in);
        Dataset ds = fact.newDataset();
        p.setDcmHandler(ds.getDcmHandler());
        try {
            FileFormat format = p.detectFileFormat();
            if (format != FileFormat.ACRNEMA_STREAM) {
                System.out.println("\n" + src + ": not an ACRNEMA stream!");
                return;
            }
            p.parseDcmFile(format, Tags.PixelData);
            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {
                System.out.println("\n" + src + ": contains UIDs!" + " => probable already DICOM - do not convert");
                return;
            }
            boolean hasPixelData = p.getReadTag() == Tags.PixelData;
            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;
            int pxlen = p.getReadLength();
            if (hasPixelData) {
                if (inflate) {
                    ds.putUS(Tags.BitsAllocated, 16);
                    pxlen = pxlen * 4 / 3;
                }
                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {
                    System.out.println("\n" + src + ": mismatch pixel data length!" + " => do not convert");
                    return;
                }
            }
            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));
            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));
            ds.putUI(Tags.SOPInstanceUID, uid(instUID));
            ds.putUI(Tags.SOPClassUID, classUID);
            if (!ds.contains(Tags.NumberOfSamples)) {
                ds.putUS(Tags.NumberOfSamples, 1);
            }
            if (!ds.contains(Tags.PhotometricInterpretation)) {
                ds.putCS(Tags.PhotometricInterpretation, "MONOCHROME2");
            }
            if (fmi) {
                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));
            }
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
            try {
            } finally {
                ds.writeFile(out, encodeParam());
                if (hasPixelData) {
                    if (!skipGroupLen) {
                        out.write(PXDATA_GROUPLEN);
                        int grlen = pxlen + 8;
                        out.write((byte) grlen);
                        out.write((byte) (grlen >> 8));
                        out.write((byte) (grlen >> 16));
                        out.write((byte) (grlen >> 24));
                    }
                    out.write(PXDATA_TAG);
                    out.write((byte) pxlen);
                    out.write((byte) (pxlen >> 8));
                    out.write((byte) (pxlen >> 16));
                    out.write((byte) (pxlen >> 24));
                }
                if (inflate) {
                    int b2, b3;
                    for (; pxlen > 0; pxlen -= 3) {
                        out.write(in.read());
                        b2 = in.read();
                        b3 = in.read();
                        out.write(b2 & 0x0f);
                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));
                        out.write(b3 >> 4);
                    }
                } else {
                    for (; pxlen > 0; --pxlen) {
                        out.write(in.read());
                    }
                }
                out.close();
            }
            System.out.print('.');
        } finally {
            in.close();
        }
    }
} </s>
<s>class temp {    public static void copy(String srcFileName, String destFileName) throws IOException {
        if (srcFileName == null) {
            throw new IllegalArgumentException("srcFileName is null");
        }
        if (destFileName == null) {
            throw new IllegalArgumentException("destFileName is null");
        }
        FileChannel src = null;
        FileChannel dest = null;
        try {
            src = new FileInputStream(srcFileName).getChannel();
            dest = new FileOutputStream(destFileName).getChannel();
            long n = src.size();
            MappedByteBuffer buf = src.map(FileChannel.MapMode.READ_ONLY, 0, n);
            dest.write(buf);
        } finally {
            if (dest != null) {
                try {
                    dest.close();
                } catch (IOException e1) {
                }
            }
            if (src != null) {
                try {
                    src.close();
                } catch (IOException e1) {
                }
            }
        }
    }
} </s>
<s>class temp {    public void convert(File src, File dest) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(src));
        DcmParser p = pfact.newDcmParser(in);
        Dataset ds = fact.newDataset();
        p.setDcmHandler(ds.getDcmHandler());
        try {
            FileFormat format = p.detectFileFormat();
            if (format != FileFormat.ACRNEMA_STREAM) {
                System.out.println("\n" + src + ": not an ACRNEMA stream!");
                return;
            }
            p.parseDcmFile(format, Tags.PixelData);
            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {
                System.out.println("\n" + src + ": contains UIDs!" + " => probable already DICOM - do not convert");
                return;
            }
            boolean hasPixelData = p.getReadTag() == Tags.PixelData;
            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;
            int pxlen = p.getReadLength();
            if (hasPixelData) {
                if (inflate) {
                    ds.putUS(Tags.BitsAllocated, 16);
                    pxlen = pxlen * 4 / 3;
                }
                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {
                    System.out.println("\n" + src + ": mismatch pixel data length!" + " => do not convert");
                    return;
                }
            }
            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));
            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));
            ds.putUI(Tags.SOPInstanceUID, uid(instUID));
            ds.putUI(Tags.SOPClassUID, classUID);
            if (!ds.contains(Tags.NumberOfSamples)) {
                ds.putUS(Tags.NumberOfSamples, 1);
            }
            if (!ds.contains(Tags.PhotometricInterpretation)) {
                ds.putCS(Tags.PhotometricInterpretation, "MONOCHROME2");
            }
            if (fmi) {
                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));
            }
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
            try {
            } finally {
                ds.writeFile(out, encodeParam());
                if (hasPixelData) {
                    if (!skipGroupLen) {
                        out.write(PXDATA_GROUPLEN);
                        int grlen = pxlen + 8;
                        out.write((byte) grlen);
                        out.write((byte) (grlen >> 8));
                        out.write((byte) (grlen >> 16));
                        out.write((byte) (grlen >> 24));
                    }
                    out.write(PXDATA_TAG);
                    out.write((byte) pxlen);
                    out.write((byte) (pxlen >> 8));
                    out.write((byte) (pxlen >> 16));
                    out.write((byte) (pxlen >> 24));
                }
                if (inflate) {
                    int b2, b3;
                    for (; pxlen > 0; pxlen -= 3) {
                        out.write(in.read());
                        b2 = in.read();
                        b3 = in.read();
                        out.write(b2 & 0x0f);
                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));
                        out.write(b3 >> 4);
                    }
                } else {
                    for (; pxlen > 0; --pxlen) {
                        out.write(in.read());
                    }
                }
                out.close();
            }
            System.out.print('.');
        } finally {
            in.close();
        }
    }
} </s>
<s>class temp {    public static String encrypt(String algorithm, String[] input) {
        try {
            MessageDigest md = MessageDigest.getInstance(algorithm);
            md.reset();
            for (int i = 0; i < input.length; i++) {
                if (input[i] != null) md.update(input[i].getBytes("UTF-8"));
            }
            byte[] messageDigest = md.digest();
            StringBuffer hexString = new StringBuffer();
            for (int i = 0; i < messageDigest.length; i++) {
                hexString.append(Integer.toHexString((0xf0 & messageDigest[i]) >> 4));
                hexString.append(Integer.toHexString(0x0f & messageDigest[i]));
            }
            return hexString.toString();
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        } catch (NullPointerException e) {
            return new StringBuffer().toString();
        }
    }
} </s>
<s>class temp {    public static Class[] findSubClasses(Class baseClass) {
        String packagePath = "/" + baseClass.getPackage().getName().replace('.', '/');
        URL url = baseClass.getResource(packagePath);
        if (url == null) {
            return new Class[0];
        }
        List<Class> derivedClasses = new ArrayList<Class>();
        try {
            URLConnection connection = url.openConnection();
            if (connection instanceof JarURLConnection) {
                JarFile jarFile = ((JarURLConnection) connection).getJarFile();
                Enumeration e = jarFile.entries();
                while (e.hasMoreElements()) {
                    ZipEntry entry = (ZipEntry) e.nextElement();
                    String entryName = entry.getName();
                    if (entryName.endsWith(".class")) {
                        String clazzName = entryName.substring(0, entryName.length() - 6);
                        clazzName = clazzName.replace('/', '.');
                        try {
                            Class clazz = Class.forName(clazzName);
                            if (isConcreteSubclass(baseClass, clazz)) {
                                derivedClasses.add(clazz);
                            }
                        } catch (Throwable ignoreIt) {
                        }
                    }
                }
            } else if (connection instanceof FileURLConnection) {
                File file = new File(url.getFile());
                File[] files = file.listFiles();
                for (int i = 0; i < files.length; i++) {
                    String filename = files[i].getName();
                    if (filename.endsWith(".class")) {
                        filename = filename.substring(0, filename.length() - 6);
                        String clazzname = baseClass.getPackage().getName() + "." + filename;
                        try {
                            Class clazz = Class.forName(clazzname);
                            if (isConcreteSubclass(baseClass, clazz)) {
                                derivedClasses.add(clazz);
                            }
                        } catch (Throwable ignoreIt) {
                        }
                    }
                }
            }
        } catch (IOException ignoreIt) {
        }
        return derivedClasses.toArray(new Class[derivedClasses.size()]);
    }
} </s>
<s>class temp {    public void load(URL urlin) throws IOException {
        index = hs.getDoIndex();
        loaded = false;
        url = urlin;
        int c, i;
        htmlDocLength = 0;
        HtmlReader in = new HtmlReader(new InputStreamReader(url.openStream(), charset));
        try {
            if (debug >= 2) System.out.print("Loading " + urlin.toString() + " ... ");
            while ((c = in.read()) >= 0) {
                htmlDoc[htmlDocLength++] = (char) (c);
                if (htmlDocLength == htmlDocMaxLength) {
                    char[] newHtmlDoc = new char[2 * htmlDocMaxLength];
                    System.arraycopy(htmlDoc, 0, newHtmlDoc, 0, htmlDocMaxLength);
                    htmlDocMaxLength = 2 * htmlDocMaxLength;
                    htmlDoc = newHtmlDoc;
                }
            }
            if (debug >= 2) System.out.println("done.");
        } catch (ArrayIndexOutOfBoundsException aioobe) {
            if (debug >= 1) System.out.println("Error, reading file into memory (too big) - skipping " + urlin.toString());
            loaded = false;
            return;
        }
        in.close();
        fetchURLpos = 0;
        dumpPos = 0;
        dumpLastChar = SPACE;
        loaded = true;
        frameset = false;
        titledone = false;
        headdone = false;
        checkhead = false;
        checkbody = false;
    }
} </s>
<s>class temp {    @Override
    public synchronized void deleteCallStatistics(Integer elementId, String contextName, String category, String project, String name, Date dateFrom, Date dateTo, Boolean extractException, String principal) throws DatabaseException {
        final Connection connection = this.getConnection();
        try {
            connection.setAutoCommit(false);
            String queryString = "DELETE " + this.getCallInvocationsSchemaAndTableName() + " FROM " + this.getCallInvocationsSchemaAndTableName() + " INNER JOIN " + this.getCallElementsSchemaAndTableName() + " ON " + this.getCallElementsSchemaAndTableName() + ".element_id =  " + this.getCallInvocationsSchemaAndTableName() + ".element_id ";
            if (principal != null) {
                queryString = queryString + "LEFT JOIN " + this.getCallPrincipalsSchemaAndTableName() + " ON " + this.getCallInvocationsSchemaAndTableName() + ".principal_id = " + this.getCallPrincipalsSchemaAndTableName() + ".principal_id ";
            }
            queryString = queryString + "WHERE ";
            if (elementId != null) {
                queryString = queryString + this.getCallElementsSchemaAndTableName() + ".elementId = ? AND ";
            }
            if (contextName != null) {
                queryString = queryString + this.getCallElementsSchemaAndTableName() + ".context_name LIKE ? AND ";
            }
            if ((category != null)) {
                queryString = queryString + this.getCallElementsSchemaAndTableName() + ".category LIKE ? AND ";
            }
            if ((project != null)) {
                queryString = queryString + this.getCallElementsSchemaAndTableName() + ".project LIKE ? AND ";
            }
            if ((name != null)) {
                queryString = queryString + this.getCallElementsSchemaAndTableName() + ".name LIKE ? AND ";
            }
            if (dateFrom != null) {
                queryString = queryString + this.getCallInvocationsSchemaAndTableName() + ".start_timestamp >= ? AND ";
            }
            if (dateTo != null) {
                queryString = queryString + this.getCallInvocationsSchemaAndTableName() + ".start_timestamp <= ? AND ";
            }
            if (principal != null) {
                queryString = queryString + this.getCallPrincipalsSchemaAndTableName() + ".principal_name LIKE ? AND ";
            }
            if (extractException != null) {
                if (extractException.booleanValue()) {
                    queryString = queryString + this.getCallInvocationsSchemaAndTableName() + ".exception_id IS NOT NULL AND ";
                } else {
                    queryString = queryString + this.getCallInvocationsSchemaAndTableName() + ".exception_id IS NULL AND ";
                }
            }
            queryString = DefaultDatabaseHandler.removeOrphanWhereAndAndFromSelect(queryString);
            final PreparedStatement preparedStatement = DebugPreparedStatement.prepareStatement(connection, queryString);
            int indexCounter = 1;
            if (elementId != null) {
                preparedStatement.setLong(indexCounter, elementId.longValue());
                indexCounter = indexCounter + 1;
            }
            if (contextName != null) {
                preparedStatement.setString(indexCounter, contextName);
                indexCounter = indexCounter + 1;
            }
            if ((category != null)) {
                preparedStatement.setString(indexCounter, category);
                indexCounter = indexCounter + 1;
            }
            if ((project != null)) {
                preparedStatement.setString(indexCounter, project);
                indexCounter = indexCounter + 1;
            }
            if ((name != null)) {
                preparedStatement.setString(indexCounter, name);
                indexCounter = indexCounter + 1;
            }
            if (dateFrom != null) {
                preparedStatement.setTimestamp(indexCounter, new Timestamp(dateFrom.getTime()));
                indexCounter = indexCounter + 1;
            }
            if (dateTo != null) {
                preparedStatement.setTimestamp(indexCounter, new Timestamp(dateTo.getTime()));
                indexCounter = indexCounter + 1;
            }
            if (principal != null) {
                preparedStatement.setString(indexCounter, principal);
                indexCounter = indexCounter + 1;
            }
            preparedStatement.executeUpdate();
            preparedStatement.close();
            connection.commit();
        } catch (final SQLException e) {
            try {
                connection.rollback();
            } catch (final SQLException ex) {
                JeeObserverServerContext.logger.log(Level.SEVERE, "Transaction rollback error.", ex);
            }
            JeeObserverServerContext.logger.log(Level.SEVERE, e.getMessage());
            throw new DatabaseException("Error deleting call statistics.", e);
        } finally {
            this.releaseConnection(connection);
        }
    }
} </s>
<s>class temp {    @Override
    public synchronized void deleteHttpSessionStatistics(String contextName, String project, Date dateFrom, Date dateTo) throws DatabaseException {
        final Connection connection = this.getConnection();
        try {
            connection.setAutoCommit(false);
            String queryString = "DELETE " + this.getHttpSessionInvocationsSchemaAndTableName() + " FROM " + this.getHttpSessionInvocationsSchemaAndTableName() + " INNER JOIN " + this.getHttpSessionElementsSchemaAndTableName() + " ON " + this.getHttpSessionElementsSchemaAndTableName() + ".element_id =  " + this.getHttpSessionInvocationsSchemaAndTableName() + ".element_id WHERE ";
            if (contextName != null) {
                queryString = queryString + " context_name LIKE ? AND ";
            }
            if (project != null) {
                queryString = queryString + " project LIKE ? AND ";
            }
            if (dateFrom != null) {
                queryString = queryString + " start_timestamp >= ? AND ";
            }
            if (dateTo != null) {
                queryString = queryString + " start_timestamp <= ? AND ";
            }
            queryString = DefaultDatabaseHandler.removeOrphanWhereAndAndFromSelect(queryString);
            final PreparedStatement preparedStatement = DebugPreparedStatement.prepareStatement(connection, queryString);
            int indexCounter = 1;
            if (contextName != null) {
                preparedStatement.setString(indexCounter, contextName);
                indexCounter = indexCounter + 1;
            }
            if (project != null) {
                preparedStatement.setString(indexCounter, project);
                indexCounter = indexCounter + 1;
            }
            if (dateFrom != null) {
                preparedStatement.setTimestamp(indexCounter, new Timestamp(dateFrom.getTime()));
                indexCounter = indexCounter + 1;
            }
            if (dateTo != null) {
                preparedStatement.setTimestamp(indexCounter, new Timestamp(dateTo.getTime()));
                indexCounter = indexCounter + 1;
            }
            preparedStatement.executeUpdate();
            preparedStatement.close();
            connection.commit();
        } catch (final SQLException e) {
            try {
                connection.rollback();
            } catch (final SQLException ex) {
                JeeObserverServerContext.logger.log(Level.SEVERE, "Transaction rollback error.", ex);
            }
            JeeObserverServerContext.logger.log(Level.SEVERE, e.getMessage());
            throw new DatabaseException("Error deleting HTTP session statistics.", e);
        } finally {
            this.releaseConnection(connection);
        }
    }
} </s>
<s>class temp {    @Override
    public synchronized void deleteJvmStatistics(String contextName, Date dateFrom, Date dateTo) throws DatabaseException {
        final Connection connection = this.getConnection();
        try {
            connection.setAutoCommit(false);
            String queryString = "DELETE " + this.getJvmInvocationsSchemaAndTableName() + " FROM " + this.getJvmInvocationsSchemaAndTableName() + " INNER JOIN " + this.getJvmElementsSchemaAndTableName() + " ON " + this.getJvmElementsSchemaAndTableName() + ".element_id =  " + this.getJvmInvocationsSchemaAndTableName() + ".element_id WHERE ";
            if (contextName != null) {
                queryString = queryString + " context_name LIKE ? AND ";
            }
            if (dateFrom != null) {
                queryString = queryString + " start_timestamp >= ? AND ";
            }
            if (dateTo != null) {
                queryString = queryString + " start_timestamp <= ? AND ";
            }
            queryString = DefaultDatabaseHandler.removeOrphanWhereAndAndFromSelect(queryString);
            final PreparedStatement preparedStatement = DebugPreparedStatement.prepareStatement(connection, queryString);
            int indexCounter = 1;
            if (contextName != null) {
                preparedStatement.setString(indexCounter, contextName);
                indexCounter = indexCounter + 1;
            }
            if (dateFrom != null) {
                preparedStatement.setTimestamp(indexCounter, new Timestamp(dateFrom.getTime()));
                indexCounter = indexCounter + 1;
            }
            if (dateTo != null) {
                preparedStatement.setTimestamp(indexCounter, new Timestamp(dateTo.getTime()));
                indexCounter = indexCounter + 1;
            }
            preparedStatement.executeUpdate();
            preparedStatement.close();
            connection.commit();
        } catch (final SQLException e) {
            try {
                connection.rollback();
            } catch (final SQLException ex) {
                JeeObserverServerContext.logger.log(Level.SEVERE, "Transaction rollback error.", ex);
            }
            JeeObserverServerContext.logger.log(Level.SEVERE, e.getMessage());
            throw new DatabaseException("Error deleting JVM statistics.", e);
        } finally {
            this.releaseConnection(connection);
        }
    }
} </s>
<s>class temp {    @Override
    public synchronized void deletePersistenceEntityStatistics(Integer elementId, String contextName, String project, String name, Date dateFrom, Date dateTo) throws DatabaseException {
        final Connection connection = this.getConnection();
        try {
            connection.setAutoCommit(false);
            String queryString = "DELETE " + this.getPersistenceEntityStatisticsSchemaAndTableName() + " FROM " + this.getPersistenceEntityStatisticsSchemaAndTableName() + " INNER JOIN " + this.getPersistenceEntityElementsSchemaAndTableName() + " ON " + this.getPersistenceEntityElementsSchemaAndTableName() + ".element_id =  " + this.getPersistenceEntityStatisticsSchemaAndTableName() + ".element_id WHERE ";
            if (elementId != null) {
                queryString = queryString + " elementId = ? AND ";
            }
            if (contextName != null) {
                queryString = queryString + " context_name LIKE ? AND ";
            }
            if ((project != null)) {
                queryString = queryString + " project LIKE ? AND ";
            }
            if ((name != null)) {
                queryString = queryString + " name LIKE ? AND ";
            }
            if (dateFrom != null) {
                queryString = queryString + " start_timestamp >= ? AND ";
            }
            if (dateTo != null) {
                queryString = queryString + " start_timestamp <= ? AND ";
            }
            queryString = DefaultDatabaseHandler.removeOrphanWhereAndAndFromSelect(queryString);
            final PreparedStatement preparedStatement = DebugPreparedStatement.prepareStatement(connection, queryString);
            int indexCounter = 1;
            if (elementId != null) {
                preparedStatement.setLong(indexCounter, elementId.longValue());
                indexCounter = indexCounter + 1;
            }
            if (contextName != null) {
                preparedStatement.setString(indexCounter, contextName);
                indexCounter = indexCounter + 1;
            }
            if ((project != null)) {
                preparedStatement.setString(indexCounter, project);
                indexCounter = indexCounter + 1;
            }
            if ((name != null)) {
                preparedStatement.setString(indexCounter, name);
                indexCounter = indexCounter + 1;
            }
            if (dateFrom != null) {
                preparedStatement.setTimestamp(indexCounter, new Timestamp(dateFrom.getTime()));
                indexCounter = indexCounter + 1;
            }
            if (dateTo != null) {
                preparedStatement.setTimestamp(indexCounter, new Timestamp(dateTo.getTime()));
                indexCounter = indexCounter + 1;
            }
            preparedStatement.executeUpdate();
            preparedStatement.close();
            connection.commit();
        } catch (final SQLException e) {
            try {
                connection.rollback();
            } catch (final SQLException ex) {
                JeeObserverServerContext.logger.log(Level.SEVERE, "Transaction rollback error.", ex);
            }
            JeeObserverServerContext.logger.log(Level.SEVERE, e.getMessage());
            throw new DatabaseException("Error deleting persistence entity statistics.", e);
        } finally {
            this.releaseConnection(connection);
        }
    }
} </s>
<s>class temp {    @Override
    public synchronized void deletePersistenceQueryStatistics(Integer elementId, String contextName, String project, String name, Date dateFrom, Date dateTo) throws DatabaseException {
        final Connection connection = this.getConnection();
        try {
            connection.setAutoCommit(false);
            String queryString = "DELETE " + this.getPersistenceQueryStatisticsSchemaAndTableName() + " FROM " + this.getPersistenceQueryStatisticsSchemaAndTableName() + " INNER JOIN " + this.getPersistenceQueryElementsSchemaAndTableName() + " ON " + this.getPersistenceQueryElementsSchemaAndTableName() + ".element_id =  " + this.getPersistenceQueryStatisticsSchemaAndTableName() + ".element_id WHERE ";
            if (elementId != null) {
                queryString = queryString + " elementId = ? AND ";
            }
            if (contextName != null) {
                queryString = queryString + " context_name LIKE ? AND ";
            }
            if ((project != null)) {
                queryString = queryString + " project LIKE ? AND ";
            }
            if ((name != null)) {
                queryString = queryString + " name LIKE ? AND ";
            }
            if (dateFrom != null) {
                queryString = queryString + " start_timestamp >= ? AND ";
            }
            if (dateTo != null) {
                queryString = queryString + " start_timestamp <= ? AND ";
            }
            queryString = DefaultDatabaseHandler.removeOrphanWhereAndAndFromSelect(queryString);
            final PreparedStatement preparedStatement = DebugPreparedStatement.prepareStatement(connection, queryString);
            int indexCounter = 1;
            if (elementId != null) {
                preparedStatement.setLong(indexCounter, elementId.longValue());
                indexCounter = indexCounter + 1;
            }
            if (contextName != null) {
                preparedStatement.setString(indexCounter, contextName);
                indexCounter = indexCounter + 1;
            }
            if ((project != null)) {
                preparedStatement.setString(indexCounter, project);
                indexCounter = indexCounter + 1;
            }
            if ((name != null)) {
                preparedStatement.setString(indexCounter, name);
                indexCounter = indexCounter + 1;
            }
            if (dateFrom != null) {
                preparedStatement.setTimestamp(indexCounter, new Timestamp(dateFrom.getTime()));
                indexCounter = indexCounter + 1;
            }
            if (dateTo != null) {
                preparedStatement.setTimestamp(indexCounter, new Timestamp(dateTo.getTime()));
                indexCounter = indexCounter + 1;
            }
            preparedStatement.executeUpdate();
            preparedStatement.close();
            connection.commit();
        } catch (final SQLException e) {
            try {
                connection.rollback();
            } catch (final SQLException ex) {
                JeeObserverServerContext.logger.log(Level.SEVERE, "Transaction rollback error.", ex);
            }
            JeeObserverServerContext.logger.log(Level.SEVERE, e.getMessage());
            throw new DatabaseException("Error deleting persistence query statistics.", e);
        } finally {
            this.releaseConnection(connection);
        }
    }
} </s>
<s>class temp {    @Override
    public synchronized void deleteHardDiskStatistics(String contextName, String path, Date dateFrom, Date dateTo) throws DatabaseException {
        final Connection connection = this.getConnection();
        try {
            connection.setAutoCommit(false);
            String queryString = "DELETE " + this.getHardDiskInvocationsSchemaAndTableName() + " FROM " + this.getHardDiskInvocationsSchemaAndTableName() + " INNER JOIN " + this.getHardDiskElementsSchemaAndTableName() + " ON " + this.getHardDiskElementsSchemaAndTableName() + ".element_id =  " + this.getHardDiskInvocationsSchemaAndTableName() + ".element_id WHERE ";
            if (contextName != null) {
                queryString = queryString + " context_name LIKE ? AND ";
            }
            if (path != null) {
                queryString = queryString + " path LIKE ? AND ";
            }
            if (dateFrom != null) {
                queryString = queryString + " start_timestamp >= ? AND ";
            }
            if (dateTo != null) {
                queryString = queryString + " start_timestamp <= ? AND ";
            }
            queryString = DefaultDatabaseHandler.removeOrphanWhereAndAndFromSelect(queryString);
            final PreparedStatement preparedStatement = DebugPreparedStatement.prepareStatement(connection, queryString);
            int indexCounter = 1;
            if (contextName != null) {
                preparedStatement.setString(indexCounter, contextName);
                indexCounter = indexCounter + 1;
            }
            if (path != null) {
                preparedStatement.setString(indexCounter, path);
                indexCounter = indexCounter + 1;
            }
            if (dateFrom != null) {
                preparedStatement.setTimestamp(indexCounter, new Timestamp(dateFrom.getTime()));
                indexCounter = indexCounter + 1;
            }
            if (dateTo != null) {
                preparedStatement.setTimestamp(indexCounter, new Timestamp(dateTo.getTime()));
                indexCounter = indexCounter + 1;
            }
            preparedStatement.executeUpdate();
            preparedStatement.close();
            connection.commit();
        } catch (final SQLException e) {
            try {
                connection.rollback();
            } catch (final SQLException ex) {
                JeeObserverServerContext.logger.log(Level.SEVERE, "Transaction rollback error.", ex);
            }
            JeeObserverServerContext.logger.log(Level.SEVERE, e.getMessage());
            throw new DatabaseException("Error deleting disk statistics.", e);
        } finally {
            this.releaseConnection(connection);
        }
    }
} </s>
<s>class temp {    @Override
    protected void removeOrphansElements() throws DatabaseException {
        this.getIdChache().clear();
        final Connection connection = this.getConnection();
        try {
            connection.setAutoCommit(false);
            PreparedStatement preparedStatement;
            preparedStatement = DebugPreparedStatement.prepareStatement(connection, "DELETE " + this.getCallElementsSchemaAndTableName() + " FROM " + this.getCallElementsSchemaAndTableName() + " LEFT JOIN " + this.getCallInvocationsSchemaAndTableName() + " ON " + this.getCallElementsSchemaAndTableName() + ".element_id =  " + this.getCallInvocationsSchemaAndTableName() + ".element_id WHERE " + this.getCallInvocationsSchemaAndTableName() + ".element_id IS NULL");
            preparedStatement.executeUpdate();
            preparedStatement.close();
            preparedStatement = DebugPreparedStatement.prepareStatement(connection, "DELETE " + this.getCallExceptionsSchemaAndTableName() + " FROM " + this.getCallExceptionsSchemaAndTableName() + " LEFT JOIN " + this.getCallInvocationsSchemaAndTableName() + " ON " + this.getCallExceptionsSchemaAndTableName() + ".exception_id =  " + this.getCallInvocationsSchemaAndTableName() + ".exception_id WHERE " + this.getCallInvocationsSchemaAndTableName() + ".exception_id IS NULL");
            preparedStatement.executeUpdate();
            preparedStatement.close();
            preparedStatement = DebugPreparedStatement.prepareStatement(connection, "DELETE " + this.getCallPrincipalsSchemaAndTableName() + " FROM " + this.getCallPrincipalsSchemaAndTableName() + " LEFT JOIN " + this.getCallInvocationsSchemaAndTableName() + " ON " + this.getCallPrincipalsSchemaAndTableName() + ".principal_id =  " + this.getCallInvocationsSchemaAndTableName() + ".principal_id WHERE " + this.getCallInvocationsSchemaAndTableName() + ".principal_id IS NULL");
            preparedStatement.executeUpdate();
            preparedStatement.close();
            preparedStatement = DebugPreparedStatement.prepareStatement(connection, "DELETE " + this.getHttpSessionElementsSchemaAndTableName() + " FROM " + this.getHttpSessionElementsSchemaAndTableName() + " LEFT JOIN " + this.getHttpSessionInvocationsSchemaAndTableName() + " ON " + this.getHttpSessionElementsSchemaAndTableName() + ".element_id =  " + this.getHttpSessionInvocationsSchemaAndTableName() + ".element_id WHERE " + this.getHttpSessionInvocationsSchemaAndTableName() + ".element_id IS NULL");
            preparedStatement.executeUpdate();
            preparedStatement.close();
            preparedStatement = DebugPreparedStatement.prepareStatement(connection, "DELETE " + this.getJvmElementsSchemaAndTableName() + " FROM " + this.getJvmElementsSchemaAndTableName() + " LEFT JOIN " + this.getJvmInvocationsSchemaAndTableName() + " ON " + this.getJvmElementsSchemaAndTableName() + ".element_id =  " + this.getJvmInvocationsSchemaAndTableName() + ".element_id WHERE " + this.getJvmInvocationsSchemaAndTableName() + ".element_id IS NULL");
            preparedStatement.executeUpdate();
            preparedStatement.close();
            preparedStatement = DebugPreparedStatement.prepareStatement(connection, "DELETE " + this.getPersistenceEntityElementsSchemaAndTableName() + " FROM " + this.getPersistenceEntityElementsSchemaAndTableName() + " LEFT JOIN " + this.getPersistenceEntityStatisticsSchemaAndTableName() + " ON " + this.getPersistenceEntityElementsSchemaAndTableName() + ".element_id =  " + this.getPersistenceEntityStatisticsSchemaAndTableName() + ".element_id WHERE " + this.getPersistenceEntityStatisticsSchemaAndTableName() + ".element_id IS NULL ");
            preparedStatement.executeUpdate();
            preparedStatement.close();
            preparedStatement = DebugPreparedStatement.prepareStatement(connection, "DELETE " + this.getPersistenceQueryElementsSchemaAndTableName() + " FROM " + this.getPersistenceQueryElementsSchemaAndTableName() + " LEFT JOIN " + this.getPersistenceQueryStatisticsSchemaAndTableName() + " ON " + this.getPersistenceQueryElementsSchemaAndTableName() + ".element_id =  " + this.getPersistenceQueryStatisticsSchemaAndTableName() + ".element_id WHERE " + this.getPersistenceQueryStatisticsSchemaAndTableName() + ".element_id IS NULL ");
            preparedStatement.executeUpdate();
            preparedStatement.close();
            preparedStatement = DebugPreparedStatement.prepareStatement(connection, "DELETE " + this.getHardDiskElementsSchemaAndTableName() + " FROM " + this.getHardDiskElementsSchemaAndTableName() + " LEFT JOIN " + this.getHardDiskInvocationsSchemaAndTableName() + " ON " + this.getHardDiskElementsSchemaAndTableName() + ".element_id =  " + this.getHardDiskInvocationsSchemaAndTableName() + ".element_id WHERE " + this.getHardDiskInvocationsSchemaAndTableName() + ".element_id IS NULL ");
            preparedStatement.executeUpdate();
            preparedStatement.close();
            connection.commit();
        } catch (final SQLException e) {
            try {
                connection.rollback();
            } catch (final SQLException ex) {
                JeeObserverServerContext.logger.log(Level.SEVERE, "Transaction rollback error.", ex);
            }
            JeeObserverServerContext.logger.log(Level.SEVERE, e.getMessage());
            throw new DatabaseException("Error cleaning database.", e);
        } finally {
            this.releaseConnection(connection);
        }
        return;
    }
} </s>
<s>class temp {    public static void doVersionCheck(View view) {
        view.showWaitCursor();
        try {
            URL url = new URL(jEdit.getProperty("version-check.url"));
            InputStream in = url.openStream();
            BufferedReader bin = new BufferedReader(new InputStreamReader(in));
            String line;
            String develBuild = null;
            String stableBuild = null;
            while ((line = bin.readLine()) != null) {
                if (line.startsWith(".build")) develBuild = line.substring(6).trim(); else if (line.startsWith(".stablebuild")) stableBuild = line.substring(12).trim();
            }
            bin.close();
            if (develBuild != null && stableBuild != null) {
                doVersionCheck(view, stableBuild, develBuild);
            }
        } catch (IOException e) {
            String[] args = { jEdit.getProperty("version-check.url"), e.toString() };
            GUIUtilities.error(view, "read-error", args);
        }
        view.hideWaitCursor();
    }
} </s>
<s>class temp {    public T02OTSUnitTestCase(String name) throws java.io.IOException {
        super(name);
        java.net.URL url = ClassLoader.getSystemResource("host0.cosnaming.jndi.properties");
        jndiProps = new java.util.Properties();
        jndiProps.load(url.openStream());
    }
} </s>
<s>class temp {    public Configuration(URL url) {
        InputStream in = null;
        try {
            load(in = url.openStream());
        } catch (Exception e) {
            throw new RuntimeException("Could not load configuration from " + url, e);
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException ignore) {
                }
            }
        }
    }
} </s>
<s>class temp {    public void buildCache() {
        CacheManager.resetCache();
        XMLCacheBuilder cacheBuilder = CompositePageUtil.getCacheBuilder();
        if (cacheBuilder == null) return;
        String pathStr = cacheBuilder.getPath();
        if (pathStr == null) return;
        String[] paths = pathStr.split("\n");
        for (int i = 0; i < paths.length; i++) {
            try {
                String path = paths[i];
                URL url = new URL(path);
                HttpURLConnection huc = (HttpURLConnection) url.openConnection();
                huc.setDoInput(true);
                huc.setDoOutput(true);
                huc.setUseCaches(false);
                huc.setRequestProperty("Content-Type", "text/html");
                DataOutputStream dos = new DataOutputStream(huc.getOutputStream());
                dos.flush();
                dos.close();
                huc.disconnect();
            } catch (MalformedURLException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
} </s>
<s>class temp {    private synchronized void executePrebuildCache() {
        isPrebuilding = true;
        String pathStr = "";
        String[] paths = null;
        XMLCacheBuilder cacheBuilder = null;
        if (this.getConfigPath() != null) {
            cacheBuilder = CompositePageUtil.getCacheBuilder();
            if (cacheBuilder == null) return;
            try {
                File file = new File(this.getConfigPath());
                FileInputStream is = new FileInputStream(file);
                OutputStream os = new ByteArrayOutputStream();
                int length = 0;
                if (is != null) {
                    byte[] buf = new byte[8192];
                    while (((length = is.read(buf)) != -1)) {
                        os.write(buf, 0, length);
                    }
                    is.close();
                    os.flush();
                    os.close();
                    is.close();
                }
                String filesStr = os.toString();
                if (filesStr == null) return;
                paths = filesStr.split("\n");
            } catch (FileNotFoundException e) {
                logger.error(e);
            } catch (IOException e) {
                logger.error(e);
            }
        } else {
            XMLRoot root = ConfigureDigester.getXmlRoot();
            cacheBuilder = root.getCacheBuilder();
            if (cacheBuilder == null) return;
            pathStr = cacheBuilder.getPath();
            if (pathStr == null) return;
            paths = pathStr.split("\n");
        }
        logger.warn("[prebuildCache start:" + new java.util.Date() + "]");
        for (int i = 0; i < paths.length; i++) {
            try {
                String path = paths[i];
                logger.info("preBuildCache path:" + path);
                URL url = new URL(path);
                HttpURLConnection huc = (HttpURLConnection) url.openConnection();
                huc.setDoInput(true);
                huc.setDoOutput(true);
                huc.setUseCaches(false);
                huc.setRequestProperty("Content-Type", "text/html");
                DataOutputStream dos = new DataOutputStream(huc.getOutputStream());
                dos.flush();
                dos.close();
                BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(huc.getInputStream()));
                StringBuffer result = new StringBuffer();
                String line;
                while (null != (line = bufferedReader.readLine())) result.append(line);
                bufferedReader.close();
                huc.disconnect();
            } catch (MalformedURLException e) {
                logger.warn("prebuildCache: MalformedURLException");
            } catch (IOException e) {
                logger.warn("prebuildCache: IOException");
                logger.warn("Is CACHE_SERVER dead? escape prebuild cache!");
                logger.error("[****Prebuild cache interrupted! Please check the CACHE_SERVER's status.****]");
            } catch (Exception e) {
                logger.warn("prebuildCache: Exception");
            }
        }
        logger.warn("[prebuildCache end:" + new java.util.Date() + "]");
        logger.info("[Time to migrate cache]");
        if (CacheManager.getPreCacheMap() == null || CacheManager.getPreCacheMap().size() == 0) {
            logger.warn("[****Something wrong in prebuild cache process is CACHE_SERVER dead? escape sending cache to CLIENT****]");
            return;
        } else {
            CacheManager.migrateCache();
        }
        logger.info("[Cache migration finish!]");
        if (cacheBuilder.getPoint() != null && cacheBuilder.getPoint().equals("SERVER")) {
            logger.info("Sending cache to CLIENT");
            if (cuttleManagerList != null) {
                for (int i = 0; i < cuttleManagerList.size(); i++) {
                    try {
                        CuttleManager cuttleManager = (CuttleManager) cuttleManagerList.get(i);
                        cuttleManager.migrateCache(CacheManager.getCacheTimeoutMap(), CacheManager.getCacheMap());
                    } catch (Exception e) {
                        e.printStackTrace();
                        logger.error(e);
                        logger.error("Sending cache to CLIENT:" + (i + 1) + " failed!");
                    }
                }
            }
            logger.info("Cache migrate to CLIENT finished!");
        }
        try {
            logger.info("Time to sleep for sending cache to CLIENT: 1 minute");
            Thread.sleep(60000);
            logger.info("Wake up for next prebuild cache!");
        } catch (Exception e) {
            logger.warn("thread sleep interrupt!");
        }
        isPrebuilding = false;
    }
} </s>
<s>class temp {    public static final synchronized String hash(String data) {
        if (digest == null) {
            try {
                digest = MessageDigest.getInstance("MD5");
            } catch (NoSuchAlgorithmException nsae) {
                System.err.println("Failed to load the MD5 MessageDigest. " + "Jive will be unable to function normally.");
                nsae.printStackTrace();
            }
        }
        digest.update(data.getBytes());
        return toHex(digest.digest());
    }
} </s>
<s>class temp {    public void GetFile(ClientConnector cc, Map<String, String> attributes) throws Exception {
        log.debug("Starting FTP FilePull");
        String sourceNode = attributes.get("src_name");
        String sourceUser = attributes.get("src_user");
        String sourcePassword = attributes.get("src_password");
        String sourceFile = attributes.get("src_file");
        String messageID = attributes.get("messageID");
        String sourceMD5 = attributes.get("src_md5");
        String sourceFileType = attributes.get("src_file_type");
        Integer sourcePort = 21;
        String sourcePortString = attributes.get("src_port");
        if ((sourcePortString != null) && (sourcePortString.equals(""))) {
            try {
                sourcePort = Integer.parseInt(sourcePortString);
            } catch (Exception e) {
                sourcePort = 21;
                log.debug("Destination Port \"" + sourcePortString + "\" was not valid. Using Default (21)");
            }
        }
        log.info("Starting FTP pull of \"" + sourceFile + "\" from \"" + sourceNode);
        if ((sourceUser == null) || (sourceUser.equals(""))) {
            List userDBVal = axt.db.GeneralDAO.getNodeValue(sourceNode, "ftpUser");
            if (userDBVal.size() < 1) {
                sourceUser = DEFAULTUSER;
            } else {
                sourceUser = (String) userDBVal.get(0);
            }
        }
        if ((sourcePassword == null) || (sourcePassword.equals(""))) {
            List passwordDBVal = axt.db.GeneralDAO.getNodeValue(sourceNode, "ftpPassword");
            if (passwordDBVal.size() < 1) {
                sourcePassword = DEFAULTPASSWORD;
            } else {
                sourcePassword = (String) passwordDBVal.get(0);
            }
        }
        String stageFile = null;
        int stageFileID;
        try {
            stageFileID = axt.db.GeneralDAO.getStageFile(messageID);
            stageFile = STAGINGDIR + "/" + stageFileID;
        } catch (Exception e) {
            throw new Exception("Failed to assign a staging file \"" + stageFile + "\" - ERROR: " + e);
        }
        FileOutputStream fos;
        try {
            fos = new FileOutputStream(stageFile);
        } catch (FileNotFoundException fileNFException) {
            throw new Exception("Failed to assign the staging file \"" + stageFile + "\" - ERROR: " + fileNFException);
        }
        FTPClient ftp = new FTPClient();
        try {
            log.debug("Connecting");
            ftp.connect(sourceNode, sourcePort);
            log.debug("Checking Status");
            int reply = ftp.getReplyCode();
            if (!FTPReply.isPositiveCompletion(reply)) {
                ftp.disconnect();
                throw new Exception("Failed to connect to \"" + sourceNode + "\"  as user \"" + sourceUser + "\" - ERROR: " + ftp.getReplyString());
            }
            log.debug("Logging In");
            if (!ftp.login(sourceUser, sourcePassword)) {
                ftp.disconnect();
                throw new Exception("Failed to connect to \"" + sourceNode + "\"  as user \"" + sourceUser + "\" - ERROR: Login Failed");
            }
        } catch (SocketException socketException) {
            throw new Exception("Failed to connect to \"" + sourceNode + "\"  as user \"" + sourceUser + "\" - ERROR: " + socketException);
        } catch (IOException ioe) {
            throw new Exception("Failed to connect to \"" + sourceNode + "\"  as user \"" + sourceUser + "\" - ERROR: " + ioe);
        }
        log.debug("Performing Site Commands");
        Iterator siteIterator = GeneralDAO.getNodeValue(sourceNode, "ftpSite").iterator();
        while (siteIterator.hasNext()) {
            String siteCommand = null;
            try {
                siteCommand = (String) siteIterator.next();
                ftp.site(siteCommand);
            } catch (IOException e) {
                throw new Exception("FTP \"site\" command \"" + siteCommand + "\" failed - ERROR: " + e);
            }
        }
        if (sourceFileType != null) {
            if (sourceFileType.equals("A")) {
                log.debug("Set File Type to ASCII");
                ftp.setFileType(FTP.ASCII_FILE_TYPE);
            } else if (sourceFileType.equals("B")) {
                log.debug("Set File Type to BINARY");
                ftp.setFileType(FTP.BINARY_FILE_TYPE);
            } else if (sourceFileType.equals("E")) {
                log.debug("Set File Type to EBCDIC");
                ftp.setFileType(FTP.EBCDIC_FILE_TYPE);
            }
        }
        log.debug("Opening the File Stream");
        InputStream in = null;
        try {
            in = ftp.retrieveFileStream(sourceFile);
            if (in == null) {
                throw new Exception("Failed get the file \"" + sourceFile + "\" from \"" + sourceNode + "\"  - ERROR: " + ftp.getReplyString());
            }
        } catch (IOException ioe2) {
            ftp.disconnect();
            log.error("Failed get the file \"" + sourceFile + "\" from \"" + sourceNode + "\"  - ERROR: " + ioe2);
            throw new Exception("Failed to retrieve file from \"" + sourceNode + "\"  as user \"" + sourceUser + "\" - ERROR: " + ioe2);
        }
        log.debug("Starting the read");
        DESCrypt encrypter = null;
        try {
            encrypter = new DESCrypt();
        } catch (Exception cryptInitError) {
            log.error("Failed to initialize the encrypt process - ERROR: " + cryptInitError);
        }
        String receivedMD5 = null;
        try {
            Object[] returnValues = encrypter.encrypt(in, fos);
            receivedMD5 = (String) returnValues[0];
            GeneralDAO.setStageFileSize(stageFileID, (Long) returnValues[1]);
        } catch (Exception cryptError) {
            log.error("Encrypt Error: " + cryptError);
            throw new Exception("Encrypt Error: " + cryptError);
        }
        log.debug("Logging Out");
        try {
            ftp.logout();
            fos.close();
        } catch (Exception ioe3) {
            log.error("Failed close connection to \"" + sourceNode + "\"  - ERROR: " + ioe3);
        }
        log.debug("Setting the File Digest");
        GeneralDAO.setStageFileDigest(stageFileID, receivedMD5);
        if ((sourceMD5 != null) && (!sourceMD5.equals(""))) {
            log.debug("File DIGEST compare - Source: " + sourceMD5.toLowerCase() + " | Received: " + receivedMD5);
            if (!receivedMD5.equals(sourceMD5.toLowerCase())) {
                throw new Exception("MD5 validation on file failed.");
            }
        }
        return;
    }
} </s>
<s>class temp {    public void PutFile(ClientConnector cc, Map<String, String> attributes) throws Exception {
        String destinationNode = attributes.get("dest_name");
        String destinationUser = attributes.get("dest_user");
        String destinationPassword = attributes.get("dest_password");
        String destinationFile = attributes.get("dest_file");
        String messageID = attributes.get("messageID");
        String destinationFileType = attributes.get("dest_file_type");
        Integer destinationPort = 21;
        String destinationPortString = attributes.get("dest_port");
        if ((destinationPortString != null) && (destinationPortString.equals(""))) {
            try {
                destinationPort = Integer.parseInt(destinationPortString);
            } catch (Exception e) {
                destinationPort = 21;
                log.debug("Destination Port \"" + destinationPortString + "\" was not valid. Using Default (21)");
            }
        }
        log.info("Starting FTP push of \"" + destinationFile + "\" to \"" + destinationNode);
        if ((destinationUser == null) || (destinationUser.equals(""))) {
            List userDBVal = axt.db.GeneralDAO.getNodeValue(destinationNode, "ftpUser");
            if (userDBVal.size() < 1) {
                destinationUser = DEFAULTUSER;
            } else {
                destinationUser = (String) userDBVal.get(0);
            }
        }
        if ((destinationPassword == null) || (destinationPassword.equals(""))) {
            List passwordDBVal = axt.db.GeneralDAO.getNodeValue(destinationNode, "ftpPassword");
            if (passwordDBVal.size() < 1) {
                destinationPassword = DEFAULTPASSWORD;
            } else {
                destinationPassword = (String) passwordDBVal.get(0);
            }
        }
        log.debug("Getting Stage File ID");
        String stageFile = null;
        try {
            stageFile = STAGINGDIR + "/" + axt.db.GeneralDAO.getStageFile(messageID);
        } catch (Exception stageException) {
            throw new Exception("Failed to assign a staging file \"" + stageFile + "\" - ERROR: " + stageException);
        }
        InputStream in;
        try {
            in = new FileInputStream(stageFile);
        } catch (FileNotFoundException fileNFException) {
            throw new Exception("Failed to get the staging file \"" + stageFile + "\" - ERROR: " + fileNFException);
        }
        log.debug("Sending File");
        FTPClient ftp = new FTPClient();
        try {
            log.debug("Connecting");
            ftp.connect(destinationNode, destinationPort);
            log.debug("Checking Status");
            int reply = ftp.getReplyCode();
            if (!FTPReply.isPositiveCompletion(reply)) {
                ftp.disconnect();
                throw new Exception("Failed to connect to \"" + destinationNode + "\"  as user \"" + destinationUser + "\" - ERROR: " + ftp.getReplyString());
            }
            log.debug("Logging In");
            if (!ftp.login(destinationUser, destinationPassword)) {
                ftp.disconnect();
                throw new Exception("Failed to connect to \"" + destinationNode + "\"  as user \"" + destinationUser + "\" - ERROR: Login Failed");
            }
        } catch (SocketException socketException) {
            throw new Exception("Failed to connect to \"" + destinationNode + "\"  as user \"" + destinationUser + "\" - ERROR: " + socketException);
        } catch (IOException ioe) {
            throw new Exception("Failed to connect to \"" + destinationNode + "\"  as user \"" + destinationUser + "\" - ERROR: " + ioe);
        }
        log.debug("Performing Site Commands");
        Iterator siteIterator = GeneralDAO.getNodeValue(destinationNode, "ftpSite").iterator();
        while (siteIterator.hasNext()) {
            String siteCommand = null;
            try {
                siteCommand = (String) siteIterator.next();
                ftp.site(siteCommand);
            } catch (IOException e) {
                throw new Exception("FTP \"site\" command \"" + siteCommand + "\" failed - ERROR: " + e);
            }
        }
        if (destinationFileType != null) {
            if (destinationFileType.equals("A")) {
                log.debug("Set File Type to ASCII");
                ftp.setFileType(FTP.ASCII_FILE_TYPE);
            } else if (destinationFileType.equals("B")) {
                log.debug("Set File Type to BINARY");
                ftp.setFileType(FTP.BINARY_FILE_TYPE);
            } else if (destinationFileType.equals("E")) {
                log.debug("Set File Type to EBCDIC");
                ftp.setFileType(FTP.EBCDIC_FILE_TYPE);
            }
        }
        log.debug("Pushing File");
        OutputStream out = null;
        try {
            out = ftp.storeFileStream(destinationFile);
            if (out == null) {
                throw new Exception("Failed send the file \"" + destinationFile + "\" to \"" + destinationNode + "\"  - ERROR: " + ftp.getReplyString());
            }
        } catch (IOException ioe2) {
            log.error("Failed to push the file \"" + destinationFile + "\" to \"" + destinationNode + "\"  - ERROR: " + ioe2);
        }
        DESCrypt decrypter = null;
        try {
            decrypter = new DESCrypt();
        } catch (Exception cryptInitError) {
            log.error("Failed to initialize the encrypt process - ERROR: " + cryptInitError);
        }
        try {
            decrypter.decrypt(in, out);
        } catch (Exception cryptError) {
            log.error("Send Error" + cryptError);
        }
        log.debug("Logging Out");
        try {
            out.close();
            ftp.logout();
            in.close();
        } catch (IOException ioe3) {
            log.error("Failed close connection to \"" + destinationNode + "\"  - ERROR: " + ioe3);
        }
        return;
    }
} </s>
<s>class temp {    public void schema(final Row row, TestResults testResults) throws Exception {
        String urlString = row.text(1);
        String schemaBase = null;
        if (row.cellExists(2)) {
            schemaBase = row.text(2);
        }
        try {
            StreamSource schemaSource;
            if (urlString.startsWith(CLASS_PREFIX)) {
                InputStream schema = XmlValidator.class.getClassLoader().getResourceAsStream(urlString.substring(CLASS_PREFIX.length()));
                schemaSource = new StreamSource(schema);
            } else {
                URL url = new URL(urlString);
                URLConnection urlConnection = url.openConnection();
                urlConnection.connect();
                InputStream inputStream = urlConnection.getInputStream();
                schemaSource = new StreamSource(inputStream);
            }
            SchemaFactory factory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
            if (schemaBase != null) {
                DefaultLSResourceResolver resolver = new DefaultLSResourceResolver(schemaBase);
                factory.setResourceResolver(resolver);
            }
            factory.newSchema(new URL(urlString));
            Validator validator = factory.newSchema(schemaSource).newValidator();
            StreamSource source = new StreamSource(new StringReader(xml));
            validator.validate(source);
            row.pass(testResults);
        } catch (SAXException e) {
            Loggers.SERVICE_LOG.warn("schema error", e);
            throw new FitFailureException(e.getMessage());
        } catch (IOException e) {
            Loggers.SERVICE_LOG.warn("schema error", e);
            throw new FitFailureException(e.getMessage());
        }
    }
} </s>
<s>class temp {    public int[] sort() {
        int i, tmp;
        int[] newIndex = new int[nrows];
        for (i = 0; i < nrows; i++) {
            newIndex[i] = i;
        }
        boolean change = true;
        if (this.ascending) {
            if (data[0][column] instanceof Comparable) {
                while (change) {
                    change = false;
                    for (i = 0; i < nrows - 1; i++) {
                        if (((Comparable) data[newIndex[i]][column]).compareTo((Comparable) data[newIndex[i + 1]][column]) > 0) {
                            tmp = newIndex[i];
                            newIndex[i] = newIndex[i + 1];
                            newIndex[i + 1] = tmp;
                            change = true;
                        }
                    }
                }
                return newIndex;
            }
            if (data[0][column] instanceof String || data[0][column] instanceof ClassLabel) {
                while (change) {
                    change = false;
                    for (i = 0; i < nrows - 1; i++) {
                        if ((data[newIndex[i]][column].toString()).compareTo(data[newIndex[i + 1]][column].toString()) > 0) {
                            tmp = newIndex[i];
                            newIndex[i] = newIndex[i + 1];
                            newIndex[i + 1] = tmp;
                            change = true;
                        }
                    }
                }
            }
            return newIndex;
        }
        if (!this.ascending) {
            if (data[0][column] instanceof Comparable) {
                while (change) {
                    change = false;
                    for (i = 0; i < nrows - 1; i++) {
                        if (((Comparable) data[newIndex[i]][column]).compareTo((Comparable) data[newIndex[i + 1]][column]) < 0) {
                            tmp = newIndex[i];
                            newIndex[i] = newIndex[i + 1];
                            newIndex[i + 1] = tmp;
                            change = true;
                        }
                    }
                }
                return newIndex;
            }
            if (data[0][column] instanceof String || data[0][column] instanceof ClassLabel) {
                while (change) {
                    change = false;
                    for (i = 0; i < nrows - 1; i++) {
                        if ((data[newIndex[i]][column].toString()).compareTo(data[newIndex[i + 1]][column].toString()) < 0) {
                            tmp = newIndex[i];
                            newIndex[i] = newIndex[i + 1];
                            newIndex[i + 1] = tmp;
                            change = true;
                        }
                    }
                }
            }
            return newIndex;
        } else return newIndex;
    }
} </s>
<s>class temp {    public boolean authenticate() {
        if (empresaFeta == null) empresaFeta = new AltaEmpresaBean();
        log.info("authenticating {0}", credentials.getUsername());
        boolean bo;
        try {
            String passwordEncriptat = credentials.getPassword();
            MessageDigest m = MessageDigest.getInstance("MD5");
            m.update(passwordEncriptat.getBytes(), 0, passwordEncriptat.length());
            passwordEncriptat = new BigInteger(1, m.digest()).toString(16);
            Query q = entityManager.createQuery("select usuari from Usuaris usuari where usuari.login=? and usuari.password=?");
            q.setParameter(1, credentials.getUsername());
            q.setParameter(2, passwordEncriptat);
            Usuaris usuari = (Usuaris) q.getSingleResult();
            bo = (usuari != null);
            if (bo) {
                if (usuari.isEsAdministrador()) {
                    identity.addRole("admin");
                } else {
                    carregaDadesEmpresa();
                    log.info("nom de l'empresa: " + empresaFeta.getInstance().getNom());
                }
            }
        } catch (Throwable t) {
            log.error(t);
            bo = false;
        }
        log.info("L'usuari {0} s'ha identificat bé? : {1} ", credentials.getUsername(), bo ? "si" : "no");
        return bo;
    }
} </s>
<s>class temp {    private boolean authenticateWithServer(String user, String password) {
        Object o;
        String response;
        byte[] dataKey;
        try {
            o = objectIn.readObject();
            if (o instanceof String) {
                response = (String) o;
                Debug.netMsg("Connected to JFritz Server: " + response);
                if (!response.equals("JFRITZ SERVER 1.1")) {
                    Debug.netMsg("Unkown Server version, newer JFritz protocoll version?");
                    Debug.netMsg("Canceling login attempt!");
                }
                objectOut.writeObject(user);
                objectOut.flush();
                MessageDigest md = MessageDigest.getInstance("MD5");
                md.update(password.getBytes());
                DESKeySpec desKeySpec = new DESKeySpec(md.digest());
                SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("DES");
                SecretKey secretKey = keyFactory.generateSecret(desKeySpec);
                Cipher desCipher = Cipher.getInstance("DES/ECB/PKCS5Padding");
                desCipher.init(Cipher.DECRYPT_MODE, secretKey);
                SealedObject sealedObject = (SealedObject) objectIn.readObject();
                o = sealedObject.getObject(desCipher);
                if (o instanceof byte[]) {
                    dataKey = (byte[]) o;
                    desKeySpec = new DESKeySpec(dataKey);
                    secretKey = keyFactory.generateSecret(desKeySpec);
                    inCipher = Cipher.getInstance("DES/ECB/PKCS5Padding");
                    outCipher = Cipher.getInstance("DES/ECB/PKCS5Padding");
                    inCipher.init(Cipher.DECRYPT_MODE, secretKey);
                    outCipher.init(Cipher.ENCRYPT_MODE, secretKey);
                    SealedObject sealed_ok = new SealedObject("OK", outCipher);
                    objectOut.writeObject(sealed_ok);
                    SealedObject sealed_response = (SealedObject) objectIn.readObject();
                    o = sealed_response.getObject(inCipher);
                    if (o instanceof String) {
                        if (o.equals("OK")) {
                            return true;
                        } else {
                            Debug.netMsg("Server sent wrong string as response to authentication challenge!");
                        }
                    } else {
                        Debug.netMsg("Server sent wrong object as response to authentication challenge!");
                    }
                } else {
                    Debug.netMsg("Server sent wrong type for data key!");
                }
            }
        } catch (ClassNotFoundException e) {
            Debug.error("Server authentication response invalid!");
            Debug.error(e.toString());
            e.printStackTrace();
        } catch (NoSuchAlgorithmException e) {
            Debug.netMsg("MD5 Algorithm not present in this JVM!");
            Debug.error(e.toString());
            e.printStackTrace();
        } catch (InvalidKeySpecException e) {
            Debug.netMsg("Error generating cipher, problems with key spec?");
            Debug.error(e.toString());
            e.printStackTrace();
        } catch (InvalidKeyException e) {
            Debug.netMsg("Error genertating cipher, problems with key?");
            Debug.error(e.toString());
            e.printStackTrace();
        } catch (NoSuchPaddingException e) {
            Debug.netMsg("Error generating cipher, problems with padding?");
            Debug.error(e.toString());
            e.printStackTrace();
        } catch (EOFException e) {
            Debug.error("Server closed Stream unexpectedly!");
            Debug.error(e.toString());
            e.printStackTrace();
        } catch (SocketTimeoutException e) {
            Debug.error("Read timeout while authenticating with server!");
            Debug.error(e.toString());
            e.printStackTrace();
        } catch (IOException e) {
            Debug.error("Error reading response during authentication!");
            Debug.error(e.toString());
            e.printStackTrace();
        } catch (IllegalBlockSizeException e) {
            Debug.error("Illegal block size exception!");
            Debug.error(e.toString());
            e.printStackTrace();
        } catch (BadPaddingException e) {
            Debug.error("Bad padding exception!");
            Debug.error(e.toString());
            e.printStackTrace();
        }
        return false;
    }
} </s>
<s>class temp {    public byte[] getEncoded(X509Certificate checkCert, X509Certificate rootCert, String url) {
        try {
            if (checkCert == null || rootCert == null) return null;
            if (url == null) {
                url = PdfPKCS7.getOCSPURL(checkCert);
            }
            if (url == null) return null;
            OCSPReq request = generateOCSPRequest(rootCert, checkCert.getSerialNumber());
            byte[] array = request.getEncoded();
            URL urlt = new URL(url);
            HttpURLConnection con = (HttpURLConnection) urlt.openConnection();
            con.setRequestProperty("Content-Type", "application/ocsp-request");
            con.setRequestProperty("Accept", "application/ocsp-response");
            con.setDoOutput(true);
            OutputStream out = con.getOutputStream();
            DataOutputStream dataOut = new DataOutputStream(new BufferedOutputStream(out));
            dataOut.write(array);
            dataOut.flush();
            dataOut.close();
            if (con.getResponseCode() / 100 != 2) {
                throw new IOException(MessageLocalization.getComposedMessage("invalid.http.response.1", con.getResponseCode()));
            }
            InputStream in = (InputStream) con.getContent();
            OCSPResp ocspResponse = new OCSPResp(RandomAccessFileOrArray.InputStreamToArray(in));
            if (ocspResponse.getStatus() != 0) throw new IOException(MessageLocalization.getComposedMessage("invalid.status.1", ocspResponse.getStatus()));
            BasicOCSPResp basicResponse = (BasicOCSPResp) ocspResponse.getResponseObject();
            if (basicResponse != null) {
                SingleResp[] responses = basicResponse.getResponses();
                if (responses.length == 1) {
                    SingleResp resp = responses[0];
                    Object status = resp.getCertStatus();
                    if (status == CertificateStatus.GOOD) {
                        return basicResponse.getEncoded();
                    } else if (status instanceof org.bouncycastle.ocsp.RevokedStatus) {
                        throw new IOException(MessageLocalization.getComposedMessage("ocsp.status.is.revoked"));
                    } else {
                        throw new IOException(MessageLocalization.getComposedMessage("ocsp.status.is.unknown"));
                    }
                }
            }
        } catch (Exception ex) {
            if (LOGGER.isLogging(Level.ERROR)) LOGGER.error("OcspClientBouncyCastle", ex);
        }
        return null;
    }
} </s>
<s>class temp {    private static String getWebPage(String urlString) throws Exception {
        URL url;
        HttpURLConnection conn;
        BufferedReader rd;
        String line;
        StringBuilder result = new StringBuilder();
        try {
            url = new URL(urlString);
            conn = (HttpURLConnection) url.openConnection();
            conn.setRequestMethod("GET");
            rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));
            while ((line = rd.readLine()) != null) {
                result.append(line);
            }
            rd.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return result.toString();
    }
} </s>
<s>class temp {    public static void doVersionCheck(View view) {
        view.showWaitCursor();
        try {
            URL url = new URL(jEdit.getProperty("version-check.url"));
            InputStream in = url.openStream();
            BufferedReader bin = new BufferedReader(new InputStreamReader(in));
            String line;
            String develBuild = null;
            String stableBuild = null;
            while ((line = bin.readLine()) != null) {
                if (line.startsWith(".build")) develBuild = line.substring(6).trim(); else if (line.startsWith(".stablebuild")) stableBuild = line.substring(12).trim();
            }
            bin.close();
            if (develBuild != null && stableBuild != null) {
                doVersionCheck(view, stableBuild, develBuild);
            }
        } catch (IOException e) {
            String[] args = { jEdit.getProperty("version-check.url"), e.toString() };
            GUIUtilities.error(view, "read-error", args);
        }
        view.hideWaitCursor();
    }
} </s>
<s>class temp {    private static void copyFile(String srFile, String dtFile) {
        try {
            File f1 = new File(srFile);
            File f2 = new File(dtFile);
            InputStream in = new FileInputStream(f1);
            OutputStream out = new FileOutputStream(f2);
            byte[] buf = new byte[1024];
            int len;
            while ((len = in.read(buf)) > 0) out.write(buf, 0, len);
            in.close();
            out.close();
        } catch (FileNotFoundException ex) {
            System.out.println("Error copying " + srFile + " to " + dtFile);
            System.out.println(ex.getMessage() + " in the specified directory.");
        } catch (IOException e) {
            System.out.println(e.getMessage());
        }
    }
} </s>
<s>class temp {    private static void doCopyFile(File srcFile, File destFile, boolean preserveFileDate) throws IOException {
        if (destFile.exists() && destFile.isDirectory()) {
            throw new IOException("Destination '" + destFile + "' exists but is a directory");
        }
        FileChannel input = new FileInputStream(srcFile).getChannel();
        try {
            FileChannel output = new FileOutputStream(destFile).getChannel();
            try {
                output.transferFrom(input, 0, input.size());
            } finally {
                IOUtils.closeQuietly(output);
            }
        } finally {
            IOUtils.closeQuietly(input);
        }
        if (srcFile.length() != destFile.length()) {
            throw new IOException("Failed to copy full contents from '" + srcFile + "' to '" + destFile + "'");
        }
        if (preserveFileDate) {
            destFile.setLastModified(srcFile.lastModified());
        }
    }
} </s>
<s>class temp {    public static void copyURLToFile(URL source, File destination) throws IOException {
        InputStream input = source.openStream();
        try {
            FileOutputStream output = openOutputStream(destination);
            try {
                IOUtils.copy(input, output);
            } finally {
                IOUtils.closeQuietly(output);
            }
        } finally {
            IOUtils.closeQuietly(input);
        }
    }
} </s>
<s>class temp {    public static Checksum checksum(File file, Checksum checksum) throws IOException {
        if (file.isDirectory()) {
            throw new IllegalArgumentException("Checksums can't be computed on directories");
        }
        InputStream in = null;
        try {
            in = new CheckedInputStream(new FileInputStream(file), checksum);
            IOUtils.copy(in, new NullOutputStream());
        } finally {
            IOUtils.closeQuietly(in);
        }
        return checksum;
    }
} </s>
<s>class temp {    public void test(TestHarness harness) {
        harness.checkPoint("TestOfMD4");
        try {
            Security.addProvider(new JarsyncProvider());
            algorithm = MessageDigest.getInstance("BrokenMD4", "JARSYNC");
        } catch (Exception x) {
            harness.debug(x);
            harness.fail("TestOfMD4.provider");
            throw new Error(x);
        }
        try {
            for (int i = 0; i < 64; i++) algorithm.update((byte) 'a');
            byte[] md = algorithm.digest();
            String exp = "755cd64425f260e356f5303ee82a2d5f";
            harness.check(exp.equals(Util.toHexString(md)), "testSixtyFourA");
        } catch (Exception x) {
            harness.debug(x);
            harness.fail("TestOfMD4.provider");
        }
        try {
            harness.verbose("NOTE: This test may take a while.");
            for (int i = 0; i < 536870913; i++) algorithm.update((byte) 'a');
            byte[] md = algorithm.digest();
            String exp = "b6cea9f528a85963f7529a9e3a2153db";
            harness.check(exp.equals(Util.toHexString(md)), "test536870913A");
        } catch (Exception x) {
            harness.debug(x);
            harness.fail("TestOfMD4.provider");
        }
        try {
            byte[] md = algorithm.digest("a".getBytes());
            String exp = "bde52cb31de33e46245e05fbdbd6fb24";
            harness.check(exp.equals(Util.toHexString(md)), "testA");
        } catch (Exception x) {
            harness.debug(x);
            harness.fail("TestOfMD4.testA");
        }
        try {
            byte[] md = algorithm.digest("abc".getBytes());
            String exp = "a448017aaf21d8525fc10ae87aa6729d";
            harness.check(exp.equals(Util.toHexString(md)), "testABC");
        } catch (Exception x) {
            harness.debug(x);
            harness.fail("TestOfMD4.testABC");
        }
        try {
            byte[] md = algorithm.digest("message digest".getBytes());
            String exp = "d9130a8164549fe818874806e1c7014b";
            harness.check(exp.equals(Util.toHexString(md)), "testMessageDigest");
        } catch (Exception x) {
            harness.debug(x);
            harness.fail("TestOfMD4.testMessageDigest");
        }
        try {
            byte[] md = algorithm.digest("abcdefghijklmnopqrstuvwxyz".getBytes());
            String exp = "d79e1c308aa5bbcdeea8ed63df412da9";
            harness.check(exp.equals(Util.toHexString(md)), "testAlphabet");
        } catch (Exception x) {
            harness.debug(x);
            harness.fail("TestOfMD4.testAlphabet");
        }
        try {
            byte[] md = algorithm.digest("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".getBytes());
            String exp = "043f8582f241db351ce627e153e7f0e4";
            harness.check(exp.equals(Util.toHexString(md)), "testAsciiSubset");
        } catch (Exception x) {
            harness.debug(x);
            harness.fail("TestOfMD4.testAsciiSubset");
        }
        try {
            byte[] md = algorithm.digest("12345678901234567890123456789012345678901234567890123456789012345678901234567890".getBytes());
            String exp = "e33b4ddc9c38f2199c3e7b164fcc0536";
            harness.check(exp.equals(Util.toHexString(md)), "testEightyNumerics");
        } catch (Exception x) {
            harness.debug(x);
            harness.fail("TestOfMD4.testEightyNumerics");
        }
        try {
            algorithm.update("a".getBytes(), 0, 1);
            clone = (MessageDigest) algorithm.clone();
            byte[] md = algorithm.digest();
            String exp = "bde52cb31de33e46245e05fbdbd6fb24";
            harness.check(exp.equals(Util.toHexString(md)), "testCloning #1");
            clone.update("bc".getBytes(), 0, 2);
            md = clone.digest();
            exp = "a448017aaf21d8525fc10ae87aa6729d";
            harness.check(exp.equals(Util.toHexString(md)), "testCloning #2");
        } catch (Exception x) {
            harness.debug(x);
            harness.fail("TestOfMD4.testCloning");
        }
    }
} </s>
<s>class temp {    private void displayDiffResults() throws IOException {
        File outFile = File.createTempFile("diff", ".htm");
        outFile.deleteOnExit();
        FileOutputStream outStream = new FileOutputStream(outFile);
        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));
        out.write("<html><head><title>LOC Differences</title>\n" + SCRIPT + "</head>\n" + "<body bgcolor='#ffffff'>\n" + "<div onMouseOver=\"window.defaultStatus='Metrics'\">\n");
        if (addedTable.length() > 0) {
            out.write("<table border><tr><th>Files Added:</th>" + "<th>Add</th><th>Type</th></tr>");
            out.write(addedTable.toString());
            out.write("</table><br><br>");
        }
        if (modifiedTable.length() > 0) {
            out.write("<table border><tr><th>Files Modified:</th>" + "<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>" + "<th>Total</th><th>Type</th></tr>");
            out.write(modifiedTable.toString());
            out.write("</table><br><br>");
        }
        if (deletedTable.length() > 0) {
            out.write("<table border><tr><th>Files Deleted:</th>" + "<th>Del</th><th>Type</th></tr>");
            out.write(deletedTable.toString());
            out.write("</table><br><br>");
        }
        out.write("<table name=METRICS BORDER>\n");
        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {
            out.write("<tr><td>Base:&nbsp;</td><td>");
            out.write(Long.toString(base));
            out.write("</td></tr>\n<tr><td>Deleted:&nbsp;</td><td>");
            out.write(Long.toString(deleted));
            out.write("</td></tr>\n<tr><td>Modified:&nbsp;</td><td>");
            out.write(Long.toString(modified));
            out.write("</td></tr>\n<tr><td>Added:&nbsp;</td><td>");
            out.write(Long.toString(added));
            out.write("</td></tr>\n<tr><td>New & Changed:&nbsp;</td><td>");
            out.write(Long.toString(added + modified));
            out.write("</td></tr>\n");
        }
        out.write("<tr><td>Total:&nbsp;</td><td>");
        out.write(Long.toString(total));
        out.write("</td></tr>\n</table></div>");
        redlinesOut.close();
        out.flush();
        InputStream redlines = new FileInputStream(redlinesTempFile);
        byte[] buffer = new byte[4096];
        int bytesRead;
        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);
        outStream.write("</BODY></HTML>".getBytes());
        outStream.close();
        Browser.launch(outFile.toURL().toString());
    }
} </s>
<s>class temp {    private String save(UploadedFile imageFile) {
        try {
            File saveFld = new File(imageFolder + File.separator + userDisplay.getUser().getUsername());
            if (!saveFld.exists()) {
                if (!saveFld.mkdir()) {
                    logger.info("Unable to create folder: " + saveFld.getAbsolutePath());
                    return null;
                }
            }
            File tmp = File.createTempFile("img", "img");
            IOUtils.copy(imageFile.getInputstream(), new FileOutputStream(tmp));
            File thumbnailImage = new File(saveFld + File.separator + UUID.randomUUID().toString() + ".png");
            File fullResolution = new File(saveFld + File.separator + UUID.randomUUID().toString() + ".png");
            BufferedImage image = ImageIO.read(tmp);
            Image thumbnailIm = image.getScaledInstance(310, 210, Image.SCALE_SMOOTH);
            BufferedImage thumbnailBi = new BufferedImage(thumbnailIm.getWidth(null), thumbnailIm.getHeight(null), BufferedImage.TYPE_INT_RGB);
            Graphics bg = thumbnailBi.getGraphics();
            bg.drawImage(thumbnailIm, 0, 0, null);
            bg.dispose();
            ImageIO.write(thumbnailBi, "png", thumbnailImage);
            ImageIO.write(image, "png", fullResolution);
            if (!tmp.delete()) {
                logger.info("Unable to delete: " + tmp.getAbsolutePath());
            }
            String imageId = UUID.randomUUID().toString();
            imageBean.addImage(imageId, new ImageRecord(imageFile.getFileName(), fullResolution.getAbsolutePath(), thumbnailImage.getAbsolutePath(), userDisplay.getUser().getUsername()));
            return imageId;
        } catch (Throwable t) {
            logger.log(Level.SEVERE, "Unable to save the image.", t);
            return null;
        }
    }
} </s>
<s>class temp {    public List load(String sourceType, Object source, String param) throws Exception {
        if (log.isTraceEnabled()) {
            log.trace("load " + source);
        }
        String location = null;
        String type = null;
        Object inputsource = null;
        if (source instanceof DynamicMBean) {
            sourceType = "MbeansDescriptorsDynamicMBeanSource";
            inputsource = source;
        } else if (source instanceof URL) {
            URL url = (URL) source;
            location = url.toString();
            type = param;
            inputsource = url.openStream();
            if (sourceType == null) {
                sourceType = sourceTypeFromExt(location);
            }
        } else if (source instanceof File) {
            location = ((File) source).getAbsolutePath();
            inputsource = new FileInputStream((File) source);
            type = param;
            if (sourceType == null) {
                sourceType = sourceTypeFromExt(location);
            }
        } else if (source instanceof InputStream) {
            type = param;
            inputsource = source;
        } else if (source instanceof Class) {
            location = ((Class) source).getName();
            type = param;
            inputsource = source;
            if (sourceType == null) {
                sourceType = "MbeansDescriptorsIntrospectionSource";
            }
        }
        if (sourceType == null) {
            sourceType = "MbeansDescriptorsDigesterSource";
        }
        ModelerSource ds = getModelerSource(sourceType);
        List mbeans = ds.loadDescriptors(this, location, type, inputsource);
        return mbeans;
    }
} </s>
<s>class temp {    protected int executeUpdates(List<UpdateStatement> statements, OlVersionCheck olVersionCheck) throws DaoException {
        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("start executeUpdates");
        }
        PreparedStatement stmt = null;
        Connection conn = null;
        int rowsAffected = 0;
        try {
            conn = ds.getConnection();
            conn.setAutoCommit(false);
            conn.rollback();
            conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
            if (olVersionCheck != null) {
                stmt = conn.prepareStatement(olVersionCheck.getQuery());
                stmt.setObject(1, olVersionCheck.getId());
                ResultSet rs = stmt.executeQuery();
                rs.next();
                Number olVersion = (Number) rs.getObject("olVersion");
                stmt.close();
                stmt = null;
                if (olVersion.intValue() != olVersionCheck.getOlVersionToCheck().intValue()) {
                    rowsAffected = -1;
                }
            }
            if (rowsAffected >= 0) {
                for (UpdateStatement query : statements) {
                    stmt = conn.prepareStatement(query.getQuery());
                    if (query.getParams() != null) {
                        for (int parameterIndex = 1; parameterIndex <= query.getParams().length; parameterIndex++) {
                            Object object = query.getParams()[parameterIndex - 1];
                            stmt.setObject(parameterIndex, object);
                        }
                    }
                    if (LOGGER.isDebugEnabled()) {
                        LOGGER.debug(" **** Sending statement:\n" + query.getQuery());
                    }
                    rowsAffected += stmt.executeUpdate();
                    stmt.close();
                    stmt = null;
                }
            }
            conn.commit();
            conn.close();
            conn = null;
        } catch (SQLException e) {
            if ("23000".equals(e.getSQLState())) {
                LOGGER.info("Integrity constraint violation", e);
                throw new UniqueConstaintException();
            }
            throw new DaoException("error.databaseError", e);
        } finally {
            try {
                if (stmt != null) {
                    LOGGER.debug("closing open statement!");
                    stmt.close();
                }
            } catch (SQLException e) {
                throw new DaoException("error.databaseError", e);
            } finally {
                stmt = null;
            }
            try {
                if (conn != null) {
                    LOGGER.debug("rolling back open connection!");
                    conn.rollback();
                    conn.setAutoCommit(true);
                    conn.close();
                }
            } catch (SQLException e) {
                throw new DaoException("error.databaseError", e);
            } finally {
                conn = null;
            }
        }
        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("finish executeUpdates");
        }
        return rowsAffected;
    }
} </s>
<s>class temp {    public static void main(String[] args) throws Exception {
        MessageDigest md = MessageDigest.getInstance("MD5");
        String text = "YUMyfj";
        md.update(text.getBytes(), 0, text.length());
        System.out.println(new BigInteger(1, md.digest()).toString(16).toString());
    }
} </s>

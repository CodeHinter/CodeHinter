<s>class temp {    public void copyFile(String oldPathFile, String newPathFile) {
        try {
            int bytesum = 0;
            int byteread = 0;
            File oldfile = new File(oldPathFile);
            if (oldfile.exists()) {
                InputStream inStream = new FileInputStream(oldPathFile);
                FileOutputStream fs = new FileOutputStream(newPathFile);
                byte[] buffer = new byte[1444];
                while ((byteread = inStream.read(buffer)) != -1) {
                    bytesum += byteread;
                    System.out.println(bytesum);
                    fs.write(buffer, 0, byteread);
                }
                inStream.close();
            }
        } catch (Exception e) {
            message = ("   Ƶ    ļ         ");
        }
    }
} </s>
<s>class temp {    private String copyAndHash(InputStream input, File into) throws IOException {
        MessageDigest digest = createMessageDigest();
        DigestInputStream dis = new DigestInputStream(input, digest);
        IOException ex;
        FileOutputStream fos = null;
        try {
            fos = new FileOutputStream(into);
            IOUtils.copyLarge(dis, fos);
            byte[] hash = digest.digest();
            Formatter formatter = new Formatter();
            for (byte b : hash) {
                formatter.format("%02x", b);
            }
            return formatter.toString();
        } catch (IOException e) {
            ex = e;
        } finally {
            IOUtils.closeQuietly(dis);
            IOUtils.closeQuietly(fos);
        }
        if (logger.isWarnEnabled()) logger.warn("Couldn't retrieve data from input!", ex);
        deleteTempFile(into);
        throw ex;
    }
} </s>
<s>class temp {    private static Long statusSWGCraftTime() {
        long current = System.currentTimeMillis() / 1000L;
        if (current < (previousStatusCheck + SWGCraft.STATUS_CHECK_DELAY)) return previousStatusTime;
        URL url = null;
        try {
            synchronized (previousStatusTime) {
                if (current >= previousStatusCheck + SWGCraft.STATUS_CHECK_DELAY) {
                    url = SWGCraft.getStatusTextURL();
                    String statusTime = ZReader.read(url.openStream());
                    previousStatusTime = Long.valueOf(statusTime);
                    previousStatusCheck = current;
                }
                return previousStatusTime;
            }
        } catch (UnknownHostException e) {
            SWGCraft.showUnknownHostDialog(url, e);
        } catch (Throwable e) {
            SWGAide.printDebug("cmgr", 1, "SWGResourceManager:statusSWGCraftTime:", e.toString());
        }
        return Long.valueOf(0);
    }
} </s>
<s>class temp {    public static String compressFile(String fileName) throws IOException {
        String newFileName = fileName + ".gz";
        FileInputStream fis = new FileInputStream(fileName);
        FileOutputStream fos = new FileOutputStream(newFileName);
        GZIPOutputStream gzos = new GZIPOutputStream(fos);
        byte[] buf = new byte[10000];
        int bytesRead;
        while ((bytesRead = fis.read(buf)) > 0) gzos.write(buf, 0, bytesRead);
        fis.close();
        gzos.close();
        return newFileName;
    }
} </s>
<s>class temp {    public static void compressWithZip(Vector fileList, String zipFileName) throws IOException {
        if (fileList == null || fileList.size() == 0) return;
        FileOutputStream fos = new FileOutputStream(zipFileName);
        ZipOutputStream zos = new ZipOutputStream(fos);
        Iterator iter = fileList.iterator();
        while (iter.hasNext()) {
            String fileName = (String) iter.next();
            int ind = Math.max(fileName.lastIndexOf('/'), fileName.lastIndexOf('\\'));
            String shortName = "unknown";
            if (ind < fileName.length() - 1) shortName = fileName.substring(ind + 1);
            zos.putNextEntry(new ZipEntry(shortName));
            FileInputStream fis = new FileInputStream(fileName);
            byte[] buf = new byte[10000];
            int bytesRead;
            while ((bytesRead = fis.read(buf)) > 0) zos.write(buf, 0, bytesRead);
            fis.close();
            zos.closeEntry();
        }
        zos.close();
    }
} </s>
<s>class temp {    public static String sha1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        MessageDigest md;
        md = MessageDigest.getInstance("SHA-1");
        byte[] sha1hash = new byte[40];
        md.update(text.getBytes("iso-8859-1"), 0, text.length());
        sha1hash = md.digest();
        return convertToHex(sha1hash);
    }
} </s>
<s>class temp {    private void saveStateAsLast(URL url) {
        InputStream sourceStream = null;
        OutputStream destinationStream = null;
        File lastBundlesTxt = getLastBundleInfo();
        try {
            try {
                destinationStream = new FileOutputStream(lastBundlesTxt);
                sourceStream = url.openStream();
                SimpleConfiguratorUtils.transferStreams(sourceStream, destinationStream);
            } finally {
                if (destinationStream != null) destinationStream.close();
                if (sourceStream != null) sourceStream.close();
            }
        } catch (IOException e) {
        }
    }
} </s>
<s>class temp {    public static String stringToHash(String text) {
        MessageDigest md = null;
        try {
            md = MessageDigest.getInstance("SHA-1");
            md.update(text.getBytes("iso-8859-1"), 0, text.length());
        } catch (NoSuchAlgorithmException e) {
            throw new IllegalStateException("Should not happened: SHA-1 algorithm is missing.");
        } catch (UnsupportedEncodingException e) {
            throw new IllegalStateException("Should not happened: Could not encode text bytes '" + text + "' to iso-8859-1.");
        }
        return new String(Base64.encodeBase64(md.digest()));
    }
} </s>
<s>class temp {    public boolean consolidateCrossrefGet(BiblioItem bib, ArrayList<BiblioItem> bib2) throws Exception {
        boolean result = false;
        String doi = bib.getDOI();
        String aut = bib.getFirstAuthorSurname();
        String title = bib.getTitle();
        String firstPage = null;
        String pageRange = bib.getPageRange();
        int beginPage = bib.getBeginPage();
        if (beginPage != -1) {
            firstPage = "" + beginPage;
        } else if (pageRange != null) {
            StringTokenizer st = new StringTokenizer(pageRange, "--");
            if (st.countTokens() == 2) {
                firstPage = st.nextToken();
            } else if (st.countTokens() == 1) firstPage = pageRange;
        }
        if (aut != null) {
            aut = TextUtilities.removeAccents(aut);
        }
        if (title != null) {
            title = TextUtilities.removeAccents(title);
        }
        if (doi != null) {
            if (doi.startsWith("doi:") | doi.startsWith("DOI:")) {
                doi.substring(4, doi.length());
                doi = doi.trim();
            }
            doi = doi.replace(" ", "");
            String xml = null;
            if (cCon != null) {
                PreparedStatement pstmt = null;
                try {
                    pstmt = cCon.prepareStatement(QUERY_CROSSREF_SQL3);
                    pstmt.setString(1, doi);
                    ResultSet res = pstmt.executeQuery();
                    if (res.next()) {
                        xml = res.getString(1);
                    }
                    res.close();
                    pstmt.close();
                } catch (SQLException se) {
                    System.err.println("EXCEPTION HANDLING CROSSREF CACHE");
                    throw new GROBIDServiceException("EXCEPTION HANDLING CROSSREF CACHE.", se);
                } finally {
                    try {
                        if (pstmt != null) pstmt.close();
                    } catch (SQLException se) {
                    }
                }
                if (xml != null) {
                    InputSource is = new InputSource();
                    is.setCharacterStream(new StringReader(xml));
                    DefaultHandler crossref = new crossrefUnixrefSaxParser(bib2);
                    SAXParserFactory spf = SAXParserFactory.newInstance();
                    SAXParser parser = spf.newSAXParser();
                    parser.parse(is, crossref);
                    if (bib2.size() > 0) {
                        if (!bib2.get(0).getError()) result = true;
                    }
                }
            }
            if (xml == null) {
                String subpath = String.format(DOI_BASE_QUERY, crossref_id, crossref_pw, doi);
                URL url = new URL("http://" + crossref_host + "/" + subpath);
                System.out.println("Sending: " + url.toString());
                HttpURLConnection urlConn = null;
                try {
                    urlConn = (HttpURLConnection) url.openConnection();
                } catch (Exception e) {
                    this.setProxy();
                    try {
                        urlConn = (HttpURLConnection) url.openConnection();
                    } catch (Exception e2) {
                        urlConn = null;
                        throw new GROBIDServiceException("An exception occured while running Grobid.", e2);
                    }
                }
                if (urlConn != null) {
                    try {
                        urlConn.setDoOutput(true);
                        urlConn.setDoInput(true);
                        urlConn.setRequestMethod("GET");
                        urlConn.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");
                        InputStream in = urlConn.getInputStream();
                        xml = TextUtilities.convertStreamToString(in);
                        InputSource is = new InputSource();
                        is.setCharacterStream(new StringReader(xml));
                        DefaultHandler crossref = new crossrefUnixrefSaxParser(bib2);
                        SAXParserFactory spf = SAXParserFactory.newInstance();
                        SAXParser parser = spf.newSAXParser();
                        parser.parse(is, crossref);
                        if (bib2.size() > 0) {
                            if (!bib2.get(0).getError()) result = true;
                        }
                        urlConn.disconnect();
                    } catch (Exception e) {
                        System.err.println("Warning: Consolidation set true, " + "but the online connection to Crossref fails.");
                    }
                    if (cCon != null) {
                        PreparedStatement pstmt2 = null;
                        try {
                            pstmt2 = cCon.prepareStatement(INSERT_CROSSREF_SQL3);
                            pstmt2.setString(1, doi);
                            pstmt2.setString(2, xml);
                            pstmt2.executeUpdate();
                            pstmt2.close();
                        } catch (SQLException se) {
                            System.err.println("EXCEPTION HANDLING CROSSREF UPDATE");
                        } finally {
                            try {
                                if (pstmt2 != null) pstmt2.close();
                            } catch (SQLException se) {
                            }
                        }
                    }
                }
            }
        } else if ((title != null) & (aut != null)) {
            String xml = null;
            if (cCon != null) {
                PreparedStatement pstmt = null;
                try {
                    pstmt = cCon.prepareStatement(QUERY_CROSSREF_SQL);
                    pstmt.setString(1, aut);
                    pstmt.setString(2, title);
                    ResultSet res = pstmt.executeQuery();
                    if (res.next()) {
                        xml = res.getString(1);
                    }
                    res.close();
                    pstmt.close();
                } catch (SQLException se) {
                    throw new GROBIDServiceException("EXCEPTION HANDLING CROSSREF CACHE", se);
                } finally {
                    try {
                        if (pstmt != null) pstmt.close();
                    } catch (SQLException se) {
                    }
                }
                if (xml != null) {
                    InputSource is = new InputSource();
                    is.setCharacterStream(new StringReader(xml));
                    DefaultHandler crossref = new crossrefUnixrefSaxParser(bib2);
                    SAXParserFactory spf = SAXParserFactory.newInstance();
                    SAXParser parser = spf.newSAXParser();
                    parser.parse(is, crossref);
                    if (bib2.size() > 0) {
                        if (!bib2.get(0).getError()) result = true;
                    }
                }
            }
            if (xml == null) {
                String subpath = String.format(TITLE_BASE_QUERY, crossref_id, crossref_pw, URLEncoder.encode(title), URLEncoder.encode(aut));
                URL url = new URL("http://" + crossref_host + "/" + subpath);
                System.out.println("Sending: " + url.toString());
                HttpURLConnection urlConn = null;
                try {
                    urlConn = (HttpURLConnection) url.openConnection();
                } catch (Exception e) {
                    this.setProxy();
                    try {
                        urlConn = (HttpURLConnection) url.openConnection();
                    } catch (Exception e2) {
                        urlConn = null;
                        throw new GROBIDServiceException("An exception occured while running Grobid.", e2);
                    }
                }
                if (urlConn != null) {
                    try {
                        urlConn.setDoOutput(true);
                        urlConn.setDoInput(true);
                        urlConn.setRequestMethod("GET");
                        urlConn.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");
                        InputStream in = urlConn.getInputStream();
                        xml = TextUtilities.convertStreamToString(in);
                        InputSource is = new InputSource();
                        is.setCharacterStream(new StringReader(xml));
                        DefaultHandler crossref = new crossrefUnixrefSaxParser(bib2);
                        SAXParserFactory spf = SAXParserFactory.newInstance();
                        SAXParser parser = spf.newSAXParser();
                        parser.parse(is, crossref);
                        if (bib2.size() > 0) {
                            if (!bib2.get(0).getError()) result = true;
                        }
                        urlConn.disconnect();
                    } catch (Exception e) {
                        System.err.println("Warning: Consolidation set true, " + "but the online connection to Crossref fails.");
                    }
                    if (cCon != null) {
                        PreparedStatement pstmt2 = null;
                        try {
                            pstmt2 = cCon.prepareStatement(INSERT_CROSSREF_SQL);
                            pstmt2.setString(1, aut);
                            pstmt2.setString(2, bib.getTitle());
                            pstmt2.setString(3, xml);
                            pstmt2.executeUpdate();
                            pstmt2.close();
                        } catch (SQLException se) {
                            System.err.println("EXCEPTION HANDLING CROSSREF UPDATE");
                        } finally {
                            try {
                                if (pstmt2 != null) pstmt2.close();
                            } catch (SQLException se) {
                            }
                        }
                    }
                }
            }
        } else if ((firstPage != null) & (bib.getJournal() != null) & (bib.getVolume() != null)) {
            String subpath = String.format(JOURNAL_BASE_QUERY, crossref_id, crossref_pw, URLEncoder.encode(bib.getJournal()), URLEncoder.encode(bib.getVolume()), firstPage);
            URL url = new URL("http://" + crossref_host + "/" + subpath);
            String urlmsg = url.toString();
            System.out.println(urlmsg);
            String xml = null;
            if (cCon != null) {
                PreparedStatement pstmt = null;
                try {
                    pstmt = cCon.prepareStatement(QUERY_CROSSREF_SQL2);
                    pstmt.setString(1, urlmsg);
                    ResultSet res = pstmt.executeQuery();
                    if (res.next()) {
                        xml = res.getString(1);
                    }
                    res.close();
                    pstmt.close();
                } catch (SQLException se) {
                    System.err.println("EXCEPTION HANDLING CROSSREF CACHE");
                    throw new GROBIDServiceException("EXCEPTION HANDLING CROSSREF CACHE.", se);
                } finally {
                    try {
                        if (pstmt != null) pstmt.close();
                    } catch (SQLException se) {
                    }
                }
                if (xml != null) {
                    InputSource is = new InputSource();
                    is.setCharacterStream(new StringReader(xml));
                    DefaultHandler crossref = new crossrefUnixrefSaxParser(bib2);
                    SAXParserFactory spf = SAXParserFactory.newInstance();
                    SAXParser parser = spf.newSAXParser();
                    parser.parse(is, crossref);
                    if (bib2.size() > 0) {
                        if (!bib2.get(0).getError()) result = true;
                    }
                }
            }
            if (xml == null) {
                System.out.println("Sending: " + urlmsg);
                HttpURLConnection urlConn = null;
                try {
                    urlConn = (HttpURLConnection) url.openConnection();
                } catch (Exception e) {
                    this.setProxy();
                    try {
                        urlConn = (HttpURLConnection) url.openConnection();
                    } catch (Exception e2) {
                        urlConn = null;
                        throw new GROBIDServiceException("An exception occured while running Grobid.", e2);
                    }
                }
                if (urlConn != null) {
                    try {
                        urlConn.setDoOutput(true);
                        urlConn.setDoInput(true);
                        urlConn.setRequestMethod("GET");
                        urlConn.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");
                        InputStream in = urlConn.getInputStream();
                        xml = TextUtilities.convertStreamToString(in);
                        InputSource is = new InputSource();
                        is.setCharacterStream(new StringReader(xml));
                        DefaultHandler crossref = new crossrefUnixrefSaxParser(bib2);
                        SAXParserFactory spf = SAXParserFactory.newInstance();
                        SAXParser p = spf.newSAXParser();
                        p.parse(is, crossref);
                        if (bib2.size() > 0) {
                            if (!bib2.get(0).getError()) result = true;
                        }
                        in.close();
                        urlConn.disconnect();
                    } catch (Exception e) {
                        System.err.println("Warning: Consolidation set true, " + "but the online connection to Crossref fails.");
                    }
                    if (cCon != null) {
                        PreparedStatement pstmt2 = null;
                        try {
                            pstmt2 = cCon.prepareStatement(INSERT_CROSSREF_SQL2);
                            pstmt2.setString(1, urlmsg);
                            pstmt2.setString(2, xml);
                            pstmt2.executeUpdate();
                            pstmt2.close();
                        } catch (SQLException se) {
                            System.err.println("EXCEPTION HANDLING CROSSREF UPDATE");
                        } finally {
                            try {
                                if (pstmt2 != null) pstmt2.close();
                            } catch (SQLException se) {
                            }
                        }
                    }
                }
            }
        }
        return result;
    }
} </s>
<s>class temp {    private String encryptPassword(String password) throws NoSuchAlgorithmException {
        StringBuffer encryptedPassword = new StringBuffer();
        MessageDigest md5 = MessageDigest.getInstance("MD5");
        md5.reset();
        md5.update(password.getBytes());
        byte digest[] = md5.digest();
        for (int i = 0; i < digest.length; i++) {
            String hex = Integer.toHexString(0xFF & digest[i]);
            if (hex.length() == 1) {
                encryptedPassword.append('0');
            }
            encryptedPassword.append(hex);
        }
        return encryptedPassword.toString();
    }
} </s>
<s>class temp {    public FTPUtil(final String server) {
        log.debug("~ftp.FTPUtil() : Creating object");
        ftpClient = new FTPClient();
        try {
            ftpClient.connect(server);
            ftpClient.login("anonymous", "");
            ftpClient.setConnectTimeout(120000);
            ftpClient.setSoTimeout(120000);
            final int reply = ftpClient.getReplyCode();
            if (!FTPReply.isPositiveCompletion(reply)) {
                final String errMsg = "Non-positive completion connecting FTPClient";
                log.warn("~ftp.FTPUtil() : [" + errMsg + "]");
            }
        } catch (IOException ioe) {
            final String errMsg = "Cannot connect and login to ftpClient [" + ioe.getMessage() + "]";
            log.warn("~ftp.FTPUtil() : [" + errMsg + "]");
            ioe.printStackTrace();
        }
    }
} </s>
<s>class temp {    protected Set<String> moduleNamesFromReader(URL url) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));
        Set<String> names = new HashSet<String>();
        String line;
        while ((line = reader.readLine()) != null) {
            line = line.trim();
            Matcher m = nonCommentPattern.matcher(line);
            if (m.find()) {
                names.add(m.group().trim());
            }
        }
        return names;
    }
} </s>
<s>class temp {    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        response.setContentType("text/plain;charset=UTF-8");
        request.setCharacterEncoding("utf-8");
        HttpURLConnection httpConn = null;
        byte[] result = null;
        try {
            byte[] bytes = HttpUtil.getHttpURLReturnData(request);
            if (-1 == bytes.length || 23 > bytes.length) throw new Exception();
            MsgPrint.showMsg("========byte length" + bytes.length);
            String userTag = request.getParameter("userTag");
            String isEncrypt = request.getParameter("isEncrypt");
            URL httpurl = new URL(ProtocolContanst.TRANSFERS_URL + userTag + "&isEncrypt=" + isEncrypt);
            httpConn = (HttpURLConnection) httpurl.openConnection();
            httpConn.setDoOutput(true);
            httpConn.setRequestProperty("Content-Length", String.valueOf(bytes.length));
            OutputStream outputStream = httpConn.getOutputStream();
            outputStream.write(bytes);
            outputStream.close();
            InputStream is = httpConn.getInputStream();
            if (0 >= httpConn.getContentLength()) {
                throw new Exception();
            }
            byte[] resultBytes = new byte[httpConn.getContentLength()];
            byte[] tempByte = new byte[1024];
            int length = 0;
            int index = 0;
            while ((length = is.read(tempByte)) != -1) {
                System.arraycopy(tempByte, 0, resultBytes, index, length);
                index += length;
            }
            is.close();
            result = resultBytes;
        } catch (Exception e) {
        }
        ServletOutputStream sos = response.getOutputStream();
        if (null != result) {
            response.setContentLength(result.length);
            sos.write(result);
        } else {
            response.setContentLength(26);
            sos.write(new byte[] { 48, 48, 55, -23, 3, 56, 49, 54, 57, 55, 49, 51, 54, 72, 71, 52, 48, 1, 3, 3, 48, 48, 48, 48, 48, 48 });
        }
        sos.flush();
        sos.close();
    }
} </s>
<s>class temp {    public File sendPayload(SoapEnvelope payload, URL url) throws IOException {
        URLConnection conn = null;
        File tempFile = null;
        Logger l = Logger.instance();
        String className = getClass().getName();
        l.log(Logger.DEBUG, loggerPrefix, className + ".sendPayload", "sending payload to " + url.toString());
        try {
            conn = url.openConnection();
            conn.setDoOutput(true);
            payload.writeTo(conn.getOutputStream());
            tempFile = readIntoTempFile(conn.getInputStream());
        } catch (IOException ioe) {
            l.log(Logger.ERROR, loggerPrefix, className + ".sendPayload", ioe);
            throw ioe;
        } finally {
            conn = null;
        }
        l.log(Logger.DEBUG, loggerPrefix, className + ".sendPayload", "received response");
        return tempFile;
    }
} </s>
<s>class temp {    public File getURL(URL url) throws IOException {
        URLConnection conn = null;
        File tempFile = null;
        Logger l = Logger.instance();
        String className = getClass().getName();
        l.log(Logger.DEBUG, loggerPrefix, className + ".getURL", "GET URL " + url.toString());
        try {
            conn = url.openConnection();
            tempFile = readIntoTempFile(conn.getInputStream());
        } catch (IOException ioe) {
            l.log(Logger.ERROR, loggerPrefix, className + ".getURL", ioe);
            throw ioe;
        } finally {
            conn = null;
        }
        l.log(Logger.DEBUG, loggerPrefix, className + ".getURL", "received URL");
        return tempFile;
    }
} </s>
<s>class temp {    public void testRetrieve() throws DigitalObjectManager.DigitalObjectNotFoundException, URISyntaxException, IOException {
        DigitalObjectManager man = new FedoraObjectManager("fedoraAdmin", "fedoraAdminPass", "http://localhost:7910/fedora");
        DigitalObject r = man.retrieve(new URI("demo:dc2mods.1"));
        String title = r.getTitle();
        List<Metadata> met = r.getMetadata();
        InputStream content = r.getContent().read();
        StringWriter theString = new StringWriter();
        IOUtils.copy(content, theString);
        assertNotNull(theString.toString(), "Content should not be null");
        assertNotNull(title, "The title should be set");
        assertNotNull(met.get(0).getContent(), "There should be some metadata");
    }
} </s>
<s>class temp {    public static void copyFile(File in, File out) throws IOException {
        FileChannel inChannel = new FileInputStream(in).getChannel();
        FileChannel outChannel = new FileOutputStream(out).getChannel();
        try {
            inChannel.transferTo(0, inChannel.size(), outChannel);
        } catch (IOException e) {
            throw e;
        } finally {
            if (inChannel != null) {
                inChannel.close();
            }
            if (outChannel != null) {
                outChannel.close();
            }
        }
    }
} </s>
<s>class temp {    public static void main(final String args[]) {
        if (args.length < 2 || (args.length == 3 && !"-d".equals(args[0]))) {
            System.out.println("Usage: AdapterGenerator [Options] <PrologFile> <ClassPath>");
            System.out.println("       where the framework is the first element in the class path");
            System.out.println("Options: -d Enables the generation of debug output");
            return;
        }
        boolean debug = args.length == 3;
        File prologFile = new File(debug ? args[1] : args[0]);
        if (!prologFile.isFile()) {
            System.out.println("The given file does not exist.");
            return;
        }
        File targetFile = new File(prologFile.getParentFile(), prologFile.getName().substring(0, prologFile.getName().lastIndexOf(".")) + ".jar");
        String source;
        try {
            source = FileUtils.readFileToString(prologFile);
        } catch (IOException ex) {
            System.out.println("Error reading file: " + ex.getMessage());
            return;
        }
        Parser myParser = new PrologParserImpl();
        PrologProgram myProgram;
        try {
            myProgram = (PrologProgram) myParser.parse(source);
        } catch (Exception ex) {
            System.out.println("Could not parse file: " + ex.getMessage());
            return;
        }
        try {
            FactVisitor myVisitor = new FactVisitor();
            myVisitor.visit(myProgram);
            Map<String, TypeGenerationInfo> adapterLayer = myVisitor.getAdapterLayer();
            if (adapterLayer.size() == 0) {
                System.out.println("No adapters to generate, " + "did you forget to run the comeback rules?");
                return;
            }
            URLClassLoader classLoader = createClassLoaderFromClassPath(debug ? args[2] : args[1]);
            ClassWriter adapterWriter = new ClassWriter(new JarEntryWriter(targetFile));
            AdapterAnnotationGenerator annotationGenerator = new AdapterAnnotationGenerator();
            Type annotationType = Type.getObjectType("net/sourceforge/comeback/Adapter");
            adapterWriter.writeClass(annotationType.getClassName(), annotationGenerator.createAnnotation(annotationType));
            AdapterLookupGenerator lookupWriter = new AdapterLookupGenerator(Type.getObjectType("net/sourceforge/comeback/Adapters"), annotationType);
            GenerationContext context = new GenerationContext(adapterLayer, classLoader, annotationType, lookupWriter, adapterWriter);
            context.setGenerateDebugOutput(debug);
            Iterator<TypeGenerationInfo> iterator = adapterLayer.values().iterator();
            while (iterator.hasNext()) {
                TypeGenerationInfo info = iterator.next();
                context.generateAdapter(info);
            }
            ByteArrayOutputStream serialized = new ByteArrayOutputStream();
            ObjectOutputStream out = new ObjectOutputStream(serialized);
            out.writeObject(adapterLayer);
            out.close();
            adapterWriter.writeResource("net/sourceforge/comeback/adapterlayer.ser", serialized.toByteArray());
            String[] sharedClassesPrefixes = new String[2];
            Assembler assembler = new Assembler(adapterWriter);
            PatternClassFilter filter = new PatternClassFilter();
            URL url = Main.class.getResource("/" + Main.class.getName().replace('.', '/') + ".class");
            JarURLConnection connection = (JarURLConnection) url.openConnection();
            sharedClassesPrefixes[0] = assembler.assemble(connection.getJarFile(), filter);
            filter = new PatternClassFilter();
            url = Type.class.getResource("/" + Type.class.getName().replace('.', '/') + ".class");
            connection = (JarURLConnection) url.openConnection();
            sharedClassesPrefixes[1] = assembler.assemble(connection.getJarFile(), filter);
            String tmp = debug ? args[2] : args[1];
            adapterWriter.writeClass(lookupWriter.getType().getClassName(), lookupWriter.createAdapterLookup(adapterLayer.values(), tmp.substring(tmp.lastIndexOf(File.pathSeparator) + 1), sharedClassesPrefixes));
            adapterWriter.close();
        } catch (Throwable e) {
            e.printStackTrace();
            return;
        }
    }
} </s>
<s>class temp {    protected void innerProcess(ProcessorURI curi) throws InterruptedException {
        Pattern regexpr = curi.get(this, STRIP_REG_EXPR);
        ReplayCharSequence cs = null;
        try {
            cs = curi.getRecorder().getReplayCharSequence();
        } catch (Exception e) {
            curi.getNonFatalFailures().add(e);
            logger.warning("Failed get of replay char sequence " + curi.toString() + " " + e.getMessage() + " " + Thread.currentThread().getName());
            return;
        }
        MessageDigest digest = null;
        try {
            try {
                digest = MessageDigest.getInstance(SHA1);
            } catch (NoSuchAlgorithmException e1) {
                e1.printStackTrace();
                return;
            }
            digest.reset();
            String s = null;
            if (regexpr != null) {
                s = cs.toString();
            } else {
                Matcher m = regexpr.matcher(cs);
                s = m.replaceAll(" ");
            }
            digest.update(s.getBytes());
            byte[] newDigestValue = digest.digest();
            curi.setContentDigest(SHA1, newDigestValue);
        } finally {
            if (cs != null) {
                try {
                    cs.close();
                } catch (IOException ioe) {
                    logger.warning(TextUtils.exceptionToString("Failed close of ReplayCharSequence.", ioe));
                }
            }
        }
    }
} </s>
<s>class temp {    public byte[] getCoded(String name, String pass) {
        byte[] digest = null;
        if (pass != null && 0 < pass.length()) {
            try {
                MessageDigest md = MessageDigest.getInstance("SHA-1");
                md.update(name.getBytes());
                md.update(pass.getBytes());
                digest = md.digest();
            } catch (Exception e) {
                e.printStackTrace();
                digest = null;
            }
        }
        return digest;
    }
} </s>
<s>class temp {    protected static String getInitialUUID() {
        if (myRand == null) {
            myRand = new Random();
        }
        long rand = myRand.nextLong();
        String sid;
        try {
            sid = InetAddress.getLocalHost().toString();
        } catch (UnknownHostException e) {
            sid = Thread.currentThread().getName();
        }
        StringBuffer sb = new StringBuffer();
        sb.append(sid);
        sb.append(":");
        sb.append(Long.toString(rand));
        MessageDigest md5 = null;
        try {
            md5 = MessageDigest.getInstance("MD5");
        } catch (NoSuchAlgorithmException e) {
        }
        md5.update(sb.toString().getBytes());
        byte[] array = md5.digest();
        StringBuffer sb2 = new StringBuffer();
        for (int j = 0; j < array.length; ++j) {
            int b = array[j] & 0xFF;
            sb2.append(Integer.toHexString(b));
        }
        int begin = myRand.nextInt();
        if (begin < 0) begin = begin * -1;
        begin = begin % 8;
        return sb2.toString().substring(begin, begin + 18).toUpperCase();
    }
} </s>
<s>class temp {    @SuppressWarnings("unchecked")
    public static <T> List<T> getServices(String service) {
        String serviceUri = "META-INF/services/" + service;
        ClassLoader loader = Thread.currentThread().getContextClassLoader();
        try {
            Enumeration<URL> urls = loader.getResources(serviceUri);
            if (urls.hasMoreElements()) {
                List<T> services = new ArrayList<T>(1);
                do {
                    URL url = urls.nextElement();
                    _LOG.finest("Processing:{0}", url);
                    try {
                        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));
                        try {
                            while (true) {
                                String line = in.readLine();
                                if (line == null) break;
                                T instance = (T) _parseLine(loader, line);
                                if (instance != null) services.add(instance);
                            }
                        } finally {
                            in.close();
                        }
                    } catch (Exception e) {
                        _LOG.warning("ERR_PARSING_URL", url);
                        _LOG.warning(e);
                    }
                } while (urls.hasMoreElements());
                if (services.size() == 1) return Collections.singletonList(services.get(0));
                return Collections.unmodifiableList(services);
            }
        } catch (IOException e) {
            _LOG.severe("ERR_LOADING_RESROUCE", serviceUri);
            _LOG.severe(e);
        }
        return Collections.emptyList();
    }
} </s>
<s>class temp {    private static String format(String check) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        check = check.replaceAll(" ", "");
        MessageDigest md5 = MessageDigest.getInstance("MD5");
        md5.update(check.getBytes("ISO-8859-1"));
        byte[] end = md5.digest();
        String digest = "";
        for (int i = 0; i < end.length; i++) {
            digest += ((end[i] & 0xff) < 16 ? "0" : "") + Integer.toHexString(end[i] & 0xff);
        }
        return digest;
    }
} </s>
<s>class temp {    public static void copy(FileInputStream source, FileOutputStream dest) throws IOException {
        FileChannel in = null, out = null;
        try {
            in = source.getChannel();
            out = dest.getChannel();
            long size = in.size();
            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);
            out.write(buf);
        } finally {
            if (in != null) in.close();
            if (out != null) out.close();
        }
    }
} </s>
<s>class temp {    private static synchronized void find(String name) throws SAXException, IOException {
        if (c_cache.containsKey(name)) return;
        CustomHandler handler = null;
        URL url = null;
        String validatorFiles = (String) Config.getProperty(Config.PROP_RULES_ENGINE_VALIDATORS_URL_LIST, XML_FILE);
        for (StringTokenizer strtknzr = new StringTokenizer(validatorFiles, ","); strtknzr.hasMoreTokens(); ) {
            String validatorFile = strtknzr.nextToken();
            try {
                url = URLHelper.newExtendedURL(validatorFile);
            } catch (MalformedURLException e) {
                url = null;
            }
            if (url == null) throw new FileNotFoundException("File not found - " + validatorFile);
            try {
                handler = new CustomHandler(name);
                XMLReader reader = XMLReaderFactory.createXMLReader(PARSER_NAME);
                reader.setContentHandler(handler);
                reader.setEntityResolver(new DefaultEntityResolver());
                reader.setErrorHandler(new DefaultErrorHandler());
                reader.parse(new InputSource(url.openStream()));
            } catch (SAXException e) {
                if (SUCCESS_MESSAGE.equals(e.getMessage()) && handler != null) break; else throw e;
            } catch (IOException e) {
                throw e;
            }
            if (handler.getFieldValidatorMetaData() != null) break;
        }
        c_cache.put(name, handler != null ? handler.getFieldValidatorMetaData() : null);
    }
} </s>
<s>class temp {    @Test
    public void shouldDownloadFileUsingPublicLink() throws Exception {
        String bucketName = "test-" + UUID.randomUUID();
        Service service = new WebClientService(credentials);
        service.createBucket(bucketName);
        File file = folder.newFile("foo.txt");
        FileUtils.writeStringToFile(file, UUID.randomUUID().toString());
        service.createObject(bucketName, file.getName(), file, new NullProgressListener());
        String publicUrl = service.getPublicUrl(bucketName, file.getName(), new DateTime().plusDays(5));
        File saved = folder.newFile("saved.txt");
        InputStream input = new URL(publicUrl).openConnection().getInputStream();
        FileOutputStream output = new FileOutputStream(saved);
        IOUtils.copy(input, output);
        output.close();
        assertThat("Corrupted download", Files.computeMD5(saved), equalTo(Files.computeMD5(file)));
        service.deleteObject(bucketName, file.getName());
        service.deleteBucket(bucketName);
    }
} </s>
<s>class temp {    public static String encryptSHA(String pwd) throws NoSuchAlgorithmException {
        MessageDigest d = java.security.MessageDigest.getInstance("SHA-1");
        d.reset();
        d.update(pwd.getBytes());
        BASE64Encoder encoder = new BASE64Encoder();
        return encoder.encode(d.digest());
    }
} </s>
<s>class temp {        public synchronized void run() {
            String s;
            URL url = null;
            try {
                String localVersionS = globals.getProperty("jmathlib.version").replaceAll("/", ".");
                url = new URL(updateSiteS + "?jmathlib_version=" + localVersionS + "&command=check");
            } catch (Exception e) {
                throwMathLibException("checkForUpdates: malformed url");
            }
            Properties props = new Properties();
            try {
                props.load(url.openStream());
            } catch (Exception e) {
                ErrorLogger.debugLine("checkForUpdates: Properties error");
            }
            String localVersionS = globals.getProperty("jmathlib.version");
            String updateVersionS = props.getProperty("update.toversion");
            String updateActionS = props.getProperty("update.action");
            if (updateActionS.equals("INCREMENTAL_DOWNLOAD")) {
                if (!silentB) {
                    globals.getInterpreter().displayText("A full download ist required");
                    globals.getInterpreter().displayText("A new version " + updateVersionS + " is available");
                    globals.getInterpreter().displayText("\n Just type    update    at the prompt.");
                }
            } else if (updateActionS.equals("FULL_DOWNLOAD_REQUIRED")) {
                if (!silentB) {
                    globals.getInterpreter().displayText("A full download ist required");
                    globals.getInterpreter().displayText("A new version " + updateVersionS + " is available");
                    globals.getInterpreter().displayText("Go to www.jmathlib.de and download the latest version");
                }
            } else if (updateActionS.equals("NO_ACTION")) {
                if (!silentB) globals.getInterpreter().displayText("The local version of JMathLib is up to date");
            } else if (updateActionS.equals("VERSION_UNKNOWN")) {
                if (!silentB) globals.getInterpreter().displayText("The local version of JMathLib ist not recognized by the server");
            } else {
                globals.getInterpreter().displayText("check for updates encountered an error.");
            }
            debugLine("checkForUpdates: web:" + updateVersionS + " local:" + localVersionS);
            Calendar cal = Calendar.getInstance();
            String checkedDate = Integer.toString(cal.get(Calendar.YEAR)) + "/" + Integer.toString(cal.get(Calendar.MONTH) + 1) + "/" + Integer.toString(cal.get(Calendar.DAY_OF_MONTH));
            globals.setProperty("update.date.last", checkedDate);
            Enumeration propnames = props.propertyNames();
            while (propnames.hasMoreElements()) {
                String propName = (String) propnames.nextElement();
                String propValue = (String) props.getProperty(propName);
                ErrorLogger.debugLine("Property: " + propName + " = " + propValue);
                globals.setProperty(propName, propValue);
            }
        }
} </s>
<s>class temp {    protected static void copyFile(File from, File to) throws IOException {
        if (!from.isFile() || !to.isFile()) {
            throw new IOException("Both parameters must be files. from is " + from.isFile() + ", to is " + to.isFile());
        }
        FileChannel in = (new FileInputStream(from)).getChannel();
        FileChannel out = (new FileOutputStream(to)).getChannel();
        in.transferTo(0, from.length(), out);
        in.close();
        out.close();
    }
} </s>
<s>class temp {    public synchronized String encrypt(String plaintext) throws PasswordException {
        MessageDigest md = null;
        try {
            md = MessageDigest.getInstance("SHA");
        } catch (NoSuchAlgorithmException e) {
            throw new PasswordException(e.getMessage());
        }
        try {
            md.update(plaintext.getBytes("UTF-8"));
        } catch (UnsupportedEncodingException e) {
            throw new PasswordException(e.getMessage());
        }
        byte raw[] = md.digest();
        String hash = (new Base64Encoder()).encode(raw);
        return hash;
    }
} </s>
<s>class temp {    private void runGetAppListing() {
        DataStorage.clearAppListings();
        GenericUrl url = new GoogleUrl(EnterpriseMarketplaceUrl.generateAppListingUrl() + DataStorage.getVendorProfile().vendorId);
        AppListingList appListingList;
        try {
            HttpRequest request = requestFactory.buildGetRequest(url);
            request.addParser(jsonHttpParser);
            request.readTimeout = readTimeout;
            HttpResponse response = request.execute();
            appListingList = response.parseAs(AppListingList.class);
            if (appListingList != null && appListingList.appListings != null) {
                operationStatus = true;
                DataStorage.setAppListings(appListingList.appListings);
            }
            response.getContent().close();
        } catch (IOException e) {
            AppsMarketplacePluginLog.logError(e);
        }
    }
} </s>
<s>class temp {    private void runGetVendorProfile() {
        DataStorage.clearVendorProfile();
        GenericUrl url = new GoogleUrl(EnterpriseMarketplaceUrl.generateVendorProfileUrl());
        VendorProfile vendorProfile = null;
        try {
            HttpRequest request = requestFactory.buildGetRequest(url);
            request.addParser(jsonHttpParser);
            request.readTimeout = readTimeout;
            HttpResponse response = request.execute();
            vendorProfile = response.parseAs(VendorProfile.class);
            if (vendorProfile != null && vendorProfile.vendorId != null && vendorProfile.email != null && !StringUtilities.isEmpty(vendorProfile.email)) {
                DataStorage.setVendorProfile(vendorProfile);
                operationStatus = true;
            }
            response.getContent().close();
        } catch (IOException e) {
            AppsMarketplacePluginLog.logError(e);
        }
    }
} </s>
<s>class temp {    private void runUpdateAppListing() {
        DataStorage.clearListedAppListing();
        GenericUrl url = new GoogleUrl(EnterpriseMarketplaceUrl.generateAppListingUrl() + DataStorage.getVendorProfile().vendorId);
        AppListing appListingBody = buildAppListing(appsMarketplaceProject);
        JsonHttpContent content = new JsonHttpContent();
        content.jsonFactory = jsonFactory;
        if (appListingBody != null) {
            content.data = appListingBody;
        }
        AppListing appListing;
        try {
            HttpRequest request = requestFactory.buildPutRequest(url, content);
            request.addParser(jsonHttpParser);
            request.readTimeout = readTimeout;
            HttpResponse response = request.execute();
            appListing = response.parseAs(AppListing.class);
            operationStatus = validateAppListing(appListing, appListingBody);
            if (operationStatus) {
                DataStorage.setListedAppListing(appListing);
            }
            response.getContent().close();
        } catch (IOException e) {
            AppsMarketplacePluginLog.logError(e);
        }
    }
} </s>
<s>class temp {    private static List<InputMethodDescriptor> loadIMDescriptors() {
        String nm = SERVICES + InputMethodDescriptor.class.getName();
        Enumeration<URL> en;
        LinkedList<InputMethodDescriptor> imdList = new LinkedList<InputMethodDescriptor>();
        NativeIM nativeIM = ContextStorage.getNativeIM();
        imdList.add(nativeIM);
        try {
            en = ClassLoader.getSystemResources(nm);
            ClassLoader cl = ClassLoader.getSystemClassLoader();
            while (en.hasMoreElements()) {
                URL url = en.nextElement();
                InputStreamReader isr = new InputStreamReader(url.openStream(), "UTF-8");
                BufferedReader br = new BufferedReader(isr);
                String str = br.readLine();
                while (str != null) {
                    str = str.trim();
                    int comPos = str.indexOf("#");
                    if (comPos >= 0) {
                        str = str.substring(0, comPos);
                    }
                    if (str.length() > 0) {
                        imdList.add((InputMethodDescriptor) cl.loadClass(str).newInstance());
                    }
                    str = br.readLine();
                }
            }
        } catch (Exception e) {
        }
        return imdList;
    }
} </s>
<s>class temp {    public static String encodeByMd5(String str) {
        try {
            if (str == null) {
                str = "";
            }
            MessageDigest md5 = MessageDigest.getInstance("MD5");
            md5.update(str.getBytes("utf-8"));
            byte[] b = md5.digest();
            int i;
            StringBuffer buff = new StringBuffer("");
            for (int offset = 0; offset < b.length; offset++) {
                i = b[offset];
                if (i < 0) {
                    i += 256;
                }
                if (i < 16) {
                    buff.append("0");
                }
                buff.append(Integer.toHexString(i));
            }
            return buff.toString();
        } catch (Exception e) {
            return str;
        }
    }
} </s>
<s>class temp {    private void generateGuid() throws NoSuchAlgorithmException {
        MessageDigest md5 = MessageDigest.getInstance("MD5");
        StringBuilder stringToDigest = new StringBuilder();
        long time = System.currentTimeMillis();
        long rand = random.nextLong();
        stringToDigest.append(time);
        stringToDigest.append("-");
        stringToDigest.append(rand);
        md5.update(stringToDigest.toString().getBytes());
        byte[] digestBytes = md5.digest();
        StringBuilder digest = new StringBuilder();
        for (int i = 0; i < digestBytes.length; ++i) {
            int b = digestBytes[i] & 0xFF;
            if (b < 0x10) {
                digest.append('0');
            }
            digest.append(Integer.toHexString(b));
        }
        guid = digest.toString();
    }
} </s>
<s>class temp {    protected boolean downloadFile(TestThread thread, ActionResult result) {
        result.setRequestString("download file " + remoteFile);
        InputStream input = null;
        OutputStream output = null;
        OutputStream target = null;
        boolean status = false;
        ftpClient.enterLocalPassiveMode();
        try {
            if (localFile != null) {
                File lcFile = new File(localFile);
                if (lcFile.exists() && lcFile.isDirectory()) output = new FileOutputStream(new File(lcFile, remoteFile)); else output = new FileOutputStream(lcFile);
                target = output;
            } else {
                target = new FileOutputStream(remoteFile);
            }
            input = ftpClient.retrieveFileStream(remoteFile);
            long bytes = IOUtils.copy(input, target);
            status = bytes > 0;
            if (status) {
                result.setResponseLength(bytes);
            }
        } catch (Exception e) {
            result.setException(new TestActionException(config, e));
        } finally {
            IOUtils.closeQuietly(input);
            IOUtils.closeQuietly(output);
        }
        return status;
    }
} </s>
<s>class temp {    public boolean login(URL strUrl, String loginName, String loginPwd, String sessionID) throws Exception {
        String starter = "-----------------------------";
        String returnChar = "\r\n";
        String lineEnd = "--";
        URL urlString = strUrl;
        String input = null;
        List txtList = new ArrayList();
        List fileList = new ArrayList();
        String targetFile = null;
        String actionStatus = null;
        StringBuffer returnMessage = new StringBuffer();
        List head = new ArrayList();
        final String boundary = String.valueOf(System.currentTimeMillis());
        URL url = null;
        URLConnection conn = null;
        BufferedReader br = null;
        DataOutputStream dos = null;
        boolean isLogin = false;
        txtList.add(new HtmlFormText("loginName", loginName));
        txtList.add(new HtmlFormText("loginPwd", loginPwd));
        txtList.add(new HtmlFormText("navMode", "I"));
        txtList.add(new HtmlFormText("action", "login"));
        try {
            url = new URL(urlString, "/" + projectName + "/Login.do");
            conn = url.openConnection();
            ((HttpURLConnection) conn).setRequestMethod("POST");
            conn.setDoInput(true);
            conn.setDoOutput(true);
            conn.setUseCaches(false);
            conn.setRequestProperty("Content-Type", "multipart/form-data, boundary=" + "---------------------------" + boundary);
            if (input != null) {
                String auth = "Basic " + new sun.misc.BASE64Encoder().encode(input.getBytes());
                conn.setRequestProperty("Authorization", auth);
            }
            dos = new DataOutputStream(conn.getOutputStream());
            dos.write((starter + boundary + returnChar).getBytes());
            for (int i = 0; i < txtList.size(); i++) {
                HtmlFormText htmltext = (HtmlFormText) txtList.get(i);
                dos.write(htmltext.getTranslated());
                if (i + 1 < txtList.size()) {
                    dos.write((starter + boundary + returnChar).getBytes());
                } else if (fileList.size() > 0) {
                    dos.write((starter + boundary + returnChar).getBytes());
                }
            }
            dos.write((starter + boundary + "--" + returnChar).getBytes());
            dos.flush();
            br = new BufferedReader(new InputStreamReader(conn.getInputStream()));
            String key;
            String header;
            int i = 1;
            key = conn.getHeaderFieldKey(i);
            header = conn.getHeaderField(i);
            System.out.println(header);
            if (Utility.isEmpty(header) || header.indexOf("JSESSIONID") < 0) {
                header = "JSESSIONID=" + sessionID + "; Path=/" + projectName;
            }
            while (key != null) {
                head.add(header);
                i++;
                key = conn.getHeaderFieldKey(i);
                header = conn.getHeaderField(i);
            }
            String tempstr;
            int line = 0;
            while (null != ((tempstr = br.readLine()))) {
                if (!tempstr.equals("")) {
                    if ("window.location.replace(\"/eip/Home.do\");".indexOf(returnMessage.append(formatLine(tempstr)).toString()) != -1) {
                        isLogin = true;
                        break;
                    }
                    line++;
                }
            }
            txtList.clear();
            fileList.clear();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                dos.close();
            } catch (Exception e) {
            }
            try {
                br.close();
            } catch (Exception e) {
            }
        }
        this.setHeadList(head);
        return isLogin;
    }
} </s>
<s>class temp {    public ObjectInputStream getObjectInputStreamFromServlet(String strUrl) throws Exception {
        if (headList.size() == 0) {
            return null;
        }
        String starter = "-----------------------------";
        String returnChar = "\r\n";
        String lineEnd = "--";
        String urlString = strUrl;
        String input = null;
        List txtList = new ArrayList();
        List fileList = new ArrayList();
        String targetFile = null;
        String actionStatus = null;
        StringBuffer returnMessage = new StringBuffer();
        List head = new ArrayList();
        final String boundary = String.valueOf(System.currentTimeMillis());
        URL url = null;
        URLConnection conn = null;
        DataOutputStream dos = null;
        ObjectInputStream inputFromServlet = null;
        try {
            url = new URL(baseURL, "/" + projectName + strUrl);
            conn = url.openConnection();
            ((HttpURLConnection) conn).setRequestMethod("POST");
            conn.setDoInput(true);
            conn.setDoOutput(true);
            conn.setUseCaches(false);
            conn.setRequestProperty("Content-Type", "multipart/form-data, boundary=" + "---------------------------" + boundary);
            conn.setRequestProperty("Cookie", (String) headList.get(0));
            if (input != null) {
                String auth = "Basic " + new sun.misc.BASE64Encoder().encode(input.getBytes());
                conn.setRequestProperty("Authorization", auth);
            }
            dos = new DataOutputStream(conn.getOutputStream());
            dos.flush();
            inputFromServlet = new ObjectInputStream(conn.getInputStream());
            txtList.clear();
            fileList.clear();
        } catch (EOFException e) {
            workflowEditor.getEditor().outputMessage("Session Expired!", false);
            throw e;
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        } finally {
            try {
                dos.close();
            } catch (Exception e) {
            }
        }
        return inputFromServlet;
    }
} </s>
<s>class temp {    public Object execute(ExecutionEvent event) throws ExecutionException {
        try {
            Shell shell = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell();
            QuizTreeView view = (QuizTreeView) PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().showView("org.rcpquizengine.views.quizzes");
            Folder rootFolder = view.getRootFolder();
            if (rootFolder.isEncrypted()) {
                PasswordDialog dialog = new PasswordDialog(shell);
                if (dialog.open() == Window.OK) {
                    String password = dialog.getPassword();
                    if (!password.equals("")) {
                        String md5 = "";
                        MessageDigest md = MessageDigest.getInstance("MD5");
                        md.update(password.getBytes());
                        md5 = new BigInteger(md.digest()).toString();
                        if (rootFolder.getMd5Digest().equals(md5)) {
                            rootFolder.setMd5Digest("");
                            rootFolder.setEncrypted(false);
                            MessageDialog.openInformation(shell, "Quiz bank unlocked", "The current quiz bank has been unlocked");
                        } else {
                            MessageDialog.openError(shell, "Error unlocking quiz bank", "Incorrect password");
                        }
                        password = "";
                        md5 = "";
                    }
                }
            } else {
                MessageDialog.openError(shell, "Error unlocking quiz bank", "Quiz bank already unlocked");
            }
        } catch (PartInitException e) {
            e.printStackTrace();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        return null;
    }
} </s>
<s>class temp {    public String getResponse(URL url) throws OAuthException {
        try {
            HttpURLConnection connection = (HttpURLConnection) url.openConnection();
            connection.connect();
            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
            String inputLine;
            StringBuilder response = new StringBuilder();
            while ((inputLine = in.readLine()) != null) {
                response.append(inputLine);
            }
            in.close();
            return response.toString();
        } catch (IOException e) {
            throw new OAuthException("Error getting HTTP response", e);
        }
    }
} </s>
<s>class temp {    Library(MainFrame mf, boolean newLibrary, String templateName, String newFileName) throws Exception {
        mainFrame = mf;
        trackMap = new HashMap<String, LibraryTrack>();
        trackVec = new Vector<LibraryTrack>();
        String propFileName = null;
        File propFile = null;
        String notExist = "";
        String[] options = templateDesc;
        boolean isCurrent = mainFrame.library != null;
        int ix;
        if (!newLibrary) {
            propFileName = mainFrame.name + ".jampal";
            propFile = new File(propFileName);
        }
        if (isCurrent) {
            options = new String[templateDesc.length + 1];
            options[0] = "Copy of Current Library";
            for (ix = 0; ix < templateDesc.length; ix++) {
                options[ix + 1] = templateDesc[ix];
            }
        }
        boolean copyLibrary = false;
        if (newLibrary) {
            if (templateName == null) {
                Object resp = JOptionPane.showInputDialog(mainFrame.frame, "Please select a template.", "Select Type of Library", JOptionPane.WARNING_MESSAGE, null, options, null);
                if (resp == null) return;
                templateName = (String) resp;
            }
            for (ix = 0; ix < options.length && !options[ix].equals(templateName); ix++) ;
            if (isCurrent) ix--;
            boolean creatingPlaylist = false;
            BufferedReader in;
            if (ix == -1) {
                in = new BufferedReader(new FileReader(mainFrame.name + ".jampal"));
                copyLibrary = true;
                creatingPlaylist = (mainFrame.library.attributes.libraryType == 'P');
            } else {
                in = new BufferedReader(new InputStreamReader(ClassLoader.getSystemResourceAsStream("pgbennett/jampal/" + templateNames[ix])));
                creatingPlaylist = ("playlist.jampal".equals(templateNames[ix]));
            }
            if (newFileName == null) {
                JFileChooser fileChooser = new JFileChooser();
                fileChooser.setDialogTitle("Create New Library File");
                String currentDirectory = null;
                if (mainFrame.name != null) {
                    File nameFile = new File(mainFrame.name);
                    currentDirectory = nameFile.getParent();
                    if (currentDirectory == null) currentDirectory = ".";
                }
                if (currentDirectory == null) currentDirectory = Jampal.jampalDirectory;
                if (currentDirectory != null) fileChooser.setCurrentDirectory(new File(currentDirectory));
                fileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
                fileChooser.setMultiSelectionEnabled(false);
                Mp3FileFilter filter = new Mp3FileFilter();
                filter.setExtension("jampal", "Jampal library files");
                fileChooser.addChoosableFileFilter(filter);
                fileChooser.setAcceptAllFileFilterUsed(false);
                fileChooser.setFileFilter(filter);
                fileChooser.setDialogType(JFileChooser.SAVE_DIALOG);
                int returnVal = fileChooser.showSaveDialog(mainFrame.frame);
                if (returnVal == fileChooser.APPROVE_OPTION) {
                    propFile = fileChooser.getSelectedFile();
                    propFileName = propFile.getPath();
                    if (!propFileName.toLowerCase().endsWith(".jampal")) {
                        propFileName = propFileName + ".jampal";
                        propFile = new File(propFileName);
                    }
                } else return;
            } else {
                propFileName = newFileName;
                propFile = new File(propFileName);
            }
            if (propFile.exists()) {
                if (JOptionPane.showConfirmDialog(mainFrame.frame, "File " + propFileName + " already exists. Do you want to overwrite it ?", "Warning", JOptionPane.YES_NO_OPTION) != JOptionPane.YES_OPTION) return;
            }
            PrintWriter out = new PrintWriter(new FileOutputStream(propFile));
            String libName = propFile.getName();
            libName = libName.substring(0, libName.length() - 7);
            for (; ; ) {
                String line = in.readLine();
                if (line == null) break;
                if (creatingPlaylist && line.startsWith("playlist=")) {
                    line = "playlist=" + libName;
                }
                if (line.startsWith("libraryname=")) {
                    line = "libraryname=" + libName + ".jmp";
                }
                out.println(line);
            }
            in.close();
            out.close();
            if (!creatingPlaylist && !copyLibrary) {
                String playlistName = propFile.getParent() + File.separator + "playlist.jampal";
                File playlistFile = new File(playlistName);
                if (!playlistFile.exists()) {
                    in = new BufferedReader(new InputStreamReader(ClassLoader.getSystemResourceAsStream("pgbennett/jampal/playlist.jampal")));
                    out = new PrintWriter(new FileOutputStream(playlistFile));
                    for (; ; ) {
                        String line = in.readLine();
                        if (line == null) break;
                        out.println(line);
                    }
                    in.close();
                    out.close();
                }
            }
        }
        if (propFileName != null) attributes = new LibraryAttributes(propFileName);
        insertBefore = -1;
    }
} </s>
<s>class temp {    @Override
    public void run() {
        try {
            FileChannel in = new FileInputStream(inputfile).getChannel();
            long pos = 0;
            for (int i = 1; i <= noofparts; i++) {
                FileChannel out = new FileOutputStream(outputfile.getAbsolutePath() + "." + "v" + i).getChannel();
                status.setText("Rozdělovač: Rozděluji část " + i + "..");
                in.transferTo(pos, splitsize, out);
                pos += splitsize;
                remainingsize -= splitsize;
                if (remainingsize < splitsize) in.transferTo(pos, remainingsize, out);
                pb.setValue(100 * i / noofparts);
                out.close();
            }
            in.close();
            if (deleteOnFinish) new File(inputfile + "").delete();
            status.setText("Rozdělovač: Hotovo..");
            JOptionPane.showMessageDialog(null, "Rozděleno!", "Rozdělovač", JOptionPane.INFORMATION_MESSAGE);
        } catch (IOException ex) {
        }
    }
} </s>
<s>class temp {    private void readURL(URL url) throws IOException {
        statusLine.setText("Opening " + url.toExternalForm());
        URLConnection connection = url.openConnection();
        StringBuffer buffer = new StringBuffer();
        BufferedReader in = null;
        try {
            in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
            String line;
            while ((line = in.readLine()) != null) {
                buffer.append(line).append('\n');
                statusLine.setText("Read " + buffer.length() + " bytes...");
            }
        } finally {
            if (in != null) in.close();
        }
        String type = connection.getContentType();
        if (type == null) type = "text/plain";
        statusLine.setText("Content type " + type);
        content.setContentType(type);
        content.setText(buffer.toString());
        statusLine.setText("Done");
    }
} </s>
<s>class temp {    public static void copyFile(File in, File out) throws IOException {
        FileChannel inChannel = new FileInputStream(in).getChannel();
        FileChannel outChannel = new FileOutputStream(out).getChannel();
        try {
            inChannel.transferTo(0, inChannel.size(), outChannel);
        } catch (IOException e) {
            throw e;
        } finally {
            if (inChannel != null) inChannel.close();
            if (outChannel != null) outChannel.close();
        }
    }
} </s>
<s>class temp {    public void cpFile(File source, File target, boolean replace, int bufferSize) throws IOException {
        if (!source.exists()) throw new IOException("source file not exists");
        if (!source.isFile()) throw new IOException("source file not exists(is a directory)");
        InputStream src = new FileInputStream(source);
        File tarn = target;
        if (target.isDirectory() || !(!(target.exists()) || replace)) {
            String tardir = target.isDirectory() ? target.getPath() : target.getParent();
            tarn = new File(tardir + File.separator + source.getName());
            int n = 1;
            while (!(!tarn.exists() || replace)) {
                tarn = new File(tardir + File.separator + String.valueOf(n) + " copy of " + source.getName());
                n++;
            }
        }
        if (source.getPath().equals(tarn.getPath()) && replace) return;
        OutputStream tar = new FileOutputStream(tarn);
        byte[] bytes = new byte[bufferSize];
        int readn = -1;
        while ((readn = src.read(bytes)) > 0) {
            tar.write(bytes, 0, readn);
        }
        tar.flush();
        tar.close();
        src.close();
    }
} </s>
<s>class temp {    public static byte[] MD5(String input) {
        MessageDigest md5 = null;
        try {
            md5 = MessageDigest.getInstance("MD5");
        } catch (NoSuchAlgorithmException e) {
            return null;
        }
        md5.update(input.getBytes());
        return md5.digest();
    }
} </s>
<s>class temp {    public void hyperlinkUpdate(HyperlinkEvent e) {
        if (e.getEventType() == EventType.ACTIVATED) {
            try {
                URL url = e.getURL();
                InputStream stream = url.openStream();
                try {
                    StringWriter writer = new StringWriter();
                    IOUtils.copy(stream, writer, "UTF-8");
                    JEditorPane editor = new JEditorPane("text/plain", writer.toString());
                    editor.setEditable(false);
                    editor.setBackground(Color.WHITE);
                    editor.setCaretPosition(0);
                    editor.setPreferredSize(new Dimension(600, 400));
                    String name = url.toString();
                    name = name.substring(name.lastIndexOf('/') + 1);
                    JDialog dialog = new JDialog(this, "内容解析: " + name);
                    dialog.add(new JScrollPane(editor));
                    dialog.pack();
                    dialog.setVisible(true);
                } finally {
                    stream.close();
                }
            } catch (IOException exception) {
                exception.printStackTrace();
            }
        }
    }
} </s>
<s>class temp {        public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {
            String name = metadata.get(Metadata.RESOURCE_NAME_KEY);
            if (name != null && wanted.containsKey(name)) {
                FileOutputStream out = new FileOutputStream(wanted.get(name));
                IOUtils.copy(stream, out);
                out.close();
            } else {
                if (downstreamParser != null) {
                    downstreamParser.parse(stream, handler, metadata, context);
                }
            }
        }
} </s>
<s>class temp {    public static void copyFile(File src, File dst) throws IOException {
        BufferedInputStream is = new BufferedInputStream(new FileInputStream(src));
        BufferedOutputStream os = new BufferedOutputStream(new FileOutputStream(dst));
        byte[] buf = new byte[1024];
        int count = 0;
        while ((count = is.read(buf, 0, 1024)) != -1) os.write(buf, 0, count);
        is.close();
        os.close();
    }
} </s>
<s>class temp {    private void UploadActionPerformed(ActionEvent evt) {
        JFileChooser chooser = new JFileChooser();
        FileNameExtensionFilter filter = new FileNameExtensionFilter("*.jpg", "jpg");
        chooser.setFileFilter(filter);
        File dir = new File(System.getProperty("user.home"));
        chooser.setCurrentDirectory(dir);
        Component parent = null;
        int returnVal = chooser.showOpenDialog(parent);
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            UserStatus.setText("Bitte warten");
        }
        try {
            Pic.setVisible(false);
            FTPClient client = new FTPClient();
            client.connect("showus.de");
            client.login("web2", "kcinnay88");
            client.enterLocalActiveMode();
            client.setFileTransferMode(FTPClient.BINARY_FILE_TYPE);
            client.setFileType(FTPClient.BINARY_FILE_TYPE);
            int reply = client.getReplyCode();
            System.out.println("Connect returned: " + reply);
            FileInputStream in = new FileInputStream(chooser.getSelectedFile().getAbsolutePath());
            System.out.println("Uploading File");
            client.storeFile("/html/Applet/user/" + Config.id + ".jpg", in);
            client.logout();
            in.close();
            System.out.println("done");
            UserStatus.setText("Upload fertig, Bild wird aktuallisiert");
        } catch (SocketException e) {
            e.printStackTrace();
        } catch (IOException e) {
            UserStatus.setText("Fehler beim Upload");
            e.printStackTrace();
        }
    }
} </s>
<s>class temp {    private Document parseResponse(String url) throws IOException, MalformedURLException, ParserConfigurationException, SAXException {
        DocumentBuilder db = DocumentBuilderFactory.newInstance().newDocumentBuilder();
        InputStream stream = null;
        try {
            stream = new URL(url).openStream();
            return db.parse(stream);
        } finally {
            if (stream != null) stream.close();
        }
    }
} </s>
<s>class temp {    private void addPlugin(URL url) throws IOException {
        logger.debug("Adding plugin with URL {}", url);
        InputStream in = url.openStream();
        try {
            Properties properties = new Properties();
            properties.load(in);
            plugins.add(new WtfPlugin(properties));
        } finally {
            in.close();
        }
    }
} </s>
<s>class temp {    public File copyFile(File in, File out) throws IOException {
        FileChannel inChannel = new FileInputStream(in).getChannel();
        FileChannel outChannel = new FileOutputStream(out).getChannel();
        copyChannel(inChannel, outChannel);
        return out;
    }
} </s>
<s>class temp {    private void getRandomGUID(boolean secure) {
        MessageDigest md5 = null;
        StringBuffer sbValueBeforeMD5 = new StringBuffer();
        try {
            md5 = MessageDigest.getInstance("MD5");
        } catch (NoSuchAlgorithmException e) {
            System.out.println("Error: " + e);
        }
        try {
            long time = System.currentTimeMillis();
            long rand = 0;
            if (secure) {
                rand = mySecureRand.nextLong();
            } else {
                rand = myRand.nextLong();
            }
            sbValueBeforeMD5.append(s_id);
            sbValueBeforeMD5.append(":");
            sbValueBeforeMD5.append(Long.toString(time));
            sbValueBeforeMD5.append(":");
            sbValueBeforeMD5.append(Long.toString(rand));
            valueBeforeMD5 = sbValueBeforeMD5.toString();
            md5.update(valueBeforeMD5.getBytes());
            byte[] array = md5.digest();
            StringBuffer sb = new StringBuffer();
            for (int j = 0; j < array.length; ++j) {
                int b = array[j] & 0xFF;
                if (b < 0x10) sb.append('0');
                sb.append(Integer.toHexString(b));
            }
            valueAfterMD5 = sb.toString();
        } catch (Exception e) {
            System.out.println("Error:" + e);
        }
    }
} </s>
<s>class temp {    private static void copySmallFile(File sourceFile, File targetFile) throws BusinessException {
        LOG.debug("Copying SMALL file '" + sourceFile.getAbsolutePath() + "' to '" + targetFile.getAbsolutePath() + "'.");
        FileChannel inChannel = null;
        FileChannel outChannel = null;
        try {
            inChannel = new FileInputStream(sourceFile).getChannel();
            outChannel = new FileOutputStream(targetFile).getChannel();
            inChannel.transferTo(0, inChannel.size(), outChannel);
        } catch (IOException e) {
            throw new BusinessException("Could not copy file from '" + sourceFile.getAbsolutePath() + "' to '" + targetFile.getAbsolutePath() + "'!", e);
        } finally {
            try {
                if (inChannel != null) inChannel.close();
            } catch (IOException e) {
                LOG.error("Could not close input stream!", e);
            }
            try {
                if (outChannel != null) outChannel.close();
            } catch (IOException e) {
                LOG.error("Could not close output stream!", e);
            }
        }
    }
} </s>
<s>class temp {    protected long getURLLastModified(final URL url) throws IOException {
        final URLConnection con = url.openConnection();
        long lastModified = con.getLastModified();
        try {
            con.getInputStream().close();
        } catch (IOException ignored) {
        }
        return lastModified;
    }
} </s>
<s>class temp {    public void createZip(File zipFileName, Vector<File> selected) {
        try {
            byte[] buffer = new byte[4096];
            ZipOutputStream out = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(zipFileName), 8096));
            out.setLevel(Deflater.BEST_COMPRESSION);
            out.setMethod(ZipOutputStream.DEFLATED);
            for (int i = 0; i < selected.size(); i++) {
                FileInputStream in = new FileInputStream(selected.get(i));
                String file = selected.get(i).getPath();
                if (file.indexOf("\\") != -1) file = file.substring(file.lastIndexOf(fs) + 1, file.length());
                ZipEntry ze = new ZipEntry(file);
                out.putNextEntry(ze);
                int len;
                while ((len = in.read(buffer)) > 0) out.write(buffer, 0, len);
                out.closeEntry();
                in.close();
                selected.get(i).delete();
            }
            out.close();
        } catch (IllegalArgumentException iae) {
            iae.printStackTrace();
        } catch (FileNotFoundException fnfe) {
            fnfe.printStackTrace();
        } catch (IOException ioe) {
            ioe.printStackTrace();
        }
    }
} </s>
<s>class temp {    @Override
    public User createUser(User bean) throws SitoolsException {
        checkUser();
        if (!User.isValid(bean)) {
            throw new SitoolsException("CREATE_USER_MALFORMED");
        }
        Connection cx = null;
        try {
            cx = ds.getConnection();
            cx.setAutoCommit(false);
            PreparedStatement st = cx.prepareStatement(jdbcStoreResource.CREATE_USER);
            int i = 1;
            st.setString(i++, bean.getIdentifier());
            st.setString(i++, bean.getFirstName());
            st.setString(i++, bean.getLastName());
            st.setString(i++, bean.getSecret());
            st.setString(i++, bean.getEmail());
            st.executeUpdate();
            st.close();
            createProperties(bean, cx);
            if (!cx.getAutoCommit()) {
                cx.commit();
            }
        } catch (SQLException e) {
            try {
                cx.rollback();
            } catch (SQLException e1) {
                e1.printStackTrace();
                throw new SitoolsException("CREATE_USER ROLLBACK" + e1.getMessage(), e1);
            }
            e.printStackTrace();
            throw new SitoolsException("CREATE_USER " + e.getMessage(), e);
        } finally {
            closeConnection(cx);
        }
        return getUserById(bean.getIdentifier());
    }
} </s>
<s>class temp {    @Override
    public User updateUser(User bean) throws SitoolsException {
        checkUser();
        Connection cx = null;
        try {
            cx = ds.getConnection();
            cx.setAutoCommit(false);
            PreparedStatement st;
            int i = 1;
            if (bean.getSecret() != null && !"".equals(bean.getSecret())) {
                st = cx.prepareStatement(jdbcStoreResource.UPDATE_USER_WITH_PW);
                st.setString(i++, bean.getFirstName());
                st.setString(i++, bean.getLastName());
                st.setString(i++, bean.getSecret());
                st.setString(i++, bean.getEmail());
                st.setString(i++, bean.getIdentifier());
            } else {
                st = cx.prepareStatement(jdbcStoreResource.UPDATE_USER_WITHOUT_PW);
                st.setString(i++, bean.getFirstName());
                st.setString(i++, bean.getLastName());
                st.setString(i++, bean.getEmail());
                st.setString(i++, bean.getIdentifier());
            }
            st.executeUpdate();
            st.close();
            if (bean.getProperties() != null) {
                deleteProperties(bean.getIdentifier(), cx);
                createProperties(bean, cx);
            }
            if (!cx.getAutoCommit()) {
                cx.commit();
            }
        } catch (SQLException e) {
            try {
                cx.rollback();
            } catch (SQLException e1) {
                throw new SitoolsException("UPDATE_USER ROLLBACK" + e1.getMessage(), e1);
            }
            throw new SitoolsException("UPDATE_USER " + e.getMessage(), e);
        } finally {
            closeConnection(cx);
        }
        return getUserById(bean.getIdentifier());
    }
} </s>
<s>class temp {    private static void copy(File source, File target) throws IOException {
        FileChannel sourceChannel = new FileInputStream(source).getChannel();
        FileChannel targetChannel = new FileOutputStream(target).getChannel();
        sourceChannel.transferTo(0, sourceChannel.size(), targetChannel);
        sourceChannel.close();
        targetChannel.close();
    }
} </s>
<s>class temp {    public boolean smsResponse(String customerPhoneNumber) throws ClientProtocolException, IOException {
        boolean message = true;
        String textMessage = "La%20sua%20prenotazione%20e%60%20andata%20a%20buon%20fine";
        DefaultHttpClient httpclient = new DefaultHttpClient();
        String uri = "http://smswizard.globalitalia.it/smsgateway/send.asp";
        String other = "http://smswizard.globalitalia.it/smsgateway/send.asp";
        String url = uri + "?" + "Account=sardricerche" + "&Password=v8LomdZT" + "&PhoneNumbers=" + "%2b393285683484" + "&SMSData=" + textMessage + "&Recipients=1" + "&Sender=Web Hotel" + "&ID=11762";
        String urlProva = other + "?" + "Account=sardricerche" + "&Password=v8LomdZT" + "&PhoneNumbers=" + customerPhoneNumber + "&SMSData=" + textMessage + "&Recipients=1" + "&Sender=+393337589951" + "&ID=11762";
        HttpPost httpPost = new HttpPost(urlProva);
        HttpResponse response = httpclient.execute(httpPost);
        HttpEntity entity = response.getEntity();
        return message;
    }
} </s>
<s>class temp {    private void retrieveData() {
        StringBuffer obsBuf = new StringBuffer();
        try {
            URL url = new URL(getProperty("sourceURL"));
            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));
            String lineIn = null;
            while ((lineIn = in.readLine()) != null) {
                if (GlobalProps.DEBUG) {
                    logger.log(Level.FINE, "WebSource retrieveData: " + lineIn);
                }
                obsBuf.append(lineIn);
            }
            String fmt = getProperty("dataFormat");
            if (GlobalProps.DEBUG) {
                logger.log(Level.FINE, "Raw: " + obsBuf.toString());
            }
            if ("NWS XML".equals(fmt)) {
                obs = new NWSXmlObservation(obsBuf.toString());
            }
        } catch (Exception e) {
            logger.log(Level.SEVERE, "Can't connect to: " + getProperty("sourceURL"));
            if (GlobalProps.DEBUG) {
                e.printStackTrace();
            }
        }
    }
} </s>
<s>class temp {    protected static String getInitialUUID() {
        if (myRand == null) {
            myRand = new Random();
        }
        long rand = myRand.nextLong();
        String sid;
        try {
            sid = InetAddress.getLocalHost().toString();
        } catch (UnknownHostException e) {
            sid = Thread.currentThread().getName();
        }
        StringBuffer sb = new StringBuffer();
        sb.append(sid);
        sb.append(":");
        sb.append(Long.toString(rand));
        MessageDigest md5 = null;
        try {
            md5 = MessageDigest.getInstance("MD5");
        } catch (NoSuchAlgorithmException e) {
            throw new OMException(e);
        }
        md5.update(sb.toString().getBytes());
        byte[] array = md5.digest();
        StringBuffer sb2 = new StringBuffer();
        for (int j = 0; j < array.length; ++j) {
            int b = array[j] & 0xFF;
            sb2.append(Integer.toHexString(b));
        }
        int begin = myRand.nextInt();
        if (begin < 0) begin = begin * -1;
        begin = begin % 8;
        return sb2.toString().substring(begin, begin + 18).toUpperCase();
    }
} </s>
<s>class temp {    public void invoke(MessageContext msgContext) throws AxisFault {
        log.debug("Enter: MD5AttachHandler::invoke");
        try {
            Message msg = msgContext.getRequestMessage();
            SOAPConstants soapConstants = msgContext.getSOAPConstants();
            org.apache.axis.message.SOAPEnvelope env = (org.apache.axis.message.SOAPEnvelope) msg.getSOAPEnvelope();
            org.apache.axis.message.SOAPBodyElement sbe = env.getFirstBody();
            org.w3c.dom.Element sbElement = sbe.getAsDOM();
            org.w3c.dom.Node n = sbElement.getFirstChild();
            for (; n != null && !(n instanceof org.w3c.dom.Element); n = n.getNextSibling()) ;
            org.w3c.dom.Element paramElement = (org.w3c.dom.Element) n;
            String href = paramElement.getAttribute(soapConstants.getAttrHref());
            org.apache.axis.Part ap = msg.getAttachmentsImpl().getAttachmentByReference(href);
            javax.activation.DataHandler dh = org.apache.axis.attachments.AttachmentUtils.getActivationDataHandler(ap);
            org.w3c.dom.Node timeNode = paramElement.getFirstChild();
            long startTime = -1;
            if (timeNode != null && timeNode instanceof org.w3c.dom.Text) {
                String startTimeStr = ((org.w3c.dom.Text) timeNode).getData();
                startTime = Long.parseLong(startTimeStr);
            }
            long receivedTime = System.currentTimeMillis();
            long elapsedTime = -1;
            if (startTime > 0) elapsedTime = receivedTime - startTime;
            String elapsedTimeStr = elapsedTime + "";
            java.security.MessageDigest md = java.security.MessageDigest.getInstance("MD5");
            java.io.InputStream attachmentStream = dh.getInputStream();
            int bread = 0;
            byte[] buf = new byte[64 * 1024];
            do {
                bread = attachmentStream.read(buf);
                if (bread > 0) {
                    md.update(buf, 0, bread);
                }
            } while (bread > -1);
            attachmentStream.close();
            buf = null;
            String contentType = dh.getContentType();
            if (contentType != null && contentType.length() != 0) {
                md.update(contentType.getBytes("US-ASCII"));
            }
            sbe = env.getFirstBody();
            sbElement = sbe.getAsDOM();
            n = sbElement.getFirstChild();
            for (; n != null && !(n instanceof org.w3c.dom.Element); n = n.getNextSibling()) ;
            paramElement = (org.w3c.dom.Element) n;
            String MD5String = org.apache.axis.encoding.Base64.encode(md.digest());
            String senddata = " elapsedTime=" + elapsedTimeStr + " MD5=" + MD5String;
            paramElement.appendChild(paramElement.getOwnerDocument().createTextNode(senddata));
            sbe = new org.apache.axis.message.SOAPBodyElement(sbElement);
            env.clearBody();
            env.addBodyElement(sbe);
            msg = new Message(env);
            msgContext.setResponseMessage(msg);
        } catch (Exception e) {
            log.error(Messages.getMessage("exception00"), e);
            throw AxisFault.makeFault(e);
        }
        log.debug("Exit: MD5AttachHandler::invoke");
    }
} </s>
<s>class temp {    public static byte[] getHashedID(String ID) {
        try {
            MessageDigest md5 = MessageDigest.getInstance("MD5");
            md5.reset();
            md5.update(ID.getBytes());
            byte[] digest = md5.digest();
            byte[] bytes = new byte[WLDB_ID_SIZE];
            for (int i = 0; i < bytes.length; i++) {
                bytes[i] = digest[i];
            }
            return bytes;
        } catch (NoSuchAlgorithmException exception) {
            System.err.println("Java VM is not compatible");
            return null;
        }
    }
} </s>
<s>class temp {    private boolean saveDocumentXml(String repository, String tempRepo) {
        boolean result = true;
        try {
            XPath xpath = XPathFactory.newInstance().newXPath();
            String expression = "documents/document";
            InputSource insource = new InputSource(new FileInputStream(tempRepo + File.separator + AppConstants.DMS_XML));
            NodeList nodeList = (NodeList) xpath.evaluate(expression, insource, XPathConstants.NODESET);
            for (int i = 0; i < nodeList.getLength(); i++) {
                Node node = nodeList.item(i);
                System.out.println(node.getNodeName());
                DocumentModel document = new DocumentModel();
                NodeList childs = node.getChildNodes();
                for (int j = 0; j < childs.getLength(); j++) {
                    Node child = childs.item(j);
                    if (child.getNodeType() == Node.ELEMENT_NODE) {
                        if (child.getNodeName() != null && child.getFirstChild() != null && child.getFirstChild().getNodeValue() != null) {
                            System.out.println(child.getNodeName() + "::" + child.getFirstChild().getNodeValue());
                        }
                        if (Document.FLD_ID.equals(child.getNodeName())) {
                            if (child.getFirstChild() != null) {
                                String szId = child.getFirstChild().getNodeValue();
                                if (szId != null && szId.length() > 0) {
                                    try {
                                        document.setId(new Long(szId));
                                    } catch (Exception e) {
                                        e.printStackTrace();
                                    }
                                }
                            }
                        } else if (document.FLD_NAME.equals(child.getNodeName())) {
                            document.setName(child.getFirstChild().getNodeValue());
                            document.setTitle(document.getName());
                            document.setDescr(document.getName());
                            document.setExt(getExtension(document.getName()));
                        } else if (document.FLD_LOCATION.equals(child.getNodeName())) {
                            document.setLocation(child.getFirstChild().getNodeValue());
                        } else if (document.FLD_OWNER.equals(child.getNodeName())) {
                            Long id = new Long(child.getFirstChild().getNodeValue());
                            User user = new UserModel();
                            user.setId(id);
                            user = (User) userService.find(user);
                            if (user != null && user.getId() != null) {
                                document.setOwner(user);
                            }
                        }
                    }
                }
                boolean isSave = docService.save(document);
                if (isSave) {
                    String repo = preference.getRepository();
                    Calendar calendar = Calendar.getInstance();
                    StringBuffer sbRepo = new StringBuffer(repo);
                    sbRepo.append(File.separator);
                    StringBuffer sbFolder = new StringBuffer(sdf.format(calendar.getTime()));
                    sbFolder.append(File.separator).append(calendar.get(Calendar.HOUR_OF_DAY));
                    File fileFolder = new File(sbRepo.append(sbFolder).toString());
                    if (!fileFolder.exists()) {
                        fileFolder.mkdirs();
                    }
                    FileChannel fcSource = null, fcDest = null;
                    try {
                        StringBuffer sbFile = new StringBuffer(fileFolder.getAbsolutePath());
                        StringBuffer fname = new StringBuffer(document.getId().toString());
                        fname.append(".").append(document.getExt());
                        sbFile.append(File.separator).append(fname);
                        fcSource = new FileInputStream(tempRepo + File.separator + document.getName()).getChannel();
                        fcDest = new FileOutputStream(sbFile.toString()).getChannel();
                        fcDest.transferFrom(fcSource, 0, fcSource.size());
                        document.setLocation(sbFolder.toString());
                        document.setSize(fcSource.size());
                        log.info("Batch upload file " + document.getName() + " into [" + document.getLocation() + "] as " + document.getName() + "." + document.getExt());
                        folder.setId(DEFAULT_FOLDER);
                        folder = (Folder) folderService.find(folder);
                        if (folder != null && folder.getId() != null) {
                            document.setFolder(folder);
                        }
                        workspace.setId(DEFAULT_WORKSPACE);
                        workspace = (Workspace) workspaceService.find(workspace);
                        if (workspace != null && workspace.getId() != null) {
                            document.setWorkspace(workspace);
                        }
                        user.setId(DEFAULT_USER);
                        user = (User) userService.find(user);
                        if (user != null && user.getId() != null) {
                            document.setCrtby(user.getId());
                        }
                        document.setCrtdate(new Date());
                        document = (DocumentModel) docService.resetDuplicateDocName(document);
                        docService.save(document);
                        DocumentIndexer.indexDocument(preference, document);
                    } catch (FileNotFoundException notFoundEx) {
                        log.error("saveFile file not found: " + document.getName(), notFoundEx);
                    } catch (IOException ioEx) {
                        log.error("saveFile IOException: " + document.getName(), ioEx);
                    } finally {
                        try {
                            if (fcSource != null) {
                                fcSource.close();
                            }
                            if (fcDest != null) {
                                fcDest.close();
                            }
                        } catch (Exception e) {
                            log.error(e.getMessage(), e);
                        }
                    }
                }
            }
        } catch (Exception e) {
            result = false;
            e.printStackTrace();
        }
        return result;
    }
} </s>
<s>class temp {    public String hash(String text) {
        try {
            MessageDigest md = MessageDigest.getInstance(hashFunction);
            md.update(text.getBytes(charset));
            byte[] raw = md.digest();
            return new String(encodeHex(raw));
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
} </s>
<s>class temp {    String readArticleFromFile(String urlStr) {
        String docbase = getDocumentBase().toString();
        int pos = docbase.lastIndexOf('/');
        if (pos > -1) {
            docbase = docbase.substring(0, pos + 1);
        } else {
            docbase = "";
        }
        docbase = docbase + urlStr;
        String prog = "";
        try {
            URL url = new URL(docbase);
            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));
            if (in != null) {
                while (true) {
                    try {
                        String mark = in.readLine();
                        if (mark == null) break;
                        prog = prog + mark + "\n";
                    } catch (Exception e) {
                    }
                }
                in.close();
            }
        } catch (Exception e) {
        }
        return prog;
    }
} </s>
<s>class temp {    private void populatePortfolioEntry(ActionResponse resp, PortfolioEntry e, String market) throws Exception {
        String tmp = getURL(market, e);
        if (tmp == null) {
            tmp = URL_QUOTE_DATA;
        }
        tmp = tmp.replace("@", e.getSymbol());
        URL url = new URL(tmp);
        HttpURLConnection conn = (HttpURLConnection) url.openConnection();
        BufferedReader in = null;
        try {
            int status = conn.getResponseCode();
            if (status == 200) {
                in = new BufferedReader(new InputStreamReader(conn.getInputStream()));
                StringBuffer responseBody = new StringBuffer();
                while (true) {
                    String line = in.readLine();
                    if (line == null) break;
                    responseBody.append(line);
                }
                ArrayList<String> data = parseData(responseBody.toString(), ",");
                if (data.size() == 2) {
                    e.setName(MiscUtils.trimChars(data.get(0), '"'));
                    String val = data.get(1);
                    val = MiscUtils.trimChars(val.trim(), '\r');
                    val = MiscUtils.trimChars(val.trim(), '\n');
                    BigDecimal d = new BigDecimal(val);
                    e.setPricePerShare(d);
                } else {
                    resp.setErrorCode(ActionResponse.GENERAL_ERROR);
                    resp.setErrorMessage("Error retrieving data");
                }
            } else {
                resp.setErrorCode(ActionResponse.GENERAL_ERROR);
                resp.setErrorMessage("Error retrieving data Http code: " + status);
            }
        } finally {
            if (in != null) in.close();
        }
    }
} </s>
<s>class temp {    public void testStreamURL() throws Exception {
        boolean ok = false;
        String url = "http://www.apache.org/dist/lucene/solr/";
        String txt = null;
        try {
            txt = IOUtils.toString(new URL(url).openStream());
        } catch (Exception ex) {
            fail("this test only works if you have a network connection.");
            return;
        }
        SolrCore core = h.getCore();
        Map<String, String[]> args = new HashMap<String, String[]>();
        args.put(CommonParams.STREAM_URL, new String[] { url });
        List<ContentStream> streams = new ArrayList<ContentStream>();
        parser.buildRequestFrom(core, new MultiMapSolrParams(args), streams);
        assertEquals(1, streams.size());
        assertEquals(txt, IOUtils.toString(streams.get(0).getStream()));
    }
} </s>
<s>class temp {    public static String hashPassword(String password) {
        String hashword = null;
        try {
            MessageDigest md5 = MessageDigest.getInstance(MESSAGE_DIGEST_ALGORITHM_MD5);
            md5.update(password.getBytes());
            BigInteger hash = new BigInteger(1, md5.digest());
            hashword = hash.toString(16);
        } catch (NoSuchAlgorithmException e) {
            logger.error("Cannot find algorithm = '" + MESSAGE_DIGEST_ALGORITHM_MD5 + "'", e);
            throw new IllegalStateException(e);
        }
        return pad(hashword, 32, '0');
    }
} </s>
<s>class temp {    public void run() {
        BufferedReader reader = null;
        log = "Downloading... " + name;
        setChanged();
        notifyObservers();
        try {
            Date marker = to;
            int previousSize = 0;
            list.clear();
            do {
                previousSize = list.size();
                URL url = new URL(createLink(from, marker));
                reader = new BufferedReader(new InputStreamReader(url.openStream()));
                String line = "";
                while ((line = reader.readLine()) != null) {
                    try {
                        IQuoteHistorical quote = parse(line + ",");
                        if (quote != null && !list.contains(quote)) list.add(quote); else System.err.println(line);
                    } catch (ParseException e) {
                        e.printStackTrace();
                    }
                }
                if (list.size() > 0) marker = list.get(list.size() - 1).getData();
            } while (marker.after(from) && previousSize != list.size());
            log = "download Completed!";
        } catch (MalformedURLException e) {
            e.printStackTrace();
            log = e.getMessage();
        } catch (IOException e) {
            e.printStackTrace();
            log = e.getMessage();
        } finally {
            try {
                if (reader != null) reader.close();
            } catch (IOException e) {
                e.printStackTrace();
                log = e.getMessage();
            }
        }
        setChanged();
        notifyObservers();
    }
} </s>
<s>class temp {    public void transaction() {
        String delPets = "delete from PETS where PERSON_ID = 1";
        String delPersons = "delete from PERSONS where PERSON_ID = 1";
        if (true) {
            System.out.println(delPets);
            System.out.println(delPersons);
        }
        Connection conn = null;
        Statement stmt = null;
        try {
            conn = ConnHelper.getConnectionByDriverManager();
            conn.setAutoCommit(false);
            stmt = conn.createStatement();
            int affectedRows = stmt.executeUpdate(delPets);
            System.out.println("affectedRows = " + affectedRows);
            if (true) {
                throw new SQLException("fasfdsaf");
            }
            affectedRows = stmt.executeUpdate(delPersons);
            System.out.println("affectedRows = " + affectedRows);
            conn.commit();
            conn.setAutoCommit(true);
        } catch (Exception e) {
            try {
                conn.rollback();
            } catch (SQLException e1) {
                e.printStackTrace(System.out);
            }
            e.printStackTrace(System.out);
        } finally {
            ConnHelper.close(conn, stmt, null);
        }
    }
} </s>
<s>class temp {    protected String getLibJSCode() throws IOException {
        if (cachedLibJSCode == null) {
            InputStream is = getClass().getResourceAsStream(JS_LIB_FILE);
            StringWriter output = new StringWriter();
            IOUtils.copy(is, output);
            cachedLibJSCode = output.toString();
        }
        return cachedLibJSCode;
    }
} </s>
<s>class temp {    @Override
    public void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException {
        resp.setContentType("application/json");
        resp.setCharacterEncoding("utf-8");
        EntityManager em = EMF.get().createEntityManager();
        String url = req.getRequestURL().toString();
        String key = req.getParameter("key");
        String format = req.getParameter("format");
        if (key == null || !key.equals(Keys.APPREGKEY)) {
            resp.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            if (format != null && format.equals("xml")) resp.getWriter().print(Error.notAuthorised("").toXML(em)); else resp.getWriter().print(Error.notAuthorised("").toJSON(em));
            em.close();
            return;
        }
        String appname = req.getParameter("name");
        if (appname == null || appname.equals("")) {
            resp.setStatus(HttpServletResponse.SC_BAD_REQUEST);
            if (format != null && format.equals("xml")) resp.getWriter().print(Error.noAppId(null).toXML(em)); else resp.getWriter().print(Error.noAppId(null).toJSON(em));
            em.close();
            return;
        }
        StringBuffer appkey = new StringBuffer();
        try {
            MessageDigest algorithm = MessageDigest.getInstance("MD5");
            algorithm.reset();
            String api = System.nanoTime() + "" + System.identityHashCode(this) + "" + appname;
            algorithm.update(api.getBytes());
            byte[] digest = algorithm.digest();
            for (int i = 0; i < digest.length; i++) {
                appkey.append(Integer.toHexString(0xFF & digest[i]));
            }
        } catch (NoSuchAlgorithmException e) {
            resp.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
            if (format != null && format.equals("xml")) resp.getWriter().print(Error.unknownError().toXML(em)); else resp.getWriter().print(Error.unknownError().toJSON(em));
            log.severe(e.toString());
            em.close();
            return;
        }
        ClientApp app = new ClientApp();
        app.setName(appname);
        app.setKey(appkey.toString());
        app.setNumreceipts(0L);
        EntityTransaction tx = em.getTransaction();
        tx.begin();
        try {
            em.persist(app);
            tx.commit();
        } catch (Throwable t) {
            log.severe("Error persisting application " + app.getName() + ": " + t.getMessage());
            tx.rollback();
            resp.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
            if (format != null && format.equals("xml")) resp.getWriter().print(Error.unknownError().toXML(em)); else resp.getWriter().print(Error.unknownError().toJSON(em));
            em.close();
            return;
        }
        resp.setStatus(HttpServletResponse.SC_CREATED);
        if (format != null && format.equals("xml")) resp.getWriter().print(app.toXML(em)); else resp.getWriter().print(app.toJSON(em));
        em.close();
    }
} </s>
<s>class temp {    public void execute(HttpResponse response) throws HttpException, IOException {
        StringBuffer content = new StringBuffer();
        NodeSet allNodes = membershipRegistry.listAllMembers();
        for (Node node : allNodes) {
            content.append(node.getId().toString());
            content.append(SystemUtils.LINE_SEPARATOR);
        }
        StringEntity body = new StringEntity(content.toString());
        body.setContentType(PLAIN_TEXT_RESPONSE_CONTENT_TYPE);
        response.setEntity(body);
    }
} </s>
<s>class temp {    public void setPassword(String password) {
        MessageDigest md;
        try {
            md = MessageDigest.getInstance("SHA-256");
            md.update(password.getBytes("UTF-8"));
            byte[] digest = md.digest();
            String encodedPassword = Base64.encode(digest);
            this.password = encodedPassword;
        } catch (NoSuchAlgorithmException e) {
            logger.log(Level.SEVERE, "Password creation failed", e);
            throw new RuntimeException(e);
        } catch (UnsupportedEncodingException e) {
            logger.log(Level.SEVERE, "Password creation failed", e);
            throw new RuntimeException(e);
        }
    }
} </s>
<s>class temp {    public final void build() {
        if (!built_) {
            built_ = true;
            final boolean[] done = new boolean[] { false };
            Runnable runnable = new Runnable() {

                public void run() {
                    try {
                        exists_ = true;
                        URL url = getContentURL();
                        URLConnection cnx = url.openConnection();
                        cnx.connect();
                        lastModified_ = cnx.getLastModified();
                        length_ = cnx.getContentLength();
                        type_ = cnx.getContentType();
                        if (isDirectory()) {
                            InputStream in = cnx.getInputStream();
                            BufferedReader nr = new BufferedReader(new InputStreamReader(in));
                            FuVectorString v = readList(nr);
                            nr.close();
                            v.sort();
                            v.uniq();
                            list_ = v.toArray();
                        }
                    } catch (Exception ex) {
                        exists_ = false;
                    }
                    done[0] = true;
                }
            };
            Thread t = new Thread(runnable, "VfsFileUrl connection " + getContentURL());
            t.setPriority(Math.max(Thread.MIN_PRIORITY, t.getPriority() - 1));
            t.start();
            for (int i = 0; i < 100; i++) {
                if (done[0]) break;
                try {
                    Thread.sleep(300L);
                } catch (InterruptedException ex) {
                }
            }
            if (!done[0]) {
                t.interrupt();
                exists_ = false;
                canRead_ = false;
                FuLog.warning("VFS: fail to get " + url_);
            }
        }
    }
} </s>
<s>class temp {                public void run() {
                    try {
                        exists_ = true;
                        URL url = getContentURL();
                        URLConnection cnx = url.openConnection();
                        cnx.connect();
                        lastModified_ = cnx.getLastModified();
                        length_ = cnx.getContentLength();
                        type_ = cnx.getContentType();
                        if (isDirectory()) {
                            InputStream in = cnx.getInputStream();
                            BufferedReader nr = new BufferedReader(new InputStreamReader(in));
                            FuVectorString v = readList(nr);
                            nr.close();
                            v.sort();
                            v.uniq();
                            list_ = v.toArray();
                        }
                    } catch (Exception ex) {
                        exists_ = false;
                    }
                    done[0] = true;
                }
} </s>
<s>class temp {    private String readData(URL url) {
        try {
            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));
            StringBuffer responseBuffer = new StringBuffer();
            String line;
            while ((line = in.readLine()) != null) {
                responseBuffer.append(line);
            }
            in.close();
            return new String(responseBuffer);
        } catch (Exception e) {
            System.out.println(e);
        }
        return null;
    }
} </s>
<s>class temp {    public static String encrypt(String text) {
        MessageDigest md = null;
        try {
            md = MessageDigest.getInstance("MD5");
        } catch (NoSuchAlgorithmException ex) {
            throw new WebDocRuntimeException(ex);
        }
        md.update(text.getBytes());
        BigInteger hash = new BigInteger(1, md.digest());
        return hash.toString(HEX);
    }
} </s>
<s>class temp {    private void fetchAvailable(ProgressObserver po) {
        if (po == null) throw new IllegalArgumentException("the progress observer can't be null");
        if (availables == null) availables = new ArrayList<Dictionary>(); else availables.clear();
        if (installed == null) initInstalled();
        File home = SpellCheckPlugin.getHomeDir(jEdit.getActiveView());
        File target = new File(home, "available.lst");
        try {
            boolean skipDownload = false;
            if (target.exists()) {
                long modifiedDate = target.lastModified();
                Calendar c = Calendar.getInstance();
                c.setTimeInMillis(modifiedDate);
                Calendar yesterday = Calendar.getInstance();
                yesterday.add(Calendar.HOUR, -1);
                skipDownload = yesterday.before(c);
            }
            String enc = null;
            if (!skipDownload) {
                URL available_url = new URL(jEdit.getProperty(OOO_DICTS_PROP) + "available.lst");
                URLConnection connect = available_url.openConnection();
                connect.connect();
                InputStream is = connect.getInputStream();
                po.setMaximum(connect.getContentLength());
                OutputStream os = new FileOutputStream(target);
                boolean copied = IOUtilities.copyStream(po, is, os, true);
                if (!copied) {
                    Log.log(Log.ERROR, HunspellDictsManager.class, "Unable to download " + available_url.toString());
                    GUIUtilities.error(null, "spell-check-hunspell-error-fetch", new String[] { "Unable to download file " + available_url.toString() });
                    availables = null;
                    if (target.exists()) target.delete();
                    return;
                }
                IOUtilities.closeQuietly(os);
                enc = connect.getContentEncoding();
            }
            FileInputStream fis = new FileInputStream(target);
            Reader r;
            if (enc != null) {
                try {
                    r = new InputStreamReader(fis, enc);
                } catch (UnsupportedEncodingException uee) {
                    r = new InputStreamReader(fis, "UTF-8");
                }
            } else {
                r = new InputStreamReader(fis, "UTF-8");
            }
            BufferedReader br = new BufferedReader(r);
            for (String line = br.readLine(); line != null; line = br.readLine()) {
                Dictionary d = parseLine(line);
                if (d != null) {
                    int ind = installed.indexOf(d);
                    if (ind == -1) {
                        d.installed = false;
                        availables.add(d);
                    } else {
                        Dictionary id = installed.get(ind);
                        if (!skipDownload) {
                            Date lmd = fetchLastModifiedDate(id.archiveName);
                            if (lmd != null) {
                                id.lastModified = lmd;
                            }
                        }
                    }
                }
            }
            IOUtilities.closeQuietly(fis);
        } catch (IOException ioe) {
            if (ioe instanceof UnknownHostException) {
                GUIUtilities.error(null, "spell-check-hunspell-error-unknownhost", new String[] { ioe.getMessage() });
            } else {
                GUIUtilities.error(null, "spell-check-hunspell-error-fetch", new String[] { ioe.getMessage() });
            }
            ioe.printStackTrace();
            if (target.exists()) target.delete();
        }
    }
} </s>
<s>class temp {    private Date fetchLastModifiedDate(String archName) {
        Date modifdate = null;
        URL url = null;
        try {
            url = new URL(jEdit.getProperty(OOO_DICTS_PROP) + archName + ".zip");
        } catch (MalformedURLException mfue) {
            Log.log(Log.ERROR, HunspellDictsManager.class, "Invalid archive name : " + archName);
            GUIUtilities.error(null, "spell-check-hunspell-error-fetch", new String[] { mfue.getMessage() });
        }
        if (url != null) {
            try {
                URLConnection connect = url.openConnection();
                connect.connect();
                if (connect.getLastModified() == 0) {
                    Log.log(Log.ERROR, HunspellDictsManager.class, "no lastModifiedDate for " + archName);
                } else {
                    modifdate = new Date(connect.getLastModified());
                    System.out.println("Modif date :" + DateFormat.getInstance().format(modifdate));
                    return modifdate;
                }
            } catch (IOException ioe) {
                GUIUtilities.error(null, "spell-check-hunspell-error-fetch", new String[] { ioe.getMessage() });
                ioe.printStackTrace();
            }
        }
        return modifdate;
    }
} </s>
<s>class temp {    public void invoke(String args[]) {
        System.err.println("invoked with args of size " + args.length);
        try {
            for (int i = 0; i < args.length; i++) {
                System.err.println("processing URL: " + args[i]);
                URL url = new URL(args[i]);
                AnnotatedLinearObjectParser parserObj = findParserForURL(url);
                if (parserObj == null) {
                    continue;
                }
                InputStream data = url.openStream();
                CompMapViewerWrapper wrapper = ((CompMapViewerProvider) sp).getWrapper();
                wrapper.parseIntoDataModel(data, new URLImpl(url.toString()), parserObj, false);
                JFrame f = wrapper.getViewer().getMainFrame();
                f.show();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
} </s>
<s>class temp {    public void connect() throws ClientProtocolException, IOException {
        HttpResponse httpResponse = httpClient.execute(httpGet);
        HttpEntity entity = httpResponse.getEntity();
        inputStream = entity.getContent();
        Header contentEncodingHeader = entity.getContentEncoding();
        if (contentEncodingHeader != null) {
            HeaderElement[] codecs = contentEncodingHeader.getElements();
            for (HeaderElement encoding : codecs) {
                if (encoding.getName().equalsIgnoreCase("gzip")) {
                    inputStream = new GZIPInputStream(inputStream);
                }
            }
        }
        inputStream = new BufferedInputStream(inputStream, 2048);
    }
} </s>
<s>class temp {    public boolean backupFile(File oldFile, File newFile) {
        boolean isBkupFileOK = false;
        FileChannel sourceChannel = null;
        FileChannel targetChannel = null;
        try {
            sourceChannel = new FileInputStream(oldFile).getChannel();
            targetChannel = new FileOutputStream(newFile).getChannel();
            targetChannel.transferFrom(sourceChannel, 0, sourceChannel.size());
        } catch (IOException e) {
            logger.log(Level.SEVERE, "IO exception occurred while copying file", e);
        } finally {
            if ((newFile != null) && (newFile.exists()) && (newFile.length() > 0)) {
                isBkupFileOK = true;
            }
            try {
                if (sourceChannel != null) {
                    sourceChannel.close();
                }
                if (targetChannel != null) {
                    targetChannel.close();
                }
            } catch (IOException e) {
                logger.log(Level.INFO, "closing channels failed");
            }
        }
        return isBkupFileOK;
    }
} </s>
<s>class temp {    public String SHA1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        MessageDigest md = MessageDigest.getInstance(SHA1);
        md.update(text.getBytes(CHAR_SET), 0, text.length());
        byte[] mdbytes = md.digest();
        return byteToHex(mdbytes);
    }
} </s>
<s>class temp {    public void connect() throws SocketException, IOException {
        Log.i(TAG, "Test attempt login to " + ftpHostname + " as " + ftpUsername);
        ftpClient = new FTPClient();
        ftpClient.connect(this.ftpHostname, this.ftpPort);
        ftpClient.login(ftpUsername, ftpPassword);
        int reply = ftpClient.getReplyCode();
        if (!FTPReply.isPositiveCompletion(reply)) {
            String error = "Login failure (" + reply + ") : " + ftpClient.getReplyString();
            Log.e(TAG, error);
            throw new IOException(error);
        }
    }
} </s>
<s>class temp {    public void copyTo(String newname) throws IOException {
        FileChannel srcChannel = new FileInputStream(dosname).getChannel();
        FileChannel dstChannel = new FileOutputStream(newname).getChannel();
        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());
        srcChannel.close();
        dstChannel.close();
    }
} </s>
<s>class temp {    public void convert(File src, File dest) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(src));
        DcmParser p = pfact.newDcmParser(in);
        Dataset ds = fact.newDataset();
        p.setDcmHandler(ds.getDcmHandler());
        try {
            FileFormat format = p.detectFileFormat();
            if (format != FileFormat.ACRNEMA_STREAM) {
                System.out.println("\n" + src + ": not an ACRNEMA stream!");
                return;
            }
            p.parseDcmFile(format, Tags.PixelData);
            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {
                System.out.println("\n" + src + ": contains UIDs!" + " => probable already DICOM - do not convert");
                return;
            }
            boolean hasPixelData = p.getReadTag() == Tags.PixelData;
            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;
            int pxlen = p.getReadLength();
            if (hasPixelData) {
                if (inflate) {
                    ds.putUS(Tags.BitsAllocated, 16);
                    pxlen = pxlen * 4 / 3;
                }
                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {
                    System.out.println("\n" + src + ": mismatch pixel data length!" + " => do not convert");
                    return;
                }
            }
            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));
            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));
            ds.putUI(Tags.SOPInstanceUID, uid(instUID));
            ds.putUI(Tags.SOPClassUID, classUID);
            if (!ds.contains(Tags.NumberOfSamples)) {
                ds.putUS(Tags.NumberOfSamples, 1);
            }
            if (!ds.contains(Tags.PhotometricInterpretation)) {
                ds.putCS(Tags.PhotometricInterpretation, "MONOCHROME2");
            }
            if (fmi) {
                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));
            }
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
            try {
            } finally {
                ds.writeFile(out, encodeParam());
                if (hasPixelData) {
                    if (!skipGroupLen) {
                        out.write(PXDATA_GROUPLEN);
                        int grlen = pxlen + 8;
                        out.write((byte) grlen);
                        out.write((byte) (grlen >> 8));
                        out.write((byte) (grlen >> 16));
                        out.write((byte) (grlen >> 24));
                    }
                    out.write(PXDATA_TAG);
                    out.write((byte) pxlen);
                    out.write((byte) (pxlen >> 8));
                    out.write((byte) (pxlen >> 16));
                    out.write((byte) (pxlen >> 24));
                }
                if (inflate) {
                    int b2, b3;
                    for (; pxlen > 0; pxlen -= 3) {
                        out.write(in.read());
                        b2 = in.read();
                        b3 = in.read();
                        out.write(b2 & 0x0f);
                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));
                        out.write(b3 >> 4);
                    }
                } else {
                    for (; pxlen > 0; --pxlen) {
                        out.write(in.read());
                    }
                }
                out.close();
            }
            System.out.print('.');
        } finally {
            in.close();
        }
    }
} </s>
<s>class temp {    public static String hashString(String sPassword) {
        if (sPassword == null || sPassword.equals("")) {
            return "empty:";
        } else {
            try {
                MessageDigest md = MessageDigest.getInstance("SHA-1");
                md.update(sPassword.getBytes("UTF-8"));
                byte[] res = md.digest();
                return "sha1:" + StringUtils.byte2hex(res);
            } catch (NoSuchAlgorithmException e) {
                return "plain:" + sPassword;
            } catch (UnsupportedEncodingException e) {
                return "plain:" + sPassword;
            }
        }
    }
} </s>
<s>class temp {    public static void main(String[] args) {
        if (args.length < 2) {
            System.out.println(" *** DDL (creates) and DML (inserts) script importer from DB ***");
            System.out.println(" You must specify name of the file with script importing data");
            System.out.println(" Fisrt rows of this file must be:");
            System.out.println(" 1) JDBC driver class for your DBMS");
            System.out.println(" 2) URL for your database instance");
            System.out.println(" 3) user in that database (with sufficient priviliges)");
            System.out.println(" 4) password of that user");
            System.out.println(" Next rows can have:");
            System.out.println("   '}' before table to create,");
            System.out.println("   '{' before schema to create tables in,");
            System.out.println("   ')' before table to insert into,");
            System.out.println("   '(' before schema to insert into tables in.");
            System.out.println(" '!' before row means that it is a comment.");
            System.out.println(" If some exception is occured, all script is rolled back.");
            System.out.println(" 2nd command line argument is name of output file;");
            System.out.println("   if its extension is *.sql, its format is standard SQL");
            System.out.println("   otherwize format is short one, understanded by SQLScript tool");
            System.out.println(" Connection information remains unchanged in the last format");
            System.out.println("   but in the first one it takes form 'connect user/password@URL'");
            System.out.println("   where URL can be formed with different rools for different DBMSs");
            System.out.println(" If file (with short format header) already exists and you specify");
            System.out.println("   3rd command line argument -db, we generate objects in the database");
            System.out.println("   (known from the file header; must differ from 1st DB) but not in file");
            System.out.println(" Note: when importing to a file of short format, line separators");
            System.out.println("    in VARCHARS will be lost; LOBs will be empty for any file");
            System.exit(0);
        }
        try {
            String[] info = new String[4];
            BufferedReader reader = new BufferedReader(new FileReader(new File(args[0])));
            Writer writer = null;
            Connection outConnection = null;
            try {
                for (int i = 0; i < info.length; i++) info[i] = reader.readLine();
                try {
                    Class.forName(info[0]);
                    Connection connection = DriverManager.getConnection(info[1], info[2], info[3]);
                    int format = args[1].toLowerCase().endsWith("sql") ? SQL_FORMAT : SHORT_FORMAT;
                    File file = new File(args[1]);
                    if (format == SHORT_FORMAT) {
                        if (file.exists() && args.length > 2 && args[2].equalsIgnoreCase("-db")) {
                            String[] outInfo = new String[info.length];
                            BufferedReader outReader = new BufferedReader(new FileReader(file));
                            for (int i = 0; i < outInfo.length; i++) outInfo[i] = reader.readLine();
                            outReader.close();
                            if (!(outInfo[1].equals(info[1]) && outInfo[2].equals(info[2]))) {
                                Class.forName(info[0]);
                                outConnection = DriverManager.getConnection(outInfo[1], outInfo[2], outInfo[3]);
                                format = SQL_FORMAT;
                            }
                        }
                    }
                    if (outConnection == null) writer = new BufferedWriter(new FileWriter(file));
                    SQLImporter script = new SQLImporter(outConnection, connection);
                    script.setFormat(format);
                    if (format == SQL_FORMAT) {
                        writer.write("connect " + info[2] + "/" + info[3] + "@" + script.getDatabaseURL(info[1]) + script.statementTerminator);
                    } else {
                        for (int i = 0; i < info.length; i++) writer.write(info[i] + lineSep);
                        writer.write(lineSep);
                    }
                    try {
                        System.out.println(script.executeScript(reader, writer) + " operations with tables has been generated during import");
                    } catch (SQLException e4) {
                        reader.close();
                        if (writer != null) writer.close(); else outConnection.close();
                        System.out.println(" Script generation error: " + e4);
                    }
                    connection.close();
                } catch (Exception e3) {
                    reader.close();
                    if (writer != null) writer.close();
                    System.out.println(" Connection error: " + e3);
                }
            } catch (IOException e2) {
                System.out.println("Error in file " + args[0]);
            }
        } catch (FileNotFoundException e1) {
            System.out.println("File " + args[0] + " not found");
        }
    }
} </s>
<s>class temp {    public static byte[] wrapBMP(Image image) throws IOException {
        if (image.getOriginalType() != Image.ORIGINAL_BMP) throw new IOException("Only BMP can be wrapped in WMF.");
        InputStream imgIn;
        byte data[] = null;
        if (image.getOriginalData() == null) {
            imgIn = image.url().openStream();
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            int b = 0;
            while ((b = imgIn.read()) != -1) out.write(b);
            imgIn.close();
            data = out.toByteArray();
        } else data = image.getOriginalData();
        int sizeBmpWords = (data.length - 14 + 1) >>> 1;
        ByteArrayOutputStream os = new ByteArrayOutputStream();
        writeWord(os, 1);
        writeWord(os, 9);
        writeWord(os, 0x0300);
        writeDWord(os, 9 + 4 + 5 + 5 + (13 + sizeBmpWords) + 3);
        writeWord(os, 1);
        writeDWord(os, 14 + sizeBmpWords);
        writeWord(os, 0);
        writeDWord(os, 4);
        writeWord(os, META_SETMAPMODE);
        writeWord(os, 8);
        writeDWord(os, 5);
        writeWord(os, META_SETWINDOWORG);
        writeWord(os, 0);
        writeWord(os, 0);
        writeDWord(os, 5);
        writeWord(os, META_SETWINDOWEXT);
        writeWord(os, (int) image.height());
        writeWord(os, (int) image.width());
        writeDWord(os, 13 + sizeBmpWords);
        writeWord(os, META_DIBSTRETCHBLT);
        writeDWord(os, 0x00cc0020);
        writeWord(os, (int) image.height());
        writeWord(os, (int) image.width());
        writeWord(os, 0);
        writeWord(os, 0);
        writeWord(os, (int) image.height());
        writeWord(os, (int) image.width());
        writeWord(os, 0);
        writeWord(os, 0);
        os.write(data, 14, data.length - 14);
        if ((data.length & 1) == 1) os.write(0);
        writeDWord(os, 3);
        writeWord(os, 0);
        os.close();
        return os.toByteArray();
    }
} </s>
<s>class temp {    private void readChildrenData() throws Exception {
        URL url;
        URLConnection connect;
        BufferedInputStream in;
        try {
            url = getURL("CHILDREN.TAB");
            connect = url.openConnection();
            InputStream ois = connect.getInputStream();
            if (ois == null) {
                concepts3 = new IntegerArray(1);
                return;
            }
            in = new BufferedInputStream(ois);
            int k1 = in.read();
            concepts3 = new IntegerArray(4096);
            StreamDecompressor sddocs = new StreamDecompressor(in);
            sddocs.ascDecode(k1, concepts3);
            int k2 = in.read();
            offsets3 = new IntegerArray(concepts3.cardinality() + 1);
            offsets3.add(0);
            StreamDecompressor sdoffsets = new StreamDecompressor(in);
            sdoffsets.ascDecode(k2, offsets3);
            in.close();
            url = getURL("CHILDREN");
            connect = url.openConnection();
            ois = connect.getInputStream();
            if (ois == null) {
                concepts3 = new IntegerArray(1);
                return;
            }
            in = new BufferedInputStream(ois);
            int length = connect.getContentLength();
            allChildren = new byte[length];
            in.read(allChildren);
            in.close();
        } catch (MalformedURLException e) {
            concepts3 = new IntegerArray(1);
        } catch (FileNotFoundException e2) {
            concepts3 = new IntegerArray(1);
        } catch (IOException e2) {
            concepts3 = new IntegerArray(1);
        }
    }
} </s>
<s>class temp {    private void readFromDB() throws Exception {
        URL url;
        URLConnection connect;
        BufferedInputStream in = null;
        Schema schema = new Schema(base, indexDir, false);
        BtreeDictParameters params = new BtreeDictParameters(schema, "TMAP");
        params.readState();
        tmap = new BtreeDict(params);
        readChildrenData();
        url = getURL("DOCS.TAB");
        connect = url.openConnection();
        in = new BufferedInputStream(connect.getInputStream());
        int k1 = in.read();
        concepts = new IntegerArray(4096);
        StreamDecompressor sddocs = new StreamDecompressor(in);
        sddocs.ascDecode(k1, concepts);
        int k2 = in.read();
        offsets = new IntegerArray(concepts.cardinality() + 1);
        offsets.add(0);
        StreamDecompressor sdoffsets = new StreamDecompressor(in);
        sdoffsets.ascDecode(k2, offsets);
        in.close();
        url = getURL("DOCS");
        connect = url.openConnection();
        in = new BufferedInputStream(connect.getInputStream());
        ByteArrayOutputStream data = new ByteArrayOutputStream();
        byte[] buff = new byte[512];
        int i = 0;
        while ((i = in.read(buff)) != -1) {
            data.write(buff, 0, i);
        }
        allLists = data.toByteArray();
        in.close();
        url = getURL("OFFSETS");
        connect = url.openConnection();
        in = new BufferedInputStream(connect.getInputStream());
        k1 = in.read();
        documents = new IntegerArray(4096);
        sddocs = new StreamDecompressor(in);
        sddocs.ascDecode(k1, documents);
        k2 = in.read();
        offsets2 = new IntegerArray(documents.cardinality() + 1);
        sdoffsets = new StreamDecompressor(in);
        sdoffsets.ascDecode(k2, offsets2);
        int k3 = in.read();
        titles = new IntegerArray(documents.cardinality());
        StreamDecompressor sdtitles = new StreamDecompressor(in);
        sdtitles.decode(k3, titles);
        in.close();
        RAFFileFactory factory = RAFFileFactory.create();
        url = getURL("POSITIONS");
        positionsFile = factory.get(url, false);
    }
} </s>
<s>class temp {    private static String getSuitableWCSVersion(String host, String _version) throws ConnectException, IOException {
        String request = WCSProtocolHandler.buildCapabilitiesSuitableVersionRequest(host, _version);
        String version = new String();
        StringReader reader = null;
        DataInputStream dis = null;
        try {
            URL url = new URL(request);
            byte[] buffer = new byte[1024];
            dis = new DataInputStream(url.openStream());
            dis.readFully(buffer);
            reader = new StringReader(new String(buffer));
            KXmlParser kxmlParser = null;
            kxmlParser = new KXmlParser();
            kxmlParser.setInput(reader);
            kxmlParser.nextTag();
            if (kxmlParser.getEventType() != KXmlParser.END_DOCUMENT) {
                if ((kxmlParser.getName().compareTo(CapabilitiesTags.WCS_CAPABILITIES_ROOT1_0_0) == 0)) {
                    version = kxmlParser.getAttributeValue("", CapabilitiesTags.VERSION);
                }
            }
            reader.close();
            dis.close();
            return version;
        } catch (ConnectException conEx) {
            throw new ConnectException(conEx.getMessage());
        } catch (IOException ioEx) {
            throw new IOException(ioEx.getMessage());
        } catch (XmlPullParserException xmlEx) {
            xmlEx.printStackTrace();
            return "";
        } finally {
            if (reader != null) {
                try {
                    reader.close();
                } catch (Exception ex) {
                    ex.printStackTrace();
                }
            }
            if (dis != null) {
                try {
                    dis.close();
                } catch (Exception ex) {
                    ex.printStackTrace();
                }
            }
        }
    }
} </s>
<s>class temp {    public static String encrypt(String text) throws NoSuchAlgorithmException {
        MessageDigest md;
        md = MessageDigest.getInstance("MD5");
        byte[] md5hash = new byte[32];
        try {
            md.update(text.getBytes("iso-8859-1"), 0, text.length());
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
        md5hash = md.digest();
        return convertToHex(md5hash);
    }
} </s>
<s>class temp {    public void get(final String remoteFilePath, final String remoteFileName, final String localName) {
        final FTPClient ftp = new FTPClient();
        final FTPMessageCollector listener = new FTPMessageCollector();
        try {
            final String localDirName = localName.substring(0, localName.lastIndexOf(File.separator));
            System.out.println("ftp:");
            System.out.println("   remoteDir " + remoteFilePath);
            System.out.println("   localDir " + localDirName);
            final File localDir = new File(localDirName);
            if (!localDir.exists()) {
                System.out.println("   create Dir " + localDirName);
                localDir.mkdir();
            }
            ftp.setTimeout(10000);
            ftp.setRemoteHost(host);
            ftp.setMessageListener(listener);
        } catch (final UnknownHostException e) {
            showConnectError();
            return;
        } catch (final Exception e) {
            e.printStackTrace();
        }
        final TileInfoManager tileInfoMgr = TileInfoManager.getInstance();
        final Job downloadJob = new Job(Messages.job_name_ftpDownload) {

            @Override
            protected IStatus run(final IProgressMonitor monitor) {
                try {
                    showTileInfo(remoteFileName, -1);
                    System.out.println("   connect " + host);
                    ftp.connect();
                    showTileInfo(remoteFileName, -2);
                    System.out.println("   login " + user + " " + password);
                    ftp.login(user, password);
                    System.out.println("   set passive mode");
                    ftp.setConnectMode(FTPConnectMode.PASV);
                    System.out.println("   set type binary");
                    ftp.setType(FTPTransferType.BINARY);
                    showTileInfo(remoteFileName, -3);
                    System.out.println("   chdir " + remoteFilePath);
                    ftp.chdir(remoteFilePath);
                    ftp.setProgressMonitor(new FTPProgressMonitor() {

                        public void bytesTransferred(final long count) {
                            tileInfoMgr.updateSRTMTileInfo(TileEventId.SRTM_DATA_LOADING_MONITOR, remoteFileName, count);
                        }
                    });
                    showTileInfo(remoteFileName, -4);
                    System.out.println("   get " + remoteFileName + " -> " + localName + " ...");
                    ftp.get(localName, remoteFileName);
                    System.out.println("   quit");
                    ftp.quit();
                } catch (final UnknownHostException e) {
                    return new Status(IStatus.ERROR, TourbookPlugin.PLUGIN_ID, IStatus.ERROR, NLS.bind(Messages.error_message_cannotConnectToServer, host), e);
                } catch (final SocketTimeoutException e) {
                    return new Status(IStatus.ERROR, TourbookPlugin.PLUGIN_ID, IStatus.ERROR, NLS.bind(Messages.error_message_timeoutWhenConnectingToServer, host), e);
                } catch (final Exception e) {
                    e.printStackTrace();
                    tileInfoMgr.updateSRTMTileInfo(TileEventId.SRTM_DATA_ERROR_LOADING, remoteFileName, 0);
                } finally {
                    tileInfoMgr.updateSRTMTileInfo(TileEventId.SRTM_DATA_END_LOADING, remoteFileName, 0);
                }
                return Status.OK_STATUS;
            }
        };
        downloadJob.schedule();
        try {
            downloadJob.join();
        } catch (final InterruptedException e) {
            e.printStackTrace();
        }
    }
} </s>
<s>class temp {            @Override
            protected IStatus run(final IProgressMonitor monitor) {
                try {
                    showTileInfo(remoteFileName, -1);
                    System.out.println("   connect " + host);
                    ftp.connect();
                    showTileInfo(remoteFileName, -2);
                    System.out.println("   login " + user + " " + password);
                    ftp.login(user, password);
                    System.out.println("   set passive mode");
                    ftp.setConnectMode(FTPConnectMode.PASV);
                    System.out.println("   set type binary");
                    ftp.setType(FTPTransferType.BINARY);
                    showTileInfo(remoteFileName, -3);
                    System.out.println("   chdir " + remoteFilePath);
                    ftp.chdir(remoteFilePath);
                    ftp.setProgressMonitor(new FTPProgressMonitor() {

                        public void bytesTransferred(final long count) {
                            tileInfoMgr.updateSRTMTileInfo(TileEventId.SRTM_DATA_LOADING_MONITOR, remoteFileName, count);
                        }
                    });
                    showTileInfo(remoteFileName, -4);
                    System.out.println("   get " + remoteFileName + " -> " + localName + " ...");
                    ftp.get(localName, remoteFileName);
                    System.out.println("   quit");
                    ftp.quit();
                } catch (final UnknownHostException e) {
                    return new Status(IStatus.ERROR, TourbookPlugin.PLUGIN_ID, IStatus.ERROR, NLS.bind(Messages.error_message_cannotConnectToServer, host), e);
                } catch (final SocketTimeoutException e) {
                    return new Status(IStatus.ERROR, TourbookPlugin.PLUGIN_ID, IStatus.ERROR, NLS.bind(Messages.error_message_timeoutWhenConnectingToServer, host), e);
                } catch (final Exception e) {
                    e.printStackTrace();
                    tileInfoMgr.updateSRTMTileInfo(TileEventId.SRTM_DATA_ERROR_LOADING, remoteFileName, 0);
                } finally {
                    tileInfoMgr.updateSRTMTileInfo(TileEventId.SRTM_DATA_END_LOADING, remoteFileName, 0);
                }
                return Status.OK_STATUS;
            }
} </s>

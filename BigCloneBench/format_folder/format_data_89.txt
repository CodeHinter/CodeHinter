<s>class temp {    private static void readAndRewrite(File inFile, File outFile) throws IOException {
        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));
        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);
        Dataset ds = DcmObjectFactory.getInstance().newDataset();
        dcmParser.setDcmHandler(ds.getDcmHandler());
        dcmParser.parseDcmFile(null, Tags.PixelData);
        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        System.out.println("reading " + inFile + "...");
        pdReader.readPixelData(false);
        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));
        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;
        ds.writeDataset(out, dcmEncParam);
        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());
        System.out.println("writing " + outFile + "...");
        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        pdWriter.writePixelData();
        out.flush();
        out.close();
        System.out.println("done!");
    }
} </s>
<s>class temp {    public static boolean dumpFile(String from, File to, String lineBreak) {
        try {
            BufferedReader in = new BufferedReader(new InputStreamReader(new FileInputStream(from)));
            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(to)));
            String line = null;
            while ((line = in.readLine()) != null) out.write(Main.getInstance().resolve(line) + lineBreak);
            in.close();
            out.close();
        } catch (Exception e) {
            Installer.getInstance().getLogger().log(StringUtils.getStackTrace(e));
            return false;
        }
        return true;
    }
} </s>
<s>class temp {    public static boolean downloadFile(String from, String to, ProgressMonitor pm) {
        try {
            FileOutputStream out = new FileOutputStream(to);
            URL url = new URL(from);
            URLConnection conn = url.openConnection();
            InputStream in = conn.getInputStream();
            byte[] buffer = new byte[1024];
            int read = 0;
            while ((read = in.read(buffer)) != -1) {
                out.write(buffer, 0, read);
                if (pm != null) pm.addToProgress(read);
            }
            out.close();
            in.close();
        } catch (Exception e) {
            Installer.getInstance().getLogger().log(StringUtils.getStackTrace(e));
            return false;
        }
        return true;
    }
} </s>
<s>class temp {    public static void unzipAndRemove(final String file) {
        String destination = file.substring(0, file.length() - 3);
        InputStream is = null;
        OutputStream os = null;
        try {
            is = new GZIPInputStream(new FileInputStream(file));
            os = new FileOutputStream(destination);
            byte[] buffer = new byte[8192];
            for (int length; (length = is.read(buffer)) != -1; ) os.write(buffer, 0, length);
        } catch (IOException e) {
            System.err.println("Fehler: Kann nicht entpacken " + file);
        } finally {
            if (os != null) try {
                os.close();
            } catch (IOException e) {
            }
            if (is != null) try {
                is.close();
            } catch (IOException e) {
            }
        }
        deleteFile(file);
    }
} </s>
<s>class temp {    public static void main(String[] args) {
        String source, destination;
        if (args[0].toLowerCase().endsWith(".gz")) {
            source = args[0];
            destination = source.substring(0, source.length() - 3);
        } else {
            source = args[0] + ".gz";
            destination = args[0];
        }
        InputStream is = null;
        OutputStream os = null;
        try {
            is = new GZIPInputStream(new FileInputStream(source));
            os = new FileOutputStream(destination);
            byte[] buffer = new byte[8192];
            for (int length; (length = is.read(buffer)) != -1; ) os.write(buffer, 0, length);
        } catch (IOException e) {
            System.err.println("Fehler: Kann nicht entpacken " + args[0]);
        } finally {
            if (os != null) try {
                os.close();
            } catch (IOException e) {
            }
            if (is != null) try {
                is.close();
            } catch (IOException e) {
            }
        }
    }
} </s>
<s>class temp {    public NamedList<Object> request(final SolrRequest request, ResponseParser processor) throws SolrServerException, IOException {
        HttpMethod method = null;
        InputStream is = null;
        SolrParams params = request.getParams();
        Collection<ContentStream> streams = requestWriter.getContentStreams(request);
        String path = requestWriter.getPath(request);
        if (path == null || !path.startsWith("/")) {
            path = "/select";
        }
        ResponseParser parser = request.getResponseParser();
        if (parser == null) {
            parser = _parser;
        }
        ModifiableSolrParams wparams = new ModifiableSolrParams();
        wparams.set(CommonParams.WT, parser.getWriterType());
        wparams.set(CommonParams.VERSION, parser.getVersion());
        if (params == null) {
            params = wparams;
        } else {
            params = new DefaultSolrParams(wparams, params);
        }
        if (_invariantParams != null) {
            params = new DefaultSolrParams(_invariantParams, params);
        }
        int tries = _maxRetries + 1;
        try {
            while (tries-- > 0) {
                try {
                    if (SolrRequest.METHOD.GET == request.getMethod()) {
                        if (streams != null) {
                            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, "GET can't send streams!");
                        }
                        method = new GetMethod(_baseURL + path + ClientUtils.toQueryString(params, false));
                    } else if (SolrRequest.METHOD.POST == request.getMethod()) {
                        String url = _baseURL + path;
                        boolean isMultipart = (streams != null && streams.size() > 1);
                        if (streams == null || isMultipart) {
                            PostMethod post = new PostMethod(url);
                            post.getParams().setContentCharset("UTF-8");
                            if (!this.useMultiPartPost && !isMultipart) {
                                post.addRequestHeader("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8");
                            }
                            List<Part> parts = new LinkedList<Part>();
                            Iterator<String> iter = params.getParameterNamesIterator();
                            while (iter.hasNext()) {
                                String p = iter.next();
                                String[] vals = params.getParams(p);
                                if (vals != null) {
                                    for (String v : vals) {
                                        if (this.useMultiPartPost || isMultipart) {
                                            parts.add(new StringPart(p, v, "UTF-8"));
                                        } else {
                                            post.addParameter(p, v);
                                        }
                                    }
                                }
                            }
                            if (isMultipart) {
                                int i = 0;
                                for (ContentStream content : streams) {
                                    final ContentStream c = content;
                                    String charSet = null;
                                    String transferEncoding = null;
                                    parts.add(new PartBase(c.getName(), c.getContentType(), charSet, transferEncoding) {

                                        @Override
                                        protected long lengthOfData() throws IOException {
                                            return c.getSize();
                                        }

                                        @Override
                                        protected void sendData(OutputStream out) throws IOException {
                                            Reader reader = c.getReader();
                                            try {
                                                IOUtils.copy(reader, out);
                                            } finally {
                                                reader.close();
                                            }
                                        }
                                    });
                                }
                            }
                            if (parts.size() > 0) {
                                post.setRequestEntity(new MultipartRequestEntity(parts.toArray(new Part[parts.size()]), post.getParams()));
                            }
                            method = post;
                        } else {
                            String pstr = ClientUtils.toQueryString(params, false);
                            PostMethod post = new PostMethod(url + pstr);
                            final ContentStream[] contentStream = new ContentStream[1];
                            for (ContentStream content : streams) {
                                contentStream[0] = content;
                                break;
                            }
                            if (contentStream[0] instanceof RequestWriter.LazyContentStream) {
                                post.setRequestEntity(new RequestEntity() {

                                    public long getContentLength() {
                                        return -1;
                                    }

                                    public String getContentType() {
                                        return contentStream[0].getContentType();
                                    }

                                    public boolean isRepeatable() {
                                        return false;
                                    }

                                    public void writeRequest(OutputStream outputStream) throws IOException {
                                        ((RequestWriter.LazyContentStream) contentStream[0]).writeTo(outputStream);
                                    }
                                });
                            } else {
                                is = contentStream[0].getStream();
                                post.setRequestEntity(new InputStreamRequestEntity(is, contentStream[0].getContentType()));
                            }
                            method = post;
                        }
                    } else {
                        throw new SolrServerException("Unsupported method: " + request.getMethod());
                    }
                } catch (NoHttpResponseException r) {
                    method.releaseConnection();
                    method = null;
                    if (is != null) {
                        is.close();
                    }
                    if ((tries < 1)) {
                        throw r;
                    }
                }
            }
        } catch (IOException ex) {
            throw new SolrServerException("error reading streams", ex);
        }
        method.setFollowRedirects(_followRedirects);
        method.addRequestHeader("User-Agent", AGENT);
        if (_allowCompression) {
            method.setRequestHeader(new Header("Accept-Encoding", "gzip,deflate"));
        }
        try {
            int statusCode = _httpClient.executeMethod(method);
            if (statusCode != HttpStatus.SC_OK) {
                StringBuilder msg = new StringBuilder();
                msg.append(method.getStatusLine().getReasonPhrase());
                msg.append("\n\n");
                msg.append(method.getStatusText());
                msg.append("\n\n");
                msg.append("request: " + method.getURI());
                throw new SolrException(statusCode, java.net.URLDecoder.decode(msg.toString(), "UTF-8"));
            }
            String charset = "UTF-8";
            if (method instanceof HttpMethodBase) {
                charset = ((HttpMethodBase) method).getResponseCharSet();
            }
            InputStream respBody = method.getResponseBodyAsStream();
            if (_allowCompression) {
                Header contentEncodingHeader = method.getResponseHeader("Content-Encoding");
                if (contentEncodingHeader != null) {
                    String contentEncoding = contentEncodingHeader.getValue();
                    if (contentEncoding.contains("gzip")) {
                        respBody = new GZIPInputStream(respBody);
                    } else if (contentEncoding.contains("deflate")) {
                        respBody = new InflaterInputStream(respBody);
                    }
                } else {
                    Header contentTypeHeader = method.getResponseHeader("Content-Type");
                    if (contentTypeHeader != null) {
                        String contentType = contentTypeHeader.getValue();
                        if (contentType != null) {
                            if (contentType.startsWith("application/x-gzip-compressed")) {
                                respBody = new GZIPInputStream(respBody);
                            } else if (contentType.startsWith("application/x-deflate")) {
                                respBody = new InflaterInputStream(respBody);
                            }
                        }
                    }
                }
            }
            return processor.processResponse(respBody, charset);
        } catch (HttpException e) {
            throw new SolrServerException(e);
        } catch (IOException e) {
            throw new SolrServerException(e);
        } finally {
            method.releaseConnection();
            if (is != null) {
                is.close();
            }
        }
    }
} </s>
<s>class temp {    public static void copy(String from_name, String to_name) throws IOException {
        File from_file = new File(from_name);
        File to_file = new File(to_name);
        if (!from_file.exists()) abort("FileCopy: no such source file: " + from_name);
        if (!from_file.isFile()) abort("FileCopy: can't copy directory: " + from_name);
        if (!from_file.canRead()) abort("FileCopy: source file is unreadable: " + from_name);
        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());
        if (to_file.exists()) {
            if (!to_file.canWrite()) abort("FileCopy: destination file is unwriteable: " + to_name);
        } else {
            String parent = to_file.getParent();
            if (parent == null) parent = System.getProperty("user.dir");
            File dir = new File(parent);
            if (!dir.exists()) abort("FileCopy: destination directory doesn't exist: " + parent);
            if (dir.isFile()) abort("FileCopy: destination is not a directory: " + parent);
            if (!dir.canWrite()) abort("FileCopy: destination directory is unwriteable: " + parent);
        }
        FileInputStream from = null;
        FileOutputStream to = null;
        try {
            from = new FileInputStream(from_file);
            to = new FileOutputStream(to_file);
            byte[] buffer = new byte[4096];
            int bytes_read;
            while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read);
        } finally {
            if (from != null) try {
                from.close();
            } catch (IOException e) {
                ;
            }
            if (to != null) try {
                to.close();
            } catch (IOException e) {
                ;
            }
        }
    }
} </s>
<s>class temp {    public static void main(String[] args) throws IOException {
        String urltext = "http://www.vogella.de";
        URL url = new URL(urltext);
        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));
        String inputLine;
        while ((inputLine = in.readLine()) != null) {
            System.out.println(inputLine);
        }
        in.close();
    }
} </s>
<s>class temp {    public void downSync(Vector v) throws SQLException {
        try {
            con = allocateConnection(tableName);
            PreparedStatement update = con.prepareStatement("update cal_Event set owner=?,subject=?,text=?,place=?," + "contactperson=?,startdate=?,enddate=?,starttime=?,endtime=?,allday=?," + "syncstatus=?,dirtybits=? where OId=? and syncstatus=?");
            PreparedStatement insert = con.prepareStatement("insert into cal_Event (owner,subject,text,place," + "contactperson,startdate,enddate,starttime,endtime,allday,syncstatus," + "dirtybits) values(?,?,?,?,?,?,?,?,?,?,?,?)");
            PreparedStatement insert1 = con.prepareStatement(DBUtil.getQueryCurrentOID(con, "cal_Event", "newoid"));
            PreparedStatement delete1 = con.prepareStatement("delete from  cal_Event_Remind where event=?");
            PreparedStatement delete2 = con.prepareStatement("delete from  cal_Event where OId=? " + "and (syncstatus=? or syncstatus=?)");
            for (int i = 0; i < v.size(); i++) {
                try {
                    DO = (EventDO) v.elementAt(i);
                    if (DO.getSyncstatus() == INSERT) {
                        insert.setBigDecimal(1, DO.getOwner());
                        insert.setString(2, DO.getSubject());
                        insert.setString(3, DO.getText());
                        insert.setString(4, DO.getPlace());
                        insert.setString(5, DO.getContactperson());
                        insert.setDate(6, DO.getStartdate());
                        insert.setDate(7, DO.getEnddate());
                        insert.setTime(8, DO.getStarttime());
                        insert.setTime(9, DO.getEndtime());
                        insert.setBoolean(10, DO.getAllday());
                        insert.setInt(11, RESET);
                        insert.setInt(12, RESET);
                        con.executeUpdate(insert, null);
                        con.reset();
                        rs = con.executeQuery(insert1, null);
                        if (rs.next()) DO.setOId(rs.getBigDecimal("newoid"));
                        con.reset();
                    } else if (DO.getSyncstatus() == UPDATE) {
                        update.setBigDecimal(1, DO.getOwner());
                        update.setString(2, DO.getSubject());
                        update.setString(3, DO.getText());
                        update.setString(4, DO.getPlace());
                        update.setString(5, DO.getContactperson());
                        update.setDate(6, DO.getStartdate());
                        update.setDate(7, DO.getEnddate());
                        update.setTime(8, DO.getStarttime());
                        update.setTime(9, DO.getEndtime());
                        update.setBoolean(10, DO.getAllday());
                        update.setInt(11, RESET);
                        update.setInt(12, RESET);
                        update.setBigDecimal(13, DO.getOId());
                        update.setInt(14, RESET);
                        con.executeUpdate(update, null);
                        con.reset();
                    } else if (DO.getSyncstatus() == DELETE) {
                        try {
                            con.setAutoCommit(false);
                            delete1.setBigDecimal(1, DO.getOId());
                            con.executeUpdate(delete1, null);
                            delete2.setBigDecimal(1, DO.getOId());
                            delete2.setInt(2, RESET);
                            delete2.setInt(3, DELETE);
                            if (con.executeUpdate(delete2, null) < 1) {
                                con.rollback();
                            } else {
                                con.commit();
                            }
                        } catch (Exception e) {
                            con.rollback();
                            throw e;
                        } finally {
                            con.reset();
                        }
                    }
                } catch (Exception e) {
                    if (DO != null) logError("Sync-EventDO.owner = " + DO.getOwner().toString() + " oid = " + (DO.getOId() != null ? DO.getOId().toString() : "NULL"), e);
                }
            }
            if (rs != null) {
                rs.close();
            }
        } catch (SQLException e) {
            if (DEBUG) logError("", e);
            throw e;
        } finally {
            release();
        }
    }
} </s>
<s>class temp {    private static HttpURLConnection sendPost(String reqUrl, Map<String, String> parameters) {
        HttpURLConnection urlConn = null;
        try {
            String params = generatorParamString(parameters);
            URL url = new URL(reqUrl);
            urlConn = (HttpURLConnection) url.openConnection();
            urlConn.setRequestMethod("POST");
            urlConn.setConnectTimeout(5000);
            urlConn.setReadTimeout(5000);
            urlConn.setDoOutput(true);
            byte[] b = params.getBytes();
            urlConn.getOutputStream().write(b, 0, b.length);
            urlConn.getOutputStream().flush();
            urlConn.getOutputStream().close();
        } catch (Exception e) {
            throw new RuntimeException(e.getMessage(), e);
        }
        return urlConn;
    }
} </s>
<s>class temp {    private PluginInterface getClasseJar(String arquivo) {
        URLClassLoader load;
        try {
            URL url = new URL("jar", "", "file:" + arquivo + "!/");
            JarURLConnection jar = (JarURLConnection) url.openConnection();
            Enumeration arq = jar.getJarFile().entries();
            load = new URLClassLoader(new URL[] { url });
            while (arq.hasMoreElements()) {
                Object object = arq.nextElement();
                if (object.toString().contains(".class") && !object.toString().contains("PluginInterface.class")) {
                    Class cl = load.loadClass(object.toString().replace(".class", ""));
                    pl = (PluginInterface) cl.newInstance();
                }
            }
        } catch (MalformedURLException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }
        return pl;
    }
} </s>
<s>class temp {    @SuppressWarnings("unchecked")
    public ProcessContext execute(ProcessContext context) throws Exception {
        List<String> urls = (List<String>) context.get(getContextKeyFileUrls(), List.class, true);
        for (String url : urls) {
            long time = System.currentTimeMillis();
            logger.info("Starting url: " + url);
            InputStream is = null;
            if (url.startsWith("http://") || url.startsWith("ftp://")) {
                is = new URL(url).openStream();
            } else {
                is = new FileInputStream(url);
            }
            String separator = (String) context.get(getContextKeySeparator(), String.class, false);
            if (separator == null) {
                separator = "\t";
            }
            String quoteCharacter = (String) context.get(getContextKeyQuoteCharacter(), String.class, false);
            DelimitedFileReader reader = new DelimitedFileReader(is, separator, quoteCharacter, true);
            Set<String> columns = reader.getColumnHeaders();
            while (reader.next()) {
                logger.debug("Starting row: " + reader.getRowNumber());
                for (String column : columns) {
                    String value = StringUtils.trimToNull(reader.get(column));
                    String key = getContextKeyPrefix() + column;
                    if (lowerCaseFirstLetterForContext && key.length() > 1) {
                        key = key.substring(0, 1).toLowerCase() + key.substring(1);
                    } else if (lowerCaseFirstLetterForContext) {
                        key = key.toLowerCase();
                    }
                    context.put(key, value);
                    logger.debug("Added key[" + key + "] value[" + value + "]");
                }
                launchWorkflow(context, null);
            }
            logger.info("Finished url [" + url + "] in " + ((System.currentTimeMillis() + 1 - time) / 1000) + " secs");
        }
        return context;
    }
} </s>
<s>class temp {    private boolean copyFile(File _file1, File _file2) {
        FileInputStream fis;
        FileOutputStream fos;
        try {
            fis = new FileInputStream(_file1);
            fos = new FileOutputStream(_file2);
            FileChannel canalFuente = fis.getChannel();
            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());
            fis.close();
            fos.close();
            return true;
        } catch (FileNotFoundException e) {
        } catch (IOException e) {
        }
        return false;
    }
} </s>
<s>class temp {    public static String encryptPassword(String password) {
        try {
            MessageDigest digest = java.security.MessageDigest.getInstance("SHA1");
            digest.update(password.getBytes("UTF-8"));
            byte[] hash = digest.digest();
            StringBuffer buf = new StringBuffer();
            for (int i = 0; i < hash.length; i++) {
                int halfbyte = (hash[i] >>> 4) & 0x0F;
                int two_halfs = 0;
                do {
                    if ((0 <= halfbyte) && (halfbyte <= 9)) {
                        buf.append((char) ('0' + halfbyte));
                    } else {
                        buf.append((char) ('a' + (halfbyte - 10)));
                    }
                    halfbyte = hash[i] & 0x0F;
                } while (two_halfs++ < 1);
            }
            return buf.toString();
        } catch (Exception e) {
        }
        return null;
    }
} </s>
<s>class temp {    public static Board readStream(InputStream is) throws IOException {
        StringWriter stringWriter = new StringWriter();
        IOUtils.copy(is, stringWriter);
        String s = stringWriter.getBuffer().toString();
        Board board = read(s);
        return board;
    }
} </s>
<s>class temp {    public static String encrypt(String passPhrase, String password) {
        String algorithm = "PBEWithMD5AndDES";
        byte[] salt = new byte[8];
        int iterations = 20;
        byte[] output = new byte[128];
        if (passPhrase == null || "".equals(passPhrase) || password == null || "".equals(password)) {
            throw new GeneralException(PassPhraseCrypto.class, "encrypt", "Required parameter missing");
        }
        try {
            Security.addProvider(new com.sun.crypto.provider.SunJCE());
            KeySpec keySpec = new PBEKeySpec(passPhrase.toCharArray());
            SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(algorithm);
            SecretKey secretKey = secretKeyFactory.generateSecret(keySpec);
            MessageDigest messageDigest = MessageDigest.getInstance("MD5");
            messageDigest.update(passPhrase.getBytes());
            byte[] input = new byte[password.length()];
            input = password.getBytes();
            messageDigest.update(input);
            byte[] digest = messageDigest.digest();
            System.arraycopy(digest, 0, salt, 0, 8);
            AlgorithmParameterSpec algorithmParameterSpec = new PBEParameterSpec(salt, iterations);
            Cipher cipher = Cipher.getInstance(algorithm);
            int mode = Cipher.ENCRYPT_MODE;
            cipher.init(mode, secretKey, algorithmParameterSpec);
            output = cipher.doFinal(input);
        } catch (NoSuchAlgorithmException e) {
            throw new GeneralException(PassPhraseCrypto.class, "encrypt", "Algorithm not found", e);
        } catch (InvalidAlgorithmParameterException e) {
            throw new GeneralException(PassPhraseCrypto.class, "encrypt", "nvalidAlgorithmParameter", e);
        } catch (InvalidKeySpecException e) {
            throw new GeneralException(PassPhraseCrypto.class, "encrypt", "InvalidKeySpec", e);
        } catch (InvalidKeyException e) {
            throw new GeneralException(PassPhraseCrypto.class, "encrypt", "InvalidKey", e);
        } catch (NoSuchPaddingException e) {
            throw new GeneralException(PassPhraseCrypto.class, "encrypt", "NoSuchPadding", e);
        } catch (BadPaddingException e) {
            throw new GeneralException(PassPhraseCrypto.class, "encrypt", "BadPadding", e);
        } catch (IllegalBlockSizeException e) {
            throw new GeneralException(PassPhraseCrypto.class, "encrypt", "IllegalBlockSize", e);
        }
        StringBuffer result = new StringBuffer();
        for (int i = 0; i < output.length; i++) {
            result.append(Byte.toString(output[i]));
        }
        return result.toString();
    }
} </s>
<s>class temp {    private void load() throws SQLException {
        Connection conn = null;
        Statement stmt = null;
        try {
            conn = FidoDataSource.getConnection();
            conn.setAutoCommit(false);
            stmt = conn.createStatement();
            clearTables(stmt);
            stmt.executeQuery("select setval('objects_objectid_seq', 1000)");
            stmt.executeQuery("select setval('instructions_instructionid_seq', 1)");
            stmt.executeQuery("select setval('transactions_transactionid_seq', 1)");
            stmt.executeQuery("select setval('verbtransactions_verbid_seq', 1)");
            stmt.executeUpdate("update SystemProperties set value = 'Minimal Data' where name = 'DB Data Version'");
            conn.commit();
        } catch (SQLException e) {
            if (conn != null) conn.rollback();
            throw e;
        } finally {
            if (stmt != null) stmt.close();
            if (conn != null) conn.close();
        }
    }
} </s>
<s>class temp {    void shutdown(final boolean unexpected) {
        if (unexpected) {
            log.warn("S H U T D O W N   ---   received unexpected shutdown request.");
        } else {
            log.info("S H U T D O W N   ---   start regular shutdown.");
        }
        if (this.uncaughtException != null) {
            log.warn("Shutdown probably caused by the following Exception.", this.uncaughtException);
        }
        log.error("check if we need the controler listener infrastructure");
        if (this.dumpDataAtEnd) {
            new PopulationWriter(this.population, this.network).write(this.controlerIO.getOutputFilename(FILENAME_POPULATION));
            new NetworkWriter(this.network).write(this.controlerIO.getOutputFilename(FILENAME_NETWORK));
            new ConfigWriter(this.config).write(this.controlerIO.getOutputFilename(FILENAME_CONFIG));
            if (!unexpected && this.getConfig().vspExperimental().isWritingOutputEvents()) {
                File toFile = new File(this.controlerIO.getOutputFilename("output_events.xml.gz"));
                File fromFile = new File(this.controlerIO.getIterationFilename(this.getLastIteration(), "events.xml.gz"));
                IOUtils.copyFile(fromFile, toFile);
            }
        }
        if (unexpected) {
            log.info("S H U T D O W N   ---   unexpected shutdown request completed.");
        } else {
            log.info("S H U T D O W N   ---   regular shutdown completed.");
        }
        try {
            Runtime.getRuntime().removeShutdownHook(this.shutdownHook);
        } catch (IllegalStateException e) {
            log.info("Cannot remove shutdown hook. " + e.getMessage());
        }
        this.shutdownHook = null;
        this.collectLogMessagesAppender = null;
        IOUtils.closeOutputDirLogging();
    }
} </s>
<s>class temp {    public static String load(String id) {
        String xml = "";
        if (id.length() < 5) return "";
        try {
            working = true;
            URL url = new URL("http://pastebin.com/download.php?i=" + id);
            URLConnection conn = url.openConnection();
            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));
            xml = "";
            String str;
            while ((str = reader.readLine()) != null) {
                xml += str;
            }
            reader.close();
            working = false;
            return xml.toString();
        } catch (IOException ex) {
            JOptionPane.showMessageDialog(null, " Load error");
        }
        working = false;
        return xml;
    }
} </s>
<s>class temp {    private static void readAndRewrite(File inFile, File outFile) throws IOException {
        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));
        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);
        Dataset ds = DcmObjectFactory.getInstance().newDataset();
        dcmParser.setDcmHandler(ds.getDcmHandler());
        dcmParser.parseDcmFile(null, Tags.PixelData);
        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        System.out.println("reading " + inFile + "...");
        pdReader.readPixelData(false);
        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));
        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;
        ds.writeDataset(out, dcmEncParam);
        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());
        System.out.println("writing " + outFile + "...");
        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        pdWriter.writePixelData();
        out.flush();
        out.close();
        System.out.println("done!");
    }
} </s>
<s>class temp {    public void createBankSignature() {
        byte b;
        try {
            _bankMessageDigest = MessageDigest.getInstance("MD5");
            _bankSig = Signature.getInstance("MD5/RSA/PKCS#1");
            _bankSig.initSign((PrivateKey) _bankPrivateKey);
            _bankMessageDigest.update(getBankString().getBytes());
            _bankMessageDigestBytes = _bankMessageDigest.digest();
            _bankSig.update(_bankMessageDigestBytes);
            _bankSignatureBytes = _bankSig.sign();
        } catch (Exception e) {
        }
        ;
    }
} </s>
<s>class temp {    public void createVendorSignature() {
        byte b;
        try {
            _vendorMessageDigest = MessageDigest.getInstance("MD5");
            _vendorSig = Signature.getInstance("MD5/RSA/PKCS#1");
            _vendorSig.initSign((PrivateKey) _vendorPrivateKey);
            _vendorMessageDigest.update(getBankString().getBytes());
            _vendorMessageDigestBytes = _vendorMessageDigest.digest();
            _vendorSig.update(_vendorMessageDigestBytes);
            _vendorSignatureBytes = _vendorSig.sign();
        } catch (Exception e) {
        }
        ;
    }
} </s>
<s>class temp {    public static void main(String[] argv) throws IOException {
        Session session = HibernateUtil.getSessionFactory().getCurrentSession();
        ;
        try {
            session.beginTransaction();
            Properties cfg = new Properties();
            URL url = SVM.class.getClassLoader().getResource(CFG_FILE);
            cfg.load(url.openStream());
            int runMode = Integer.valueOf(cfg.getProperty(KEY_RUN_MODE));
            switch(runMode) {
                case RUN_OPT:
                    new SVM().optimizeParameters(cfg);
                    break;
                case RUN_PREDICT:
                    new SVM().trainAndPredict(cfg);
                    break;
                case RUN_OPT_AND_PREDICT:
                    break;
            }
            session.getTransaction().commit();
        } catch (HibernateException he) {
            session.getTransaction().rollback();
            logger.error("Database error.", he);
            session.close();
        }
    }
} </s>
<s>class temp {    public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {
        String name = metadata.get(Metadata.RESOURCE_NAME_KEY);
        if (name != null && wanted.containsKey(name)) {
            FileOutputStream out = new FileOutputStream(wanted.get(name));
            IOUtils.copy(stream, out);
            out.close();
        } else {
            if (downstreamParser != null) {
                downstreamParser.parse(stream, handler, metadata, context);
            }
        }
    }
} </s>
<s>class temp {    public static void copy(File source, File dest) throws IOException {
        FileChannel in = null, out = null;
        try {
            in = new FileInputStream(source).getChannel();
            out = new FileOutputStream(dest).getChannel();
            long size = in.size();
            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);
            out.write(buf);
        } finally {
            if (in != null) in.close();
            if (out != null) out.close();
        }
    }
} </s>
<s>class temp {    @Test
    public void test01_ok_failed_500() throws Exception {
        DefaultHttpClient client = new DefaultHttpClient();
        try {
            HttpPost post = new HttpPost(chartURL);
            HttpResponse response = client.execute(post);
            assertEquals("failed code for ", 500, response.getStatusLine().getStatusCode());
        } finally {
            client.getConnectionManager().shutdown();
        }
    }
} </s>
<s>class temp {    @Test
    public void test02_ok() throws Exception {
        DefaultHttpClient client = new DefaultHttpClient();
        try {
            HttpPost post = new HttpPost(chartURL);
            List<NameValuePair> nameValuePairs = new ArrayList<NameValuePair>(1);
            nameValuePairs.add(new BasicNameValuePair("ws", "getDomainEvolution"));
            nameValuePairs.add(new BasicNameValuePair("chartTitle", "test"));
            nameValuePairs.add(new BasicNameValuePair("type", "chart"));
            nameValuePairs.add(new BasicNameValuePair("firstDate", "20111124"));
            nameValuePairs.add(new BasicNameValuePair("lastDate", "20111125"));
            nameValuePairs.add(new BasicNameValuePair("wsParams", "type,counting,protocol,unit,proxy,domain,timeScale,period"));
            nameValuePairs.add(new BasicNameValuePair("wsParamsValues", "chart,volume,all,hits,all,google.com,day,360"));
            nameValuePairs.add(new BasicNameValuePair("serieTitle", "serie"));
            post.setEntity(new UrlEncodedFormEntity(nameValuePairs));
            HttpResponse response = client.execute(post);
            HttpEntity entity = response.getEntity();
            assertNotNull(entity);
            InputStream instream = entity.getContent();
            BufferedReader reader = new BufferedReader(new InputStreamReader(instream));
            System.out.println(reader.readLine());
            instream.close();
            assertEquals("error :" + response.getStatusLine(), 200, response.getStatusLine().getStatusCode());
        } finally {
            client.getConnectionManager().shutdown();
        }
    }
} </s>
<s>class temp {    public File getPreprocessedTextFile(File originalTextFile) throws IOException {
        File preprocessedTextFile = File.createTempFile("cvs", null);
        String separatorSeq = getSeparatorSequence();
        byte[] newLine = separatorSeq.getBytes();
        Constants.CVS_LOG.debug("Preprocessing " + originalTextFile.getAbsolutePath() + " to " + preprocessedTextFile.getAbsolutePath() + " using " + debugSequence(separatorSeq));
        byte[] crlf = "\r\n".getBytes();
        byte[] lf = "\n".getBytes();
        OutputStream out = null;
        InputStream in = null;
        try {
            in = new BufferedInputStream(new FileInputStream(originalTextFile));
            out = new BufferedOutputStream(new FileOutputStream(preprocessedTextFile));
            byte[] fileChunk = new byte[CHUNK_SIZE];
            byte[] fileWriteChunk = new byte[CHUNK_SIZE];
            for (int readLength = in.read(fileChunk); readLength > 0; readLength = in.read(fileChunk)) {
                if (newLine.length == 0) {
                    out.write(fileChunk, 0, readLength);
                } else {
                    int writeLength = 0;
                    for (int i = 0; i < readLength; ) {
                        int pos = findIndexOf(fileChunk, crlf, i);
                        int lineSepLength = crlf.length;
                        if (pos < i || pos >= readLength) {
                            pos = findIndexOf(fileChunk, lf, i);
                            lineSepLength = lf.length;
                        }
                        if (pos >= i && pos < readLength) {
                            try {
                                System.arraycopy(fileChunk, i, fileWriteChunk, writeLength, pos - i);
                            } catch (ArrayIndexOutOfBoundsException aiobe) {
                                Constants.CVS_LOG.error("fileChunk.length=" + fileChunk.length + " i=" + i + " writeLength=" + writeLength + " pos=" + pos + " fileWriteChunk.length=" + fileWriteChunk.length);
                                throw aiobe;
                            }
                            writeLength += pos - i;
                            i = pos + lineSepLength;
                            for (int j = 0; j < newLine.length; j++) fileWriteChunk[writeLength++] = newLine[j];
                        } else {
                            System.arraycopy(fileChunk, i, fileWriteChunk, writeLength, readLength - i);
                            writeLength += readLength - i;
                            i = readLength;
                        }
                    }
                    out.write(fileWriteChunk, 0, writeLength);
                }
            }
            return preprocessedTextFile;
        } catch (IOException ex) {
            if (preprocessedTextFile != null) {
                cleanup(preprocessedTextFile);
            }
            throw ex;
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException ex) {
                }
            }
            if (out != null) {
                try {
                    out.close();
                } catch (IOException ex) {
                }
            }
        }
    }
} </s>
<s>class temp {    public FileReader(String filePath, Configuration aConfiguration) throws IOException {
        file = new File(URLDecoder.decode(filePath, "UTF-8")).getCanonicalFile();
        readerConf = aConfiguration;
        if (file.isDirectory()) {
            File indexFile = new File(file, "index.php");
            File indexFile_1 = new File(file, "index.html");
            if (indexFile.exists() && !indexFile.isDirectory()) {
                file = indexFile;
            } else if (indexFile_1.exists() && !indexFile_1.isDirectory()) {
                file = indexFile_1;
            } else {
                if (!readerConf.getOption("showFolders").equals("Yes")) {
                    makeErrorPage(503, "Permision denied");
                } else {
                    FileOutputStream out = new FileOutputStream(readerConf.getOption("wwwPath") + "/temp/temp.php");
                    File[] files = file.listFiles();
                    makeHeader(200, -1, new Date(System.currentTimeMillis()).toString(), "text/html");
                    String title = "Index of " + file;
                    out.write(("<html><head><title>" + title + "</title></head><body><h3>Index of " + file + "</h3><p>\n").getBytes());
                    for (int i = 0; i < files.length; i++) {
                        file = files[i];
                        String filename = file.getName();
                        String description = "";
                        if (file.isDirectory()) {
                            description = "&lt;DIR&gt;";
                        }
                        out.write(("<a href=\"" + file.getPath().substring(readerConf.getOption("wwwPath").length()) + "\">" + filename + "</a> " + description + "<br>\n").getBytes());
                    }
                    out.write(("</p><hr><p>yawwwserwer</p></body><html>").getBytes());
                    file = new File(URLDecoder.decode(readerConf.getOption("wwwPath") + "/temp/temp.php", "UTF-8")).getCanonicalFile();
                }
            }
        } else if (!file.exists()) {
            makeErrorPage(404, "File Not Found.");
        } else if (getExtension() == ".exe" || getExtension().contains(".py")) {
            FileOutputStream out = new FileOutputStream(readerConf.getOption("wwwPath") + "/temp/temp.php");
            out.write((runCommand(filePath)).getBytes());
            file = new File(URLDecoder.decode(readerConf.getOption("wwwPath") + "/temp/temp.php", "UTF-8")).getCanonicalFile();
        } else {
            System.out.println(getExtension());
            makeHeader(200, file.length(), new Date(file.lastModified()).toString(), TYPES.get(getExtension()).toString());
        }
        System.out.println(file);
    }
} </s>
<s>class temp {    private static void readAndRewrite(File inFile, File outFile) throws IOException {
        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));
        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);
        Dataset ds = DcmObjectFactory.getInstance().newDataset();
        dcmParser.setDcmHandler(ds.getDcmHandler());
        dcmParser.parseDcmFile(null, Tags.PixelData);
        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        System.out.println("reading " + inFile + "...");
        pdReader.readPixelData(false);
        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));
        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;
        ds.writeDataset(out, dcmEncParam);
        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());
        System.out.println("writing " + outFile + "...");
        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        pdWriter.writePixelData();
        out.flush();
        out.close();
        System.out.println("done!");
    }
} </s>
<s>class temp {    public static String getExternalIPAddress() {
        String address = null;
        URL url = null;
        try {
            url = new URL("http://checkip.dyndns.org/");
            URLConnection connection = (URLConnection) url.openConnection();
            BufferedInputStream in = new BufferedInputStream(connection.getInputStream());
            int i;
            while ((i = in.read()) != -1) {
                address = address + (char) i;
            }
            in.close();
            address = address.substring(address.indexOf(": ") + 2);
            address = address.substring(0, address.indexOf("</body>"));
        } catch (Exception e) {
            return null;
        }
        return address;
    }
} </s>
<s>class temp {    public void writeData(String name, int items, int mzmin, int mzmax, long tstart, long tdelta, int[] peaks) {
        PrintWriter file = getWriter(name + ".txt");
        file.print("Filename\t");
        file.print("Date\t");
        file.print("Acquisition #\t");
        file.print(" m Diameter\t");
        for (int i = mzmin; i <= mzmax; i++) file.print(i + "\t");
        file.println();
        int nothing = 0;
        String fileLoc = "C:/abcd/" + name + ".txt\t";
        Date tempDate;
        for (int i = 0; i < items; i++) {
            tempDate = new Date(tstart);
            tstart += tdelta;
            file.print(fileLoc);
            file.print(dateFormat.format(tempDate) + "\t");
            file.print(i + 1 + "\t");
            double t = (double) (i) / 10;
            file.print(t + "\t");
            boolean peaked = false;
            for (int k = mzmin; k <= mzmax; k++) {
                for (int j = 0; j < peaks.length && !peaked; j++) {
                    if (k == peaks[j]) {
                        file.print(peakVals[j % peakVals.length] + "\t");
                        peaked = true;
                    }
                }
                if (!peaked) {
                    if (k == mzmax) file.print(nothing); else file.print(nothing + "\t");
                }
                peaked = false;
            }
            file.println();
        }
        try {
            Scanner test = new Scanner(f);
            while (test.hasNext()) {
                System.out.println(test.nextLine());
            }
            System.out.println("test");
        } catch (Exception e) {
        }
        file.close();
    }
} </s>
<s>class temp {    public Image storeImage(String title, String pathToImage, Map<String, Object> additionalProperties) {
        File collectionFolder = ProjectManager.getInstance().getFolder(PropertyHandler.getInstance().getProperty("_default_collection_name"));
        File imageFile = new File(pathToImage);
        String filename = "";
        String format = "";
        File copiedImageFile;
        while (true) {
            filename = "image" + UUID.randomUUID().hashCode();
            if (!DbEntryProvider.INSTANCE.idExists(filename)) {
                Path path = new Path(pathToImage);
                format = path.getFileExtension();
                copiedImageFile = new File(collectionFolder.getAbsolutePath() + File.separator + filename + "." + format);
                if (!copiedImageFile.exists()) break;
            }
        }
        try {
            copiedImageFile.createNewFile();
        } catch (IOException e1) {
            ExceptionHandlingService.INSTANCE.handleException(e1);
            return null;
        }
        BufferedInputStream in = null;
        BufferedOutputStream out = null;
        try {
            in = new BufferedInputStream(new FileInputStream(imageFile), 4096);
            out = new BufferedOutputStream(new FileOutputStream(copiedImageFile), 4096);
            int c;
            while ((c = in.read()) != -1) out.write(c);
            in.close();
            out.close();
        } catch (FileNotFoundException e) {
            ExceptionHandlingService.INSTANCE.handleException(e);
            return null;
        } catch (IOException e) {
            ExceptionHandlingService.INSTANCE.handleException(e);
            return null;
        }
        Image image = new ImageImpl();
        image.setId(filename);
        image.setFormat(format);
        image.setEntryDate(new Date());
        image.setTitle(title);
        image.setAdditionalProperties(additionalProperties);
        boolean success = DbEntryProvider.INSTANCE.storeNewImage(image);
        if (success) return image;
        return null;
    }
} </s>
<s>class temp {    public void convert(File src, File dest) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(src));
        DcmParser p = pfact.newDcmParser(in);
        Dataset ds = fact.newDataset();
        p.setDcmHandler(ds.getDcmHandler());
        try {
            FileFormat format = p.detectFileFormat();
            if (format != FileFormat.ACRNEMA_STREAM) {
                System.out.println("\n" + src + ": not an ACRNEMA stream!");
                return;
            }
            p.parseDcmFile(format, Tags.PixelData);
            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {
                System.out.println("\n" + src + ": contains UIDs!" + " => probable already DICOM - do not convert");
                return;
            }
            boolean hasPixelData = p.getReadTag() == Tags.PixelData;
            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;
            int pxlen = p.getReadLength();
            if (hasPixelData) {
                if (inflate) {
                    ds.putUS(Tags.BitsAllocated, 16);
                    pxlen = pxlen * 4 / 3;
                }
                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {
                    System.out.println("\n" + src + ": mismatch pixel data length!" + " => do not convert");
                    return;
                }
            }
            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));
            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));
            ds.putUI(Tags.SOPInstanceUID, uid(instUID));
            ds.putUI(Tags.SOPClassUID, classUID);
            if (!ds.contains(Tags.NumberOfSamples)) {
                ds.putUS(Tags.NumberOfSamples, 1);
            }
            if (!ds.contains(Tags.PhotometricInterpretation)) {
                ds.putCS(Tags.PhotometricInterpretation, "MONOCHROME2");
            }
            if (fmi) {
                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));
            }
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
            try {
            } finally {
                ds.writeFile(out, encodeParam());
                if (hasPixelData) {
                    if (!skipGroupLen) {
                        out.write(PXDATA_GROUPLEN);
                        int grlen = pxlen + 8;
                        out.write((byte) grlen);
                        out.write((byte) (grlen >> 8));
                        out.write((byte) (grlen >> 16));
                        out.write((byte) (grlen >> 24));
                    }
                    out.write(PXDATA_TAG);
                    out.write((byte) pxlen);
                    out.write((byte) (pxlen >> 8));
                    out.write((byte) (pxlen >> 16));
                    out.write((byte) (pxlen >> 24));
                }
                if (inflate) {
                    int b2, b3;
                    for (; pxlen > 0; pxlen -= 3) {
                        out.write(in.read());
                        b2 = in.read();
                        b3 = in.read();
                        out.write(b2 & 0x0f);
                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));
                        out.write(b3 >> 4);
                    }
                } else {
                    for (; pxlen > 0; --pxlen) {
                        out.write(in.read());
                    }
                }
                out.close();
            }
            System.out.print('.');
        } finally {
            in.close();
        }
    }
} </s>
<s>class temp {    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.listview);
        HttpGet request = new HttpGet(SERVICE_URI + "/json/getallpersons");
        request.setHeader("Accept", "application/json");
        request.setHeader("Content-type", "application/json");
        DefaultHttpClient httpClient = new DefaultHttpClient();
        String theString = new String("");
        try {
            HttpResponse response = httpClient.execute(request);
            HttpEntity responseEntity = response.getEntity();
            InputStream stream = responseEntity.getContent();
            BufferedReader reader = new BufferedReader(new InputStreamReader(stream));
            StringBuilder builder = new StringBuilder();
            String line;
            while ((line = reader.readLine()) != null) {
                builder.append(line);
            }
            stream.close();
            theString = builder.toString();
        } catch (Exception e) {
            e.printStackTrace();
        }
        Toast.makeText(this, theString + "\n", Toast.LENGTH_LONG).show();
    }
} </s>
<s>class temp {    JSONResponse execute() throws ServerException, RtmApiException, IOException {
        HttpClient httpclient = new DefaultHttpClient();
        URI uri;
        try {
            uri = new URI(this.request.getUrl());
            HttpPost httppost = new HttpPost(uri);
            HttpResponse response = httpclient.execute(httppost);
            InputStream is = response.getEntity().getContent();
            try {
                StringBuilder sb = new StringBuilder();
                BufferedReader r = new BufferedReader(new InputStreamReader(new DoneHandlerInputStream(is)));
                for (String line = r.readLine(); line != null; line = r.readLine()) {
                    sb.append(line);
                }
                return new JSONResponse(sb.toString());
            } finally {
                is.close();
            }
        } catch (URISyntaxException e) {
            throw new RtmApiException(e.getMessage());
        } catch (ClientProtocolException e) {
            throw new RtmApiException(e.getMessage());
        }
    }
} </s>
<s>class temp {    String test() throws ServerException, RtmApiException, IOException {
        HttpClient httpclient = new DefaultHttpClient();
        URI uri;
        try {
            uri = new URI(this.request.getUrl());
            HttpPost httppost = new HttpPost(uri);
            HttpResponse response = httpclient.execute(httppost);
            InputStream is = response.getEntity().getContent();
            StringBuilder sb = new StringBuilder();
            BufferedReader r = new BufferedReader(new InputStreamReader(new DoneHandlerInputStream(is)));
            for (String line = r.readLine(); line != null; line = r.readLine()) {
                sb.append(line);
            }
            return sb.toString();
        } catch (URISyntaxException e) {
            throw new RtmApiException(e.getMessage());
        } catch (ClientProtocolException e) {
            throw new RtmApiException(e.getMessage());
        }
    }
} </s>
<s>class temp {    public void encryptPassword() {
        MessageDigest digest = null;
        try {
            digest = MessageDigest.getInstance("SHA");
        } catch (NoSuchAlgorithmException e) {
            System.out.print(e);
        }
        try {
            digest.update(passwordIn.getBytes("UTF-8"));
        } catch (UnsupportedEncodingException e) {
            System.out.println("cannot find char set for getBytes");
        }
        byte digestBytes[] = digest.digest();
        passwordHash = (new BASE64Encoder()).encode(digestBytes);
    }
} </s>
<s>class temp {    public void addScanURL(final URL url) {
        if (url == null) throw new NullArgumentException();
        try {
            url.openConnection().connect();
        } catch (IOException e) {
            e.printStackTrace();
        }
        urlList.add(url);
    }
} </s>
<s>class temp {    private FTPClient loginToSharedWorkspace() throws SocketException, IOException {
        FTPClient ftp = new FTPClient();
        ftp.connect(mSwarm.getHost(), mSharedWorkspacePort);
        if (!ftp.login(SHARED_WORKSPACE_LOGIN_NAME, mWorkspacePassword)) {
            throw new IOException("Unable to login to shared workspace.");
        }
        ftp.setFileType(FTPClient.BINARY_FILE_TYPE);
        return ftp;
    }
} </s>
<s>class temp {    protected String encrypt(String text) throws Exception {
        MessageDigest md = MessageDigest.getInstance("SHA");
        md.update(text.getBytes("UTF-8"));
        byte raw[] = md.digest();
        String hash = (new BASE64Encoder()).encode(raw);
        return hash;
    }
} </s>
<s>class temp {    public synchronized void download(URL url, File file) throws IOException {
        reset();
        MessageDigest digest;
        try {
            digest = MessageDigest.getInstance("MD5");
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        }
        InputStream in = url.openConnection(proxy).getInputStream();
        byte[] buffer = new byte[2048];
        BufferedOutputStream bos = file == null ? null : new BufferedOutputStream(new FileOutputStream(file), buffer.length);
        try {
            int size;
            while ((size = in.read(buffer, 0, buffer.length)) != -1) {
                if (this.isCancelled()) break;
                if (bos != null) bos.write(buffer, 0, size);
                if (size > 0) {
                    digest.update(buffer, 0, size);
                    this.length += size;
                    progress();
                }
            }
        } finally {
            if (bos != null) {
                bos.flush();
                bos.close();
            }
        }
        if (!cancelled) this.checkSum = CheckSum.toString(digest.digest());
    }
} </s>
<s>class temp {    public static String eventHash(String eventstr) {
        try {
            if (md == null) {
                md = MessageDigest.getInstance("MD5");
            }
            md.update(eventstr.getBytes("utf-8"));
            byte[] theDigest = md.digest();
            return new BASE64Encoder().encode(theDigest);
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
        return null;
    }
} </s>
<s>class temp {    public SWORDEntry ingestDepost(final DepositCollection pDeposit, final ServiceDocument pServiceDocument) throws SWORDException {
        try {
            ZipFileAccess tZipFile = new ZipFileAccess(super.getTempDir());
            LOG.debug("copying file");
            String tZipTempFileName = super.getTempDir() + "uploaded-file.tmp";
            IOUtils.copy(pDeposit.getFile(), new FileOutputStream(tZipTempFileName));
            Datastream tDatastream = new LocalDatastream(super.getGenericFileName(pDeposit), this.getContentType(), tZipTempFileName);
            _datastreamList.add(tDatastream);
            _datastreamList.addAll(tZipFile.getFiles(tZipTempFileName));
            int i = 0;
            boolean found = false;
            for (i = 0; i < _datastreamList.size(); i++) {
                if (_datastreamList.get(i).getId().equalsIgnoreCase("mets")) {
                    found = true;
                    break;
                }
            }
            if (found) {
                SAXBuilder tBuilder = new SAXBuilder();
                _mets = new METSObject(tBuilder.build(((LocalDatastream) _datastreamList.get(i)).getPath()));
                LocalDatastream tLocalMETSDS = (LocalDatastream) _datastreamList.remove(i);
                new File(tLocalMETSDS.getPath()).delete();
                _datastreamList.add(_mets.getMETSDs());
                _datastreamList.addAll(_mets.getMetadataDatastreams());
            } else {
                throw new SWORDException("Couldn't find a METS document in the zip file, ensure it is named mets.xml or METS.xml");
            }
            SWORDEntry tEntry = super.ingestDepost(pDeposit, pServiceDocument);
            tZipFile.removeLocalFiles();
            return tEntry;
        } catch (IOException tIOExcpt) {
            String tMessage = "Couldn't retrieve METS from deposit: " + tIOExcpt.toString();
            LOG.error(tMessage);
            tIOExcpt.printStackTrace();
            throw new SWORDException(tMessage, tIOExcpt);
        } catch (JDOMException tJDOMExcpt) {
            String tMessage = "Couldn't build METS from deposit: " + tJDOMExcpt.toString();
            LOG.error(tMessage);
            tJDOMExcpt.printStackTrace();
            throw new SWORDException(tMessage, tJDOMExcpt);
        }
    }
} </s>
<s>class temp {    public String new2Password(String passwd) {
        try {
            MessageDigest md = MessageDigest.getInstance("SHA-1");
            String clearPassword = passwd;
            md.update(clearPassword.getBytes());
            byte[] digestedPassword = md.digest();
            return new String(digestedPassword);
        } catch (java.security.NoSuchAlgorithmException e) {
            System.out.println("MD5 doesn't exist");
            System.out.println(e.toString());
            return null;
        }
    }
} </s>
<s>class temp {    public static String md5It(String data) {
        MessageDigest digest;
        String output = "";
        try {
            digest = java.security.MessageDigest.getInstance("MD5");
            digest.update(data.getBytes());
            byte[] hash = digest.digest();
            for (byte b : hash) {
                output = output + String.format("%02X", b);
            }
        } catch (NoSuchAlgorithmException ex) {
            Logger.getLogger(Authenticator.class.getName()).log(Level.SEVERE, null, ex);
        }
        return output;
    }
} </s>
<s>class temp {    public static void main(String[] args) throws Exception {
        long start = System.currentTimeMillis();
        XSLTBuddy buddy = new XSLTBuddy();
        buddy.parseArgs(args);
        XSLTransformer transformer = new XSLTransformer();
        if (buddy.templateDir != null) {
            transformer.setTemplateDir(buddy.templateDir);
        }
        FileReader xslReader = new FileReader(buddy.xsl);
        Templates xslTemplate = transformer.getXSLTemplate(buddy.xsl, xslReader);
        for (Enumeration e = buddy.params.keys(); e.hasMoreElements(); ) {
            String key = (String) e.nextElement();
            transformer.addParam(key, buddy.params.get(key));
        }
        Reader reader = null;
        if (buddy.src == null) {
            reader = new StringReader(XSLTBuddy.BLANK_XML);
        } else {
            reader = new FileReader(buddy.src);
        }
        if (buddy.out == null) {
            String result = transformer.doTransform(reader, xslTemplate, buddy.xsl);
            buddy.getLogger().info("\n\nXSLT Result:\n\n" + result + "\n");
        } else {
            File file = new File(buddy.out);
            File dir = file.getParentFile();
            if (dir != null) {
                dir.mkdirs();
            }
            FileWriter writer = new FileWriter(buddy.out);
            transformer.doTransform(reader, xslTemplate, buddy.xsl, writer);
            writer.flush();
            writer.close();
        }
        buddy.getLogger().info("Transform done successfully in " + (System.currentTimeMillis() - start) + " milliseconds");
    }
} </s>
<s>class temp {    protected void setRankOrder() {
        this.rankOrder = new int[values.length];
        for (int i = 0; i < rankOrder.length; i++) {
            rankOrder[i] = i;
            assert (!Double.isNaN(values[i]));
        }
        for (int i = rankOrder.length - 1; i >= 0; i--) {
            boolean swapped = false;
            for (int j = 0; j < i; j++) if (values[rankOrder[j]] < values[rankOrder[j + 1]]) {
                int r = rankOrder[j];
                rankOrder[j] = rankOrder[j + 1];
                rankOrder[j + 1] = r;
            }
        }
    }
} </s>
<s>class temp {    public void copyFile(String oldPathFile, String newPathFile) {
        try {
            int bytesum = 0;
            int byteread = 0;
            File oldfile = new File(oldPathFile);
            if (oldfile.exists()) {
                InputStream inStream = new FileInputStream(oldPathFile);
                FileOutputStream fs = new FileOutputStream(newPathFile);
                byte[] buffer = new byte[1444];
                while ((byteread = inStream.read(buffer)) != -1) {
                    bytesum += byteread;
                    System.out.println(bytesum);
                    fs.write(buffer, 0, byteread);
                }
                inStream.close();
            }
        } catch (Exception e) {
            message = ("   Ƶ    ļ         ");
        }
    }
} </s>
<s>class temp {    private byte[] getCharImage(long chrId) {
        byte[] imgData = null;
        try {
            URL url = new URL("http://img.eve.is/serv.asp?s=256&c=" + chrId);
            URLConnection conn = url.openConnection();
            InputStream is = conn.getInputStream();
            ByteArrayOutputStream os = new ByteArrayOutputStream();
            int data;
            try {
                while ((data = is.read()) >= 0) {
                    os.write(data);
                }
            } finally {
                is.close();
            }
            imgData = os.toByteArray();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return imgData;
    }
} </s>
<s>class temp {    private static boolean isRemoteFileExist(String url) {
        InputStream in = null;
        try {
            HttpURLConnection conn = (HttpURLConnection) (new URL(url)).openConnection();
            in = conn.getInputStream();
        } catch (MalformedURLException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        if (in != null) {
            return true;
        } else {
            return false;
        }
    }
} </s>
<s>class temp {    private static RemoteFile getRemoteFile(String url) {
        long size = 0;
        String realUrl = "";
        try {
            HttpURLConnection conn = (HttpURLConnection) (new URL(url)).openConnection();
            size = conn.getContentLength();
            realUrl = conn.getURL().toString();
            conn.disconnect();
        } catch (Exception e) {
            e.printStackTrace();
        }
        RemoteFile rf = new RemoteFile(size, realUrl);
        return rf;
    }
} </s>
<s>class temp {    public byte[] downloadAttachmentContent(Attachment issueAttachment) throws IOException {
        byte[] result = null;
        URL url = new URL(issueAttachment.getContentURL());
        BufferedReader inputReader = null;
        try {
            inputReader = new BufferedReader(new InputStreamReader(url.openStream()));
            StringBuilder contentBuilder = new StringBuilder();
            String line;
            while ((line = inputReader.readLine()) != null) {
                contentBuilder.append(line);
            }
            result = contentBuilder.toString().getBytes();
        } finally {
            if (inputReader != null) {
                inputReader.close();
            }
        }
        return result;
    }
} </s>
<s>class temp {        public void close() throws IOException {
            output.flush();
            output.close();
            FTPClient client = new FTPClient();
            if (server == null) {
                throw new IOException("FTP_SERVER property is missing");
            } else {
                if (port != null) {
                    client.connect(server, Integer.parseInt(port));
                } else {
                    client.connect(server);
                }
            }
            if (username != null) {
                logger.debug("log in as specified user");
                client.login(username, password);
            } else {
                logger.debug("log in as anonymous");
                client.login("anonymous", this.getClass().getName());
            }
            if (binaery) {
                logger.debug("use binaery mode");
                client.setFileType(FTP.BINARY_FILE_TYPE);
            } else {
                logger.debug("use ascii mode");
                client.setFileType(FTP.ASCII_FILE_TYPE);
            }
            client.enterLocalPassiveMode();
            logger.debug("store file on server: " + tempFile + " under name: " + file);
            InputStream stream = new FileInputStream(tempFile);
            String dir = file.substring(0, file.lastIndexOf("/")) + "/";
            String split[] = dir.split("/");
            String last = "";
            logger.debug("creating dir: " + dir);
            for (int i = 0; i < split.length; i++) {
                last = last + "/" + split[i];
                logger.debug(last + " --> " + client.makeDirectory(last));
            }
            logger.debug("storing file: " + file);
            client.deleteFile(file);
            client.storeFile(file, stream);
            client.disconnect();
            tempFile.delete();
            try {
                FTPSource source = new FTPSource();
                source.configure(properties);
                source.setIdentifier(file);
                if (source.exist()) {
                    logger.debug("done");
                } else {
                    throw new IOException("can't find file I just wrote, something went wrong!");
                }
            } catch (ConfigurationException e) {
                throw new IOException(e.getMessage());
            }
        }
} </s>
<s>class temp {    @Test
    public void testGetResource_FileOutsideOfClasspath() throws Exception {
        File temp = File.createTempFile("dozerfiletest", ".txt");
        temp.deleteOnExit();
        String resourceName = "file:" + temp.getAbsolutePath();
        URL url = loader.getResource(resourceName);
        assertNotNull("URL should not be null", url);
        InputStream is = url.openStream();
        assertNotNull("input stream should not be null", is);
    }
} </s>
<s>class temp {    protected static String fileName2md5(String input) {
        try {
            MessageDigest md = MessageDigest.getInstance("MD5");
            md.reset();
            md.update(input.getBytes("iso-8859-1"));
            byte[] byteHash = md.digest();
            md.reset();
            StringBuffer resultString = new StringBuffer();
            for (int i = 0; i < byteHash.length; i++) {
                resultString.append(Integer.toHexString(0xFF & byteHash[i]));
            }
            return (resultString.toString());
        } catch (Exception ex) {
            Logger.error(ex.getClass() + " " + ex.getMessage());
            for (int i = 0; i < ex.getStackTrace().length; i++) Logger.error("     " + ex.getStackTrace()[i].toString());
            ex.printStackTrace();
        }
        return String.valueOf(Math.random() * Long.MAX_VALUE);
    }
} </s>
<s>class temp {    public byte[] uniqueID(String name, String topic) {
        String key;
        byte[] id;
        synchronized (cache_) {
            key = name + "|" + topic;
            id = (byte[]) cache_.get(key);
            if (id == null) {
                MessageDigest md;
                try {
                    md = MessageDigest.getInstance("SHA");
                    md.update(name.getBytes());
                    md.update(topic.getBytes());
                    id = md.digest();
                    cache_.put(key, id);
                    if (debug_) {
                        System.out.println("Cached " + key + " [" + id[0] + "," + id[1] + ",...]");
                    }
                } catch (NoSuchAlgorithmException e) {
                    throw new Error("SHA not available!");
                }
            }
        }
        return id;
    }
} </s>
<s>class temp {    public void startImport(ActionEvent evt) {
        final PsiExchange psiExchange = PsiExchangeFactory.createPsiExchange(IntactContext.getCurrentInstance().getSpringContext());
        for (final URL url : urlsToImport) {
            try {
                if (log.isInfoEnabled()) log.info("Importing: " + url);
                psiExchange.importIntoIntact(url.openStream());
            } catch (IOException e) {
                handleException(e);
                return;
            }
        }
        addInfoMessage("File successfully imported", Arrays.asList(urlsToImport).toString());
    }
} </s>
<s>class temp {    void bubbleSort(int[] a) {
        int i = 0;
        int j = a.length - 1;
        int aux = 0;
        int stop = 0;
        while (stop == 0) {
            stop = 1;
            i = 0;
            while (i < j) {
                if (a[i] > a[i + 1]) {
                    aux = a[i];
                    a[i] = a[i + 1];
                    a[i + 1] = aux;
                    stop = 0;
                }
                i = i + 1;
            }
            j = j - 1;
        }
    }
} </s>
<s>class temp {    @Override
    public void run() {
        try {
            FileChannel out = new FileOutputStream(outputfile).getChannel();
            long pos = 0;
            status.setText("Slučovač: Proces slučování spuštěn.. Prosím čekejte..");
            for (int i = 1; i <= noofparts; i++) {
                FileChannel in = new FileInputStream(originalfilename.getAbsolutePath() + "." + String.format("%03d", i)).getChannel();
                status.setText("Slučovač: Slučuji část " + i + "..");
                this.splitsize = in.size();
                out.transferFrom(in, pos, splitsize);
                pos += splitsize;
                in.close();
                if (deleteOnFinish) new File(originalfilename + String.format(".%03d", i)).delete();
                pb.setValue(100 * i / noofparts);
            }
            out.close();
            status.setText("Slučovač: Hotovo..");
            JOptionPane.showMessageDialog(null, "Sloučeno!", "Slučovač", JOptionPane.INFORMATION_MESSAGE);
        } catch (Exception e) {
        }
    }
} </s>
<s>class temp {    String getLocation(Class clazz) {
        try {
            java.net.URL url = clazz.getProtectionDomain().getCodeSource().getLocation();
            String location = url.toString();
            if (location.startsWith("jar")) {
                url = ((java.net.JarURLConnection) url.openConnection()).getJarFileURL();
                location = url.toString();
            }
            if (location.startsWith("file")) {
                java.io.File file = new java.io.File(url.getFile());
                return file.getAbsolutePath();
            } else {
                return url.toString();
            }
        } catch (Throwable t) {
        }
        return Messages.getMessage("happyClientUnknownLocation");
    }
} </s>
<s>class temp {    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        MessageDigest md;
        md = MessageDigest.getInstance("MD5");
        byte[] md5hash = new byte[32];
        md.update(text.getBytes("iso-8859-1"), 0, text.length());
        md5hash = md.digest();
        return convertToHex(md5hash);
    }
} </s>
<s>class temp {    public void convert(File src, File dest) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(src));
        DcmParser p = pfact.newDcmParser(in);
        Dataset ds = fact.newDataset();
        p.setDcmHandler(ds.getDcmHandler());
        try {
            FileFormat format = p.detectFileFormat();
            if (format != FileFormat.ACRNEMA_STREAM) {
                System.out.println("\n" + src + ": not an ACRNEMA stream!");
                return;
            }
            p.parseDcmFile(format, Tags.PixelData);
            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {
                System.out.println("\n" + src + ": contains UIDs!" + " => probable already DICOM - do not convert");
                return;
            }
            boolean hasPixelData = p.getReadTag() == Tags.PixelData;
            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;
            int pxlen = p.getReadLength();
            if (hasPixelData) {
                if (inflate) {
                    ds.putUS(Tags.BitsAllocated, 16);
                    pxlen = pxlen * 4 / 3;
                }
                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {
                    System.out.println("\n" + src + ": mismatch pixel data length!" + " => do not convert");
                    return;
                }
            }
            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));
            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));
            ds.putUI(Tags.SOPInstanceUID, uid(instUID));
            ds.putUI(Tags.SOPClassUID, classUID);
            if (!ds.contains(Tags.NumberOfSamples)) {
                ds.putUS(Tags.NumberOfSamples, 1);
            }
            if (!ds.contains(Tags.PhotometricInterpretation)) {
                ds.putCS(Tags.PhotometricInterpretation, "MONOCHROME2");
            }
            if (fmi) {
                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));
            }
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
            try {
            } finally {
                ds.writeFile(out, encodeParam());
                if (hasPixelData) {
                    if (!skipGroupLen) {
                        out.write(PXDATA_GROUPLEN);
                        int grlen = pxlen + 8;
                        out.write((byte) grlen);
                        out.write((byte) (grlen >> 8));
                        out.write((byte) (grlen >> 16));
                        out.write((byte) (grlen >> 24));
                    }
                    out.write(PXDATA_TAG);
                    out.write((byte) pxlen);
                    out.write((byte) (pxlen >> 8));
                    out.write((byte) (pxlen >> 16));
                    out.write((byte) (pxlen >> 24));
                }
                if (inflate) {
                    int b2, b3;
                    for (; pxlen > 0; pxlen -= 3) {
                        out.write(in.read());
                        b2 = in.read();
                        b3 = in.read();
                        out.write(b2 & 0x0f);
                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));
                        out.write(b3 >> 4);
                    }
                } else {
                    for (; pxlen > 0; --pxlen) {
                        out.write(in.read());
                    }
                }
                out.close();
            }
            System.out.print('.');
        } finally {
            in.close();
        }
    }
} </s>
<s>class temp {    private void initialize() {
        if (!initialized) {
            if (context.getJavadocLinks() != null) {
                for (String url : context.getJavadocLinks()) {
                    if (!url.endsWith("/")) {
                        url += "/";
                    }
                    StringWriter writer = new StringWriter();
                    try {
                        IOUtils.copy(new URL(url + "package-list").openStream(), writer);
                    } catch (Exception e) {
                        e.printStackTrace();
                        continue;
                    }
                    StringTokenizer tokenizer2 = new StringTokenizer(writer.toString());
                    while (tokenizer2.hasMoreTokens()) {
                        javadocByPackage.put(tokenizer2.nextToken(), url);
                    }
                }
            }
            initialized = true;
        }
    }
} </s>
<s>class temp {    public ContentPackage resolveItem() {
        URL url;
        try {
            url = new URL(itembankURL + "/" + deposit.get("http://www.caret.cam.ac.uk/minibix/metadata/ticket"));
            return new ContentPackage(url.openStream());
        } catch (MalformedURLException e1) {
            e1.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }
} </s>
<s>class temp {    public void addButtons() {
        BufferedImage bufImage = null;
        BufferedImage bufImage1 = null;
        for (int i = 0; i < urls.size(); i++) {
            String url = (String) urls.elementAt(i);
            if (url.contains(java.util.ResourceBundle.getBundle("com/jjcp/resources/Strings").getString("IHERETRIEVEDOCUMENT"))) {
                return;
            }
            try {
                URL url1 = new URL(url);
                URLConnection conn = null;
                conn = url1.openConnection();
                InputStream in = conn.getInputStream();
                in.close();
                bufImage = ImageIO.read(url1);
                bufImage1 = resizeAnImage(bufImage, 0.25);
                ImageIcon icon = new ImageIcon(bufImage1);
                ImageButton imageButton = new ImageButton(icon, this, i);
                imageButton.setIndex(i);
                jPanel1.add(imageButton);
                jPanel1.setPreferredSize(new Dimension(imageButton.getWidth() * urls.size(), imageButton.getHeight() + 20));
            } catch (Exception exception) {
                exception.printStackTrace();
            }
        }
        this.setVisible(true);
        this.repaint();
    }
} </s>
<s>class temp {    public void convert(File src, File dest) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(src));
        DcmParser p = pfact.newDcmParser(in);
        Dataset ds = fact.newDataset();
        p.setDcmHandler(ds.getDcmHandler());
        try {
            FileFormat format = p.detectFileFormat();
            if (format != FileFormat.ACRNEMA_STREAM) {
                System.out.println("\n" + src + ": not an ACRNEMA stream!");
                return;
            }
            p.parseDcmFile(format, Tags.PixelData);
            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {
                System.out.println("\n" + src + ": contains UIDs!" + " => probable already DICOM - do not convert");
                return;
            }
            boolean hasPixelData = p.getReadTag() == Tags.PixelData;
            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;
            int pxlen = p.getReadLength();
            if (hasPixelData) {
                if (inflate) {
                    ds.putUS(Tags.BitsAllocated, 16);
                    pxlen = pxlen * 4 / 3;
                }
                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {
                    System.out.println("\n" + src + ": mismatch pixel data length!" + " => do not convert");
                    return;
                }
            }
            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));
            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));
            ds.putUI(Tags.SOPInstanceUID, uid(instUID));
            ds.putUI(Tags.SOPClassUID, classUID);
            if (!ds.contains(Tags.NumberOfSamples)) {
                ds.putUS(Tags.NumberOfSamples, 1);
            }
            if (!ds.contains(Tags.PhotometricInterpretation)) {
                ds.putCS(Tags.PhotometricInterpretation, "MONOCHROME2");
            }
            if (fmi) {
                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));
            }
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
            try {
            } finally {
                ds.writeFile(out, encodeParam());
                if (hasPixelData) {
                    if (!skipGroupLen) {
                        out.write(PXDATA_GROUPLEN);
                        int grlen = pxlen + 8;
                        out.write((byte) grlen);
                        out.write((byte) (grlen >> 8));
                        out.write((byte) (grlen >> 16));
                        out.write((byte) (grlen >> 24));
                    }
                    out.write(PXDATA_TAG);
                    out.write((byte) pxlen);
                    out.write((byte) (pxlen >> 8));
                    out.write((byte) (pxlen >> 16));
                    out.write((byte) (pxlen >> 24));
                }
                if (inflate) {
                    int b2, b3;
                    for (; pxlen > 0; pxlen -= 3) {
                        out.write(in.read());
                        b2 = in.read();
                        b3 = in.read();
                        out.write(b2 & 0x0f);
                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));
                        out.write(b3 >> 4);
                    }
                } else {
                    for (; pxlen > 0; --pxlen) {
                        out.write(in.read());
                    }
                }
                out.close();
            }
            System.out.print('.');
        } finally {
            in.close();
        }
    }
} </s>
<s>class temp {    private void CopyTo(File dest) throws IOException {
        FileReader in = null;
        FileWriter out = null;
        int c;
        try {
            in = new FileReader(image);
            out = new FileWriter(dest);
            while ((c = in.read()) != -1) out.write(c);
        } finally {
            if (in != null) try {
                in.close();
            } catch (Exception e) {
            }
            if (out != null) try {
                out.close();
            } catch (Exception e) {
            }
        }
    }
} </s>
<s>class temp {        @Override
        void execute(Connection conn, Component parent, String context, ProgressMonitor progressBar, ProgressWrapper progressWrapper) throws Exception {
            Statement statement = null;
            try {
                conn.setAutoCommit(false);
                statement = conn.createStatement();
                String deleteSql = getDeleteSql(m_compositionId);
                statement.executeUpdate(deleteSql);
                conn.commit();
                s_compostionCache.delete(new Integer(m_compositionId));
            } catch (SQLException ex) {
                try {
                    conn.rollback();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
                throw ex;
            } finally {
                if (statement != null) {
                    statement.close();
                }
            }
        }
} </s>
<s>class temp {    public static void doVersionCheck(View view) {
        view.showWaitCursor();
        try {
            URL url = new URL(jEdit.getProperty("version-check.url"));
            InputStream in = url.openStream();
            BufferedReader bin = new BufferedReader(new InputStreamReader(in));
            String line;
            String version = null;
            String build = null;
            while ((line = bin.readLine()) != null) {
                if (line.startsWith(".version")) version = line.substring(8).trim(); else if (line.startsWith(".build")) build = line.substring(6).trim();
            }
            bin.close();
            if (version != null && build != null) {
                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {
                    GUIUtilities.message(view, "version-check" + ".up-to-date", new String[0]);
                }
            }
        } catch (IOException e) {
            String[] args = { jEdit.getProperty("version-check.url"), e.toString() };
            GUIUtilities.error(view, "read-error", args);
        }
        view.hideWaitCursor();
    }
} </s>
<s>class temp {    public String encryptPassword(String clearPassword) throws NullPointerException {
        MessageDigest sha;
        try {
            sha = MessageDigest.getInstance("SHA");
        } catch (NoSuchAlgorithmException e) {
            throw new NullPointerException("NoSuchAlgorithmException: " + e.toString());
        }
        sha.update(clearPassword.getBytes());
        byte encryptedPassword[] = sha.digest();
        sha = null;
        StringBuffer result = new StringBuffer();
        for (int i = 0; i < encryptedPassword.length; i++) {
            result.append(Byte.toString(encryptedPassword[i]));
        }
        return (result.toString());
    }
} </s>
<s>class temp {    public static void transfer(FileInputStream fileInStream, FileOutputStream fileOutStream) throws IOException {
        FileChannel fileInChannel = fileInStream.getChannel();
        FileChannel fileOutChannel = fileOutStream.getChannel();
        long fileInSize = fileInChannel.size();
        try {
            long transferred = fileInChannel.transferTo(0, fileInSize, fileOutChannel);
            if (transferred != fileInSize) {
                throw new IOException("transfer() did not complete");
            }
        } finally {
            ensureClose(fileInChannel, fileOutChannel);
        }
    }
} </s>
<s>class temp {    protected URLConnection openConnection(URL url) throws IOException {
        log.log(Level.FINE, url.toString());
        MSServletRequest urlManager = new MSServletRequest(url);
        MicroServlet servlet = getServlet(urlManager);
        return (new MSConnection(url, servlet, urlManager));
    }
} </s>
<s>class temp {    private static void ftpTest() {
        FTPClient f = new FTPClient();
        try {
            f.connect("oscomak.net");
            System.out.print(f.getReplyString());
            f.setFileType(FTPClient.BINARY_FILE_TYPE);
        } catch (SocketException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        String password = JOptionPane.showInputDialog("Enter password");
        if (password == null || password.equals("")) {
            System.out.println("No password");
            return;
        }
        try {
            f.login("oscomak_pointrel", password);
            System.out.print(f.getReplyString());
        } catch (IOException e) {
            e.printStackTrace();
        }
        try {
            String workingDirectory = f.printWorkingDirectory();
            System.out.println("Working directory: " + workingDirectory);
            System.out.print(f.getReplyString());
        } catch (IOException e1) {
            e1.printStackTrace();
        }
        try {
            f.enterLocalPassiveMode();
            System.out.print(f.getReplyString());
            System.out.println("Trying to list files");
            String[] fileNames = f.listNames();
            System.out.print(f.getReplyString());
            System.out.println("Got file list fileNames: " + fileNames.length);
            for (String fileName : fileNames) {
                System.out.println("File: " + fileName);
            }
            System.out.println();
            System.out.println("done reading stream");
            System.out.println("trying alterative way to read stream");
            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
            f.retrieveFile(fileNames[0], outputStream);
            System.out.println("size: " + outputStream.size());
            System.out.println(outputStream.toString());
            System.out.println("done with alternative");
            System.out.println("Trying to store file back");
            ByteArrayInputStream inputStream = new ByteArrayInputStream(outputStream.toByteArray());
            boolean storeResult = f.storeFile("test.txt", inputStream);
            System.out.println("Done storing " + storeResult);
            f.disconnect();
            System.out.print(f.getReplyString());
            System.out.println("disconnected");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
} </s>
<s>class temp {    public static void main(String[] args) {
        try {
            boolean readExp = Utils.getFlag('l', args);
            final boolean writeExp = Utils.getFlag('s', args);
            final String expFile = Utils.getOption('f', args);
            if ((readExp || writeExp) && (expFile.length() == 0)) {
                throw new Exception("A filename must be given with the -f option");
            }
            Experiment exp = null;
            if (readExp) {
                FileInputStream fi = new FileInputStream(expFile);
                ObjectInputStream oi = new ObjectInputStream(new BufferedInputStream(fi));
                exp = (Experiment) oi.readObject();
                oi.close();
            } else {
                exp = new Experiment();
            }
            System.err.println("Initial Experiment:\n" + exp.toString());
            final JFrame jf = new JFrame("Weka Experiment Setup");
            jf.getContentPane().setLayout(new BorderLayout());
            final SetupPanel sp = new SetupPanel();
            jf.getContentPane().add(sp, BorderLayout.CENTER);
            jf.addWindowListener(new WindowAdapter() {

                public void windowClosing(WindowEvent e) {
                    System.err.println("\nFinal Experiment:\n" + sp.m_Exp.toString());
                    if (writeExp) {
                        try {
                            FileOutputStream fo = new FileOutputStream(expFile);
                            ObjectOutputStream oo = new ObjectOutputStream(new BufferedOutputStream(fo));
                            oo.writeObject(sp.m_Exp);
                            oo.close();
                        } catch (Exception ex) {
                            ex.printStackTrace();
                            System.err.println("Couldn't write experiment to: " + expFile + '\n' + ex.getMessage());
                        }
                    }
                    jf.dispose();
                    System.exit(0);
                }
            });
            jf.pack();
            jf.setVisible(true);
            System.err.println("Short nap");
            Thread.currentThread().sleep(3000);
            System.err.println("Done");
            sp.setExperiment(exp);
        } catch (Exception ex) {
            ex.printStackTrace();
            System.err.println(ex.getMessage());
        }
    }
} </s>
<s>class temp {    public void seeURLConnection() throws Exception {
        URL url = new URL("http://wantmeet.iptime.org");
        URLConnection uc = url.openConnection();
        BufferedReader br = new BufferedReader(new InputStreamReader(uc.getInputStream()));
        String s = null;
        StringBuffer sb = new StringBuffer();
        while ((s = br.readLine()) != null) {
            sb.append(s);
        }
        br.close();
        log.debug("sb=[" + sb.toString() + "]");
    }
} </s>
<s>class temp {    public void url2SaveAsFile(String urlStr, String saveAsFileName) throws Exception {
        URL url = new URL(urlStr);
        URLConnection uc = url.openConnection();
        File f = new File(saveAsFileName);
        if (!f.exists()) {
            FileOutputStream fos = new FileOutputStream(f);
            BufferedInputStream bis = new BufferedInputStream(uc.getInputStream());
            byte[] buffer = new byte[4096];
            int readCount = 0;
            while ((readCount = bis.read(buffer)) != -1) {
                fos.write(buffer, 0, readCount);
            }
            fos.flush();
            fos.close();
            bis.close();
        }
    }
} </s>
<s>class temp {    private String[] getPamFiles() throws IOException {
        URL url = WorkflowStructure.class.getResource("/de/ibis/permoto/loganalyzer/pam");
        Set<String> result = new LinkedHashSet<String>(8);
        if (url.getProtocol().equals("jar")) {
            URLConnection con = url.openConnection();
            JarURLConnection jarCon = (JarURLConnection) con;
            JarFile jarFile = jarCon.getJarFile();
            JarEntry jarEntry = jarCon.getJarEntry();
            String rootEntryPath = (jarEntry != null ? jarEntry.getName() : "");
            rootEntryPath = rootEntryPath + "/";
            for (Enumeration<JarEntry> entries = jarFile.entries(); entries.hasMoreElements(); ) {
                JarEntry entry = entries.nextElement();
                String entryPath = entry.getName();
                if (entryPath.startsWith(rootEntryPath)) {
                    if (entryPath.endsWith(".pam")) {
                        result.add("/" + entryPath);
                    }
                }
            }
        } else {
            String rootEntryPath = url.getFile();
            File dir = new File(url.getFile());
            File[] dirContents = dir.listFiles();
            for (int i = 0; i < dirContents.length; i++) {
                File content = dirContents[i];
                if (content.getName().endsWith(".pam")) {
                    String relativePath = content.getAbsolutePath().substring(rootEntryPath.length());
                    result.add("/de/ibis/permoto/loganalyzer/pam/" + relativePath.replace(File.separatorChar, '/'));
                }
            }
        }
        return result.toArray(new String[result.size()]);
    }
} </s>
<s>class temp {    public void convert(File src, File dest) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(src));
        DcmParser p = pfact.newDcmParser(in);
        Dataset ds = fact.newDataset();
        p.setDcmHandler(ds.getDcmHandler());
        try {
            FileFormat format = p.detectFileFormat();
            if (format != FileFormat.ACRNEMA_STREAM) {
                System.out.println("\n" + src + ": not an ACRNEMA stream!");
                return;
            }
            p.parseDcmFile(format, Tags.PixelData);
            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {
                System.out.println("\n" + src + ": contains UIDs!" + " => probable already DICOM - do not convert");
                return;
            }
            boolean hasPixelData = p.getReadTag() == Tags.PixelData;
            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;
            int pxlen = p.getReadLength();
            if (hasPixelData) {
                if (inflate) {
                    ds.putUS(Tags.BitsAllocated, 16);
                    pxlen = pxlen * 4 / 3;
                }
                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {
                    System.out.println("\n" + src + ": mismatch pixel data length!" + " => do not convert");
                    return;
                }
            }
            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));
            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));
            ds.putUI(Tags.SOPInstanceUID, uid(instUID));
            ds.putUI(Tags.SOPClassUID, classUID);
            if (!ds.contains(Tags.NumberOfSamples)) {
                ds.putUS(Tags.NumberOfSamples, 1);
            }
            if (!ds.contains(Tags.PhotometricInterpretation)) {
                ds.putCS(Tags.PhotometricInterpretation, "MONOCHROME2");
            }
            if (fmi) {
                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));
            }
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
            try {
            } finally {
                ds.writeFile(out, encodeParam());
                if (hasPixelData) {
                    if (!skipGroupLen) {
                        out.write(PXDATA_GROUPLEN);
                        int grlen = pxlen + 8;
                        out.write((byte) grlen);
                        out.write((byte) (grlen >> 8));
                        out.write((byte) (grlen >> 16));
                        out.write((byte) (grlen >> 24));
                    }
                    out.write(PXDATA_TAG);
                    out.write((byte) pxlen);
                    out.write((byte) (pxlen >> 8));
                    out.write((byte) (pxlen >> 16));
                    out.write((byte) (pxlen >> 24));
                }
                if (inflate) {
                    int b2, b3;
                    for (; pxlen > 0; pxlen -= 3) {
                        out.write(in.read());
                        b2 = in.read();
                        b3 = in.read();
                        out.write(b2 & 0x0f);
                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));
                        out.write(b3 >> 4);
                    }
                } else {
                    for (; pxlen > 0; --pxlen) {
                        out.write(in.read());
                    }
                }
                out.close();
            }
            System.out.print('.');
        } finally {
            in.close();
        }
    }
} </s>
<s>class temp {    public static String getHash(String text) {
        if (text == null) return null;
        try {
            MessageDigest md = MessageDigest.getInstance("MD5");
            md.update(text.getBytes());
            byte[] hashedTextBytes = md.digest();
            BigInteger hashedTextBigInteger = new BigInteger(1, hashedTextBytes);
            String hashedTextString = hashedTextBigInteger.toString(16);
            return hashedTextString;
        } catch (NoSuchAlgorithmException e) {
            LOG.warning(e.toString());
            return null;
        }
    }
} </s>
<s>class temp {    private void displayDiffResults() throws IOException {
        File outFile = File.createTempFile("diff", ".htm");
        outFile.deleteOnExit();
        FileOutputStream outStream = new FileOutputStream(outFile);
        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));
        out.write("<html><head><title>LOC Differences</title>\n" + SCRIPT + "</head>\n" + "<body bgcolor='#ffffff'>\n" + "<div onMouseOver=\"window.defaultStatus='Metrics'\">\n");
        if (addedTable.length() > 0) {
            out.write("<table border><tr><th>Files Added:</th>" + "<th>Add</th><th>Type</th></tr>");
            out.write(addedTable.toString());
            out.write("</table><br><br>");
        }
        if (modifiedTable.length() > 0) {
            out.write("<table border><tr><th>Files Modified:</th>" + "<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>" + "<th>Total</th><th>Type</th></tr>");
            out.write(modifiedTable.toString());
            out.write("</table><br><br>");
        }
        if (deletedTable.length() > 0) {
            out.write("<table border><tr><th>Files Deleted:</th>" + "<th>Del</th><th>Type</th></tr>");
            out.write(deletedTable.toString());
            out.write("</table><br><br>");
        }
        out.write("<table name=METRICS BORDER>\n");
        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {
            out.write("<tr><td>Base:&nbsp;</td><td>");
            out.write(Long.toString(base));
            out.write("</td></tr>\n<tr><td>Deleted:&nbsp;</td><td>");
            out.write(Long.toString(deleted));
            out.write("</td></tr>\n<tr><td>Modified:&nbsp;</td><td>");
            out.write(Long.toString(modified));
            out.write("</td></tr>\n<tr><td>Added:&nbsp;</td><td>");
            out.write(Long.toString(added));
            out.write("</td></tr>\n<tr><td>New & Changed:&nbsp;</td><td>");
            out.write(Long.toString(added + modified));
            out.write("</td></tr>\n");
        }
        out.write("<tr><td>Total:&nbsp;</td><td>");
        out.write(Long.toString(total));
        out.write("</td></tr>\n</table></div>");
        redlinesOut.close();
        out.flush();
        InputStream redlines = new FileInputStream(redlinesTempFile);
        byte[] buffer = new byte[4096];
        int bytesRead;
        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);
        outStream.write("</BODY></HTML>".getBytes());
        outStream.close();
        Browser.launch(outFile.toURL().toString());
    }
} </s>
<s>class temp {    private static void readAndRewrite(File inFile, File outFile) throws IOException {
        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));
        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);
        Dataset ds = DcmObjectFactory.getInstance().newDataset();
        dcmParser.setDcmHandler(ds.getDcmHandler());
        dcmParser.parseDcmFile(null, Tags.PixelData);
        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        System.out.println("reading " + inFile + "...");
        pdReader.readPixelData(false);
        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));
        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;
        ds.writeDataset(out, dcmEncParam);
        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());
        System.out.println("writing " + outFile + "...");
        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        pdWriter.writePixelData();
        out.flush();
        out.close();
        System.out.println("done!");
    }
} </s>
<s>class temp {    static void copy(String src, String dest) throws IOException {
        InputStream in = null;
        OutputStream out = null;
        try {
            in = new FileInputStream(src);
            out = new FileOutputStream(dest);
            byte[] buf = new byte[1024];
            int n;
            while ((n = in.read(buf)) > 0) out.write(buf, 0, n);
        } finally {
            if (in != null) in.close();
            if (out != null) out.close();
        }
    }
} </s>
<s>class temp {    public void test() throws Exception {
        StringDocument doc = new StringDocument("Test", "UTF-8");
        doc.open();
        try {
            assertEquals("UTF-8", doc.getCharacterEncoding());
            assertEquals("Test", doc.getText());
            InputStream input = doc.getInputStream();
            StringWriter writer = new StringWriter();
            try {
                IOUtils.copy(input, writer, "UTF-8");
            } finally {
                writer.close();
            }
            assertEquals("Test", writer.toString());
        } finally {
            doc.close();
        }
    }
} </s>
<s>class temp {    private File unpackZIP(URL url, String dirName) {
        try {
            URLConnection connection = url.openConnection();
            if (connection instanceof JarURLConnection) {
                File destDir = new File(getExtensionsDirectory() + EGEConstants.fS + dirName);
                destDir.mkdirs();
                EGEIOUtils.unzipFile(((JarURLConnection) connection).getJarFile(), destDir);
                return destDir;
            }
        } catch (IOException e) {
            LOGGER.error("Could not unzip jar file.", e);
        }
        return null;
    }
} </s>
<s>class temp {    public String sendGetRequest(String endpoint, String requestParameters, String username, String password) throws Exception {
        String result = null;
        if (endpoint.startsWith("http://")) {
            try {
                String urlStr = endpoint;
                if (requestParameters != null && requestParameters.length() > 0) {
                    urlStr += "?" + requestParameters;
                }
                URL url = new URL(urlStr);
                URLConnection conn = url.openConnection();
                String userPassword = username + ":" + password;
                byte[] encoding = org.apache.commons.codec.binary.Base64.encodeBase64(userPassword.getBytes());
                String authStringEnc = new String(encoding);
                log.debug("Base64 encoded auth string: '" + authStringEnc + "'");
                conn.setRequestProperty("Authorization", "Basic " + authStringEnc);
                BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));
                StringBuffer sb = new StringBuffer();
                String line;
                while ((line = rd.readLine()) != null) {
                    sb.append(line);
                }
                rd.close();
                result = sb.toString();
            } catch (Throwable e) {
                throw new Exception("problem issuing get to URL", e);
            }
        }
        return result;
    }
} </s>
<s>class temp {    public Vector Get() throws Exception {
        String query_str = BuildYahooQueryString();
        if (query_str == null) return null;
        Vector result = new Vector();
        HttpURLConnection urlc = null;
        try {
            URL url = new URL(URL_YAHOO_QUOTE + "?" + query_str + "&" + FORMAT);
            urlc = (HttpURLConnection) url.openConnection();
            urlc.setRequestMethod("GET");
            urlc.setDoOutput(true);
            urlc.setDoInput(true);
            urlc.setUseCaches(false);
            urlc.setAllowUserInteraction(false);
            urlc.setRequestProperty("Content-type", "text/html;charset=UTF-8");
            if (urlc.getResponseCode() == 200) {
                InputStream in = urlc.getInputStream();
                BufferedReader reader = null;
                try {
                    reader = new BufferedReader(new InputStreamReader(in, "UTF-8"));
                    String msg = null;
                    while ((msg = reader.readLine()) != null) {
                        ExchangeRate rate = ParseYahooData(msg);
                        if (rate != null) result.add(rate);
                    }
                } finally {
                    if (reader != null) try {
                        reader.close();
                    } catch (Exception e1) {
                    }
                    if (in != null) try {
                        in.close();
                    } catch (Exception e1) {
                    }
                }
                return result;
            }
        } finally {
            if (urlc != null) try {
                urlc.disconnect();
            } catch (Exception e) {
            }
        }
        return null;
    }
} </s>
<s>class temp {    public void save(InputStream is) throws IOException {
        File dest = Config.getDataFile(getInternalDate(), getPhysMessageID());
        OutputStream os = null;
        try {
            os = new FileOutputStream(dest);
            IOUtils.copyLarge(is, os);
        } finally {
            IOUtils.closeQuietly(os);
            IOUtils.closeQuietly(is);
        }
    }
} </s>
<s>class temp {    public static boolean encodeFileToFile(String infile, String outfile) {
        boolean success = false;
        java.io.InputStream in = null;
        java.io.OutputStream out = null;
        try {
            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            byte[] buffer = new byte[65536];
            int read = -1;
            while ((read = in.read(buffer)) >= 0) {
                out.write(buffer, 0, read);
            }
            success = true;
        } catch (java.io.IOException exc) {
            exc.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (Exception exc) {
            }
            try {
                out.close();
            } catch (Exception exc) {
            }
        }
        return success;
    }
} </s>
<s>class temp {    public static boolean decodeFileToFile(String infile, String outfile) {
        boolean success = false;
        java.io.InputStream in = null;
        java.io.OutputStream out = null;
        try {
            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            byte[] buffer = new byte[65536];
            int read = -1;
            while ((read = in.read(buffer)) >= 0) {
                out.write(buffer, 0, read);
            }
            success = true;
        } catch (java.io.IOException exc) {
            exc.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (Exception exc) {
            }
            try {
                out.close();
            } catch (Exception exc) {
            }
        }
        return success;
    }
} </s>
<s>class temp {    private void getRandomGUID(boolean secure) {
        MessageDigest md5 = null;
        StringBuffer sbValueBeforeMD5 = new StringBuffer();
        try {
            md5 = MessageDigest.getInstance("MD5");
        } catch (NoSuchAlgorithmException e) {
        }
        try {
            long time = System.currentTimeMillis();
            long rand = 0;
            if (secure) {
                rand = mySecureRand.nextLong();
            } else {
                rand = random.nextLong();
            }
            sbValueBeforeMD5.append(sid);
            sbValueBeforeMD5.append(":");
            sbValueBeforeMD5.append(Long.toString(time));
            sbValueBeforeMD5.append(":");
            sbValueBeforeMD5.append(Long.toString(rand));
            valueBeforeMD5 = sbValueBeforeMD5.toString();
            md5.update(valueBeforeMD5.getBytes());
            byte[] array = md5.digest();
            StringBuffer sb = new StringBuffer();
            for (int j = 0; j < array.length; ++j) {
                int b = array[j] & 0xFF;
                if (b < 0x10) sb.append('0');
                sb.append(Integer.toHexString(b));
            }
            valueAfterMD5 = sb.toString();
        } catch (Exception e) {
        }
    }
} </s>
<s>class temp {    private static void readAndRewrite(File inFile, File outFile) throws IOException {
        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));
        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);
        Dataset ds = DcmObjectFactory.getInstance().newDataset();
        dcmParser.setDcmHandler(ds.getDcmHandler());
        dcmParser.parseDcmFile(null, Tags.PixelData);
        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        System.out.println("reading " + inFile + "...");
        pdReader.readPixelData(false);
        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));
        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;
        ds.writeDataset(out, dcmEncParam);
        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());
        System.out.println("writing " + outFile + "...");
        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        pdWriter.writePixelData();
        out.flush();
        out.close();
        System.out.println("done!");
    }
} </s>
<s>class temp {    public static Object getInputStream(String name, boolean showMsg, URL appletDocumentBase, String appletProxy) {
        String errorMessage = null;
        int iurlPrefix;
        for (iurlPrefix = urlPrefixes.length; --iurlPrefix >= 0; ) if (name.startsWith(urlPrefixes[iurlPrefix])) break;
        boolean isURL = (iurlPrefix >= 0);
        boolean isApplet = (appletDocumentBase != null);
        InputStream in = null;
        int length;
        try {
            if (isApplet || isURL) {
                if (isApplet && isURL && appletProxy != null) name = appletProxy + "?url=" + URLEncoder.encode(name, "utf-8");
                URL url = (isApplet ? new URL(appletDocumentBase, name) : new URL(name));
                name = url.toString();
                if (showMsg) Logger.info("FileManager opening " + url.toString());
                URLConnection conn = url.openConnection();
                length = conn.getContentLength();
                in = conn.getInputStream();
            } else {
                if (showMsg) Logger.info("FileManager opening " + name);
                File file = new File(name);
                length = (int) file.length();
                in = new FileInputStream(file);
            }
            return new MonitorInputStream(in, length);
        } catch (Exception e) {
            try {
                if (in != null) in.close();
            } catch (IOException e1) {
            }
            errorMessage = "" + e;
        }
        return errorMessage;
    }
} </s>
<s>class temp {    private static void main(String[] args) {
        try {
            File f = new File("test.txt");
            if (f.exists()) {
                throw new IOException(f + " already exists.  I don't want to overwrite it.");
            }
            StraightStreamReader in;
            char[] cbuf = new char[0x1000];
            int read;
            int totRead;
            FileOutputStream out = new FileOutputStream(f);
            for (int i = 0x00; i < 0x100; i++) {
                out.write(i);
            }
            out.close();
            in = new StraightStreamReader(new FileInputStream(f));
            for (int i = 0x00; i < 0x100; i++) {
                read = in.read();
                if (read != i) {
                    System.err.println("Error: " + i + " read as " + read);
                }
            }
            in.close();
            in = new StraightStreamReader(new FileInputStream(f));
            totRead = in.read(cbuf);
            if (totRead != 0x100) {
                System.err.println("Simple buffered read did not read the full amount: 0x" + Integer.toHexString(totRead));
            }
            for (int i = 0x00; i < totRead; i++) {
                if (cbuf[i] != i) {
                    System.err.println("Error: 0x" + i + " read as 0x" + cbuf[i]);
                }
            }
            in.close();
            in = new StraightStreamReader(new FileInputStream(f));
            totRead = 0;
            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {
                totRead += read;
            }
            if (totRead != 0x100) {
                System.err.println("Not enough read. Bytes read: " + Integer.toHexString(totRead));
            }
            for (int i = 0x00; i < totRead; i++) {
                if (cbuf[i] != i) {
                    System.err.println("Error: 0x" + i + " read as 0x" + cbuf[i]);
                }
            }
            in.close();
            in = new StraightStreamReader(new FileInputStream(f));
            totRead = 0;
            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {
                totRead += read;
            }
            if (totRead != 0x100) {
                System.err.println("Not enough read. Bytes read: " + Integer.toHexString(totRead));
            }
            for (int i = 0x00; i < totRead; i++) {
                if (cbuf[i + 0x123] != i) {
                    System.err.println("Error: 0x" + i + " read as 0x" + cbuf[i + 0x123]);
                }
            }
            in.close();
            in = new StraightStreamReader(new FileInputStream(f));
            totRead = 0;
            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {
                totRead += read;
            }
            if (totRead != 0x100) {
                System.err.println("Not enough read. Bytes read: " + Integer.toHexString(totRead));
            }
            for (int i = 0x00; i < totRead; i++) {
                if (cbuf[i + 0x123] != i) {
                    System.err.println("Error: 0x" + i + " read as 0x" + cbuf[i + 0x123]);
                }
            }
            in.close();
            f.delete();
        } catch (IOException x) {
            System.err.println(x.getMessage());
        }
    }
} </s>
<s>class temp {    public boolean loadFile(String inpfile) {
        if (osmlContainer == null) return false;
        hApdx.clear();
        try {
            BufferedReader in = null;
            if (inpfile.indexOf("http://") >= 0) {
                URL url = null;
                url = new URL(inpfile);
                URLConnection conn = url.openConnection();
                conn.setUseCaches(false);
                InputStreamReader is = new InputStreamReader(conn.getInputStream());
                in = new BufferedReader(is);
            } else {
                in = new BufferedReader(new FileReader(inpfile));
            }
            String pline = null;
            while ((pline = in.readLine()) != null) {
                StringTokenizer tok = new StringTokenizer(pline, "\t\n\r");
                if (tok.countTokens() < 2) continue;
                String name = tok.nextToken();
                String apdx = tok.nextToken();
                String note = "";
                if (tok.countTokens() > 0) note = tok.nextToken();
                if (name.length() == 0 || apdx.length() == 0) continue;
                OmicElementContainer element = (OmicElementContainer) OmicElementContainer.createContainer();
                element.setName(name);
                element.setNote(note);
                element.addAppendix(apdx);
                String keys[] = commaPattern.split(apdx);
                for (int j = 0; j < keys.length; j++) {
                    ArrayList v = (ArrayList) hApdx.get(keys[j]);
                    if (v == null) v = new ArrayList();
                    v.add(element);
                    hApdx.put(keys[j], v);
                }
            }
            in.close();
        } catch (MalformedURLException mfe) {
            System.out.println("MalformedURLException");
            return false;
        } catch (IOException ioe) {
            System.out.println("IOException");
            return false;
        }
        System.out.println("appendix name list size " + hApdx.size());
        if (bElementDirected) {
            int nCount = 0;
            ArrayList<OmicElementContainer> omicElementList = osmlContainer.getAllOmicElementContainers();
            for (OmicElementContainer element : omicElementList) {
                String name = element.getName();
                String apdx = element.getAppendix();
                if (name.length() == 0) continue;
                String names[] = commaPattern.split(name);
                String apdxs[] = commaPattern.split(apdx);
                String list[] = new String[names.length + apdxs.length];
                for (int j = 0; j < names.length; j++) list[j] = names[j];
                for (int j = 0; j < apdxs.length; j++) list[j + names.length] = apdxs[j];
                for (int j = 0; j < list.length; j++) {
                    ArrayList v = (ArrayList) hApdx.get(list[j]);
                    if (v == null) continue;
                    for (int k = 0; k < v.size(); k++) {
                        OmicElementContainer appendix = (OmicElementContainer) v.get(k);
                        element.addAppendix(appendix.getName());
                        nCount++;
                    }
                }
            }
            System.out.println("match appendix element " + nCount + " items");
        }
        if (bFunctionDirected) {
            int nCount = 0;
            FunctionalClassContainer functions[] = osmlContainer.getFunctionalClassContainer("[@container=all]");
            ArrayList vFunction = new ArrayList();
            for (int i = 0; i < functions.length; i++) {
                if (!vFunction.contains(functions[i])) vFunction.add(functions[i]);
            }
            for (int i = 0; i < vFunction.size(); i++) {
                FunctionalClassContainer function = (FunctionalClassContainer) vFunction.get(i);
                String name = function.getName();
                if (name.length() == 0) continue;
                String names[] = name.split(",");
                for (int j = 0; j < names.length; j++) {
                    ArrayList v = (ArrayList) hApdx.get(names[j]);
                    if (v == null) continue;
                    for (int k = 0; k < v.size(); k++) {
                        OmicElementContainer appendix = (OmicElementContainer) v.get(k);
                        functions[i].addOmicElementContainer(appendix);
                        nCount++;
                    }
                }
            }
            System.out.println("match appendix function " + nCount + " items");
        }
        return true;
    }
} </s>
<s>class temp {    public static HttpURLConnection create(URL url, String id, String action, HTTPRequestInfo info) throws IOException {
        HttpURLConnection connection = (HttpURLConnection) url.openConnection();
        connection.setRequestMethod("POST");
        if (id != null) {
            connection.setRequestProperty("id", id);
        }
        connection.setRequestProperty("action", action);
        connection.setUseCaches(false);
        if (info.getProxyUser() != null && info.getProxyPassword() != null) {
            String pwd = info.getProxyUser() + ":" + info.getProxyPassword();
            String encoded = new String(Base64.encodeBase64(pwd.getBytes()));
            connection.setRequestProperty("Proxy-Authorization", "Basic " + encoded);
        }
        return connection;
    }
} </s>
<s>class temp {    private static void copy(String fromFileName, String toFileName) throws IOException {
        File fromFile = new File(fromFileName);
        File toFile = new File(toFileName);
        if (!fromFile.exists()) throw new IOException("FileCopy: " + "no such source file: " + fromFileName);
        if (!fromFile.isFile()) throw new IOException("FileCopy: " + "can't copy directory: " + fromFileName);
        if (!fromFile.canRead()) throw new IOException("FileCopy: " + "source file is unreadable: " + fromFileName);
        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());
        if (toFile.exists()) {
            if (!toFile.canWrite()) throw new IOException("FileCopy: " + "destination file is unwriteable: " + toFileName);
            System.out.print("Overwrite existing file " + toFile.getName() + "? (Y/N): ");
            System.out.flush();
            BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
            String response = in.readLine();
            if (!response.equals("Y") && !response.equals("y")) throw new IOException("FileCopy: " + "existing file was not overwritten.");
        } else {
            String parent = toFile.getParent();
            if (parent == null) parent = System.getProperty("user.dir");
            File dir = new File(parent);
            if (!dir.exists()) throw new IOException("FileCopy: " + "destination directory doesn't exist: " + parent);
            if (dir.isFile()) throw new IOException("FileCopy: " + "destination is not a directory: " + parent);
            if (!dir.canWrite()) throw new IOException("FileCopy: " + "destination directory is unwriteable: " + parent);
        }
        FileInputStream from = null;
        FileOutputStream to = null;
        try {
            from = new FileInputStream(fromFile);
            to = new FileOutputStream(toFile);
            byte[] buffer = new byte[4096];
            int bytesRead;
            while ((bytesRead = from.read(buffer)) != -1) to.write(buffer, 0, bytesRead);
        } finally {
            if (from != null) try {
                from.close();
            } catch (IOException e) {
                ;
            }
            if (to != null) try {
                to.close();
            } catch (IOException e) {
                ;
            }
        }
    }
} </s>
<s>class temp {    public InputStream getDaoConfig(String connectionType) throws IOException {
        URL url = null;
        if (connectionType.equals(SQL.ORACLE)) {
            url = DBCreateConfig.class.getResource("oracle.xml");
        } else if (connectionType.equals(SQL.SQL2K)) {
            url = DBCreateConfig.class.getResource("sql2k.xml");
        }
        return url.openStream();
    }
} </s>
<s>class temp {    public static Image getPluginImage(final Object plugin, final String name) {
        try {
            try {
                URL url = getPluginImageURL(plugin, name);
                if (m_URLImageMap.containsKey(url)) return m_URLImageMap.get(url);
                InputStream is = url.openStream();
                Image image;
                try {
                    image = getImage(is);
                    m_URLImageMap.put(url, image);
                } finally {
                    is.close();
                }
                return image;
            } catch (Throwable e) {
            }
        } catch (Throwable e) {
        }
        return null;
    }
} </s>
<s>class temp {    private static void readAndRewrite(File inFile, File outFile) throws IOException {
        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));
        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);
        Dataset ds = DcmObjectFactory.getInstance().newDataset();
        dcmParser.setDcmHandler(ds.getDcmHandler());
        dcmParser.parseDcmFile(null, Tags.PixelData);
        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        System.out.println("reading " + inFile + "...");
        pdReader.readPixelData(false);
        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));
        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;
        ds.writeDataset(out, dcmEncParam);
        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());
        System.out.println("writing " + outFile + "...");
        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        pdWriter.writePixelData();
        out.flush();
        out.close();
        System.out.println("done!");
    }
} </s>

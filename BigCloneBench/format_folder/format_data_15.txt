<s>class temp {    public ObservationResult[] call(String url, String servicename, String srsname, String version, String offering, String observed_property, String responseFormat) {
        System.out.println("GetObservationBasic.call url " + url);
        URL service = null;
        URLConnection connection = null;
        ArrayList<ObservationResult> obsList = new ArrayList<ObservationResult>();
        boolean isDataArrayRead = false;
        try {
            service = new URL(url);
            connection = service.openConnection();
        } catch (MalformedURLException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        connection.setDoOutput(true);
        connection.setDoInput(true);
        connection.setUseCaches(false);
        connection.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");
        try {
            DataOutputStream out = new DataOutputStream(connection.getOutputStream());
            GetObservationDocument getobDoc = GetObservationDocument.Factory.newInstance();
            GetObservation getob = getobDoc.addNewGetObservation();
            getob.setService(servicename);
            getob.setVersion(version);
            getob.setSrsName(srsname);
            getob.setOffering(offering);
            getob.setObservedPropertyArray(new String[] { observed_property });
            getob.setResponseFormat(responseFormat);
            String request = URLEncoder.encode(getobDoc.xmlText(), "UTF-8");
            out.writeBytes(request);
            out.flush();
            out.close();
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        try {
            URL observation_url = new URL("file:///E:/Temp/Observation.xml");
            URLConnection urlc = observation_url.openConnection();
            urlc.connect();
            InputStream observation_url_is = urlc.getInputStream();
            ObservationCollectionDocument obsCollDoc = ObservationCollectionDocument.Factory.parse(observation_url_is);
            ObservationCollectionType obsColl = obsCollDoc.getObservationCollection();
            ObservationPropertyType[] aObsPropType = obsColl.getMemberArray();
            for (ObservationPropertyType observationPropertyType : aObsPropType) {
                ObservationType observation = observationPropertyType.getObservation();
                if (observation != null) {
                    System.out.println("observation " + observation.getClass().getName());
                    ObservationResult obsResult = new ObservationResult();
                    if (observation instanceof GeometryObservationTypeImpl) {
                        GeometryObservationTypeImpl geometryObservation = (GeometryObservationTypeImpl) observation;
                        TimeObjectPropertyType samplingTime = geometryObservation.getSamplingTime();
                        TimeInstantTypeImpl timeInstant = (TimeInstantTypeImpl) samplingTime.getTimeObject();
                        TimePositionType timePosition = timeInstant.getTimePosition();
                        String time = (String) timePosition.getObjectValue();
                        StringTokenizer date_st;
                        String day = new StringTokenizer(time, "T").nextToken();
                        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
                        Date d = sdf.parse(day);
                        String timetemp = null;
                        date_st = new StringTokenizer(time, "T");
                        while (date_st.hasMoreElements()) timetemp = date_st.nextToken();
                        sdf = new SimpleDateFormat("HH:mm:ss");
                        Date ti = sdf.parse(timetemp.substring(0, timetemp.lastIndexOf(':') + 2));
                        d.setHours(ti.getHours());
                        d.setMinutes(ti.getMinutes());
                        d.setSeconds(ti.getSeconds());
                        obsResult.setDatetime(d);
                        String textValue = "null";
                        FeaturePropertyType featureOfInterest = (FeaturePropertyType) geometryObservation.getFeatureOfInterest();
                        Node fnode = featureOfInterest.getDomNode();
                        NodeList childNodes = fnode.getChildNodes();
                        for (int j = 0; j < childNodes.getLength(); j++) {
                            Node cnode = childNodes.item(j);
                            if (cnode.getNodeName().equals("n52:movingObject")) {
                                NamedNodeMap att = cnode.getAttributes();
                                Node id = att.getNamedItem("gml:id");
                                textValue = id.getNodeValue();
                                obsResult.setTextValue(textValue);
                                obsResult.setIsTextValue(true);
                            }
                        }
                        XmlObject result = geometryObservation.getResult();
                        if (result instanceof GeometryPropertyTypeImpl) {
                            GeometryPropertyTypeImpl geometryPropertyType = (GeometryPropertyTypeImpl) result;
                            AbstractGeometryType geometry = geometryPropertyType.getGeometry();
                            String srsName = geometry.getSrsName();
                            StringTokenizer st = new StringTokenizer(srsName, ":");
                            String epsg = null;
                            while (st.hasMoreElements()) epsg = st.nextToken();
                            int sri = Integer.parseInt(epsg);
                            if (geometry instanceof PointTypeImpl) {
                                PointTypeImpl point = (PointTypeImpl) geometry;
                                Node node = point.getDomNode();
                                PointDocument pointDocument = PointDocument.Factory.parse(node);
                                PointType point2 = pointDocument.getPoint();
                                XmlCursor cursor = point.newCursor();
                                cursor.toFirstChild();
                                CoordinatesDocument coordinatesDocument = CoordinatesDocument.Factory.parse(cursor.xmlText());
                                CoordinatesType coords = coordinatesDocument.getCoordinates();
                                StringTokenizer tok = new StringTokenizer(coords.getStringValue(), " ,;", false);
                                double x = Double.parseDouble(tok.nextToken());
                                double y = Double.parseDouble(tok.nextToken());
                                double z = 0;
                                if (tok.hasMoreTokens()) {
                                    z = Double.parseDouble(tok.nextToken());
                                }
                                x += 207561;
                                y += 3318814;
                                z += 20;
                                Point3d center = new Point3d(x, y, z);
                                obsResult.setCenter(center);
                                GeometryFactory fact = new GeometryFactory();
                                Coordinate coordinate = new Coordinate(x, y, z);
                                Geometry g1 = fact.createPoint(coordinate);
                                g1.setSRID(sri);
                                obsResult.setGeometry(g1);
                                String href = observation.getProcedure().getHref();
                                obsResult.setProcedure(href);
                                obsList.add(obsResult);
                            }
                        }
                    }
                }
            }
            observation_url_is.close();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (XmlException e) {
            e.printStackTrace();
        } catch (Exception e) {
            e.printStackTrace();
        }
        ObservationResult[] ar = new ObservationResult[obsList.size()];
        return obsList.toArray(ar);
    }
} </s>
<s>class temp {    private void downloadDirectory() throws SocketException, IOException {
        FTPClient client = new FTPClient();
        client.connect(source.getHost());
        client.login(username, password);
        FTPFile[] files = client.listFiles(source.getPath());
        for (FTPFile file : files) {
            if (!file.isDirectory()) {
                long file_size = file.getSize() / 1024;
                Calendar cal = file.getTimestamp();
                URL source_file = new File(source + file.getName()).toURI().toURL();
                DownloadQueue.add(new Download(projectName, parser.getParserID(), source_file, file_size, cal, target + file.getName()));
            }
        }
    }
} </s>
<s>class temp {    private void downloadFiles() throws SocketException, IOException {
        HashSet<String> files_set = new HashSet<String>();
        boolean hasWildcarts = false;
        FTPClient client = new FTPClient();
        for (String file : downloadFiles) {
            files_set.add(file);
            if (file.contains(WILDCARD_WORD) || file.contains(WILDCARD_DIGIT)) hasWildcarts = true;
        }
        client.connect(source.getHost());
        client.login(username, password);
        FTPFile[] files = client.listFiles(source.getPath());
        if (!hasWildcarts) {
            for (FTPFile file : files) {
                String filename = file.getName();
                if (files_set.contains(filename)) {
                    long file_size = file.getSize() / 1024;
                    Calendar cal = file.getTimestamp();
                    URL source_file = new File(source + file.getName()).toURI().toURL();
                    DownloadQueue.add(new Download(projectName, parser.getParserID(), source_file, file_size, cal, target + file.getName()));
                }
            }
        } else {
            for (FTPFile file : files) {
                String filename = file.getName();
                boolean match = false;
                for (String db_filename : downloadFiles) {
                    db_filename = db_filename.replaceAll("\\" + WILDCARD_WORD, WILDCARD_WORD_PATTERN);
                    db_filename = db_filename.replaceAll("\\" + WILDCARD_DIGIT, WILDCARD_DIGIT_PATTERN);
                    Pattern p = Pattern.compile(db_filename);
                    Matcher m = p.matcher(filename);
                    match = m.matches();
                }
                if (match) {
                    long file_size = file.getSize() / 1024;
                    Calendar cal = file.getTimestamp();
                    URL source_file = new File(source + file.getName()).toURI().toURL();
                    DownloadQueue.add(new Download(projectName, parser.getParserID(), source_file, file_size, cal, target + file.getName()));
                }
            }
        }
    }
} </s>
<s>class temp {    public void descargarArchivo() {
        try {
            FileInputStream fis = new FileInputStream(resultados.elementAt(materialSelccionado).getRuta());
            FileOutputStream fos = new FileOutputStream(rutaDestinoDescarga);
            FileChannel inChannel = fis.getChannel();
            FileChannel outChannel = fos.getChannel();
            inChannel.transferTo(0, inChannel.size(), outChannel);
            fis.close();
            fos.close();
        } catch (IOException ioe) {
            System.err.println("Error al Generar Copia del Material\n" + ioe);
        }
    }
} </s>
<s>class temp {    protected void doTransfer(HttpServletRequest request, HttpServletResponse response, String method) throws ServletException, IOException {
        ServletContext servletContext = this.getServletConfig().getServletContext();
        WebApplicationContext wac = WebApplicationContextUtils.getRequiredWebApplicationContext(servletContext);
        String szUrl = request.getParameter("url");
        System.out.println(szUrl);
        URL url;
        InputStream is = null;
        ServletOutputStream sout = null;
        try {
            url = new URL(szUrl);
            HttpURLConnection con = (HttpURLConnection) url.openConnection();
            Enumeration hNames = request.getHeaderNames();
            while (hNames.hasMoreElements()) {
                String txt = hNames.nextElement().toString();
                con.setRequestProperty(txt, request.getHeader(txt));
            }
            con.setRequestProperty("host", url.getHost());
            con.setRequestProperty("refer", szUrl);
            con.setRequestMethod(method);
            con.setDoOutput(true);
            con.setDoInput(true);
            InputStreamReader inBody = new InputStreamReader(request.getInputStream());
            char bufCh[] = new char[1024];
            int r;
            OutputStreamWriter outReq = new OutputStreamWriter(con.getOutputStream());
            while ((r = inBody.read(bufCh)) != -1) {
                System.out.println(bufCh);
                outReq.write(bufCh, 0, r);
            }
            outReq.flush();
            outReq.close();
            inBody.close();
            System.out.println(con.getResponseCode());
            System.out.println(con.getResponseMessage());
            if (con.getResponseCode() == con.HTTP_OK) {
                response.setContentType(con.getContentType());
                response.addHeader("Content-Encoding", con.getContentEncoding());
                sout = response.getOutputStream();
                is = con.getInputStream();
                byte buff[] = new byte[1024];
                while ((r = is.read(buff)) != -1) {
                    sout.write(buff, 0, r);
                    System.out.print(buff);
                }
                sout.flush();
                is.close();
                sout.close();
            } else {
                response.sendError(con.getResponseCode(), con.getResponseMessage());
            }
        } catch (MalformedURLException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
} </s>
<s>class temp {    public String getWeather(String cityName, String fileAddr) {
        try {
            URL url = new URL("http://www.google.com/ig/api?hl=zh_cn&weather=" + cityName);
            InputStream inputstream = url.openStream();
            String s, str;
            BufferedReader in = new BufferedReader(new InputStreamReader(inputstream));
            StringBuffer stringbuffer = new StringBuffer();
            Writer out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(fileAddr), "utf-8"));
            while ((s = in.readLine()) != null) {
                stringbuffer.append(s);
            }
            str = new String(stringbuffer);
            out.write(str);
            out.close();
            in.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
        File file = new File(fileAddr);
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        String str = null;
        try {
            DocumentBuilder builder = factory.newDocumentBuilder();
            Document doc = builder.parse(file);
            NodeList nodelist1 = (NodeList) doc.getElementsByTagName("forecast_conditions");
            NodeList nodelist2 = nodelist1.item(0).getChildNodes();
            str = nodelist2.item(4).getAttributes().item(0).getNodeValue() + ",temperature:" + nodelist2.item(1).getAttributes().item(0).getNodeValue() + "℃-" + nodelist2.item(2).getAttributes().item(0).getNodeValue() + "℃";
        } catch (Exception e) {
            e.printStackTrace();
        }
        return str;
    }
} </s>
<s>class temp {    @Before
    public void setUp() throws IOException {
        final URL url = getClass().getResource("maventest.properties.xml");
        workdir = new File(new File(url.getPath()).getParentFile(), "workdir");
        final Properties properties = new Properties();
        properties.load(url.openStream());
        for (Map.Entry<Object, Object> entry : properties.entrySet()) {
            jobParams.put(entry.getKey() + "", entry.getValue() + "");
        }
        FileUtils.deleteDirectory(workdir);
        workdir.mkdirs();
    }
} </s>
<s>class temp {    public static int executeUpdate(EOAdaptorChannel channel, String sql, boolean autoCommit) throws SQLException {
        int rowsUpdated;
        boolean wasOpen = channel.isOpen();
        if (!wasOpen) {
            channel.openChannel();
        }
        Connection conn = ((JDBCContext) channel.adaptorContext()).connection();
        try {
            Statement stmt = conn.createStatement();
            try {
                rowsUpdated = stmt.executeUpdate(sql);
                if (autoCommit) {
                    conn.commit();
                }
            } catch (SQLException ex) {
                if (autoCommit) {
                    conn.rollback();
                }
                throw new RuntimeException("Failed to execute the statement '" + sql + "'.", ex);
            } finally {
                stmt.close();
            }
        } finally {
            if (!wasOpen) {
                channel.closeChannel();
            }
        }
        return rowsUpdated;
    }
} </s>
<s>class temp {    private Element getXmlFromGeoNetwork(String urlIn, Session userSession) throws FailedActionException {
        Element results = null;
        try {
            URL url = new URL(urlIn);
            URLConnection conn = url.openConnection();
            conn.setConnectTimeout(1000);
            String cookie = (String) userSession.getAttribute("usercookie.object");
            if (cookie != null) conn.setRequestProperty("Cookie", cookie);
            BufferedInputStream in = new BufferedInputStream(conn.getInputStream());
            try {
                results = Xml.loadStream(in);
            } finally {
                in.close();
            }
        } catch (Exception e) {
            throw new FailedActionException(FailedActionReason.SYSTEM_ERROR);
        }
        return results;
    }
} </s>
<s>class temp {    private ArrayList<String> loadProperties(String filename) throws DevFailed, IOException {
        java.net.URL url = getClass().getResource(filename);
        if (url == null) {
            Except.throw_exception("LOAD_PROPERTY_FAILED", "URL for property file (" + filename + ") is null !", "PogoProperty.loadProperties()");
            return null;
        }
        InputStream is = url.openStream();
        BufferedReader br = new BufferedReader(new InputStreamReader(is));
        ArrayList<String> vs = new ArrayList<String>();
        String str;
        while ((str = br.readLine()) != null) {
            str = str.trim();
            if (!str.startsWith("#")) if (str.length() > 0) vs.add(str);
        }
        br.close();
        return vs;
    }
} </s>
<s>class temp {    public void write(File file) throws Exception {
        if (medooFile != null) {
            if (!medooFile.renameTo(file)) {
                BufferedInputStream in = null;
                BufferedOutputStream out = null;
                try {
                    in = new BufferedInputStream(new FileInputStream(medooFile));
                    out = new BufferedOutputStream(new FileOutputStream(file));
                    IOUtils.copy(in, out);
                } finally {
                    if (in != null) {
                        try {
                            in.close();
                        } catch (IOException e) {
                        }
                    }
                    if (out != null) {
                        try {
                            out.close();
                        } catch (IOException e) {
                        }
                    }
                }
            }
        } else {
            throw new FileUploadException("Cannot write uploaded file to disk!");
        }
    }
} </s>
<s>class temp {    private static String digest(String myinfo) {
        try {
            MessageDigest alga = MessageDigest.getInstance("SHA");
            alga.update(myinfo.getBytes());
            byte[] digesta = alga.digest();
            return byte2hex(digesta);
        } catch (Exception ex) {
            return myinfo;
        }
    }
} </s>
<s>class temp {    @Override
    protected IProject createProject(String projectName, IProgressMonitor monitor) throws CoreException {
        monitor.beginTask(CheatSheetsPlugin.INSTANCE.getString("_UI_CreateJavaProject_message", new String[] { projectName }), 5);
        IProject project = super.createProject(projectName, new SubProgressMonitor(monitor, 1));
        if (project != null) {
            IProjectDescription description = project.getDescription();
            if (!description.hasNature(JavaCore.NATURE_ID)) {
                IJavaProject javaProject = JavaCore.create(project);
                if (javaProject != null) {
                    String[] natures = description.getNatureIds();
                    String[] javaNatures = new String[natures.length + 1];
                    System.arraycopy(natures, 0, javaNatures, 0, natures.length);
                    javaNatures[natures.length] = JavaCore.NATURE_ID;
                    description.setNatureIds(javaNatures);
                    project.setDescription(description, new SubProgressMonitor(monitor, 1));
                    IFolder sourceFolder = project.getFolder(SOURCE_FOLDER);
                    if (!sourceFolder.exists()) {
                        sourceFolder.create(true, true, new SubProgressMonitor(monitor, 1));
                    }
                    javaProject.setOutputLocation(project.getFolder(OUTPUT_FOLDER).getFullPath(), new SubProgressMonitor(monitor, 1));
                    IClasspathEntry[] entries = new IClasspathEntry[] { JavaCore.newSourceEntry(sourceFolder.getFullPath()), JavaCore.newContainerEntry(new Path("org.eclipse.jdt.launching.JRE_CONTAINER")) };
                    javaProject.setRawClasspath(entries, new SubProgressMonitor(monitor, 1));
                }
            }
        }
        monitor.done();
        return project;
    }
} </s>
<s>class temp {    public static int[] bubbleSort(int... a) {
        boolean swapped;
        do {
            swapped = false;
            for (int i = 0; i < a.length - 1; i++) {
                if (a[i] > a[i + 1]) {
                    int tmp = a[i];
                    a[i] = a[i + 1];
                    a[i + 1] = tmp;
                    swapped = true;
                }
            }
        } while (swapped);
        return a;
    }
} </s>
<s>class temp {    public InputStream resolve(String uri) throws SAJException {
        try {
            URI url = new URI(uri);
            InputStream stream = url.toURL().openStream();
            if (stream == null) throw new SAJException("URI " + uri + " can't be resolved");
            return stream;
        } catch (SAJException e) {
            throw e;
        } catch (Exception e) {
            throw new SAJException("Invalid uri to resolve " + uri, e);
        }
    }
} </s>
<s>class temp {    public void moveRowUp(int row) throws FidoDatabaseException {
        try {
            Connection conn = null;
            Statement stmt = null;
            try {
                conn = fido.util.FidoDataSource.getConnection();
                conn.setAutoCommit(false);
                stmt = conn.createStatement();
                int max = findMaxRank(stmt);
                if ((row < 2) || (row > max)) throw new IllegalArgumentException("Row number not between 2 and " + max);
                stmt.executeUpdate("update WordClassifications set Rank = -1 where Rank = " + row);
                stmt.executeUpdate("update WordClassifications set Rank = " + row + " where Rank = " + (row - 1));
                stmt.executeUpdate("update WordClassifications set Rank = " + (row - 1) + " where Rank = -1");
                conn.commit();
            } catch (SQLException e) {
                if (conn != null) conn.rollback();
                throw e;
            } finally {
                if (stmt != null) stmt.close();
                if (conn != null) conn.close();
            }
        } catch (SQLException e) {
            throw new FidoDatabaseException(e);
        }
    }
} </s>
<s>class temp {    public void moveRowDown(int row) throws FidoDatabaseException {
        try {
            Connection conn = null;
            Statement stmt = null;
            try {
                conn = fido.util.FidoDataSource.getConnection();
                conn.setAutoCommit(false);
                stmt = conn.createStatement();
                int max = findMaxRank(stmt);
                if ((row < 1) || (row > (max - 1))) throw new IllegalArgumentException("Row number not between 1 and " + (max - 1));
                stmt.executeUpdate("update WordClassifications set Rank = -1 where Rank = " + row);
                stmt.executeUpdate("update WordClassifications set Rank = " + row + " where Rank = " + (row + 1));
                stmt.executeUpdate("update WordClassifications set Rank = " + (row + 1) + " where Rank = -1");
                conn.commit();
            } catch (SQLException e) {
                if (conn != null) conn.rollback();
                throw e;
            } finally {
                if (stmt != null) stmt.close();
                if (conn != null) conn.close();
            }
        } catch (SQLException e) {
            throw new FidoDatabaseException(e);
        }
    }
} </s>
<s>class temp {    public void delete(int row) throws FidoDatabaseException {
        try {
            Connection conn = null;
            Statement stmt = null;
            try {
                conn = fido.util.FidoDataSource.getConnection();
                conn.setAutoCommit(false);
                stmt = conn.createStatement();
                int max = findMaxRank(stmt);
                if ((row < 1) || (row > max)) throw new IllegalArgumentException("Row number not between 1 and " + max);
                stmt.executeUpdate("delete from WordClassifications where Rank = " + row);
                for (int i = row; i < max; ++i) stmt.executeUpdate("update WordClassifications set Rank = " + i + " where Rank = " + (i + 1));
                conn.commit();
            } catch (SQLException e) {
                if (conn != null) conn.rollback();
                throw e;
            } finally {
                if (stmt != null) stmt.close();
                if (conn != null) conn.close();
            }
        } catch (SQLException e) {
            throw new FidoDatabaseException(e);
        }
    }
} </s>
<s>class temp {    public void createPartControl(Composite parent) {
        FormToolkit toolkit;
        toolkit = new FormToolkit(parent.getDisplay());
        form = toolkit.createForm(parent);
        form.setText("Apple Inc.");
        toolkit.decorateFormHeading(form);
        form.getBody().setLayout(new GridLayout());
        chart = createChart();
        final DateAxis dateAxis = new DateAxis();
        viewer = new GraphicalViewerImpl();
        viewer.setRootEditPart(new ScalableRootEditPart());
        viewer.setEditPartFactory(new ChartEditPartFactory(dateAxis));
        viewer.createControl(form.getBody());
        viewer.setContents(chart);
        viewer.setEditDomain(new EditDomain());
        viewer.addSelectionChangedListener(new ISelectionChangedListener() {

            public void selectionChanged(SelectionChangedEvent event) {
                System.err.println("selectionChanged " + event.getSelection());
            }
        });
        viewer.addSelectionChangedListener(new ISelectionChangedListener() {

            public void selectionChanged(SelectionChangedEvent event) {
                deleteAction.update();
            }
        });
        ActionRegistry actionRegistry = new ActionRegistry();
        createActions(actionRegistry);
        ContextMenuProvider cmProvider = new BlockContextMenuProvider(viewer, actionRegistry);
        viewer.setContextMenu(cmProvider);
        getSite().setSelectionProvider(viewer);
        deleteAction.setSelectionProvider(viewer);
        viewer.getEditDomain().getCommandStack().addCommandStackEventListener(new CommandStackEventListener() {

            public void stackChanged(CommandStackEvent event) {
                undoAction.setEnabled(viewer.getEditDomain().getCommandStack().canUndo());
                redoAction.setEnabled(viewer.getEditDomain().getCommandStack().canRedo());
            }
        });
        Data data = Data.getData();
        chart.setInput(data);
        DateRange dateRange = new DateRange(0, 50);
        dateAxis.setDates(data.date);
        dateAxis.setSelectedRange(dateRange);
        slider = new Slider(form.getBody(), SWT.NONE);
        slider.setMinimum(0);
        slider.setMaximum(data.close.length - 1);
        slider.setSelection(dateRange.start);
        slider.setThumb(dateRange.length);
        slider.addListener(SWT.Selection, new Listener() {

            public void handleEvent(Event event) {
                DateRange r = new DateRange(slider.getSelection(), slider.getThumb());
                dateAxis.setSelectedRange(r);
            }
        });
        final Scale spinner = new Scale(form.getBody(), SWT.NONE);
        spinner.setMinimum(5);
        spinner.setMaximum(data.close.length - 1);
        spinner.setSelection(dateRange.length);
        spinner.addListener(SWT.Selection, new Listener() {

            public void handleEvent(Event event) {
                slider.setThumb(spinner.getSelection());
                DateRange r = new DateRange(slider.getSelection(), slider.getThumb());
                dateAxis.setSelectedRange(r);
            }
        });
        GridDataFactory.defaultsFor(viewer.getControl()).grab(true, true).align(GridData.FILL, GridData.FILL).applyTo(viewer.getControl());
        GridDataFactory.defaultsFor(slider).grab(true, false).align(GridData.FILL, GridData.FILL).grab(true, false).applyTo(slider);
        GridDataFactory.defaultsFor(spinner).grab(true, false).align(GridData.FILL, GridData.FILL).grab(true, false).applyTo(spinner);
        getSite().getWorkbenchWindow().getSelectionService().addSelectionListener(this);
    }
} </s>
<s>class temp {    public static synchronized String hash(String plaintext) {
        MessageDigest md;
        try {
            md = MessageDigest.getInstance("SHA");
        } catch (NoSuchAlgorithmException e) {
            return null;
        }
        try {
            md.update(plaintext.getBytes("UTF-8"));
        } catch (UnsupportedEncodingException e) {
            return null;
        }
        byte raw[] = md.digest();
        return (new BASE64Encoder()).encode(raw);
    }
} </s>
<s>class temp {    public static int[] bubbleSortOtimizado(int... a) {
        boolean swapped;
        int n = a.length - 2;
        do {
            swapped = false;
            for (int i = 0; i <= n; i++) {
                if (a[i] > a[i + 1]) {
                    int tmp = a[i];
                    a[i] = a[i + 1];
                    a[i + 1] = tmp;
                    swapped = true;
                }
            }
            n = n - 1;
        } while (swapped);
        return a;
    }
} </s>
<s>class temp {    @Nullable
    public LSInput resolveResource(String type, String namespaceURI, String publicId, String systemId, String baseURI) {
        if (logger.isLoggable(Level.FINE)) {
            logger.fine("Try to resolve the resource with the public ID: " + publicId + ", system ID: " + systemId + " and baseURI " + baseURI + ".");
        }
        InputSource inputSource = null;
        try {
            inputSource = resolveIntern(publicId, systemId);
        } catch (IOException e) {
            logger.log(Level.SEVERE, "", e);
        }
        if (inputSource != null) {
            return new LSInputSAXWrapper(inputSource);
        }
        if (baseURI != null) {
            String resolved = baseURI.substring(0, baseURI.lastIndexOf('/') + 1) + systemId;
            try {
                URL url = new URL(resolved);
                url.openConnection().connect();
                if (logger.isLoggable(Level.FINE)) {
                    logger.fine("Resolve with help of baseURI to: " + resolved);
                }
                inputSource = new InputSource(resolved);
                return new LSInputSAXWrapper(inputSource);
            } catch (MalformedURLException e) {
            } catch (IOException e) {
            }
        }
        if (logger.isLoggable(Level.WARNING)) {
            logger.warning("Failed to resolve the resource with the public ID: " + publicId + ", system ID: " + systemId + " and baseURI " + baseURI + ".");
        }
        return null;
    }
} </s>
<s>class temp {    private static void loadProperties(Properties props, String res, boolean warnIfNotFound) throws IOException {
        log.debug("Reading properties from resource " + res);
        URL url = ResourceFileStorageFactory.class.getResource(res);
        if (null == url) {
            if (warnIfNotFound) {
                log.warn("Resource " + res + " was not found");
            } else {
                log.debug("Resource " + res + " was not found");
            }
        } else {
            InputStream in = url.openStream();
            try {
                props.load(in);
            } finally {
                in.close();
            }
        }
    }
} </s>
<s>class temp {        public void actionPerformed(ActionEvent e) {
            String aboutText = "Slug application.";
            String aboutURL = System.getProperty(GateConstants.ABOUT_URL_JAVA_PROPERTY_NAME);
            boolean canShowInPane = false;
            if (aboutURL != null) {
                try {
                    URL url = new URL(aboutURL);
                    AboutPaneDialog dlg = new AboutPaneDialog(ShellSlacFrame.this, "Slug application about", true);
                    canShowInPane = dlg.setURL(url);
                    if (canShowInPane) {
                        dlg.setSize(300, 200);
                        dlg.setLocationRelativeTo(ShellSlacFrame.this);
                        dlg.setVisible(true);
                    } else {
                        BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));
                        String line = "";
                        StringBuffer content = new StringBuffer();
                        do {
                            content.append(line);
                            line = reader.readLine();
                        } while (line != null);
                        if (content.length() != 0) {
                            aboutText = content.toString();
                        }
                    }
                } catch (Exception ex) {
                    if (DEBUG) {
                        ex.printStackTrace();
                    }
                }
            }
            if (!canShowInPane) JOptionPane.showMessageDialog(ShellSlacFrame.this, aboutText, "Slug application about", JOptionPane.INFORMATION_MESSAGE);
        }
} </s>
<s>class temp {    public boolean extract(File f, String folder) {
        Enumeration entries;
        ZipFile zipFile;
        try {
            zipFile = new ZipFile(f);
            entries = zipFile.getEntries();
            while (entries.hasMoreElements()) {
                ZipArchiveEntry entry = (ZipArchiveEntry) entries.nextElement();
                if (entry == null) continue;
                String path = folder + "/" + entry.getName().replace('\\', '/');
                if (!entry.isDirectory()) {
                    File destFile = new File(path);
                    String parent = destFile.getParent();
                    if (parent != null) {
                        File parentFile = new File(parent);
                        if (!parentFile.exists()) {
                            parentFile.mkdirs();
                        }
                    }
                    copyInputStream(zipFile.getInputStream(entry), new BufferedOutputStream(new FileOutputStream(destFile)));
                }
            }
            zipFile.close();
        } catch (IOException ioe) {
            this.errMsg = ioe.getMessage();
            Malgn.errorLog("{Zip.unzip} " + ioe.getMessage());
            return false;
        }
        return true;
    }
} </s>
<s>class temp {    protected void handleConnection(Socket server) throws IOException {
        OutputStream out = server.getOutputStream();
        PrintWriter pout = new PrintWriter(out, true);
        BufferedReader in = SocketUtil.getReader(server);
        String failureReason = null;
        int failureCode = 0;
        String httpVersion = "HTTP/1.0";
        String uri = null;
        String command = in.readLine();
        URL url = null;
        if (command != null) {
            StringTokenizer tokenizer = new StringTokenizer(command);
            if (tokenizer.countTokens() != 3) {
                failureCode = 400;
                failureReason = "Illformed Request-Line";
            } else {
                String method = tokenizer.nextToken();
                if (!method.equalsIgnoreCase("get")) {
                    failureCode = 501;
                    failureReason = "Only supports GET method";
                } else {
                    uri = tokenizer.nextToken();
                    httpVersion = tokenizer.nextToken();
                    try {
                        url = getURL(uri);
                    } catch (IOException e) {
                        failureCode = 404;
                        failureReason = "resource not found";
                    }
                }
            }
        } else {
            failureCode = 400;
            failureReason = "Null request";
        }
        if (url != null) {
            InputStream stream = null;
            try {
                URLConnection connection = url.openConnection();
                byte[] chunk = new byte[1024];
                int read = 0;
                pout.println(httpVersion + " 200 ");
                pout.println("Content-Type: " + connection.getContentType());
                pout.println("Content-Length: " + connection.getContentLength());
                pout.println("Content-Encoding: " + connection.getContentEncoding());
                pout.println();
                stream = connection.getInputStream();
                read = stream.read(chunk);
                while (read != -1) {
                    out.write(chunk, 0, read);
                    read = stream.read(chunk);
                }
            } catch (IOException e) {
                failureCode = 500;
                failureReason = "problem reading the resource content";
            } finally {
                if (stream != null) {
                    stream.close();
                }
            }
        } else {
            failureCode = 404;
            failureReason = "resource not found";
        }
        if (failureCode != 0) {
            pout.println(httpVersion + " " + failureCode + " " + failureReason);
            pout.println();
        }
        doDelay();
        server.close();
    }
} </s>
<s>class temp {    @Override
    public void run() {
        if (mMode == 0) {
            long currentVersion = Version.extractVersion(App.getVersion());
            if (currentVersion == 0) {
                mMode = 2;
                RESULT = MSG_UP_TO_DATE;
                return;
            }
            long versionAvailable = currentVersion;
            mMode = 2;
            try {
                StringBuilder buffer = new StringBuilder(mCheckURL);
                try {
                    NetworkInterface ni = NetworkInterface.getByInetAddress(InetAddress.getLocalHost());
                    if (!ni.isLoopback()) {
                        if (ni.isUp()) {
                            if (!ni.isVirtual()) {
                                buffer.append('?');
                                byte[] macAddress = ni.getHardwareAddress();
                                for (byte one : macAddress) {
                                    buffer.append(Integer.toHexString(one >>> 4 & 0xF));
                                    buffer.append(Integer.toHexString(one & 0xF));
                                }
                            }
                        }
                    }
                } catch (Exception exception) {
                }
                URL url = new URL(buffer.toString());
                BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));
                String line = in.readLine();
                while (line != null) {
                    StringTokenizer tokenizer = new StringTokenizer(line, "\t");
                    if (tokenizer.hasMoreTokens()) {
                        try {
                            if (tokenizer.nextToken().equalsIgnoreCase(mProductKey)) {
                                String token = tokenizer.nextToken();
                                long version = Version.extractVersion(token);
                                if (version > versionAvailable) {
                                    versionAvailable = version;
                                }
                            }
                        } catch (Exception exception) {
                        }
                    }
                    line = in.readLine();
                }
            } catch (Exception exception) {
            }
            if (versionAvailable > currentVersion) {
                Preferences prefs = Preferences.getInstance();
                String humanReadableVersion = Version.getHumanReadableVersion(versionAvailable);
                NEW_VERSION_AVAILABLE = true;
                RESULT = MessageFormat.format(MSG_OUT_OF_DATE, humanReadableVersion);
                if (versionAvailable > Version.extractVersion(prefs.getStringValue(MODULE, LAST_VERSION_KEY, App.getVersion()))) {
                    prefs.setValue(MODULE, LAST_VERSION_KEY, humanReadableVersion);
                    prefs.save();
                    mMode = 1;
                    EventQueue.invokeLater(this);
                    return;
                }
            } else {
                RESULT = MSG_UP_TO_DATE;
            }
        } else if (mMode == 1) {
            if (App.isNotificationAllowed()) {
                String result = getResult();
                mMode = 2;
                if (WindowUtils.showConfirmDialog(null, result, MSG_UPDATE_TITLE, JOptionPane.OK_CANCEL_OPTION, new String[] { MSG_UPDATE_TITLE, MSG_IGNORE_TITLE }, MSG_UPDATE_TITLE) == JOptionPane.OK_OPTION) {
                    goToUpdate();
                }
            } else {
                DelayedTask.schedule(this, 250);
            }
        }
    }
} </s>
<s>class temp {    public static void main(String[] args) throws Exception {
        String layerName = args[0];
        String layerDescription = args[1];
        String units = args[2];
        String rawDataDirPath = args[3];
        String processDirPath = args[4];
        String divaDirPath = args[5];
        String legendDirPath = args[6];
        String geotiffDirPath = args[7];
        String dbJdbcUrl = args[8];
        String dbUsername = args[9];
        String dbPassword = args[10];
        String geoserverUsername = args[11];
        String geoserverPassword = args[12];
        File rawDataDir = new File(rawDataDirPath);
        if (!rawDataDir.exists() || !rawDataDir.isDirectory()) {
            throw new RuntimeException("Supplied raw data directory " + rawDataDirPath + " does not exist or is not a directory");
        }
        File processDir = new File(processDirPath);
        if (!processDir.exists() || !processDir.isDirectory()) {
            throw new RuntimeException("Supplied process directory " + processDirPath + " does not exist or is not a directory");
        }
        File divaDir = new File(divaDirPath);
        if (!divaDir.exists() || !divaDir.isDirectory()) {
            throw new RuntimeException("Supplied diva directory " + divaDirPath + " does not exist or is not a directory");
        }
        File legendDir = new File(legendDirPath);
        if (!legendDir.exists() || !legendDir.isDirectory()) {
            throw new RuntimeException("Supplied legend directory " + legendDirPath + " does not exist or is not a directory");
        }
        File geotiffDir = new File(geotiffDirPath);
        if (!geotiffDir.exists() || !geotiffDir.isDirectory()) {
            throw new RuntimeException("Supplied geotiff directory " + geotiffDirPath + " does not exist or is not a directory");
        }
        System.out.println("Beginning environmetal load");
        System.out.println("Connecting to database");
        Class.forName("org.postgresql.Driver");
        Properties props = new Properties();
        props.setProperty("user", dbUsername);
        props.setProperty("password", dbPassword);
        Connection conn = DriverManager.getConnection(dbJdbcUrl, props);
        conn.setAutoCommit(false);
        try {
            File layerProcessDir = new File(processDir, layerName);
            layerProcessDir.mkdir();
            System.out.println("Running gdalwarp");
            File hdrFile = new File(rawDataDir, "hdr.adf");
            if (!hdrFile.exists()) {
                throw new RuntimeException("Could not find hdr.adf in " + rawDataDirPath);
            }
            File bilFile = new File(layerProcessDir, layerName + ".bil");
            Process procGdalWarp = Runtime.getRuntime().exec(new String[] { "gdalwarp", "-of", "EHdr", "-ot", "Float32", hdrFile.getAbsolutePath(), bilFile.getAbsolutePath() });
            int gdalWarpReturnVal = procGdalWarp.waitFor();
            if (gdalWarpReturnVal != 0) {
                String gdalWarpErrorOutput = IOUtils.toString(procGdalWarp.getErrorStream());
                throw new RuntimeException("gdalwarp failed: " + gdalWarpErrorOutput);
            }
            System.out.println("Running Bil2diva");
            boolean bil2DivaSuccess = Bil2diva.bil2diva(layerProcessDir.getAbsolutePath() + File.separator + layerName, divaDir.getAbsolutePath() + File.separator + layerName, units);
            if (!bil2DivaSuccess) {
                throw new RuntimeException("Bil2diva Failed");
            }
            System.out.println("Running GridLegend");
            boolean gridLegendSuccess = GridLegend.generateGridLegend(divaDir.getAbsolutePath() + File.separator + layerName, legendDir.getAbsolutePath() + File.separator + layerName, 1, false);
            if (!gridLegendSuccess) {
                throw new RuntimeException("GridLegend Failed");
            }
            System.out.println("Running gdal_translate");
            File geotiffFile = new File(geotiffDir, layerName + ".tif");
            Process procGdalTranslate = Runtime.getRuntime().exec(new String[] { "gdal_translate", "-of", "GTiff", bilFile.getAbsolutePath(), geotiffFile.getAbsolutePath() });
            int gdalTranslateReturnVal = procGdalTranslate.waitFor();
            if (gdalTranslateReturnVal != 0) {
                String gdalTranslateErrorOutput = IOUtils.toString(procGdalTranslate.getErrorStream());
                throw new RuntimeException("gdal_translate failed: " + gdalTranslateErrorOutput);
            }
            System.out.println("Extracting extents and min/max environmental value from diva .grd file");
            File divaGrd = new File(divaDir, layerName + ".grd");
            if (!divaGrd.exists()) {
                throw new RuntimeException("Could not locate diva .grd file: " + divaGrd.toString());
            }
            String strDivaGrd = FileUtils.readFileToString(divaGrd);
            float minValue = Float.parseFloat(matchPattern(strDivaGrd, "^MinValue=(.+)$"));
            float maxValue = Float.parseFloat(matchPattern(strDivaGrd, "^MaxValue=(.+)$"));
            float minLatitude = Float.parseFloat(matchPattern(strDivaGrd, "^MinY=(.+)$"));
            float maxLatitude = Float.parseFloat(matchPattern(strDivaGrd, "^MaxY=(.+)$"));
            float minLongitude = Float.parseFloat(matchPattern(strDivaGrd, "^MinX=(.+)$"));
            float maxLongitude = Float.parseFloat(matchPattern(strDivaGrd, "^MaxX=(.+)$"));
            System.out.println("Generating ID for new layer...");
            Statement st = conn.createStatement();
            ResultSet rs = st.executeQuery("SELECT MAX(id) from layers");
            rs.next();
            int id = 1;
            String idAsString = rs.getString(1);
            if (idAsString != null) {
                id = Integer.parseInt(idAsString);
                id++;
            }
            String displayPath = MessageFormat.format(GEOSERVER_QUERY_TEMPLATE, layerName);
            System.out.println("Creating layers table entry...");
            PreparedStatement createLayersStatement = createLayersInsert(conn, id, layerDescription, divaDir.getAbsolutePath(), layerName, displayPath, minLatitude, minLongitude, maxLatitude, maxLongitude, minValue, maxValue, units);
            createLayersStatement.execute();
            System.out.println("Creating fields table entry...");
            PreparedStatement createFieldsStatement = createFieldsInsert(conn, id, layerName, layerDescription);
            createFieldsStatement.execute();
            DefaultHttpClient httpClient = new DefaultHttpClient();
            httpClient.getCredentialsProvider().setCredentials(new AuthScope("localhost", 8082), new UsernamePasswordCredentials(geoserverUsername, geoserverPassword));
            System.out.println("Creating layer in geoserver...");
            HttpPut createLayerPut = new HttpPut(String.format("http://localhost:8082/geoserver/rest/workspaces/ALA/coveragestores/%s/external.geotiff", layerName));
            createLayerPut.setHeader("Content-type", "text/plain");
            createLayerPut.setEntity(new StringEntity(geotiffFile.toURI().toURL().toString()));
            HttpResponse createLayerResponse = httpClient.execute(createLayerPut);
            if (createLayerResponse.getStatusLine().getStatusCode() != 200) {
                throw new RuntimeException("Error creating layer in geoserver: " + createLayerResponse.toString());
            }
            EntityUtils.consume(createLayerResponse.getEntity());
            System.out.println("Creating style in geoserver");
            HttpPost createStylePost = new HttpPost("http://localhost:8082/geoserver/rest/styles");
            createStylePost.setHeader("Content-type", "text/xml");
            createStylePost.setEntity(new StringEntity(String.format("<style><name>%s_style</name><filename>%s.sld</filename></style>", layerName, layerName)));
            HttpResponse createStyleResponse = httpClient.execute(createLayerPut);
            if (createStyleResponse.getStatusLine().getStatusCode() != 201) {
                throw new RuntimeException("Error creating style in geoserver: " + createStyleResponse.toString());
            }
            EntityUtils.consume(createStyleResponse.getEntity());
            System.out.println("Uploading sld file to geoserver");
            File sldFile = new File(legendDir, layerName + ".sld");
            String sldData = FileUtils.readFileToString(sldFile);
            HttpPut uploadSldPut = new HttpPut(String.format("http://localhost:8082/geoserver/rest/styles/%s_style", layerName));
            uploadSldPut.setHeader("Content-type", "application/vnd.ogc.sld+xml");
            uploadSldPut.setEntity(new StringEntity(sldData));
            HttpResponse uploadSldResponse = httpClient.execute(uploadSldPut);
            if (uploadSldResponse.getStatusLine().getStatusCode() != 200) {
                throw new RuntimeException("Error uploading sld file geoserver: " + uploadSldResponse.toString());
            }
            EntityUtils.consume(uploadSldResponse.getEntity());
            System.out.println("Setting default style in geoserver");
            HttpPut setDefaultStylePut = new HttpPut(String.format("http://localhost:8082/geoserver/rest/layers/ALA:%s", layerName));
            setDefaultStylePut.setHeader("Content-type", "text/xml");
            setDefaultStylePut.setEntity(new StringEntity(String.format("<layer><enabled>true</enabled><defaultStyle><name>%s_style</name></defaultStyle></layer>", layerName)));
            HttpResponse setDefaultStyleResponse = httpClient.execute(createLayerPut);
            if (setDefaultStyleResponse.getStatusLine().getStatusCode() != 200) {
                throw new RuntimeException("Setting default style in geoserver: " + setDefaultStyleResponse.toString());
            }
            EntityUtils.consume(setDefaultStyleResponse.getEntity());
            conn.commit();
        } catch (Exception ex) {
            ex.printStackTrace();
            conn.rollback();
        }
    }
} </s>
<s>class temp {    public byte[] getBytesFromUrl(String url) {
        try {
            HttpGet get = new HttpGet(url);
            HttpResponse response = this.getHttpClient().execute(get);
            HttpEntity entity = response.getEntity();
            if (entity == null) {
                throw new RuntimeException("response body was empty");
            }
            return EntityUtils.toByteArray(entity);
        } catch (RuntimeException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new RuntimeException(ex);
        }
    }
} </s>
<s>class temp {    public String get(String url) {
        try {
            HttpGet get = new HttpGet(url);
            HttpResponse response = this.getHttpClient().execute(get);
            HttpEntity entity = response.getEntity();
            if (entity == null) {
                throw new RuntimeException("response body was empty");
            }
            return EntityUtils.toString(entity);
        } catch (RuntimeException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new RuntimeException(ex);
        }
    }
} </s>
<s>class temp {    public TestReport runImpl() throws Exception {
        String parser = XMLResourceDescriptor.getXMLParserClassName();
        DocumentFactory df = new SAXDocumentFactory(GenericDOMImplementation.getDOMImplementation(), parser);
        File f = (new File(testFileName));
        URL url = f.toURL();
        Document doc = df.createDocument(null, rootTag, url.toString(), url.openStream());
        Element e = doc.getElementById(targetId);
        if (e == null) {
            DefaultTestReport report = new DefaultTestReport(this);
            report.setErrorCode(ERROR_GET_ELEMENT_BY_ID_FAILED);
            report.addDescriptionEntry(ENTRY_KEY_ID, targetId);
            report.setPassed(false);
            return report;
        }
        Document otherDocument = df.createDocument(null, rootTag, url.toString(), url.openStream());
        DocumentFragment docFrag = otherDocument.createDocumentFragment();
        try {
            docFrag.appendChild(doc.getDocumentElement());
        } catch (DOMException ex) {
            return reportSuccess();
        }
        DefaultTestReport report = new DefaultTestReport(this);
        report.setErrorCode(ERROR_EXCEPTION_NOT_THROWN);
        report.setPassed(false);
        return report;
    }
} </s>
<s>class temp {    public static ChannelIF addChannel(String url) throws Exception {
        ChannelIF channel = null;
        try {
            channel = FeedParser.parse(new ChannelBuilder(), url);
            if (channel.getLocation() == null) channel.setLocation(new URL(url));
        } catch (ParseException e) {
            InputStream is = new URL(url).openStream();
            InputStreamReader reader = new InputStreamReader(is);
            channel = FeedParser.parse(new ChannelBuilder(), reader);
            reader.close();
            is.close();
            if (channel.getLocation() == null) channel.setLocation(new URL(url));
        }
        DAOChannel.addChannel(channel);
        DAOFavicon.addFaviconForChannel(channel);
        return channel;
    }
} </s>
<s>class temp {    public boolean consolidateCrossrefGet(BiblioItem bib, ArrayList<BiblioItem> bib2) throws Exception {
        boolean result = false;
        String doi = bib.getDOI();
        String aut = bib.getFirstAuthorSurname();
        String title = bib.getTitle();
        String firstPage = null;
        String pageRange = bib.getPageRange();
        int beginPage = bib.getBeginPage();
        if (beginPage != -1) {
            firstPage = "" + beginPage;
        } else if (pageRange != null) {
            StringTokenizer st = new StringTokenizer(pageRange, "--");
            if (st.countTokens() == 2) {
                firstPage = st.nextToken();
            } else if (st.countTokens() == 1) firstPage = pageRange;
        }
        if (aut != null) {
            aut = TextUtilities.removeAccents(aut);
        }
        if (title != null) {
            title = TextUtilities.removeAccents(title);
        }
        if (doi != null) {
            if (doi.startsWith("doi:") | doi.startsWith("DOI:")) {
                doi.substring(4, doi.length());
                doi = doi.trim();
            }
            doi = doi.replace(" ", "");
            String xml = null;
            if (cCon != null) {
                PreparedStatement pstmt = null;
                try {
                    pstmt = cCon.prepareStatement(QUERY_CROSSREF_SQL3);
                    pstmt.setString(1, doi);
                    ResultSet res = pstmt.executeQuery();
                    if (res.next()) {
                        xml = res.getString(1);
                    }
                    res.close();
                    pstmt.close();
                } catch (SQLException se) {
                    System.err.println("EXCEPTION HANDLING CROSSREF CACHE");
                    se.printStackTrace();
                } finally {
                    try {
                        if (pstmt != null) pstmt.close();
                    } catch (SQLException se) {
                    }
                }
                if (xml != null) {
                    InputSource is = new InputSource();
                    is.setCharacterStream(new StringReader(xml));
                    DefaultHandler crossref = new crossrefUnixrefSaxParser(bib2);
                    SAXParserFactory spf = SAXParserFactory.newInstance();
                    SAXParser parser = spf.newSAXParser();
                    parser.parse(is, crossref);
                    if (bib2.size() > 0) {
                        if (!bib2.get(0).getError()) result = true;
                    }
                }
            }
            if (xml == null) {
                String subpath = String.format(DOI_BASE_QUERY, crossref_id, crossref_pw, doi);
                URL url = new URL("http://" + crossref_host + "/" + subpath);
                System.out.println("Sending: " + url.toString());
                HttpURLConnection urlConn = null;
                try {
                    urlConn = (HttpURLConnection) url.openConnection();
                } catch (Exception e) {
                    this.setProxy();
                    try {
                        urlConn = (HttpURLConnection) url.openConnection();
                    } catch (Exception e2) {
                        e2.printStackTrace();
                        urlConn = null;
                    }
                }
                if (urlConn != null) {
                    try {
                        urlConn.setDoOutput(true);
                        urlConn.setDoInput(true);
                        urlConn.setRequestMethod("GET");
                        urlConn.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");
                        InputStream in = urlConn.getInputStream();
                        xml = TextUtilities.convertStreamToString(in);
                        InputSource is = new InputSource();
                        is.setCharacterStream(new StringReader(xml));
                        DefaultHandler crossref = new crossrefUnixrefSaxParser(bib2);
                        SAXParserFactory spf = SAXParserFactory.newInstance();
                        SAXParser parser = spf.newSAXParser();
                        parser.parse(is, crossref);
                        if (bib2.size() > 0) {
                            if (!bib2.get(0).getError()) result = true;
                        }
                        urlConn.disconnect();
                    } catch (Exception e) {
                        System.err.println("Warning: Consolidation set true, but the online connection to Crossref fails.");
                    }
                    if (cCon != null) {
                        PreparedStatement pstmt2 = null;
                        try {
                            pstmt2 = cCon.prepareStatement(INSERT_CROSSREF_SQL3);
                            pstmt2.setString(1, doi);
                            pstmt2.setString(2, xml);
                            pstmt2.executeUpdate();
                            pstmt2.close();
                        } catch (SQLException se) {
                            System.err.println("EXCEPTION HANDLING CROSSREF UPDATE");
                        } finally {
                            try {
                                if (pstmt2 != null) pstmt2.close();
                            } catch (SQLException se) {
                            }
                        }
                    }
                }
            }
        } else if ((title != null) & (aut != null)) {
            String xml = null;
            if (cCon != null) {
                PreparedStatement pstmt = null;
                try {
                    pstmt = cCon.prepareStatement(QUERY_CROSSREF_SQL);
                    pstmt.setString(1, aut);
                    pstmt.setString(2, title);
                    ResultSet res = pstmt.executeQuery();
                    if (res.next()) {
                        xml = res.getString(1);
                    }
                    res.close();
                    pstmt.close();
                } catch (SQLException se) {
                    System.err.println("EXCEPTION HANDLING CROSSREF CACHE");
                    se.printStackTrace();
                } finally {
                    try {
                        if (pstmt != null) pstmt.close();
                    } catch (SQLException se) {
                    }
                }
                if (xml != null) {
                    InputSource is = new InputSource();
                    is.setCharacterStream(new StringReader(xml));
                    DefaultHandler crossref = new crossrefUnixrefSaxParser(bib2);
                    SAXParserFactory spf = SAXParserFactory.newInstance();
                    SAXParser parser = spf.newSAXParser();
                    parser.parse(is, crossref);
                    if (bib2.size() > 0) {
                        if (!bib2.get(0).getError()) result = true;
                    }
                }
            }
            if (xml == null) {
                String subpath = String.format(TITLE_BASE_QUERY, crossref_id, crossref_pw, URLEncoder.encode(title), URLEncoder.encode(aut));
                URL url = new URL("http://" + crossref_host + "/" + subpath);
                System.out.println("Sending: " + url.toString());
                HttpURLConnection urlConn = null;
                try {
                    urlConn = (HttpURLConnection) url.openConnection();
                } catch (Exception e) {
                    this.setProxy();
                    try {
                        urlConn = (HttpURLConnection) url.openConnection();
                    } catch (Exception e2) {
                        e2.printStackTrace();
                        urlConn = null;
                    }
                }
                if (urlConn != null) {
                    try {
                        urlConn.setDoOutput(true);
                        urlConn.setDoInput(true);
                        urlConn.setRequestMethod("GET");
                        urlConn.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");
                        InputStream in = urlConn.getInputStream();
                        xml = TextUtilities.convertStreamToString(in);
                        InputSource is = new InputSource();
                        is.setCharacterStream(new StringReader(xml));
                        DefaultHandler crossref = new crossrefUnixrefSaxParser(bib2);
                        SAXParserFactory spf = SAXParserFactory.newInstance();
                        SAXParser parser = spf.newSAXParser();
                        parser.parse(is, crossref);
                        if (bib2.size() > 0) {
                            if (!bib2.get(0).getError()) result = true;
                        }
                        urlConn.disconnect();
                    } catch (Exception e) {
                        System.err.println("Warning: Consolidation set true, but the online connection to Crossref fails.");
                    }
                    if (cCon != null) {
                        PreparedStatement pstmt2 = null;
                        try {
                            pstmt2 = cCon.prepareStatement(INSERT_CROSSREF_SQL);
                            pstmt2.setString(1, aut);
                            pstmt2.setString(2, bib.getTitle());
                            pstmt2.setString(3, xml);
                            pstmt2.executeUpdate();
                            pstmt2.close();
                        } catch (SQLException se) {
                            System.err.println("EXCEPTION HANDLING CROSSREF UPDATE");
                        } finally {
                            try {
                                if (pstmt2 != null) pstmt2.close();
                            } catch (SQLException se) {
                            }
                        }
                    }
                }
            }
        } else if ((firstPage != null) & (bib.getJournal() != null) & (bib.getVolume() != null)) {
            String subpath = String.format(JOURNAL_BASE_QUERY, crossref_id, crossref_pw, URLEncoder.encode(bib.getJournal()), URLEncoder.encode(bib.getVolume()), firstPage);
            URL url = new URL("http://" + crossref_host + "/" + subpath);
            String urlmsg = url.toString();
            System.out.println(urlmsg);
            String xml = null;
            if (cCon != null) {
                PreparedStatement pstmt = null;
                try {
                    pstmt = cCon.prepareStatement(QUERY_CROSSREF_SQL2);
                    pstmt.setString(1, urlmsg);
                    ResultSet res = pstmt.executeQuery();
                    if (res.next()) {
                        xml = res.getString(1);
                    }
                    res.close();
                    pstmt.close();
                } catch (SQLException se) {
                    System.err.println("EXCEPTION HANDLING CROSSREF CACHE");
                    se.printStackTrace();
                } finally {
                    try {
                        if (pstmt != null) pstmt.close();
                    } catch (SQLException se) {
                    }
                }
                if (xml != null) {
                    InputSource is = new InputSource();
                    is.setCharacterStream(new StringReader(xml));
                    DefaultHandler crossref = new crossrefUnixrefSaxParser(bib2);
                    SAXParserFactory spf = SAXParserFactory.newInstance();
                    SAXParser parser = spf.newSAXParser();
                    parser.parse(is, crossref);
                    if (bib2.size() > 0) {
                        if (!bib2.get(0).getError()) result = true;
                    }
                }
            }
            if (xml == null) {
                System.out.println("Sending: " + urlmsg);
                HttpURLConnection urlConn = null;
                try {
                    urlConn = (HttpURLConnection) url.openConnection();
                } catch (Exception e) {
                    this.setProxy();
                    try {
                        urlConn = (HttpURLConnection) url.openConnection();
                    } catch (Exception e2) {
                        e2.printStackTrace();
                        urlConn = null;
                    }
                }
                if (urlConn != null) {
                    try {
                        urlConn.setDoOutput(true);
                        urlConn.setDoInput(true);
                        urlConn.setRequestMethod("GET");
                        urlConn.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");
                        InputStream in = urlConn.getInputStream();
                        xml = TextUtilities.convertStreamToString(in);
                        InputSource is = new InputSource();
                        is.setCharacterStream(new StringReader(xml));
                        DefaultHandler crossref = new crossrefUnixrefSaxParser(bib2);
                        SAXParserFactory spf = SAXParserFactory.newInstance();
                        SAXParser p = spf.newSAXParser();
                        p.parse(is, crossref);
                        if (bib2.size() > 0) {
                            if (!bib2.get(0).getError()) result = true;
                        }
                        in.close();
                        urlConn.disconnect();
                    } catch (Exception e) {
                        System.err.println("Warning: Consolidation set true, but the online connection to Crossref fails.");
                    }
                    if (cCon != null) {
                        PreparedStatement pstmt2 = null;
                        try {
                            pstmt2 = cCon.prepareStatement(INSERT_CROSSREF_SQL2);
                            pstmt2.setString(1, urlmsg);
                            pstmt2.setString(2, xml);
                            pstmt2.executeUpdate();
                            pstmt2.close();
                        } catch (SQLException se) {
                            System.err.println("EXCEPTION HANDLING CROSSREF UPDATE");
                        } finally {
                            try {
                                if (pstmt2 != null) pstmt2.close();
                            } catch (SQLException se) {
                            }
                        }
                    }
                }
            }
        }
        return result;
    }
} </s>
<s>class temp {    public static void main(String[] arg) throws IOException {
        XmlPullParserFactory PULL_PARSER_FACTORY;
        try {
            PULL_PARSER_FACTORY = XmlPullParserFactory.newInstance(System.getProperty(XmlPullParserFactory.PROPERTY_NAME), null);
            PULL_PARSER_FACTORY.setNamespaceAware(true);
            DasParser dp = new DasParser(PULL_PARSER_FACTORY);
            URL url = new URL("http://www.ebi.ac.uk/das-srv/uniprot/das/uniprot/features?segment=P05067");
            InputStream in = url.openStream();
            BufferedReader br = new BufferedReader(new InputStreamReader(in));
            String aLine, xml = "";
            while ((aLine = br.readLine()) != null) {
                xml += aLine;
            }
            WritebackDocument wbd = dp.parse(xml);
            System.out.println("FIN" + wbd);
        } catch (XmlPullParserException xppe) {
            throw new IllegalStateException("Fatal Exception thrown at initialisation.  Cannot initialise the PullParserFactory required to allow generation of the DAS XML.", xppe);
        }
    }
} </s>
<s>class temp {    public static void loadConfig(DeviceEntry defaultDevice, EmulatorContext emulatorContext) {
        Config.defaultDevice = defaultDevice;
        Config.emulatorContext = emulatorContext;
        File configFile = new File(getConfigPath(), "config2.xml");
        try {
            if (configFile.exists()) {
                loadConfigFile("config2.xml");
            } else {
                configFile = new File(getConfigPath(), "config.xml");
                if (configFile.exists()) {
                    loadConfigFile("config.xml");
                    for (Enumeration e = getDeviceEntries().elements(); e.hasMoreElements(); ) {
                        DeviceEntry entry = (DeviceEntry) e.nextElement();
                        if (!entry.canRemove()) {
                            continue;
                        }
                        removeDeviceEntry(entry);
                        File src = new File(getConfigPath(), entry.getFileName());
                        File dst = File.createTempFile("dev", ".jar", getConfigPath());
                        IOUtils.copyFile(src, dst);
                        entry.setFileName(dst.getName());
                        addDeviceEntry(entry);
                    }
                } else {
                    createDefaultConfigXml();
                }
                saveConfig();
            }
        } catch (IOException ex) {
            Logger.error(ex);
            createDefaultConfigXml();
        } finally {
            if (configXml == null) {
                createDefaultConfigXml();
            }
        }
        urlsMRU.read(configXml.getChildOrNew("files").getChildOrNew("recent"));
        initSystemProperties();
    }
} </s>
<s>class temp {    public ViewInitListener() throws IOException {
        URL url = this.getClass().getResource(VIEW_INIT_CONFIG);
        log.debug("Loading configuration from: " + url);
        config = new Properties();
        InputStream in = url.openStream();
        config.load(in);
        in.close();
    }
} </s>
<s>class temp {    private static String scramble(String text) {
        try {
            MessageDigest md = MessageDigest.getInstance("SHA-1");
            md.update(text.getBytes("UTF-8"));
            StringBuffer sb = new StringBuffer();
            for (byte b : md.digest()) sb.append(Integer.toString(b & 0xFF, 16));
            return sb.toString();
        } catch (UnsupportedEncodingException e) {
            return null;
        } catch (NoSuchAlgorithmException e) {
            return null;
        }
    }
} </s>
<s>class temp {    private void forBundle(BundleManipulator manip) {
        ByteArrayOutputStream bout = null;
        try {
            bout = new ByteArrayOutputStream();
            ZipOutputStream zout = new ZipOutputStream(bout);
            Bundle bundle = getBundle();
            Enumeration<URL> files = bundle.findEntries("/", "*.vm", false);
            if (files != null) {
                while (files.hasMoreElements()) {
                    URL url = files.nextElement();
                    String name = url.getFile();
                    if (name.startsWith("/")) {
                        name = name.substring(1);
                    }
                    if (manip.includeEntry(name)) {
                        zout.putNextEntry(new ZipEntry(name));
                        IOUtils.copy(url.openStream(), zout);
                    }
                }
            }
            manip.finish(bundle, zout);
            Manifest mf = new Manifest(bundle.getEntry("META-INF/MANIFEST.MF").openStream());
            zout.putNextEntry(new ZipEntry("META-INF/MANIFEST.MF"));
            mf.write(zout);
            zout.close();
            File tmpFile = File.createTempFile(TEMPLATES_SYMBOLIC_NAME, ".jar");
            FileUtils.writeByteArrayToFile(tmpFile, bout.toByteArray());
            if (pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME) != null) {
                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME));
            } else if (pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY) != null) {
                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY));
            }
            pluginController.installPlugin(new JarPluginArtifact(tmpFile));
            ServiceReference ref = bundleContext.getServiceReference(PackageAdmin.class.getName());
            ((PackageAdmin) bundleContext.getService(ref)).refreshPackages(null);
            tmpFile.delete();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            IOUtils.closeQuietly(bout);
        }
    }
} </s>
<s>class temp {    public void add(final String name, final String content) {
        forBundle(new BundleManipulator() {

            public boolean includeEntry(String entryName) {
                return !name.equals(entryName);
            }

            public void finish(Bundle bundle, ZipOutputStream zout) throws IOException {
                zout.putNextEntry(new ZipEntry(name));
                IOUtils.copy(new StringReader(content), zout, "UTF-8");
            }
        });
    }
} </s>
<s>class temp {    synchronized List<String> getDatasetsList(String surl) {
        if (datasetsList == null) {
            datasetsList = new HashMap<String, List<String>>();
        }
        List<String> result = datasetsList.get(surl);
        if (result == null) {
            BufferedReader reader = null;
            try {
                URL url = new URL(surl + "?server=list");
                reader = new BufferedReader(new InputStreamReader(url.openStream()));
                String s = reader.readLine();
                ArrayList<String> list = new ArrayList<String>();
                while (s != null) {
                    list.add(s);
                    s = reader.readLine();
                }
                datasetsList.put(surl, list);
            } catch (IOException ex) {
                Logger.getLogger(Das2ServerDataSourceFactory.class.getName()).log(Level.SEVERE, null, ex);
                throw new RuntimeException(ex);
            } finally {
                try {
                    reader.close();
                } catch (IOException ex) {
                    Logger.getLogger(Das2ServerDataSourceFactory.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
        }
        return datasetsList.get(surl);
    }
} </s>
<s>class temp {    public static void main(String[] args) throws Exception {
        if (args.length != 2) {
            PrintUtil.prt("arguments: sourcefile, destfile");
            System.exit(1);
        }
        FileChannel in = new FileInputStream(args[0]).getChannel(), out = new FileOutputStream(args[1]).getChannel();
        in.transferTo(0, in.size(), out);
    }
} </s>
<s>class temp {    public static void main(String[] args) {
        Usage u = new ccngetmeta();
        for (int i = 0; i < args.length - 3; i++) {
            if (!CommonArguments.parseArguments(args, i, u)) {
                u.usage();
                System.exit(1);
            }
            if (CommonParameters.startArg > i + 1) i = CommonParameters.startArg - 1;
        }
        if (args.length != CommonParameters.startArg + 3) {
            u.usage();
            System.exit(1);
        }
        try {
            int readsize = 1024;
            CCNHandle handle = CCNHandle.open();
            String metaArg = args[CommonParameters.startArg + 1];
            if (!metaArg.startsWith("/")) metaArg = "/" + metaArg;
            ContentName fileName = MetadataProfile.getLatestVersion(ContentName.fromURI(args[CommonParameters.startArg]), ContentName.fromNative(metaArg), CommonParameters.timeout, handle);
            if (fileName == null) {
                System.out.println("File " + args[CommonParameters.startArg] + " does not exist");
                System.exit(1);
            }
            if (VersioningProfile.hasTerminalVersion(fileName)) {
            } else {
                System.out.println("File " + fileName + " does not exist...  exiting");
                System.exit(1);
            }
            File theFile = new File(args[CommonParameters.startArg + 2]);
            if (theFile.exists()) {
                System.out.println("Overwriting file: " + args[CommonParameters.startArg + 1]);
            }
            FileOutputStream output = new FileOutputStream(theFile);
            long starttime = System.currentTimeMillis();
            CCNInputStream input;
            if (CommonParameters.unversioned) input = new CCNInputStream(fileName, handle); else input = new CCNFileInputStream(fileName, handle);
            if (CommonParameters.timeout != null) {
                input.setTimeout(CommonParameters.timeout);
            }
            byte[] buffer = new byte[readsize];
            int readcount = 0;
            long readtotal = 0;
            while ((readcount = input.read(buffer)) != -1) {
                readtotal += readcount;
                output.write(buffer, 0, readcount);
                output.flush();
            }
            if (CommonParameters.verbose) System.out.println("ccngetfile took: " + (System.currentTimeMillis() - starttime) + "ms");
            System.out.println("Retrieved content " + args[CommonParameters.startArg + 1] + " got " + readtotal + " bytes.");
            System.exit(0);
        } catch (ConfigurationException e) {
            System.out.println("Configuration exception in ccngetfile: " + e.getMessage());
            e.printStackTrace();
        } catch (MalformedContentNameStringException e) {
            System.out.println("Malformed name: " + args[CommonParameters.startArg] + " " + e.getMessage());
            e.printStackTrace();
        } catch (IOException e) {
            System.out.println("Cannot write file or read content. " + e.getMessage());
            e.printStackTrace();
        }
        System.exit(1);
    }
} </s>
<s>class temp {    @Override
    public String transformSingleFile(X3DEditorSupport.X3dEditor xed) {
        Node[] node = xed.getActivatedNodes();
        X3DDataObject dob = (X3DDataObject) xed.getX3dEditorSupport().getDataObject();
        FileObject mySrc = dob.getPrimaryFile();
        File mySrcF = FileUtil.toFile(mySrc);
        File myOutF = new File(mySrcF.getParentFile(), mySrc.getName() + ".x3dv.gz");
        TransformListener co = TransformListener.getInstance();
        co.message(NbBundle.getMessage(getClass(), "Gzip_compression_starting"));
        co.message(NbBundle.getMessage(getClass(), "Saving_as_") + myOutF.getAbsolutePath());
        co.moveToFront();
        co.setNode(node[0]);
        try {
            String x3dvFile = ExportClassicVRMLAction.instance.transformSingleFile(xed);
            FileInputStream fis = new FileInputStream(new File(x3dvFile));
            GZIPOutputStream gzos = new GZIPOutputStream(new FileOutputStream(myOutF));
            byte[] buf = new byte[4096];
            int ret;
            while ((ret = fis.read(buf)) > 0) gzos.write(buf, 0, ret);
            gzos.close();
        } catch (Exception ex) {
            co.message(NbBundle.getMessage(getClass(), "Exception:__") + ex.getLocalizedMessage());
            return null;
        }
        co.message(NbBundle.getMessage(getClass(), "Gzip_compression_complete"));
        return myOutF.getAbsolutePath();
    }
} </s>
<s>class temp {    private Bitmap fetchImage(String urlstr) throws Exception {
        URL url;
        url = new URL(urlstr);
        HttpURLConnection c = (HttpURLConnection) url.openConnection();
        c.setDoInput(true);
        c.setRequestProperty("User-Agent", "Agent");
        c.connect();
        InputStream is = c.getInputStream();
        Bitmap img;
        img = BitmapFactory.decodeStream(is);
        return img;
    }
} </s>
<s>class temp {    protected void runTest(URL pBaseURL, String pName, String pHref) throws Exception {
        URL url = new URL(pBaseURL, pHref);
        XSParser parser = new XSParser();
        parser.setValidating(false);
        InputSource isource = new InputSource(url.openStream());
        isource.setSystemId(url.toString());
        String result;
        try {
            parser.parse(isource);
            ++numOk;
            result = "Ok";
        } catch (Exception e) {
            ++numFailed;
            result = e.getMessage();
        }
        log("Running test " + pName + " with URL " + url + ": " + result);
    }
} </s>
<s>class temp {    protected void runTests(URL pBaseURL, String pName, String pHref) throws Exception {
        URL url = new URL(pBaseURL, pHref);
        InputSource isource = new InputSource(url.openStream());
        isource.setSystemId(url.toString());
        Document document = getDocumentBuilder().parse(isource);
        NodeList schemas = document.getElementsByTagNameNS(null, "Schema");
        for (int i = 0; i < schemas.getLength(); i++) {
            Element schema = (Element) schemas.item(i);
            runTest(url, schema.getAttribute("name"), schema.getAttribute("href"));
        }
    }
} </s>
<s>class temp {    private void transferFile(String fileName) throws SocketException, IOException, Exception {
        FTPClient client = new FTPClient();
        client.connect(server.getExternalName(), server.getPort());
        int reply = client.getReplyCode();
        if (!FTPReply.isPositiveCompletion(reply)) {
            throw new Exception("Failed connecting to server");
        }
        client.login(server.getDefaultUserName(), server.getDefaultUserPassword());
        reply = client.getReplyCode();
        if (!FTPReply.isPositiveCompletion(reply)) {
            throw new Exception("Failed connecting to server");
        }
        InputStream stream = getClass().getClassLoader().getResourceAsStream("res/conf/ftpd.properties");
        client.storeFile(fileName, stream);
        File transfferedFile = new File(server.getServerRootDirectory(), fileName);
        assertTrue(transfferedFile.exists());
        assertTrue(transfferedFile.delete());
    }
} </s>
<s>class temp {    private String fetchCompareContent() throws IOException {
        URL url = new URL(compareTo);
        StringWriter sw = new StringWriter();
        IOUtils.copy(url.openStream(), sw);
        return sw.getBuffer().toString();
    }
} </s>
<s>class temp {    public static void writeFromURL(String urlstr, String filename) throws Exception {
        URL url = new URL(urlstr);
        InputStream in = url.openStream();
        BufferedReader bf = null;
        StringBuffer sb = new StringBuffer();
        try {
            bf = new BufferedReader(new InputStreamReader(in, "latin1"));
            String s;
            while (true) {
                s = bf.readLine();
                if (s != null) {
                    sb.append(s);
                } else {
                    break;
                }
            }
        } catch (Exception e) {
            throw e;
        } finally {
            bf.close();
        }
        writeRawBytes(sb.toString(), filename);
    }
} </s>
<s>class temp {    private void generate(String salt) {
        MessageDigest md5 = null;
        StringBuffer sbValueBeforeMD5 = new StringBuffer();
        try {
            md5 = MessageDigest.getInstance("MD5");
        } catch (NoSuchAlgorithmException e) {
            logger.error("No MD5", e);
        }
        long time = System.currentTimeMillis();
        long rand = random.nextLong();
        sbValueBeforeMD5.append(systemId);
        sbValueBeforeMD5.append(salt);
        sbValueBeforeMD5.append(Long.toString(time));
        sbValueBeforeMD5.append(Long.toString(rand));
        md5.update(sbValueBeforeMD5.toString().getBytes());
        byte[] array = md5.digest();
        StringBuffer sb = new StringBuffer();
        int position = 0;
        for (int j = 0; j < array.length; ++j) {
            if (position == 4 || position == 6 || position == 8 || position == 10) {
                sb.append('-');
            }
            position++;
            int b = array[j] & 0xFF;
            if (b < 0x10) {
                sb.append('0');
            }
            sb.append(Integer.toHexString(b).toUpperCase());
        }
        guidString = sb.toString().toUpperCase();
    }
} </s>
<s>class temp {    public URL getResource(String path) throws MalformedURLException {
        if (!path.startsWith("/")) throw new MalformedURLException("Path '" + path + "' does not start with '/'");
        URL url = new URL(myResourceBaseURL, path.substring(1));
        InputStream is = null;
        try {
            is = url.openStream();
        } catch (Throwable t) {
            url = null;
        } finally {
            if (is != null) {
                try {
                    is.close();
                } catch (Throwable t2) {
                }
            }
        }
        return url;
    }
} </s>
<s>class temp {    @Override
    public boolean checkLink(String link) {
        boolean result = false;
        URLConnection connection = null;
        URL url = null;
        try {
            url = new URL(link);
            connection = url.openConnection();
            connection.setRequestProperty("Cookie", cookie.getCookie(RAPIDSHARE_LOGIN_PAGE));
            connection.connect();
            if (connection.getContentLength() > 0) {
                if (connection.getContentType().equals("application/octet-stream")) {
                    result = true;
                }
                Logger.getRootLogger().debug(connection.getContentType());
            }
        } catch (MalformedURLException e) {
            Logger.getRootLogger().error(link + " cannot be url", e);
        } catch (IOException e) {
            Logger.getRootLogger().error("connection failed", e);
        }
        if (!result) {
            Logger.getRootLogger().warn(link + " doesn't exist");
        }
        return result;
    }
} </s>
<s>class temp {    @Test
    public void testOther() throws Exception {
        filter.init(this.mockConfig);
        ByteArrayOutputStream jpg = new ByteArrayOutputStream();
        IOUtils.copy(this.getClass().getResourceAsStream("Buffalo-Theory.jpg"), jpg);
        MockFilterChain mockChain = new MockFilterChain();
        mockChain.setContentType("image/jpg");
        mockChain.setOutputData(jpg.toByteArray());
        MockResponse mockResponse = new MockResponse();
        filter.doFilter(this.mockRequest, mockResponse, mockChain);
        Assert.assertTrue("Time stamp content type", "image/jpg".equals(mockResponse.getContentType()));
        Assert.assertTrue("OutputStream as original", ArrayUtils.isEquals(jpg.toByteArray(), mockResponse.getMockServletOutputStream().getBytes()));
    }
} </s>
<s>class temp {    protected void sort(int a) {
        int[] masiv = new int[a];
        Random rand = new Random();
        for (int i = 0; i <= a; i++) {
            masiv[i] = rand.nextInt(200);
        }
        int d;
        for (int j = 0; j < a; j++) {
            for (int i = 0; i < a; i++) {
                if (masiv[i] < masiv[i + 1]) {
                } else {
                    d = masiv[i];
                    masiv[i] = masiv[i + 1];
                    masiv[i + 1] = d;
                }
            }
        }
        while (a != 0) {
            System.out.println("sort: " + masiv[a]);
            a--;
        }
    }
} </s>
<s>class temp {    public static String encriptarContrasena(String contrasena) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        StringBuffer sb = new StringBuffer();
        MessageDigest md = MessageDigest.getInstance("SHA-512");
        md.update(contrasena.getBytes("UTF-8"));
        byte[] digestBytes = md.digest();
        String hex = null;
        for (int i = 0; i < digestBytes.length; i++) {
            hex = Integer.toHexString(0xFF & digestBytes[i]);
            if (hex.length() < 2) sb.append("0");
            sb.append(hex);
        }
        return new String(sb);
    }
} </s>
<s>class temp {    public InputStream getInputStream() throws java.io.IOException {
        if (!_urlString.endsWith("!/")) return super.getInputStream();
        URL url = new URL(_urlString.substring(4, _urlString.length() - 2));
        return url.openStream();
    }
} </s>
<s>class temp {    public void update(String channelPath, String dataField, String fatherDocId) {
        String sqlInitial = "select uri from t_ip_doc_res where doc_id = '" + fatherDocId + "' and type=" + " '" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + "' ";
        String sqlsortURL = "update t_ip_doc_res set uri = ? where doc_id = '" + fatherDocId + "' " + " and type = '" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + "' ";
        Connection conn = null;
        ResultSet rs = null;
        PreparedStatement ps = null;
        try {
            dbo = (ERDBOperation) createDBOperation();
            String url = "";
            boolean flag = true;
            StringTokenizer st = null;
            conn = dbo.getConnection();
            conn.setAutoCommit(false);
            ps = conn.prepareStatement(sqlInitial);
            rs = ps.executeQuery();
            if (rs.next()) url = rs.getString(1);
            if (!url.equals("")) {
                st = new StringTokenizer(url, ",");
                String sortDocId = "";
                while (st.hasMoreTokens()) {
                    if (flag) {
                        sortDocId = "'" + st.nextToken() + "'";
                        flag = false;
                    } else {
                        sortDocId = sortDocId + "," + "'" + st.nextToken() + "'";
                    }
                }
                String sqlsort = "select id from t_ip_doc where id in (" + sortDocId + ") order by " + dataField;
                ps = conn.prepareStatement(sqlsort);
                rs = ps.executeQuery();
                String sortURL = "";
                boolean sortflag = true;
                while (rs.next()) {
                    if (sortflag) {
                        sortURL = rs.getString(1);
                        sortflag = false;
                    } else {
                        sortURL = sortURL + "," + rs.getString(1);
                    }
                }
                ps = conn.prepareStatement(sqlsortURL);
                ps.setString(1, sortURL);
                ps.executeUpdate();
            }
            conn.commit();
        } catch (Exception e) {
            e.printStackTrace();
            try {
                conn.rollback();
            } catch (SQLException e1) {
                e1.printStackTrace();
            }
        } finally {
            close(rs, null, ps, conn, dbo);
        }
    }
} </s>
<s>class temp {    private String sendMessage(HttpURLConnection connection, String reqMessage) throws IOException, XMLStreamException {
        if (msgLog.isTraceEnabled()) msgLog.trace("Outgoing SOAPMessage\n" + reqMessage);
        BufferedOutputStream out = new BufferedOutputStream(connection.getOutputStream());
        out.write(reqMessage.getBytes("UTF-8"));
        out.close();
        InputStream inputStream = null;
        if (connection.getResponseCode() < 400) inputStream = connection.getInputStream(); else inputStream = connection.getErrorStream();
        ByteArrayOutputStream baos = new ByteArrayOutputStream(1024);
        IOUtils.copyStream(baos, inputStream);
        inputStream.close();
        byte[] byteArray = baos.toByteArray();
        String resMessage = new String(byteArray, "UTF-8");
        if (msgLog.isTraceEnabled()) msgLog.trace("Incoming Response SOAPMessage\n" + resMessage);
        return resMessage;
    }
} </s>
<s>class temp {    public void adjustPadding(File file, int paddingSize, long audioStart) throws FileNotFoundException, IOException {
        logger.finer("Need to move audio file to accomodate tag");
        FileChannel fcIn = null;
        FileChannel fcOut;
        ByteBuffer paddingBuffer = ByteBuffer.wrap(new byte[paddingSize]);
        File paddedFile;
        try {
            paddedFile = File.createTempFile(Utils.getMinBaseFilenameAllowedForTempFile(file), ".new", file.getParentFile());
            logger.finest("Created temp file:" + paddedFile.getName() + " for " + file.getName());
        } catch (IOException ioe) {
            logger.log(Level.SEVERE, ioe.getMessage(), ioe);
            if (ioe.getMessage().equals(FileSystemMessage.ACCESS_IS_DENIED.getMsg())) {
                logger.severe(ErrorMessage.GENERAL_WRITE_FAILED_TO_CREATE_TEMPORARY_FILE_IN_FOLDER.getMsg(file.getName(), file.getParentFile().getPath()));
                throw new UnableToCreateFileException(ErrorMessage.GENERAL_WRITE_FAILED_TO_CREATE_TEMPORARY_FILE_IN_FOLDER.getMsg(file.getName(), file.getParentFile().getPath()));
            } else {
                logger.severe(ErrorMessage.GENERAL_WRITE_FAILED_TO_CREATE_TEMPORARY_FILE_IN_FOLDER.getMsg(file.getName(), file.getParentFile().getPath()));
                throw new UnableToCreateFileException(ErrorMessage.GENERAL_WRITE_FAILED_TO_CREATE_TEMPORARY_FILE_IN_FOLDER.getMsg(file.getName(), file.getParentFile().getPath()));
            }
        }
        try {
            fcOut = new FileOutputStream(paddedFile).getChannel();
        } catch (FileNotFoundException ioe) {
            logger.log(Level.SEVERE, ioe.getMessage(), ioe);
            logger.severe(ErrorMessage.GENERAL_WRITE_FAILED_TO_MODIFY_TEMPORARY_FILE_IN_FOLDER.getMsg(file.getName(), file.getParentFile().getPath()));
            throw new UnableToModifyFileException(ErrorMessage.GENERAL_WRITE_FAILED_TO_MODIFY_TEMPORARY_FILE_IN_FOLDER.getMsg(file.getName(), file.getParentFile().getPath()));
        }
        try {
            fcIn = new FileInputStream(file).getChannel();
            long written = fcOut.write(paddingBuffer);
            logger.finer("Copying:" + (file.length() - audioStart) + "bytes");
            long audiolength = file.length() - audioStart;
            if (audiolength <= MAXIMUM_WRITABLE_CHUNK_SIZE) {
                long written2 = fcIn.transferTo(audioStart, audiolength, fcOut);
                logger.finer("Written padding:" + written + " Data:" + written2);
                if (written2 != audiolength) {
                    throw new RuntimeException(ErrorMessage.MP3_UNABLE_TO_ADJUST_PADDING.getMsg(audiolength, written2));
                }
            } else {
                long noOfChunks = audiolength / MAXIMUM_WRITABLE_CHUNK_SIZE;
                long lastChunkSize = audiolength % MAXIMUM_WRITABLE_CHUNK_SIZE;
                long written2 = 0;
                for (int i = 0; i < noOfChunks; i++) {
                    written2 += fcIn.transferTo(audioStart + (i * MAXIMUM_WRITABLE_CHUNK_SIZE), MAXIMUM_WRITABLE_CHUNK_SIZE, fcOut);
                }
                written2 += fcIn.transferTo(audioStart + (noOfChunks * MAXIMUM_WRITABLE_CHUNK_SIZE), lastChunkSize, fcOut);
                logger.finer("Written padding:" + written + " Data:" + written2);
                if (written2 != audiolength) {
                    throw new RuntimeException(ErrorMessage.MP3_UNABLE_TO_ADJUST_PADDING.getMsg(audiolength, written2));
                }
            }
            long lastModified = file.lastModified();
            if (fcIn != null) {
                if (fcIn.isOpen()) {
                    fcIn.close();
                }
            }
            if (fcOut != null) {
                if (fcOut.isOpen()) {
                    fcOut.close();
                }
            }
            replaceFile(file, paddedFile);
            paddedFile.setLastModified(lastModified);
        } finally {
            try {
                if (fcIn != null) {
                    if (fcIn.isOpen()) {
                        fcIn.close();
                    }
                }
                if (fcOut != null) {
                    if (fcOut.isOpen()) {
                        fcOut.close();
                    }
                }
            } catch (Exception e) {
                logger.log(Level.WARNING, "Problem closing channels and locks:" + e.getMessage(), e);
            }
        }
    }
} </s>
<s>class temp {    private HttpURLConnection getConnection() throws IOException {
        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();
        conn.setRequestMethod(method);
        conn.setDoOutput(true);
        conn.setDoInput(true);
        if (cookie != null) conn.setRequestProperty("Cookie", cookie);
        conn.setRequestProperty("Connection", "Keep-Alive");
        conn.setRequestProperty("Accept-Encoding", "gzip, deflate");
        conn.setRequestProperty("User-Agent", Constants.USER_AGENT());
        conn.connect();
        if (!parameters.equals("")) {
            DataOutputStream out = new DataOutputStream(conn.getOutputStream());
            out.writeBytes(parameters);
            out.flush();
            out.close();
        }
        return conn;
    }
} </s>
<s>class temp {    private void onDhReply(final SshDhReply msg) throws GeneralSecurityException, IOException {
        if ((this.keyPair == null) || this.connection.isServer()) throw new SshException("%s: unexpected %s", this.connection.uri, msg.getType());
        final BigInteger k;
        {
            final DHPublicKeySpec remoteKeySpec = new DHPublicKeySpec(new BigInteger(msg.f), P1, G);
            final KeyFactory dhKeyFact = KeyFactory.getInstance("DH");
            final DHPublicKey remotePubKey = (DHPublicKey) dhKeyFact.generatePublic(remoteKeySpec);
            final KeyAgreement dhKex = KeyAgreement.getInstance("DH");
            dhKex.init(this.keyPair.getPrivate());
            dhKex.doPhase(remotePubKey, true);
            k = new BigInteger(dhKex.generateSecret());
        }
        final MessageDigest md = createMessageDigest();
        final byte[] h;
        {
            updateByteArray(md, SshVersion.LOCAL.toString().getBytes());
            updateByteArray(md, this.connection.getRemoteSshVersion().toString().getBytes());
            updateByteArray(md, this.keyExchangeInitLocal.getPayload());
            updateByteArray(md, this.keyExchangeInitRemote.getPayload());
            updateByteArray(md, msg.hostKey);
            updateByteArray(md, ((DHPublicKey) this.keyPair.getPublic()).getY().toByteArray());
            updateByteArray(md, msg.f);
            updateBigInt(md, k);
            h = md.digest();
        }
        if (this.sessionId == null) this.sessionId = h;
        this.keyExchangeInitLocal = null;
        this.keyExchangeInitRemote = null;
        this.h = h;
        this.k = k;
        this.connection.send(new SshKeyExchangeNewKeys());
    }
} </s>
<s>class temp {    private void modifyProperty(String valueID, String value, Long userID) throws JspTagException {
        Property property = new Property(new Long(valueID), userID);
        String newValue = value;
        System.out.println(property.getName());
        if (property.getName().equals("Password")) {
            try {
                MessageDigest crypt = MessageDigest.getInstance("MD5");
                crypt.update(value.getBytes());
                byte digest[] = crypt.digest();
                StringBuffer hexString = new StringBuffer();
                for (int i = 0; i < digest.length; i++) {
                    hexString.append(hexDigit(digest[i]));
                }
                newValue = hexString.toString();
                crypt.reset();
            } catch (NoSuchAlgorithmException e) {
                System.err.println("jspShop: Could not get instance of MD5 algorithm. Please fix this!" + e.getMessage());
                e.printStackTrace();
                throw new JspTagException("Error crypting password!: " + e.getMessage());
            }
        }
        property.setValue(newValue);
    }
} </s>
<s>class temp {    public CServletContextWrapper(final FileSystem fs, final String contextName) {
        this.fs = fs;
        this.name = contextName;
        CContext.getInstance().init(this);
        try {
            URL url = this.getResource("/WEB-INF/classes/log4j.properties");
            boolean ok = false;
            InputStream in = null;
            try {
                in = url.openStream();
                ok = true;
            } catch (Throwable e) {
            } finally {
                try {
                    if (in != null) in.close();
                } catch (Exception ignore) {
                }
            }
            if (ok) {
                PropertyConfigurator.configure(url);
            }
        } catch (final Throwable e) {
            if (!hasPrintedLog4JWarning) {
                hasPrintedLog4JWarning = true;
                System.err.println("!!! WARNING: /WEB-INF/classes/log4j.properties missing.");
            }
        }
        this.init();
        this.loadServletContextListener();
        this.log = LOGGERHelper.getLogger(this.getClass());
        CJNDIContextSetup.init(this);
        JDBCPooler.init(this);
        CResourceBundle.registerBundles(this);
        this.fireInitEvent();
    }
} </s>
<s>class temp {    static String getMD5Hash(String str) throws NoSuchAlgorithmException {
        MessageDigest md = MessageDigest.getInstance("MD5");
        md.update(str.getBytes());
        byte[] b = md.digest();
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < b.length; i++) {
            int v = (int) b[i];
            v = v < 0 ? 0x100 + v : v;
            String cc = Integer.toHexString(v);
            if (cc.length() == 1) sb.append('0');
            sb.append(cc);
        }
        return sb.toString();
    }
} </s>
<s>class temp {    public FlashExObj get(String s, int page) {
        FlashExObj retVal = new FlashExObj();
        s = s.replaceAll("[^a-z0-9_]", "");
        ArrayList list = new ArrayList();
        retVal.list = list;
        try {
            String result = null;
            URL url = new URL("http://www.flashcardexchange.com/flashcards/list/" + URLEncoder.encode(s, "UTF-8") + "?page=" + page);
            URLConnection connection = url.openConnection();
            connection.setRequestProperty("User-Agent", "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)");
            connection.setDoOutput(false);
            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream(), "UTF-8"));
            String inputLine;
            int state = 2;
            StringBuilder sb = new StringBuilder();
            while ((inputLine = in.readLine()) != null) {
                if (state == 0) {
                    int textPos = inputLine.indexOf("Number of Card");
                    if (textPos >= 0) {
                        state = 1;
                    }
                } else if (state == 1) {
                    int s1 = inputLine.indexOf(">");
                    int s2 = inputLine.indexOf("<", 1);
                    if (s1 >= 0 && s1 < s2) {
                        String numOfCardStr = inputLine.substring(s1 + 1, s2);
                        try {
                        } catch (Exception e) {
                        }
                        state = 2;
                    }
                } else if (state == 2) {
                    int textPos = inputLine.indexOf("tbody class=\"shaded\"");
                    if (textPos >= 0) {
                        state = 3;
                    }
                } else if (state == 3) {
                    int textPos = inputLine.indexOf("tbody");
                    if (textPos >= 0) {
                        break;
                    }
                    sb.append(inputLine);
                    sb.append(" ");
                }
            }
            in.close();
            Pattern myPattern = Pattern.compile("<td>(.*?)</td>");
            Matcher myMatcher = myPattern.matcher(sb);
            String str;
            int counter = 0;
            String buff[] = new String[4];
            while (myMatcher.find()) {
                int tt = counter % 4;
                buff[tt] = myMatcher.group(1);
                if (tt == 3) {
                    String toAdd[] = new String[2];
                    toAdd[0] = buff[1];
                    toAdd[1] = buff[2];
                    list.add(toAdd);
                }
                counter++;
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return retVal;
    }
} </s>
<s>class temp {    protected void handleUrl(URL url) throws Exception {
        File file = new File(dir.getAbsolutePath() + "/" + new Date().getTime() + "." + this.ext);
        FileWriter writer = new FileWriter(file);
        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));
        String s;
        while ((s = in.readLine()) != null) {
            writer.write(s + "\n");
        }
        in.close();
        writer.close();
    }
} </s>
<s>class temp {    public static void contentTrans(String contents, String urlString, String urlString2, String serverIp, int port) {
        try {
            URL url = new URL(urlString);
            url.openStream();
        } catch (Exception e) {
            e.printStackTrace();
        }
        try {
            Socket server = new Socket(InetAddress.getByName(serverIp), port);
            OutputStream outputStream = server.getOutputStream();
            BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(outputStream, "UTF-8"));
            bufferedWriter.write(contents);
            bufferedWriter.flush();
            bufferedWriter.close();
            server.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
        try {
            URL url2 = new URL(urlString2);
            url2.openStream();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
} </s>
<s>class temp {    public static void fileTrans(String filePath, String urlString, String urlString2, String serverIp, int port) {
        try {
            URL url = new URL(urlString);
            url.openStream();
        } catch (Exception e) {
            e.printStackTrace();
        }
        File file = new File(filePath);
        try {
            FileInputStream fis = new FileInputStream(file);
            Socket server = new Socket(InetAddress.getByName(serverIp), port);
            OutputStream outputStream = server.getOutputStream();
            DataOutputStream dataOutputStream = new DataOutputStream(new BufferedOutputStream(outputStream));
            byte[] buffer = new byte[2048];
            int num = fis.read(buffer);
            while (num != -1) {
                dataOutputStream.write(buffer, 0, num);
                dataOutputStream.flush();
                num = fis.read(buffer);
            }
            fis.close();
            dataOutputStream.close();
            server.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
        try {
            URL url2 = new URL(urlString2);
            url2.openStream();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
} </s>
<s>class temp {    public static boolean copy(String source, String dest) {
        int bytes;
        byte array[] = new byte[BUFFER_LEN];
        try {
            InputStream is = new FileInputStream(source);
            OutputStream os = new FileOutputStream(dest);
            while ((bytes = is.read(array, 0, BUFFER_LEN)) > 0) os.write(array, 0, bytes);
            is.close();
            os.close();
            return true;
        } catch (IOException e) {
            return false;
        }
    }
} </s>
<s>class temp {    @Override
    public void run() {
        try {
            FileChannel in = new FileInputStream(inputfile).getChannel();
            long pos = 0;
            for (int i = 1; i <= noofparts; i++) {
                FileChannel out = new FileOutputStream(outputfile.getAbsolutePath() + "." + "v" + i).getChannel();
                status.setText("Rozdělovač: Rozděluji část " + i + "..");
                if (remainingsize >= splitsize) {
                    in.transferTo(pos, splitsize, out);
                    pos += splitsize;
                    remainingsize -= splitsize;
                } else {
                    in.transferTo(pos, remainingsize, out);
                }
                pb.setValue(100 * i / noofparts);
                out.close();
            }
            in.close();
            if (deleteOnFinish) new File(inputfile + "").delete();
            status.setText("Rozdělovač: Hotovo..");
            JOptionPane.showMessageDialog(null, "Rozděleno!", "Rozdělovač", JOptionPane.INFORMATION_MESSAGE);
        } catch (IOException ex) {
        }
    }
} </s>
<s>class temp {        public IStatus runInUIThread(IProgressMonitor monitor) {
            monitor.beginTask(Strings.MSG_CONNECT_SERVER, 3);
            InputStream in = null;
            try {
                URL url = createOpenUrl(resource, pref);
                if (url != null) {
                    URLConnection con = url.openConnection();
                    monitor.worked(1);
                    monitor.setTaskName(Strings.MSG_WAIT_FOR_SERVER);
                    con.connect();
                    in = con.getInputStream();
                    in.read();
                    monitor.worked(1);
                    monitor.setTaskName(NLS.bind(Strings.MSG_OPEN_URL, url));
                    open(url, resource.getProject(), pref);
                    monitor.worked(1);
                }
            } catch (ConnectException con) {
                if (count < 3) {
                    ConnectAndOpenJob job = new ConnectAndOpenJob(resource, pref, ++count);
                    job.schedule(1000L);
                } else {
                    Activator.log(con);
                }
            } catch (Exception e) {
                Activator.log(e);
            } finally {
                Streams.close(in);
                monitor.done();
            }
            return Status.OK_STATUS;
        }
} </s>
<s>class temp {    private String fetchHtml(URL url) throws IOException {
        URLConnection connection;
        if (StringUtils.isNotBlank(proxyHost) && proxyPort != null) {
            Proxy proxy = new Proxy(Proxy.Type.HTTP, InetSocketAddress.createUnresolved(proxyHost, proxyPort));
            connection = url.openConnection(proxy);
        } else {
            connection = url.openConnection();
        }
        Object content = connection.getContent();
        if (content instanceof InputStream) {
            return IOUtils.toString(InputStream.class.cast(content));
        } else {
            String msg = "Bad content type! " + content.getClass();
            log.error(msg);
            throw new IOException(msg);
        }
    }
} </s>
<s>class temp {    public static final String Digest(String credentials, String algorithm, String encoding) {
        try {
            MessageDigest md = (MessageDigest) MessageDigest.getInstance(algorithm).clone();
            if (encoding == null) {
                md.update(credentials.getBytes());
            } else {
                md.update(credentials.getBytes(encoding));
            }
            return (HexUtils.convert(md.digest()));
        } catch (Exception ex) {
            log.error(ex);
            return credentials;
        }
    }
} </s>
<s>class temp {    public DefaultMainControl(@NotNull final FileFilter scriptFileFilter, @NotNull final String scriptExtension, @NotNull final String scriptName, final int spellType, @Nullable final String spellFile, @NotNull final String scriptsDir, final ErrorView errorView, @NotNull final EditorFactory<G, A, R> editorFactory, final boolean forceReadFromFiles, @NotNull final GlobalSettings globalSettings, @NotNull final ConfigSourceFactory configSourceFactory, @NotNull final PathManager pathManager, @NotNull final GameObjectMatchers gameObjectMatchers, @NotNull final GameObjectFactory<G, A, R> gameObjectFactory, @NotNull final ArchetypeTypeSet archetypeTypeSet, @NotNull final ArchetypeSet<G, A, R> archetypeSet, @NotNull final ArchetypeChooserModel<G, A, R> archetypeChooserModel, @NotNull final AutojoinLists<G, A, R> autojoinLists, @NotNull final AbstractMapManager<G, A, R> mapManager, @NotNull final PluginModel<G, A, R> pluginModel, @NotNull final DelegatingMapValidator<G, A, R> validators, @NotNull final ScriptedEventEditor<G, A, R> scriptedEventEditor, @NotNull final AbstractResources<G, A, R> resources, @NotNull final Spells<NumberSpell> numberSpells, @NotNull final Spells<GameObjectSpell<G, A, R>> gameObjectSpells, @NotNull final PluginParameterFactory<G, A, R> pluginParameterFactory, @NotNull final ValidatorPreferences validatorPreferences, @NotNull final MapWriter<G, A, R> mapWriter) {
        final XmlHelper xmlHelper;
        try {
            xmlHelper = new XmlHelper();
        } catch (final ParserConfigurationException ex) {
            log.fatal("Cannot create XML parser: " + ex.getMessage());
            throw new MissingResourceException("Cannot create XML parser: " + ex.getMessage(), null, null);
        }
        final AttributeRangeChecker<G, A, R> attributeRangeChecker = new AttributeRangeChecker<G, A, R>(validatorPreferences);
        final EnvironmentChecker<G, A, R> environmentChecker = new EnvironmentChecker<G, A, R>(validatorPreferences);
        final DocumentBuilder documentBuilder = xmlHelper.getDocumentBuilder();
        try {
            final URL url = IOUtils.getResource(globalSettings.getConfigurationDirectory(), "GameObjectMatchers.xml");
            final ErrorViewCollector gameObjectMatchersErrorViewCollector = new ErrorViewCollector(errorView, url);
            try {
                documentBuilder.setErrorHandler(new ErrorViewCollectorErrorHandler(gameObjectMatchersErrorViewCollector, ErrorViewCategory.GAMEOBJECTMATCHERS_FILE_INVALID));
                try {
                    final GameObjectMatchersParser gameObjectMatchersParser = new GameObjectMatchersParser(documentBuilder, xmlHelper.getXPath());
                    gameObjectMatchersParser.readGameObjectMatchers(url, gameObjectMatchers, gameObjectMatchersErrorViewCollector);
                } finally {
                    documentBuilder.setErrorHandler(null);
                }
            } catch (final IOException ex) {
                gameObjectMatchersErrorViewCollector.addWarning(ErrorViewCategory.GAMEOBJECTMATCHERS_FILE_INVALID, ex.getMessage());
            }
            final ValidatorFactory<G, A, R> validatorFactory = new ValidatorFactory<G, A, R>(validatorPreferences, gameObjectMatchers, globalSettings, mapWriter);
            loadValidators(validators, validatorFactory, errorView);
            editorFactory.initMapValidators(validators, gameObjectMatchersErrorViewCollector, globalSettings, gameObjectMatchers, attributeRangeChecker, validatorPreferences);
            validators.addValidator(attributeRangeChecker);
            validators.addValidator(environmentChecker);
        } catch (final FileNotFoundException ex) {
            errorView.addWarning(ErrorViewCategory.GAMEOBJECTMATCHERS_FILE_INVALID, "GameObjectMatchers.xml: " + ex.getMessage());
        }
        final GameObjectMatcher shopSquareMatcher = gameObjectMatchers.getMatcher("system_shop_square", "shop_square");
        if (shopSquareMatcher != null) {
            final GameObjectMatcher noSpellsMatcher = gameObjectMatchers.getMatcher("system_no_spells", "no_spells");
            if (noSpellsMatcher != null) {
                final GameObjectMatcher blockedMatcher = gameObjectMatchers.getMatcher("system_blocked", "blocked");
                validators.addValidator(new ShopSquareChecker<G, A, R>(validatorPreferences, shopSquareMatcher, noSpellsMatcher, blockedMatcher));
            }
            final GameObjectMatcher paidItemMatcher = gameObjectMatchers.getMatcher("system_paid_item");
            if (paidItemMatcher != null) {
                validators.addValidator(new PaidItemShopSquareChecker<G, A, R>(validatorPreferences, shopSquareMatcher, paidItemMatcher));
            }
        }
        Map<String, TreasureTreeNode> specialTreasureLists;
        try {
            final URL url = IOUtils.getResource(globalSettings.getConfigurationDirectory(), "TreasureLists.xml");
            final ErrorViewCollector treasureListsErrorViewCollector = new ErrorViewCollector(errorView, url);
            try {
                final InputStream inputStream = url.openStream();
                try {
                    documentBuilder.setErrorHandler(new ErrorViewCollectorErrorHandler(treasureListsErrorViewCollector, ErrorViewCategory.TREASURES_FILE_INVALID));
                    try {
                        final Document specialTreasureListsDocument = documentBuilder.parse(new InputSource(inputStream));
                        specialTreasureLists = TreasureListsParser.parseTreasureLists(specialTreasureListsDocument);
                    } finally {
                        documentBuilder.setErrorHandler(null);
                    }
                } finally {
                    inputStream.close();
                }
            } catch (final IOException ex) {
                treasureListsErrorViewCollector.addWarning(ErrorViewCategory.TREASURES_FILE_INVALID, ex.getMessage());
                specialTreasureLists = Collections.emptyMap();
            } catch (final SAXException ex) {
                treasureListsErrorViewCollector.addWarning(ErrorViewCategory.TREASURES_FILE_INVALID, ex.getMessage());
                specialTreasureLists = Collections.emptyMap();
            }
        } catch (final FileNotFoundException ex) {
            errorView.addWarning(ErrorViewCategory.TREASURES_FILE_INVALID, "TreasureLists.xml: " + ex.getMessage());
            specialTreasureLists = Collections.emptyMap();
        }
        final ConfigSource configSource = forceReadFromFiles ? configSourceFactory.getFilesConfigSource() : configSourceFactory.getConfigSource(globalSettings.getConfigSourceName());
        treasureTree = TreasureLoader.parseTreasures(errorView, specialTreasureLists, configSource, globalSettings);
        final ArchetypeAttributeFactory archetypeAttributeFactory = new DefaultArchetypeAttributeFactory();
        final ArchetypeAttributeParser archetypeAttributeParser = new ArchetypeAttributeParser(archetypeAttributeFactory);
        final ArchetypeTypeParser archetypeTypeParser = new ArchetypeTypeParser(archetypeAttributeParser);
        ArchetypeTypeList eventTypeSet = null;
        try {
            final URL url = IOUtils.getResource(globalSettings.getConfigurationDirectory(), CommonConstants.TYPEDEF_FILE);
            final ErrorViewCollector typesErrorViewCollector = new ErrorViewCollector(errorView, url);
            documentBuilder.setErrorHandler(new ErrorViewCollectorErrorHandler(typesErrorViewCollector, ErrorViewCategory.GAMEOBJECTMATCHERS_FILE_INVALID));
            try {
                final ArchetypeTypeSetParser archetypeTypeSetParser = new ArchetypeTypeSetParser(documentBuilder, archetypeTypeSet, archetypeTypeParser);
                archetypeTypeSetParser.loadTypesFromXML(typesErrorViewCollector, new InputSource(url.toString()));
            } finally {
                documentBuilder.setErrorHandler(null);
            }
            final ArchetypeTypeList eventTypeSetTmp = archetypeTypeSet.getList("event");
            if (eventTypeSetTmp == null) {
                typesErrorViewCollector.addWarning(ErrorViewCategory.TYPES_ENTRY_INVALID, "list 'list_event' does not exist");
            } else {
                eventTypeSet = eventTypeSetTmp;
            }
        } catch (final FileNotFoundException ex) {
            errorView.addWarning(ErrorViewCategory.TYPES_FILE_INVALID, CommonConstants.TYPEDEF_FILE + ": " + ex.getMessage());
        }
        if (eventTypeSet == null) {
            eventTypeSet = new ArchetypeTypeList();
        }
        scriptArchUtils = editorFactory.newScriptArchUtils(eventTypeSet);
        final ScriptedEventFactory<G, A, R> scriptedEventFactory = editorFactory.newScriptedEventFactory(scriptArchUtils, gameObjectFactory, scriptedEventEditor, archetypeSet);
        scriptArchEditor = new DefaultScriptArchEditor<G, A, R>(scriptedEventFactory, scriptExtension, scriptName, scriptArchUtils, scriptFileFilter, globalSettings, mapManager, pathManager);
        scriptedEventEditor.setScriptArchEditor(scriptArchEditor);
        scriptArchData = editorFactory.newScriptArchData();
        scriptArchDataUtils = editorFactory.newScriptArchDataUtils(scriptArchUtils, scriptedEventFactory, scriptedEventEditor);
        final long timeStart = System.currentTimeMillis();
        if (log.isInfoEnabled()) {
            log.info("Start to load archetypes...");
        }
        configSource.read(globalSettings, resources, errorView);
        for (final R archetype : archetypeSet.getArchetypes()) {
            final CharSequence editorFolder = archetype.getEditorFolder();
            if (editorFolder != null && !editorFolder.equals(GameObject.EDITOR_FOLDER_INTERN)) {
                final String[] tmp = StringUtils.PATTERN_SLASH.split(editorFolder, 2);
                if (tmp.length == 2) {
                    final String panelName = tmp[0];
                    final String folderName = tmp[1];
                    archetypeChooserModel.addArchetype(panelName, folderName, archetype);
                }
            }
        }
        if (log.isInfoEnabled()) {
            log.info("Archetype loading took " + (double) (System.currentTimeMillis() - timeStart) / 1000.0 + " seconds.");
        }
        if (spellType != 0) {
            new ArchetypeSetSpellLoader<G, A, R>(gameObjectFactory).load(archetypeSet, spellType, gameObjectSpells);
            gameObjectSpells.sort();
        }
        if (spellFile != null) {
            try {
                final URL url = IOUtils.getResource(globalSettings.getConfigurationDirectory(), spellFile);
                final ErrorViewCollector errorViewCollector = new ErrorViewCollector(errorView, url);
                documentBuilder.setErrorHandler(new ErrorViewCollectorErrorHandler(errorViewCollector, ErrorViewCategory.SPELLS_FILE_INVALID));
                try {
                    XMLSpellLoader.load(errorViewCollector, url, xmlHelper.getDocumentBuilder(), numberSpells);
                } finally {
                    documentBuilder.setErrorHandler(null);
                }
            } catch (final FileNotFoundException ex) {
                errorView.addWarning(ErrorViewCategory.SPELLS_FILE_INVALID, spellFile + ": " + ex.getMessage());
            }
            numberSpells.sort();
        }
        final File scriptsFile = new File(globalSettings.getMapsDirectory(), scriptsDir);
        final PluginModelParser<G, A, R> pluginModelParser = new PluginModelParser<G, A, R>(pluginParameterFactory);
        new PluginModelLoader<G, A, R>(pluginModelParser).loadPlugins(errorView, scriptsFile, pluginModel);
        new AutojoinListsParser<G, A, R>(errorView, archetypeSet, autojoinLists).loadList(globalSettings.getConfigurationDirectory());
        ArchetypeTypeChecks.addChecks(archetypeTypeSet, attributeRangeChecker, environmentChecker);
    }
} </s>
<s>class temp {    public static String getDigest(String input) throws NoSuchAlgorithmException {
        MessageDigest md5 = MessageDigest.getInstance("MD5");
        md5.update(input.getBytes());
        byte[] outDigest = md5.digest();
        StringBuffer outBuf = new StringBuffer(33);
        for (int i = 0; i < outDigest.length; i++) {
            byte b = outDigest[i];
            int hi = (b >> 4) & 0x0f;
            outBuf.append(MD5Digest.hexTab[hi]);
            int lo = b & 0x0f;
            outBuf.append(MD5Digest.hexTab[lo]);
        }
        return outBuf.toString();
    }
} </s>
<s>class temp {    public static void s_copy(FileInputStream fis, FileOutputStream fos) throws Exception {
        FileChannel in = fis.getChannel();
        FileChannel out = fos.getChannel();
        in.transferTo(0, in.size(), out);
        if (in != null) in.close();
        if (out != null) out.close();
    }
} </s>
<s>class temp {    public void process(@NotNull Template tpl, @NotNull Document model, @NotNull String packageName, @NotNull String outFileName, Map<String, String> xsltParam, String artifact) throws ModelGenerationException {
        System.out.print("Processing with " + tpl);
        String destinationPath;
        switch(tpl.destination) {
            case target:
                if (tpl.path == null) {
                    destinationPath = where.buildDir + separatorChar + "generated-sources" + separatorChar + GENERATION_TARGET;
                } else {
                    destinationPath = where.buildDir;
                }
                break;
            case source:
                if (tpl.path == null) {
                    destinationPath = where.sourceDir;
                } else {
                    destinationPath = "src";
                }
                break;
            case redora:
                destinationPath = where.redoraDir;
                break;
            default:
                throw new IllegalArgumentException("Unused destination " + tpl.destination);
        }
        if (tpl.path == null) {
            if (tpl.destination == Destination.redora) destinationPath += separator + artifact; else destinationPath += separator + packageName.replace('.', separatorChar);
        } else {
            destinationPath += separator + tpl.path.replace('/', separatorChar).replace('\\', separatorChar);
        }
        System.out.println(" to " + destinationPath + "..." + outFileName);
        if (tpl.destination == Destination.source) {
            if (new File(destinationPath, outFileName).exists()) {
                System.out.println("Stub " + outFileName + " already exists.");
                return;
            }
        }
        new File(destinationPath).mkdirs();
        InputStream in = null;
        Writer out;
        try {
            out = new FileWriter(new File(destinationPath, outFileName));
        } catch (IOException e) {
            throw new ModelGenerationException("Can't find: " + destinationPath + separatorChar + outFileName, e);
        }
        switch(tpl.type) {
            case freemarker:
                Map<String, NodeModel> root = new HashMap<String, NodeModel>();
                root.put("doc", NodeModel.wrap(model));
                try {
                    freemarker.template.Template template = freemarkerConf.getTemplate(tpl.getTemplateFileName());
                    template.process(root, out);
                } catch (ParseException e) {
                    throw new ModelGenerationException("There is an error in template: " + tpl + ". I found it when generating " + outFileName, e);
                } catch (IOException e) {
                    throw new ModelGenerationException("Can't find '" + tpl + "' when generating " + outFileName, e);
                } catch (TemplateException e) {
                    throw new ModelGenerationException("There is an error in template: " + tpl + ". I found it when generating " + outFileName, e);
                } catch (RuntimeException e) {
                    throw new ModelGenerationException("There is another error while trying this template: " + tpl + ". I found it when generating " + outFileName, e);
                }
                break;
            case xslt:
                try {
                    in = new FileInputStream(tpl.getAbsolutePath());
                    xsltTransform(model.getFirstChild(), in, out, xsltParam);
                } catch (FileNotFoundException e) {
                    throw new ModelGenerationException("Can't find " + tpl, e);
                } catch (TransformerException e) {
                    throw new ModelGenerationException("Sorry, i failed to use this template: " + tpl + ". It broke when generating " + outFileName, e);
                } finally {
                    IOUtils.closeQuietly(in);
                }
                break;
            case copy:
                try {
                    in = new FileInputStream(tpl.getAbsolutePath());
                    IOUtils.copy(in, out);
                } catch (IOException e) {
                    throw new ModelGenerationException("File copy failed " + tpl.getTemplateFileName(), e);
                } finally {
                    IOUtils.closeQuietly(in);
                }
        }
        IOUtils.closeQuietly(out);
    }
} </s>
<s>class temp {    public void convert(File src, File dest) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(src));
        DcmParser p = pfact.newDcmParser(in);
        Dataset ds = fact.newDataset();
        p.setDcmHandler(ds.getDcmHandler());
        try {
            FileFormat format = p.detectFileFormat();
            if (format != FileFormat.ACRNEMA_STREAM) {
                System.out.println("\n" + src + ": not an ACRNEMA stream!");
                return;
            }
            p.parseDcmFile(format, Tags.PixelData);
            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {
                System.out.println("\n" + src + ": contains UIDs!" + " => probable already DICOM - do not convert");
                return;
            }
            boolean hasPixelData = p.getReadTag() == Tags.PixelData;
            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;
            int pxlen = p.getReadLength();
            if (hasPixelData) {
                if (inflate) {
                    ds.putUS(Tags.BitsAllocated, 16);
                    pxlen = pxlen * 4 / 3;
                }
                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {
                    System.out.println("\n" + src + ": mismatch pixel data length!" + " => do not convert");
                    return;
                }
            }
            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));
            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));
            ds.putUI(Tags.SOPInstanceUID, uid(instUID));
            ds.putUI(Tags.SOPClassUID, classUID);
            if (!ds.contains(Tags.NumberOfSamples)) {
                ds.putUS(Tags.NumberOfSamples, 1);
            }
            if (!ds.contains(Tags.PhotometricInterpretation)) {
                ds.putCS(Tags.PhotometricInterpretation, "MONOCHROME2");
            }
            if (fmi) {
                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));
            }
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
            try {
            } finally {
                ds.writeFile(out, encodeParam());
                if (hasPixelData) {
                    if (!skipGroupLen) {
                        out.write(PXDATA_GROUPLEN);
                        int grlen = pxlen + 8;
                        out.write((byte) grlen);
                        out.write((byte) (grlen >> 8));
                        out.write((byte) (grlen >> 16));
                        out.write((byte) (grlen >> 24));
                    }
                    out.write(PXDATA_TAG);
                    out.write((byte) pxlen);
                    out.write((byte) (pxlen >> 8));
                    out.write((byte) (pxlen >> 16));
                    out.write((byte) (pxlen >> 24));
                }
                if (inflate) {
                    int b2, b3;
                    for (; pxlen > 0; pxlen -= 3) {
                        out.write(in.read());
                        b2 = in.read();
                        b3 = in.read();
                        out.write(b2 & 0x0f);
                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));
                        out.write(b3 >> 4);
                    }
                } else {
                    for (; pxlen > 0; --pxlen) {
                        out.write(in.read());
                    }
                }
                out.close();
            }
            System.out.print('.');
        } finally {
            in.close();
        }
    }
} </s>
<s>class temp {    private void pack() {
        String szImageDir = m_szBasePath + "Images";
        File fImageDir = new File(szImageDir);
        fImageDir.mkdirs();
        String ljIcon = System.getProperty("user.home");
        ljIcon += System.getProperty("file.separator") + "MochaJournal" + System.getProperty("file.separator") + m_szUsername + System.getProperty("file.separator") + "Cache";
        File fUserDir = new File(ljIcon);
        File[] fIcons = fUserDir.listFiles();
        int iSize = fIcons.length;
        for (int i = 0; i < iSize; i++) {
            try {
                File fOutput = new File(fImageDir, fIcons[i].getName());
                if (!fOutput.exists()) {
                    fOutput.createNewFile();
                    FileOutputStream fOut = new FileOutputStream(fOutput);
                    FileInputStream fIn = new FileInputStream(fIcons[i]);
                    while (fIn.available() > 0) fOut.write(fIn.read());
                }
            } catch (IOException e) {
                System.err.println(e);
            }
        }
        try {
            FileOutputStream fOut;
            InputStream fLJIcon = getClass().getResourceAsStream("/org/homedns/krolain/MochaJournal/Images/userinfo.gif");
            File fLJOut = new File(fImageDir, "user.gif");
            if (!fLJOut.exists()) {
                fOut = new FileOutputStream(fLJOut);
                while (fLJIcon.available() > 0) fOut.write(fLJIcon.read());
            }
            fLJIcon = getClass().getResourceAsStream("/org/homedns/krolain/MochaJournal/Images/communitynfo.gif");
            fLJOut = new File(fImageDir, "comm.gif");
            if (!fLJOut.exists()) {
                fOut = new FileOutputStream(fLJOut);
                while (fLJIcon.available() > 0) fOut.write(fLJIcon.read());
            }
            fLJIcon = getClass().getResourceAsStream("/org/homedns/krolain/MochaJournal/Images/icon_private.gif");
            fLJOut = new File(fImageDir, "icon_private.gif");
            if (!fLJOut.exists()) {
                fOut = new FileOutputStream(fLJOut);
                while (fLJIcon.available() > 0) fOut.write(fLJIcon.read());
            }
            fLJIcon = getClass().getResourceAsStream("/org/homedns/krolain/MochaJournal/Images/icon_protected.gif");
            fLJOut = new File(fImageDir, "icon_protected.gif");
            if (!fLJOut.exists()) {
                fOut = new FileOutputStream(fLJOut);
                while (fLJIcon.available() > 0) fOut.write(fLJIcon.read());
            }
        } catch (IOException e) {
            System.err.println(e);
        }
    }
} </s>
<s>class temp {    public static File downloadFile(Proxy proxy, URL url, File path) throws IOException {
        URLConnection conn = null;
        if (null == proxy) {
            conn = url.openConnection();
        } else {
            conn = url.openConnection(proxy);
        }
        conn.connect();
        File destFile = null;
        if (conn instanceof HttpURLConnection) {
            HttpURLConnection hc = (HttpURLConnection) conn;
            String filename = null;
            String hv = hc.getHeaderField("Content-Disposition");
            if (null == hv) {
                String str = url.toString();
                int index = str.lastIndexOf("/");
                filename = str.substring(index + 1);
            } else {
                int index = hv.indexOf("filename=");
                filename = hv.substring(index).replace("\"", "").trim();
            }
            destFile = new File(path, filename);
        } else {
            destFile = new File(path, "downloadfile" + url.toString().hashCode());
        }
        if (destFile.exists()) {
            return destFile;
        }
        FileOutputStream fos = new FileOutputStream(destFile);
        byte[] buffer = new byte[2048];
        try {
            while (true) {
                int len = conn.getInputStream().read(buffer);
                if (len < 0) {
                    break;
                } else {
                    fos.write(buffer, 0, len);
                }
            }
            fos.close();
        } catch (IOException e) {
            destFile.delete();
            throw e;
        }
        return destFile;
    }
} </s>
<s>class temp {    @SuppressWarnings("unused")
    private GraphicalViewer createGraphicalViewer(Composite parent) {
        GraphicalViewer viewer = new ScrollingGraphicalViewer();
        viewer.createControl(parent);
        viewer.getControl().setBackground(parent.getBackground());
        viewer.setRootEditPart(new ScalableFreeformRootEditPart());
        viewer.setKeyHandler(new GraphicalViewerKeyHandler(viewer));
        getEditDomain().addViewer(viewer);
        getSite().setSelectionProvider(viewer);
        viewer.setEditPartFactory(getEditPartFactory());
        viewer.setContents(getContent());
        return viewer;
    }
} </s>
<s>class temp {    public static String generate(String username, String password) throws PersistenceException {
        String output = null;
        try {
            MessageDigest md = MessageDigest.getInstance("SHA-256");
            md.reset();
            md.update(username.getBytes());
            md.update(password.getBytes());
            byte[] rawhash = md.digest();
            output = byteToBase64(rawhash);
        } catch (Exception e) {
            throw new PersistenceException("error, could not generate password");
        }
        return output;
    }
} </s>
<s>class temp {    private static String getData(String myurl) throws Exception {
        URL url = new URL(myurl);
        uc = (HttpURLConnection) url.openConnection();
        if (login) {
            uc.setRequestProperty("Cookie", logincookie + ";" + xfsscookie);
        }
        br = new BufferedReader(new InputStreamReader(uc.getInputStream()));
        String temp = "", k = "";
        while ((temp = br.readLine()) != null) {
            k += temp;
        }
        br.close();
        return k;
    }
} </s>
<s>class temp {    private static void fileUpload() throws IOException {
        HttpClient httpclient = new DefaultHttpClient();
        HttpPost httppost = new HttpPost(postURL);
        file = new File("h:/UploadingdotcomUploaderPlugin.java");
        MultipartEntity mpEntity = new MultipartEntity(HttpMultipartMode.BROWSER_COMPATIBLE);
        ContentBody cbFile = new FileBody(file);
        mpEntity.addPart("upload_type", new StringBody("file"));
        mpEntity.addPart("sess_id", new StringBody(sessid));
        mpEntity.addPart("srv_tmp_url", new StringBody(servertmpurl));
        mpEntity.addPart("file_0", cbFile);
        mpEntity.addPart("submit_btn", new StringBody(" Upload!"));
        httppost.setEntity(mpEntity);
        System.out.println("executing request " + httppost.getRequestLine());
        System.out.println("Now uploading your file into enterupload.com");
        HttpResponse response = httpclient.execute(httppost);
        HttpEntity resEntity = response.getEntity();
        System.out.println(response.getStatusLine());
        if (resEntity != null) {
            uploadresponse = EntityUtils.toString(resEntity);
        }
        downloadid = parseResponse(uploadresponse, "<textarea name='fn'>", "<");
        httpclient.getConnectionManager().shutdown();
    }
} </s>
<s>class temp {    private GmailContact convertContactToGmailContact(Contact contact) throws GmailManagerException {
        boolean homePhone = false, homePhone2 = false, homeFax = false, homeMobile = false, homePager = false;
        boolean businessPhone = false, businessPhone2 = false, businessFax = false, businessMobile = false, businessPager = false;
        boolean otherPhone = false, otherFax = false;
        if (log.isTraceEnabled()) log.trace("Converting Foundation contact to Gmail contact: Name:" + contact.getName().getFirstName().getPropertyValueAsString());
        try {
            GmailContact gmailContact = new GmailContact();
            gmailContact.setId(contact.getUid());
            Name name = contact.getName();
            if (name != null) if (name.getFirstName() != null && name.getFirstName().getPropertyValueAsString() != null) {
                StringBuffer buffer = new StringBuffer();
                buffer.append(name.getFirstName().getPropertyValueAsString()).append(" ");
                if (name.getMiddleName() != null && name.getMiddleName().getPropertyValueAsString() != null) buffer.append(name.getMiddleName().getPropertyValueAsString()).append(" ");
                if (name.getLastName() != null && name.getLastName().getPropertyValueAsString() != null) buffer.append(name.getLastName().getPropertyValueAsString()).append(" ");
                if (log.isDebugEnabled()) log.debug("NAME: " + buffer.toString().trim());
                gmailContact.setName(buffer.toString().trim());
            }
            if (contact.getPersonalDetail() != null) {
                if (contact.getPersonalDetail().getEmails() != null && contact.getPersonalDetail().getEmails().size() > 0) {
                    if (contact.getPersonalDetail().getEmails().get(0) != null) {
                        Email email1 = (Email) contact.getPersonalDetail().getEmails().get(0);
                        if (email1.getPropertyValueAsString() != null && email1.getPropertyValueAsString().equals("") == false) {
                            if (log.isDebugEnabled()) log.debug("EMAIL1: " + email1.getPropertyValueAsString());
                            gmailContact.setEmail(email1.getPropertyValueAsString());
                        }
                    }
                    if (contact.getPersonalDetail().getEmails().size() > 1 && contact.getPersonalDetail().getEmails().get(1) != null) {
                        Email email2 = (Email) contact.getPersonalDetail().getEmails().get(1);
                        if (email2.getPropertyValueAsString() != null && email2.getPropertyValueAsString().equals("") == false) {
                            if (log.isDebugEnabled()) log.debug("EMAIL2: " + email2.getPropertyValueAsString());
                            gmailContact.setEmail2(email2.getPropertyValueAsString());
                        }
                    }
                }
                Address address = contact.getPersonalDetail().getAddress();
                if (address != null) if (address.getStreet() != null) if (address.getStreet().getPropertyValueAsString() != null) {
                    StringBuffer addressBuffer = new StringBuffer();
                    addressBuffer.append(address.getStreet().getPropertyValueAsString()).append(" ");
                    addressBuffer.append(address.getPostalCode().getPropertyValueAsString()).append(" ");
                    addressBuffer.append(address.getCity().getPropertyValueAsString()).append(" ");
                    addressBuffer.append(address.getState().getPropertyValueAsString()).append(" ");
                    addressBuffer.append(address.getCountry().getPropertyValueAsString());
                    if (log.isDebugEnabled()) log.debug("HOME_ADDRESS: " + addressBuffer.toString());
                    gmailContact.setHomeAddress(addressBuffer.toString());
                }
                Address addressOther = contact.getPersonalDetail().getOtherAddress();
                if (addressOther != null) if (addressOther.getStreet() != null) if (addressOther.getStreet().getPropertyValueAsString() != null) {
                    StringBuffer addressBuffer = new StringBuffer();
                    addressBuffer.append(addressOther.getStreet().getPropertyValueAsString()).append(" ");
                    addressBuffer.append(addressOther.getPostalCode().getPropertyValueAsString()).append(" ");
                    addressBuffer.append(addressOther.getCity().getPropertyValueAsString()).append(" ");
                    addressBuffer.append(addressOther.getState().getPropertyValueAsString()).append(" ");
                    addressBuffer.append(addressOther.getCountry().getPropertyValueAsString());
                    if (log.isDebugEnabled()) log.debug("OTHER_ADDRESS: " + addressBuffer.toString());
                    gmailContact.setOtherAddress(addressBuffer.toString());
                }
                if (contact.getPersonalDetail().getPhones() != null && contact.getPersonalDetail().getPhones().size() > 0) {
                    for (int i = 0; i < contact.getPersonalDetail().getPhones().size(); i++) {
                        Phone phone = (Phone) contact.getPersonalDetail().getPhones().get(i);
                        if (log.isDebugEnabled()) log.debug("PERSONAL_PHONE: " + phone.getPropertyValueAsString() + " type:" + phone.getPhoneType());
                        if (phone.getPhoneType().equals(SIFC.HOME_TELEPHONE_NUMBER) && homePhone == false) {
                            gmailContact.setHomePhone(phone.getPropertyValueAsString());
                            homePhone = true;
                        } else if (phone.getPhoneType().equals(SIFC.HOME2_TELEPHONE_NUMBER) && homePhone2 == false) {
                            gmailContact.setHomePhone2(phone.getPropertyValueAsString());
                            homePhone2 = true;
                        } else if (phone.getPhoneType().equals(SIFC.HOME_FAX_NUMBER) && homeFax == false) {
                            gmailContact.setHomeFax(phone.getPropertyValueAsString());
                            homeFax = true;
                        } else if ((phone.getPhoneType().equals(SIFC.MOBILE_TELEPHONE_NUMBER) || phone.getPhoneType().equals(SIFC.MOBILE_HOME_TELEPHONE_NUMBER)) && homeMobile == false) {
                            gmailContact.setMobilePhone(phone.getPropertyValueAsString());
                            homeMobile = true;
                        } else if (phone.getPhoneType().equals(SIFC.PAGER_NUMBER) && homePager == false) {
                            gmailContact.setPager(phone.getPropertyValueAsString());
                            homePager = true;
                        } else if (phone.getPhoneType().equals(SIFC.OTHER_TELEPHONE_NUMBER) && otherPhone == false) {
                            gmailContact.setOtherPhone(phone.getPropertyValueAsString());
                            otherPhone = true;
                        } else if (phone.getPhoneType().equals(SIFC.OTHER_FAX_NUMBER) && otherFax == false) {
                            gmailContact.setOtherFax(phone.getPropertyValueAsString());
                            otherFax = true;
                        } else {
                            if (log.isDebugEnabled()) log.debug("GOOGLE - Whoops - Personal Phones UNKNOWN TYPE:" + phone.getPhoneType() + " VALUE:" + phone.getPropertyValueAsString());
                        }
                    }
                }
            }
            if (contact.getBusinessDetail() != null) {
                if (contact.getBusinessDetail().getEmails() != null && contact.getBusinessDetail().getEmails().size() > 0) {
                    if (contact.getBusinessDetail().getEmails().get(0) != null) {
                        Email email3 = (Email) contact.getBusinessDetail().getEmails().get(0);
                        if (email3.getPropertyValueAsString() != null && email3.getPropertyValueAsString().equals("") == false) {
                            if (log.isDebugEnabled()) log.debug("EMAIL3: " + email3.getPropertyValueAsString());
                            gmailContact.setEmail3(email3.getPropertyValueAsString());
                        }
                    }
                }
                Address address = contact.getBusinessDetail().getAddress();
                if (address != null) if (address.getStreet() != null) if (address.getStreet().getPropertyValueAsString() != null) {
                    StringBuffer addressBuffer = new StringBuffer();
                    addressBuffer.append(address.getStreet().getPropertyValueAsString()).append(" ");
                    addressBuffer.append(address.getPostalCode().getPropertyValueAsString()).append(" ");
                    addressBuffer.append(address.getCity().getPropertyValueAsString()).append(" ");
                    addressBuffer.append(address.getState().getPropertyValueAsString()).append(" ");
                    addressBuffer.append(address.getCountry().getPropertyValueAsString());
                    if (log.isDebugEnabled()) log.debug("BUSINESS_ADDRESS: " + addressBuffer.toString());
                    gmailContact.setBusinessAddress(addressBuffer.toString());
                }
                if (contact.getBusinessDetail().getPhones() != null && contact.getBusinessDetail().getPhones().size() > 0) {
                    for (int i = 0; i < contact.getBusinessDetail().getPhones().size(); i++) {
                        Phone phone = (Phone) contact.getBusinessDetail().getPhones().get(i);
                        if (log.isDebugEnabled()) log.debug("BUSINESS_PHONE: " + phone.getPropertyValueAsString() + " type:" + phone.getPhoneType());
                        if (phone.getPhoneType().equals(SIFC.BUSINESS_TELEPHONE_NUMBER) && businessPhone == false) {
                            gmailContact.setBusinessPhone(phone.getPropertyValueAsString());
                            businessPhone = true;
                        } else if (phone.getPhoneType().equals(SIFC.BUSINESS2_TELEPHONE_NUMBER) && businessPhone2 == false) {
                            gmailContact.setBusinessPhone2(phone.getPropertyValueAsString());
                            businessPhone2 = true;
                        } else if (phone.getPhoneType().equals(SIFC.BUSINESS_FAX_NUMBER) && businessFax == false) {
                            gmailContact.setBusinessFax(phone.getPropertyValueAsString());
                            businessFax = true;
                        } else if (phone.getPhoneType().equals(SIFC.MOBILE_BUSINESS_TELEPHONE_NUMBER) && homeMobile == false && businessMobile == false) {
                            gmailContact.setMobilePhone(phone.getPropertyValueAsString());
                            businessMobile = true;
                        } else if (phone.getPhoneType().equals(SIFC.PAGER_NUMBER) && homePager == false && businessPager == false) {
                            gmailContact.setPager(phone.getPropertyValueAsString());
                            businessPager = true;
                        } else {
                            if (log.isDebugEnabled()) log.debug("GOOGLE - Whoops - Business Phones UNKNOWN TYPE:" + phone.getPhoneType() + " VALUE:" + phone.getPropertyValueAsString());
                        }
                    }
                }
                if (contact.getBusinessDetail().getCompany() != null) if (contact.getBusinessDetail().getCompany().getPropertyValueAsString() != null) {
                    if (log.isDebugEnabled()) log.debug("COMPANY: " + contact.getBusinessDetail().getCompany().getPropertyValueAsString());
                    gmailContact.setCompany(contact.getBusinessDetail().getCompany().getPropertyValueAsString());
                }
                if (contact.getBusinessDetail().getTitles() != null && contact.getBusinessDetail().getTitles().size() > 0) {
                    if (contact.getBusinessDetail().getTitles().get(0) != null) {
                        Title title = (Title) contact.getBusinessDetail().getTitles().get(0);
                        if (log.isDebugEnabled()) log.debug("TITLE: " + title.getPropertyValueAsString());
                        gmailContact.setJobTitle(title.getPropertyValueAsString());
                    }
                }
            }
            if (contact.getNotes() != null && contact.getNotes().size() > 0) {
                if (contact.getNotes().get(0) != null) {
                    Note notes = (Note) contact.getNotes().get(0);
                    if (notes.getPropertyValueAsString() != null && notes.getPropertyValueAsString().equals("") == false) {
                        if (log.isDebugEnabled()) log.debug("NOTES: " + notes.getPropertyValueAsString());
                        gmailContact.setNotes(notes.getPropertyValueAsString());
                    }
                }
            }
            MessageDigest m = MessageDigest.getInstance("MD5");
            m.update(contact.toString().getBytes());
            gmailContact.setMd5Hash(new BigInteger(m.digest()).toString());
            return gmailContact;
        } catch (Exception e) {
            throw new GmailManagerException("GOOGLE Gmail - convertContactToGmailContact error: " + e.getMessage());
        }
    }
} </s>
<s>class temp {    private static void readAndRewrite(File inFile, File outFile) throws IOException {
        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));
        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);
        Dataset ds = DcmObjectFactory.getInstance().newDataset();
        dcmParser.setDcmHandler(ds.getDcmHandler());
        dcmParser.parseDcmFile(null, Tags.PixelData);
        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        System.out.println("reading " + inFile + "...");
        pdReader.readPixelData(false);
        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));
        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;
        ds.writeDataset(out, dcmEncParam);
        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());
        System.out.println("writing " + outFile + "...");
        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        pdWriter.writePixelData();
        out.flush();
        out.close();
        System.out.println("done!");
    }
} </s>
<s>class temp {    private static void copy(String sourceName, String destName) throws IOException {
        File source = new File(sourceName);
        File dest = new File(destName);
        FileChannel in = null, out = null;
        try {
            in = new FileInputStream(source).getChannel();
            out = new FileOutputStream(dest).getChannel();
            long size = in.size();
            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);
            out.write(buf);
        } finally {
            if (in != null) in.close();
            if (out != null) out.close();
        }
    }
} </s>
<s>class temp {    public static boolean encodeFileToFile(String infile, String outfile) {
        boolean success = false;
        java.io.InputStream in = null;
        java.io.OutputStream out = null;
        try {
            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            byte[] buffer = new byte[65536];
            int read = -1;
            while ((read = in.read(buffer)) >= 0) {
                out.write(buffer, 0, read);
            }
            success = true;
        } catch (java.io.IOException exc) {
            exc.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (Exception exc) {
            }
            try {
                out.close();
            } catch (Exception exc) {
            }
        }
        return success;
    }
} </s>
<s>class temp {    public static boolean decodeFileToFile(String infile, String outfile) {
        boolean success = false;
        java.io.InputStream in = null;
        java.io.OutputStream out = null;
        try {
            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            byte[] buffer = new byte[65536];
            int read = -1;
            while ((read = in.read(buffer)) >= 0) {
                out.write(buffer, 0, read);
            }
            success = true;
        } catch (java.io.IOException exc) {
            exc.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (Exception exc) {
            }
            try {
                out.close();
            } catch (Exception exc) {
            }
        }
        return success;
    }
} </s>
<s>class temp {    public NodeId generateTopicId(String topicName) {
        MessageDigest md = null;
        try {
            md = MessageDigest.getInstance("SHA");
        } catch (NoSuchAlgorithmException e) {
            System.err.println("No SHA support!");
        }
        md.update(topicName.getBytes());
        byte[] digest = md.digest();
        NodeId newId = new NodeId(digest);
        return newId;
    }
} </s>
<s>class temp {    public Source get_source(String pageURL, Boolean checkInBase) {
        URL url;
        URLConnection conn;
        Reader inReader;
        Source source = null;
        String LastModified = "";
        Boolean updateData = false;
        try {
            url = new URL(pageURL);
            conn = url.openConnection();
            conn.setRequestProperty("Accept-Charset", "windows-1251");
            if (checkInBase) {
                for (int i = 0; ; i++) {
                    String name = conn.getHeaderFieldKey(i);
                    String value = conn.getHeaderField(i);
                    if (name == null && value == null) {
                        break;
                    }
                    if ("Last-Modified".equals(name)) {
                        LastModified = value;
                    }
                }
                Ini.rs = Ini.stmt.executeQuery("select count(1) as qwe from " + " PUBLIC.PAGES " + "where url = '" + pageURL + "';");
                Ini.rs.next();
                if (Ini.rs.getInt("qwe") == 0) {
                    Ini.stmt.executeUpdate("insert into PUBLIC.PAGES(url, lastUpdateDate) " + " values('" + pageURL + "', " + "'" + LastModified + "'" + ");");
                } else {
                    Ini.rs = Ini.stmt.executeQuery("select lastUpdateDate from " + " PUBLIC.PAGES " + "where url = '" + pageURL + "';");
                    Ini.rs.next();
                    if (!Ini.rs.getString("lastUpdateDate").equals(LastModified)) {
                        updateData = true;
                    } else {
                        return null;
                    }
                }
            }
            inReader = new InputStreamReader(conn.getInputStream(), "windows-1251");
            source = new Source(inReader);
            source.setLogger(null);
            source.fullSequentialParse();
            if (updateData) {
                Ini.stmt.executeUpdate("delete from PUBLIC.LINKDATA " + "where id in (" + "select id from PUBLIC.PAGES " + "where url = '" + pageURL + "'" + ")");
                Ini.stmt.executeUpdate("delete from PUBLIC.PAGES " + "where url = '" + pageURL + "';");
                Ini.stmt.executeUpdate("insert into PUBLIC.PAGES " + " values('" + pageURL + "', " + "'" + LastModified + "'" + ");");
            }
        } catch (Exception ex) {
            Ini.logger.fatal("Error: ", ex);
        }
        return source;
    }
} </s>
<s>class temp {    void bubbleSort(int ids[]) {
        boolean flag = true;
        int temp;
        while (flag) {
            flag = false;
            for (int i = 0; i < ids.length - 1; i++) if (ids[i] < ids[i + 1]) {
                temp = ids[i];
                ids[i] = ids[i + 1];
                ids[i + 1] = temp;
                flag = true;
            }
        }
    }
} </s>
<s>class temp {    private void makeQuery(String query) {
        System.out.println(" Querying for " + query);
        try {
            query = URLEncoder.encode(query, "UTF-8");
            for (int k = 0; k < 100; k++) {
                System.out.println(query);
                URL url = new URL("http://ajax.googleapis.com/ajax/services/search/web?start=" + k * 8 + "&rsz=large&v=1.0&q=" + query);
                URLConnection connection = url.openConnection();
                connection.addRequestProperty("Referer", HTTP_REFERER);
                String line;
                StringBuilder builder = new StringBuilder();
                BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                while ((line = reader.readLine()) != null) {
                    builder.append(line);
                }
                String response = builder.toString();
                JSONObject json = new JSONObject(response);
                if (k == 0) {
                    result = "Total results = " + json.getJSONObject("responseData").getJSONObject("cursor").getString("estimatedResultCount") + "\n";
                }
                JSONArray ja = json.getJSONObject("responseData").getJSONArray("results");
                jsonres = ja;
                for (int i = 0; i < ja.length(); i++) {
                    System.out.print((i + 1) + ". ");
                    JSONObject j = ja.getJSONObject(i);
                    result = result + j.getString("titleNoFormatting") + " ";
                    result = result + j.getString("url") + "\n";
                    result = result + j.getString("content") + "\n\n";
                }
            }
        } catch (Exception e) {
            System.err.println("Something went wrong...");
            e.printStackTrace();
        }
    }
} </s>
<s>class temp {    public static void copyFile(IPath fromFileName, IPath toFileName) throws IOException {
        File fromFile = fromFileName.toFile();
        File toFile = toFileName.toFile();
        if (!fromFile.exists()) throw new IOException("FileCopy: " + "no such source file: " + fromFileName);
        if (!fromFile.isFile()) throw new IOException("FileCopy: " + "can't copy directory: " + fromFileName);
        if (!fromFile.canRead()) throw new IOException("FileCopy: " + "source file is unreadable: " + fromFileName);
        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());
        if (toFile.exists()) {
            if (!toFile.canWrite()) throw new IOException("FileCopy: " + "destination file is unwriteable: " + toFileName);
        } else {
            String parent = toFile.getParent();
            if (parent == null) parent = System.getProperty("user.dir");
            File dir = new File(parent);
            if (!dir.exists()) throw new IOException("FileCopy: " + "destination directory doesn't exist: " + parent);
            if (dir.isFile()) throw new IOException("FileCopy: " + "destination is not a directory: " + parent);
            if (!dir.canWrite()) throw new IOException("FileCopy: " + "destination directory is unwriteable: " + parent);
        }
        InputStream from = null;
        OutputStream to = null;
        try {
            from = new BufferedInputStream(new FileInputStream(fromFile));
            to = new BufferedOutputStream(new FileOutputStream(toFile));
            byte[] buffer = new byte[4096];
            int bytesRead;
            while ((bytesRead = from.read(buffer)) != -1) to.write(buffer, 0, bytesRead);
        } finally {
            if (from != null) try {
                from.close();
            } catch (IOException e) {
            }
            if (to != null) try {
                to.close();
            } catch (IOException e) {
            }
        }
    }
} </s>
<s>class temp {    private void getRdfResponse(StringBuilder sb, String url) {
        try {
            String inputLine = null;
            BufferedReader reader = new BufferedReader(new InputStreamReader(new URL(url).openStream()));
            while ((inputLine = reader.readLine()) != null) {
                sb.append(inputLine);
            }
            reader.close();
        } catch (MalformedURLException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
} </s>
<s>class temp {    private synchronized void createFTPConnection() throws RemoteClientException {
        ftpClient = new FTPClient();
        try {
            URL url = fileset.getHostURL();
            PasswordAuthentication passwordAuthentication = fileset.getPasswordAuthentication();
            if (null == passwordAuthentication) {
                passwordAuthentication = anonPassAuth;
            }
            InetAddress inetAddress = InetAddress.getByName(url.getHost());
            if (url.getPort() == -1) {
                ftpClient.connect(inetAddress);
            } else {
                ftpClient.connect(inetAddress, url.getPort());
            }
            if (!FTPReply.isPositiveCompletion(ftpClient.getReplyCode())) {
                throw new FTPBrowseException(ftpClient.getReplyString());
            }
            ftpClient.login(passwordAuthentication.getUserName(), new StringBuffer().append(passwordAuthentication.getPassword()).toString());
            if (url.getPath().length() > 0) {
                ftpClient.changeWorkingDirectory(url.getPath());
            }
        } catch (UnknownHostException e) {
            throw new RemoteClientException("Host not found.", e);
        } catch (SocketException e) {
            throw new RemoteClientException("Socket cannot be opened.", e);
        } catch (IOException e) {
            throw new RemoteClientException("Socket cannot be opened.", e);
        }
    }
} </s>
<s>class temp {    private void RotaDraw(GeoPoint orig, GeoPoint dest, int color, MapView mapa) {
        StringBuilder urlString = new StringBuilder();
        urlString.append("http://maps.google.com/maps?f=d&hl=en");
        urlString.append("&saddr=");
        urlString.append(Double.toString((double) orig.getLatitudeE6() / 1.0E6));
        urlString.append(",");
        urlString.append(Double.toString((double) orig.getLongitudeE6() / 1.0E6));
        urlString.append("&daddr=");
        urlString.append(Double.toString((double) dest.getLatitudeE6() / 1.0E6));
        urlString.append(",");
        urlString.append(Double.toString((double) dest.getLongitudeE6() / 1.0E6));
        urlString.append("&ie=UTF8&0&om=0&output=kml");
        Document doc = null;
        HttpURLConnection urlConnection = null;
        URL url = null;
        try {
            url = new URL(urlString.toString());
            urlConnection = (HttpURLConnection) url.openConnection();
            urlConnection.setRequestMethod("GET");
            urlConnection.setDoOutput(true);
            urlConnection.setDoInput(true);
            urlConnection.connect();
            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
            DocumentBuilder db = dbf.newDocumentBuilder();
            doc = db.parse(urlConnection.getInputStream());
            if (doc.getElementsByTagName("GeometryCollection").getLength() > 0) {
                String path = doc.getElementsByTagName("GeometryCollection").item(0).getFirstChild().getFirstChild().getFirstChild().getNodeValue();
                Log.d("xxx", "path=" + path);
                String[] pairs = path.split(" ");
                String[] lngLat = pairs[0].split(",");
                GeoPoint startGP = new GeoPoint((int) (Double.parseDouble(lngLat[1]) * 1E6), (int) (Double.parseDouble(lngLat[0]) * 1E6));
                mapa.getOverlays().add(new CamadaGS(startGP, startGP, 1));
                GeoPoint gp1;
                GeoPoint gp2 = startGP;
                for (int i = 1; i < pairs.length; i++) {
                    lngLat = pairs[i].split(",");
                    gp1 = gp2;
                    gp2 = new GeoPoint((int) (Double.parseDouble(lngLat[1]) * 1E6), (int) (Double.parseDouble(lngLat[0]) * 1E6));
                    mapa.getOverlays().add(new CamadaGS(gp1, gp2, 2, color));
                    Log.d("xxx", "pair:" + pairs[i]);
                }
                mapa.getOverlays().add(new CamadaGS(dest, dest, 3));
            }
        } catch (MalformedURLException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ParserConfigurationException e) {
            e.printStackTrace();
        } catch (SAXException e) {
            e.printStackTrace();
        }
    }
} </s>
<s>class temp {    public static String readUrlText(String urlString) throws IOException {
        URL url = new URL(urlString);
        InputStream stream = url.openStream();
        StringBuilder buf = new StringBuilder();
        BufferedReader in = null;
        try {
            in = new BufferedReader(new InputStreamReader(stream));
            String str;
            while ((str = in.readLine()) != null) {
                buf.append(str);
                buf.append(System.getProperty("line.separator"));
            }
        } catch (IOException e) {
            System.out.println("Error reading text from URL [" + url + "]: " + e.toString());
            throw e;
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException e) {
                    System.out.println("Error closing after reading text from URL [" + url + "]: " + e.toString());
                }
            }
        }
        return buf.toString();
    }
} </s>
<s>class temp {    public static String md5(String password) {
        try {
            MessageDigest md5 = MessageDigest.getInstance("MD5");
            md5.update(password.getBytes());
            BigInteger hash = new BigInteger(1, md5.digest());
            return hash.toString(16);
        } catch (NoSuchAlgorithmException ex) {
            return password;
        }
    }
} </s>
<s>class temp {    public static void copyFile(File source, File destination) {
        if (!source.exists()) {
            return;
        }
        if ((destination.getParentFile() != null) && (!destination.getParentFile().exists())) {
            destination.getParentFile().mkdirs();
        }
        try {
            FileChannel srcChannel = new FileInputStream(source).getChannel();
            FileChannel dstChannel = new FileOutputStream(destination).getChannel();
            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());
            srcChannel.close();
            dstChannel.close();
        } catch (IOException ioe) {
            ioe.printStackTrace();
        }
    }
} </s>

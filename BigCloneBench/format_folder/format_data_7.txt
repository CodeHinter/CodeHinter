<s>class temp {    public static boolean canWeConnectToInternet() {
        String s = "http://www.google.com/";
        URL url = null;
        boolean can = false;
        URLConnection conection = null;
        try {
            url = new URL(s);
        } catch (MalformedURLException e) {
            System.out.println("This should never happend. Error in URL name. URL specified was:" + s + ".");
        }
        try {
            conection = url.openConnection();
            conection.connect();
            can = true;
        } catch (IOException e) {
            can = false;
        }
        if (can) {
        }
        return can;
    }
} </s>
<s>class temp {    public static void copyFile(File in, File out) throws IOException {
        FileChannel inChannel = new FileInputStream(in).getChannel();
        FileChannel outChannel = new FileOutputStream(out).getChannel();
        try {
            int maxCount = 67076096;
            long size = inChannel.size();
            long position = 0;
            while (position < size) {
                position += inChannel.transferTo(position, maxCount, outChannel);
            }
        } catch (IOException e) {
            throw e;
        } finally {
            if (inChannel != null) {
                inChannel.close();
            }
            if (outChannel != null) {
                outChannel.close();
            }
        }
    }
} </s>
<s>class temp {    public String getMediaURL(String strLink) {
        try {
            String res = de.nomule.mediaproviders.KeepVid.getAnswer(strLink, "aa");
            if (NoMuleRuntime.DEBUG) System.out.println(res);
            String regexp = "http:\\/\\/[^\"]+\\/get_video[^\"]+";
            Pattern p = Pattern.compile(regexp);
            Matcher m = p.matcher(res);
            m.find();
            String strRetUrl = res.substring(m.start(), m.end());
            strRetUrl = URLDecoder.decode(strRetUrl, "UTF-8");
            if (TRY_HIGH_QUALITY) {
                NoMuleRuntime.showDebug("HIGH_QUALITY");
                strRetUrl += "&fmt=18";
                try {
                    URL url = new URL(strRetUrl);
                    URLConnection conn = url.openConnection();
                    InputStream in = conn.getInputStream();
                    in.close();
                } catch (MalformedURLException e) {
                    e.printStackTrace();
                } catch (IOException e) {
                    strRetUrl = strRetUrl.substring(0, strRetUrl.length() - 7);
                }
            }
            if (NoMuleRuntime.DEBUG) System.out.println(strRetUrl);
            return strRetUrl;
        } catch (UnsupportedEncodingException e) {
            System.out.println("Error in Youtube Media Provider. Encoding is not supported. (How would that happen?!)");
            e.printStackTrace();
        }
        return "";
    }
} </s>
<s>class temp {    void addDataFromURL(URL theurl) {
        String line;
        InputStream in = null;
        try {
            in = theurl.openStream();
            BufferedReader data = new BufferedReader(new InputStreamReader(in));
            while ((line = data.readLine()) != null) {
                thetext.append(line + "\n");
            }
        } catch (Exception e) {
            System.out.println(e.toString());
            thetext.append(theurl.toString());
        }
        try {
            in.close();
        } catch (Exception e) {
        }
    }
} </s>
<s>class temp {    private static void loadDefaultSettings(final String configFileName) {
        InputStream in = null;
        OutputStream out = null;
        try {
            in = Thread.currentThread().getContextClassLoader().getResourceAsStream(META_INF_DEFAULT_CONFIG_PROPERTIES);
            out = new FileOutputStream(configFileName);
            IOUtils.copy(in, out);
        } catch (final Exception e) {
            log.warn("Unable to pull out the default.", e);
            throw new RuntimeException(e);
        } finally {
            IOUtils.closeQuietly(in);
            IOUtils.closeQuietly(out);
        }
    }
} </s>
<s>class temp {    public boolean copy(File fromFile) throws IOException {
        FileUtility toFile = this;
        if (!fromFile.exists()) {
            abort("FileUtility: no such source file: " + fromFile.getAbsolutePath());
            return false;
        }
        if (!fromFile.isFile()) {
            abort("FileUtility: can't copy directory: " + fromFile.getAbsolutePath());
            return false;
        }
        if (!fromFile.canRead()) {
            abort("FileUtility: source file is unreadable: " + fromFile.getAbsolutePath());
            return false;
        }
        if (this.isDirectory()) toFile = (FileUtility) (new File(this, fromFile.getName()));
        if (toFile.exists()) {
            if (!toFile.canWrite()) {
                abort("FileUtility: destination file is unwriteable: " + pathName);
                return false;
            }
        } else {
            String parent = toFile.getParent();
            File dir = new File(parent);
            if (!dir.exists()) {
                abort("FileUtility: destination directory doesn't exist: " + parent);
                return false;
            }
            if (dir.isFile()) {
                abort("FileUtility: destination is not a directory: " + parent);
                return false;
            }
            if (!dir.canWrite()) {
                abort("FileUtility: destination directory is unwriteable: " + parent);
                return false;
            }
        }
        FileInputStream from = null;
        FileOutputStream to = null;
        try {
            from = new FileInputStream(fromFile);
            to = new FileOutputStream(toFile);
            byte[] buffer = new byte[4096];
            int bytes_read;
            while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read);
        } finally {
            if (from != null) try {
                from.close();
            } catch (IOException e) {
                ;
            }
            if (to != null) try {
                to.close();
            } catch (IOException e) {
                ;
            }
        }
        return true;
    }
} </s>
<s>class temp {    public void generate(FileObject outputDirectory, FileObject generatedOutputDirectory, List<Library> libraryModels, String tapdocXml) throws FileSystemException {
        if (!outputDirectory.exists()) {
            outputDirectory.createFolder();
        }
        ZipUtils.extractZip(new ClasspathResource(classResolver, "/com/erinors/tapestry/tapdoc/standalone/resources.zip"), outputDirectory);
        for (Library library : libraryModels) {
            String libraryName = library.getName();
            String libraryLocation = library.getLocation();
            outputDirectory.resolveFile(fileNameGenerator.getLibraryDirectory(libraryLocation)).createFolder();
            try {
                {
                    String result = XsltUtils.xsltTransform(tapdocXml, getClass().getResourceAsStream("Library.xsl"), "libraryName", libraryName);
                    FileObject index = outputDirectory.resolveFile(fileNameGenerator.getLibraryDirectory(libraryLocation)).resolveFile("index.html");
                    Writer out = new OutputStreamWriter(index.getContent().getOutputStream(), "UTF-8");
                    out.write(result);
                    out.close();
                }
                {
                    String result = XsltUtils.xsltTransform(tapdocXml, getClass().getResourceAsStream("ComponentIndex.xsl"), "libraryName", libraryName);
                    FileObject index = outputDirectory.resolveFile(fileNameGenerator.getLibraryDirectory(libraryLocation)).resolveFile("components.html");
                    Writer out = new OutputStreamWriter(index.getContent().getOutputStream(), "UTF-8");
                    out.write(result);
                    out.close();
                }
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
            for (Component component : library.getComponents()) {
                String componentName = component.getName();
                System.out.println("Generating " + libraryName + ":" + componentName + "...");
                Map<String, String> parameters = new HashMap<String, String>();
                parameters.put("libraryName", libraryName);
                parameters.put("componentName", componentName);
                String result = XsltUtils.xsltTransform(tapdocXml, getClass().getResourceAsStream("Component.xsl"), parameters);
                Writer out = null;
                try {
                    FileObject index = outputDirectory.resolveFile(fileNameGenerator.getComponentIndexFile(libraryLocation, componentName, true));
                    out = new OutputStreamWriter(index.getContent().getOutputStream(), "UTF-8");
                    out.write(result);
                    out.close();
                    Resource specificationLocation = component.getSpecificationLocation();
                    if (specificationLocation.getRelativeResource(componentName + "_tapdoc/resource").getResourceURL() != null) {
                        File srcResourcesDirectory = new File(specificationLocation.getRelativeResource(componentName + "_tapdoc/resource").getResourceURL().toURI());
                        FileObject dstResourcesFileObject = outputDirectory.resolveFile(fileNameGenerator.getComponentDirectory(libraryLocation, componentName)).resolveFile("resource");
                        if (srcResourcesDirectory.exists() && srcResourcesDirectory.isDirectory()) {
                            File[] files = srcResourcesDirectory.listFiles();
                            if (files != null) {
                                for (File resource : files) {
                                    if (resource.isFile() && !resource.isHidden()) {
                                        FileObject resourceFileObject = dstResourcesFileObject.resolveFile(resource.getName());
                                        resourceFileObject.createFile();
                                        InputStream inResource = null;
                                        OutputStream outResource = null;
                                        try {
                                            inResource = new FileInputStream(resource);
                                            outResource = resourceFileObject.getContent().getOutputStream();
                                            IOUtils.copy(inResource, outResource);
                                        } finally {
                                            IOUtils.closeQuietly(inResource);
                                            IOUtils.closeQuietly(outResource);
                                        }
                                    }
                                }
                            }
                        }
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                } finally {
                    if (out != null) {
                        try {
                            out.close();
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }
        }
        {
            Writer out = null;
            try {
                {
                    String result = XsltUtils.xsltTransform(tapdocXml, getClass().getResourceAsStream("LibraryIndex.xsl"));
                    FileObject index = outputDirectory.resolveFile("libraries.html");
                    out = new OutputStreamWriter(index.getContent().getOutputStream(), "UTF-8");
                    out.write(result);
                    out.close();
                }
                {
                    String result = XsltUtils.xsltTransform(tapdocXml, getClass().getResourceAsStream("Overview.xsl"));
                    FileObject index = outputDirectory.resolveFile("overview.html");
                    out = new OutputStreamWriter(index.getContent().getOutputStream(), "UTF-8");
                    out.write(result);
                    out.close();
                }
                {
                    String result = XsltUtils.xsltTransform(tapdocXml, getClass().getResourceAsStream("AllComponents.xsl"));
                    FileObject index = outputDirectory.resolveFile("allcomponents.html");
                    out = new OutputStreamWriter(index.getContent().getOutputStream(), "UTF-8");
                    out.write(result);
                    out.close();
                }
            } catch (Exception e) {
                throw new RuntimeException(e);
            } finally {
                IOUtils.closeQuietly(out);
            }
        }
    }
} </s>
<s>class temp {    private void moveFile(File orig, File target) throws IOException {
        byte buffer[] = new byte[1000];
        int bread = 0;
        FileInputStream fis = new FileInputStream(orig);
        FileOutputStream fos = new FileOutputStream(target);
        while (bread != -1) {
            bread = fis.read(buffer);
            if (bread != -1) fos.write(buffer, 0, bread);
        }
        fis.close();
        fos.close();
        orig.delete();
    }
} </s>
<s>class temp {    private void loadHtmlHeader() {
        String skinUrl = getClass().getResource("/" + Properties.defaultSkinFileName).toString();
        if (Properties.headerSkin != null && !Properties.headerSkin.equals("")) {
            try {
                URL url = new URL(Properties.headerSkin);
                if (url.getProtocol().equalsIgnoreCase("http")) {
                    isHttpUrl = true;
                    HttpURLConnection.setFollowRedirects(false);
                    HttpURLConnection httpConn = (HttpURLConnection) url.openConnection();
                    httpConn.setRequestMethod("HEAD");
                    boolean urlExists = (httpConn.getResponseCode() == HttpURLConnection.HTTP_OK);
                    if (urlExists) skinUrl = Properties.headerSkin;
                } else if (url.getProtocol().equalsIgnoreCase("jar")) {
                    String jarFile = Properties.headerSkin.substring(9).split("!")[0];
                    File skinFile = new File(jarFile);
                    if (skinFile.exists() && skinFile.canRead()) skinUrl = Properties.headerSkin;
                } else if (url.getProtocol().equalsIgnoreCase("file")) {
                    File skinFile = new File(Properties.headerSkin.substring(5));
                    if (skinFile.exists() && skinFile.canRead()) skinUrl = Properties.headerSkin;
                } else {
                    File skinFile = new File(Properties.headerSkin);
                    if (skinFile.exists() && skinFile.canRead()) skinUrl = Properties.headerSkin;
                }
            } catch (Exception ex) {
                XohmLogger.debugPrintln("Header skin url not valid. " + ex.getMessage());
                XohmLogger.debugPrintln("Loading the default skin.");
                ex.printStackTrace();
            }
        }
        XohmLogger.debugPrintln("Header skin file = " + skinUrl);
        try {
            LocalHtmlRendererContext rendererContext = new LocalHtmlRendererContext(htmlHeaderPanel, new SimpleUserAgentContext());
            rendererContext.navigate(skinUrl);
            headerLoaded = true;
        } catch (IOException urlEx) {
            XohmLogger.debugPrintln("Exception occured while loading the skin. " + urlEx.getMessage());
        }
    }
} </s>
<s>class temp {    private void outputSignedOpenDocument(byte[] signatureData) throws IOException {
        LOG.debug("output signed open document");
        OutputStream signedOdfOutputStream = getSignedOpenDocumentOutputStream();
        if (null == signedOdfOutputStream) {
            throw new NullPointerException("signedOpenDocumentOutputStream is null");
        }
        ZipOutputStream zipOutputStream = new ZipOutputStream(signedOdfOutputStream);
        ZipInputStream zipInputStream = new ZipInputStream(this.getOpenDocumentURL().openStream());
        ZipEntry zipEntry;
        while (null != (zipEntry = zipInputStream.getNextEntry())) {
            if (!zipEntry.getName().equals(ODFUtil.SIGNATURE_FILE)) {
                zipOutputStream.putNextEntry(zipEntry);
                IOUtils.copy(zipInputStream, zipOutputStream);
            }
        }
        zipInputStream.close();
        zipEntry = new ZipEntry(ODFUtil.SIGNATURE_FILE);
        zipOutputStream.putNextEntry(zipEntry);
        IOUtils.write(signatureData, zipOutputStream);
        zipOutputStream.close();
    }
} </s>
<s>class temp {    public InputLattice(String file, int type, boolean convertJoinMeet) throws FileNotFoundException, IOException {
        InputStream latStream = null;
        labels = new Vector();
        upperCoversVector = new Vector();
        Vector upperCovers = new Vector();
        edgeColors = new Hashtable();
        Vector upperCovering = new Vector();
        int level = 0;
        String str;
        String currentElt = null;
        String cover = null;
        boolean first = true;
        StreamTokenizer in;
        switch(type) {
            case FILE:
                latStream = new FileInputStream(file);
                break;
            case STRING:
                latStream = new StringBufferInputStream(file);
                break;
            case URL:
                URL url = new URL("http", Config.HOST, Config.PORT, "/" + Config.HASSE + "/" + Config.URL_STREAMER + file);
                System.out.println("url is " + url);
                URLConnection connection = url.openConnection();
                latStream = new DataInputStream(connection.getInputStream());
                break;
        }
        in = new StreamTokenizer(latStream);
        in.wordChars('^', '_');
        in.wordChars('*', '.');
        while (in.nextToken() != StreamTokenizer.TT_EOF) {
            if (in.ttype == StreamTokenizer.TT_WORD || in.ttype == StreamTokenizer.TT_NUMBER || in.ttype == '"') {
                if (in.ttype == StreamTokenizer.TT_NUMBER) {
                    str = "" + Math.round(in.nval);
                } else {
                    str = in.sval;
                }
                if (convertJoinMeet && level > 1) {
                    str = stringSubstitute(str, joinStr, joinSign);
                    str = stringSubstitute(str, meetStr, meetSign);
                }
                if (level == 1) {
                    name = new String(str);
                }
                if (level == 2) {
                    labels.addElement(str);
                    currentElt = str;
                }
                if (level == 3) {
                    upperCovers.addElement(str);
                }
                if (level == 4) {
                    if (first) {
                        upperCovers.addElement(str);
                        cover = str;
                        first = false;
                    } else {
                        edgeColors.put(new Edge(currentElt, cover), str);
                    }
                }
            }
            if (in.ttype == '(') {
                level++;
                if (level == 3) upperCovers = new Vector();
            }
            if (in.ttype == ')') {
                level--;
                if (level == 3) first = true;
                if (level == 2) upperCoversVector.addElement(upperCovers);
                if (level == 0) {
                    if (latStream != null) latStream.close();
                    return;
                }
            }
        }
    }
} </s>
<s>class temp {        public void mouseClicked(MouseEvent e) {
            String userNameString;
            String passwordString;
            String md5String = "";
            MessageDigest md;
            userNameString = userNameJTextField.getText();
            passwordString = passwordJTextField.getText();
            try {
                md = MessageDigest.getInstance("MD5");
                md.update(passwordString.getBytes());
                md5String = new String(md.digest());
                md5String = Base64.encode(md5String.getBytes());
                System.out.println(md5String);
            } catch (NoSuchAlgorithmException e1) {
                e1.printStackTrace();
                System.out.println("ʧ  ");
            }
            if (userNameString.equals("zouwulingde") && md5String.equals("aKdtP09kSTkWCD/cylk=")) {
                JOptionPane.showMessageDialog(null, "  ӭʹ  ѧ   ڹ   ϵͳ  ");
            } else {
                JOptionPane.showMessageDialog(null, " û       벻  ȷ!!!!");
            }
        }
} </s>
<s>class temp {    public static String encrypt(String password) throws NoSuchAlgorithmException {
        java.security.MessageDigest d = null;
        d = java.security.MessageDigest.getInstance("MD5");
        d.reset();
        d.update(password.getBytes());
        byte[] cr = d.digest();
        return getString(cr).toLowerCase();
    }
} </s>
<s>class temp {    @Override
    public boolean setupDatabaseSchema() {
        Configuration cfg = Configuration.getInstance();
        Connection con = getConnection();
        if (null == con) return false;
        try {
            String sql = FileTool.readFile(cfg.getProperty("database.sql.rootdir") + System.getProperty("file.separator") + cfg.getProperty("database.sql.mysql.setupschema"));
            sql = sql.replaceAll(MYSQL_SQL_SCHEMA_REPLACEMENT, StateSaver.getInstance().getDatabaseSettings().getSchema());
            con.setAutoCommit(false);
            Statement stmt = con.createStatement();
            String[] sqlParts = sql.split(";");
            for (String sqlPart : sqlParts) {
                if (sqlPart.trim().length() > 0) stmt.executeUpdate(sqlPart);
            }
            con.commit();
            JOptionPane.showMessageDialog(null, language.getProperty("database.messages.executionsuccess"), language.getProperty("dialog.information.title"), JOptionPane.INFORMATION_MESSAGE);
            return true;
        } catch (SQLException e) {
            Logger.logException(e);
        }
        try {
            if (con != null) con.rollback();
        } catch (SQLException e) {
            Logger.logException(e);
        }
        JOptionPane.showMessageDialog(null, language.getProperty("database.messages.executionerror"), language.getProperty("dialog.error.title"), JOptionPane.ERROR_MESSAGE);
        return false;
    }
} </s>
<s>class temp {    public PollSetMessage(String username, String question, String title, String[] choices) {
        this.username = username;
        MessageDigest m = null;
        try {
            m = MessageDigest.getInstance("SHA-1");
        } catch (NoSuchAlgorithmException ex) {
            ex.printStackTrace();
        }
        String id = username + String.valueOf(System.nanoTime());
        m.update(id.getBytes(), 0, id.length());
        voteId = new BigInteger(1, m.digest()).toString(16);
        this.question = question;
        this.title = title;
        this.choices = choices;
    }
} </s>
<s>class temp {    public static void test() {
        try {
            Pattern pattern = Pattern.compile("[0-9]{3}\\. <a href='(.*)\\.html'>(.*)</a><br />");
            URL url = new URL("http://farmfive.com/");
            BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));
            String line;
            int count = 0;
            while ((line = br.readLine()) != null) {
                Matcher match = pattern.matcher(line);
                if (match.matches()) {
                    System.out.println(match.group(1) + " " + match.group(2));
                    count++;
                }
            }
            System.out.println(count + " counted");
            br.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
} </s>
<s>class temp {    public static void bubbleSort(String[] a) {
        Collator myCollator = Collator.getInstance();
        boolean switched = true;
        for (int pass = 0; pass < a.length - 1 && switched; pass++) {
            switched = false;
            for (int i = 0; i < a.length - pass - 1; i++) {
                if (myCollator.compare(a[i], a[i + 1]) > 0) {
                    switched = true;
                    String temp = a[i];
                    a[i] = a[i + 1];
                    a[i + 1] = temp;
                }
            }
        }
    }
} </s>
<s>class temp {    public String hash(String password) {
        MessageDigest sha1Digest;
        try {
            sha1Digest = MessageDigest.getInstance("SHA-1");
        } catch (NoSuchAlgorithmException e) {
            throw NestedException.wrap(e);
        }
        sha1Digest.update(password.getBytes());
        StringBuilder retval = new StringBuilder("sha1:");
        retval.append(new String(Base64.encodeBase64(sha1Digest.digest())));
        return retval.toString();
    }
} </s>
<s>class temp {    private RSSFeed getFeed(String urlToRssFeed) {
        try {
            URL url = new URL(urlToRssFeed);
            SAXParserFactory factory = SAXParserFactory.newInstance();
            SAXParser parser = factory.newSAXParser();
            XMLReader xmlreader = parser.getXMLReader();
            RSSHandler theRssHandler = new RSSHandler();
            xmlreader.setContentHandler(theRssHandler);
            InputSource is = new InputSource(url.openStream());
            xmlreader.parse(is);
            return theRssHandler.getFeed();
        } catch (Exception ee) {
            return null;
        }
    }
} </s>
<s>class temp {    public void copyFile(File sourceFile, String toDir, boolean create, boolean overwrite) throws FileNotFoundException, IOException {
        FileInputStream source = null;
        FileOutputStream destination = null;
        byte[] buffer;
        int bytes_read;
        File toFile = new File(toDir);
        if (create && !toFile.exists()) toFile.mkdirs();
        if (toFile.exists()) {
            File destFile = new File(toDir + "/" + sourceFile.getName());
            try {
                if (!destFile.exists() || overwrite) {
                    source = new FileInputStream(sourceFile);
                    destination = new FileOutputStream(destFile);
                    buffer = new byte[1024];
                    while (true) {
                        bytes_read = source.read(buffer);
                        if (bytes_read == -1) break;
                        destination.write(buffer, 0, bytes_read);
                    }
                }
            } catch (Exception exx) {
                exx.printStackTrace();
            } finally {
                if (source != null) try {
                    source.close();
                } catch (IOException e) {
                }
                if (destination != null) try {
                    destination.close();
                } catch (IOException e) {
                }
            }
        }
    }
} </s>
<s>class temp {    private static void copyFile(File sourceFile, File destFile) {
        try {
            if (!destFile.exists()) {
                destFile.createNewFile();
            }
            FileChannel source = null;
            FileChannel destination = null;
            try {
                source = new FileInputStream(sourceFile).getChannel();
                destination = new FileOutputStream(destFile).getChannel();
                destination.transferFrom(source, 0, source.size());
            } finally {
                if (source != null) {
                    source.close();
                }
                if (destination != null) {
                    destination.close();
                }
            }
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
} </s>
<s>class temp {    protected static void copyFile(File in, File out) throws IOException {
        java.io.FileWriter filewriter = null;
        java.io.FileReader filereader = null;
        try {
            filewriter = new java.io.FileWriter(out);
            filereader = new java.io.FileReader(in);
            char[] buf = new char[4096];
            int nread = filereader.read(buf, 0, 4096);
            while (nread >= 0) {
                filewriter.write(buf, 0, nread);
                nread = filereader.read(buf, 0, 4096);
            }
            buf = null;
        } finally {
            try {
                filereader.close();
            } catch (Throwable t) {
            }
            try {
                filewriter.close();
            } catch (Throwable t) {
            }
        }
    }
} </s>
<s>class temp {    @SuppressWarnings("unchecked")
    public ArrayList<GmailContact> getAllContacts() throws GmailException {
        String query = properties.getString("export_page");
        query = query.replace("[RANDOM_INT]", "" + random.nextInt());
        int statusCode = -1;
        GetMethod get = new GetMethod(query);
        if (log.isInfoEnabled()) log.info("getting all contacts ...");
        try {
            statusCode = client.executeMethod(get);
            if (statusCode != 200) throw new GmailException("In contacts export page: Status code expected: 200 -> Status code returned: " + statusCode);
        } catch (HttpException e) {
            throw new GmailException("HttpException in contacts export page:" + e.getMessage());
        } catch (IOException e) {
            throw new GmailException("IOException in contacts export page:" + e.getMessage());
        } finally {
            get.releaseConnection();
        }
        if (log.isTraceEnabled()) log.trace("accessing contacts export page successful...");
        String query_post = properties.getString("outlook_export_page");
        PostMethod post = new PostMethod(query_post);
        post.addRequestHeader("Accept-Encoding", "gzip,deflate");
        post.addRequestHeader("Accept-Charset", "ISO-8859-1,utf-8;q=0.7,*;q=0.8");
        NameValuePair[] data = { new NameValuePair("at", getCookie("GMAIL_AT")), new NameValuePair("ecf", "o"), new NameValuePair("ac", "Export Contacts") };
        post.setRequestBody(data);
        if (log.isTraceEnabled()) log.trace("getting contacts csv file...");
        try {
            statusCode = client.executeMethod(post);
            if (statusCode != 200) throw new GmailException("In csv file post: Status code expected: 200 -> Status code returned: " + statusCode);
            if (log.isTraceEnabled()) log.trace("Gmail: csv charset: " + post.getResponseCharSet());
            GMAIL_OUTPUT_CHARSET = post.getResponseCharSet();
            InputStreamReader isr = new InputStreamReader(new GZIPInputStream(post.getResponseBodyAsStream()), post.getResponseCharSet());
            CSVReader reader = new CSVReader(isr);
            List csvEntries = reader.readAll();
            reader.close();
            ArrayList<GmailContact> contacts = new ArrayList<GmailContact>();
            MessageDigest m = MessageDigest.getInstance("MD5");
            if (log.isTraceEnabled()) log.trace("creating Gmail contacts...");
            for (int i = 1; i < csvEntries.size(); i++) {
                GmailContact contact = new GmailContact();
                String[] value = (String[]) csvEntries.get(i);
                for (int j = 0; j < value.length; j++) {
                    switch(j) {
                        case 0:
                            contact.setName(value[j]);
                            break;
                        case 1:
                            contact.setEmail(value[j]);
                            if (contact.getName() == null) contact.setIdName(value[j]); else contact.setIdName(contact.getName() + value[j]);
                            break;
                        case 2:
                            contact.setNotes(value[j]);
                            break;
                        case 3:
                            contact.setEmail2(value[j]);
                            break;
                        case 4:
                            contact.setEmail3(value[j]);
                            break;
                        case 5:
                            contact.setMobilePhone(value[j]);
                            break;
                        case 6:
                            contact.setPager(value[j]);
                            break;
                        case 7:
                            contact.setCompany(value[j]);
                            break;
                        case 8:
                            contact.setJobTitle(value[j]);
                            break;
                        case 9:
                            contact.setHomePhone(value[j]);
                            break;
                        case 10:
                            contact.setHomePhone2(value[j]);
                            break;
                        case 11:
                            contact.setHomeFax(value[j]);
                            break;
                        case 12:
                            contact.setHomeAddress(value[j]);
                            break;
                        case 13:
                            contact.setBusinessPhone(value[j]);
                            break;
                        case 14:
                            contact.setBusinessPhone2(value[j]);
                            break;
                        case 15:
                            contact.setBusinessFax(value[j]);
                            break;
                        case 16:
                            contact.setBusinessAddress(value[j]);
                            break;
                        case 17:
                            contact.setOtherPhone(value[j]);
                            break;
                        case 18:
                            contact.setOtherFax(value[j]);
                            break;
                        case 19:
                            contact.setOtherAddress(value[j]);
                            break;
                    }
                }
                m.update(contact.toString().getBytes());
                if (log.isTraceEnabled()) log.trace("setting Md5 Hash...");
                contact.setMd5Hash(new BigInteger(m.digest()).toString());
                contacts.add(contact);
            }
            if (log.isTraceEnabled()) log.trace("Mapping contacts uid...");
            Collections.sort(contacts);
            ArrayList<GmailContact> idList = getAllContactsID();
            for (int i = 0; i < idList.size(); i++) {
                contacts.get(i).setId(idList.get(i).getId());
            }
            if (log.isInfoEnabled()) log.info("getting all contacts info successful...");
            return contacts;
        } catch (HttpException e) {
            throw new GmailException("HttpException in csv file post:" + e.getMessage());
        } catch (IOException e) {
            throw new GmailException("IOException in csv file post:" + e.getMessage());
        } catch (NoSuchAlgorithmException e) {
            throw new GmailException("No such md5 algorithm " + e.getMessage());
        } finally {
            post.releaseConnection();
        }
    }
} </s>
<s>class temp {    private static void sentRequest() {
        try {
            URLConnection urlConn;
            URL url = new URL(gatewayURL);
            urlConn = url.openConnection();
            urlConn.setRequestProperty("Content-Type", "text/xml");
            urlConn.setDoOutput(true);
            OutputStream ostream = urlConn.getOutputStream();
            PrintWriter out = new PrintWriter(ostream);
            out.print(request);
            out.close();
            ostream.close();
            InputStream inStream = urlConn.getInputStream();
            File myFile = new File(styleSheetLocation);
            if (type.equals("A") && myFile.exists()) {
                TransformerFactory tFactory = TransformerFactory.newInstance();
                Transformer transformer = tFactory.newTransformer(new StreamSource(styleSheetLocation));
                transformer.transform(new StreamSource(inStream), new StreamResult(System.out));
            } else {
                BufferedReader in = new BufferedReader(new InputStreamReader(inStream));
                String inputLine;
                while ((inputLine = in.readLine()) != null) {
                    System.out.println(inputLine);
                }
                in.close();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
} </s>
<s>class temp {    public static void copyFile(File in, File out) {
        int len;
        byte[] buffer = new byte[1024];
        try {
            FileInputStream fin = new FileInputStream(in);
            FileOutputStream fout = new FileOutputStream(out);
            while ((len = fin.read(buffer)) >= 0) fout.write(buffer, 0, len);
            fin.close();
            fout.close();
        } catch (IOException ex) {
        }
    }
} </s>
<s>class temp {    @Test
    public final void testImportODScontentXml() throws Exception {
        URL url = ODSTableImporterTest.class.getResource("/Messages.ods_FILES/content.xml");
        String systemId = url.getPath();
        InputStream in = url.openStream();
        ODSTableImporter b = new ODSTableImporter();
        b.importODSContentXml(systemId, in, null);
        assertMessagesOds(b);
    }
} </s>
<s>class temp {    @Test
    public final void testImportODS() throws Exception {
        URL url = ODSTableImporterTest.class.getResource("/Messages.ods");
        InputStream in = url.openStream();
        ODSTableImporter b = new ODSTableImporter();
        b.importODS(in, null);
        assertMessagesOds(b);
    }
} </s>
<s>class temp {    public File uploadImage(InputStream inputStream, String fileName, String sessionId) {
        File file = new File(PathConfig.getInstance().sessionFolder(sessionId) + File.separator + fileName);
        FileOutputStream fileOutputStream = null;
        try {
            FileUtils.touch(file);
            fileOutputStream = new FileOutputStream(file);
            IOUtils.copy(inputStream, fileOutputStream);
        } catch (IOException e) {
            logger.error("Save uploaded image to file occur IOException.", e);
            throw new FileOperationException("Save uploaded image to file occur IOException.", e);
        } finally {
            try {
                if (fileOutputStream != null) {
                    fileOutputStream.close();
                }
            } catch (IOException e) {
                logger.error("Close FileOutputStream Occur IOException while save a uploaded image.", e);
            }
        }
        return file;
    }
} </s>
<s>class temp {    private void initFiles() throws IOException {
        if (!tempDir.exists()) {
            if (!tempDir.mkdir()) throw new IOException("Temp dir '' can not be created");
        }
        File tmp = new File(tempDir, TORRENT_FILENAME);
        if (!tmp.exists()) {
            FileChannel in = new FileInputStream(torrentFile).getChannel();
            FileChannel out = new FileOutputStream(tmp).getChannel();
            in.transferTo(0, in.size(), out);
            in.close();
            out.close();
        }
        torrentFile = tmp;
        if (!stateFile.exists()) {
            FileChannel out = new FileOutputStream(stateFile).getChannel();
            int numChunks = metadata.getPieceHashes().size();
            ByteBuffer zero = ByteBuffer.wrap(new byte[] { 0, 0, 0, 0 });
            for (int i = 0; i < numChunks; i++) {
                out.write(zero);
                zero.clear();
            }
            out.close();
        }
    }
} </s>
<s>class temp {    @Override
    public void run() {
        try {
            BufferedReader in = new BufferedReader(new InputStreamReader(new URL(urlInfo).openStream()));
            String ligneEnCours;
            int i = 0;
            informations = "";
            while ((ligneEnCours = in.readLine()) != null) {
                switch(i) {
                    case 0:
                        version = ligneEnCours;
                        break;
                    case 1:
                        url = ligneEnCours;
                        break;
                    default:
                        informations += ligneEnCours + '\n';
                        break;
                }
                i++;
            }
            in.close();
            erreur = false;
        } catch (IOException e) {
            erreur = true;
            texteErreur = e.getMessage();
            if (texteErreur.equals("Network is unreachable")) {
                texteErreur = "Pas de réseau";
                numErreur = 1;
            }
            if (e instanceof FileNotFoundException) {
                texteErreur = "Problème paramétrage";
                numErreur = 2;
            }
            e.printStackTrace();
        } finally {
            for (ActionListener al : listeners) {
                al.actionPerformed(null);
            }
        }
    }
} </s>
<s>class temp {    public static boolean encodeFileToFile(String infile, String outfile) {
        boolean success = false;
        java.io.InputStream in = null;
        java.io.OutputStream out = null;
        try {
            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            byte[] buffer = new byte[65536];
            int read = -1;
            while ((read = in.read(buffer)) >= 0) {
                out.write(buffer, 0, read);
            }
            success = true;
        } catch (java.io.IOException exc) {
            exc.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (Exception exc) {
            }
            try {
                out.close();
            } catch (Exception exc) {
            }
        }
        return success;
    }
} </s>
<s>class temp {    public static boolean decodeFileToFile(String infile, String outfile) {
        boolean success = false;
        java.io.InputStream in = null;
        java.io.OutputStream out = null;
        try {
            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            byte[] buffer = new byte[65536];
            int read = -1;
            while ((read = in.read(buffer)) >= 0) {
                out.write(buffer, 0, read);
            }
            success = true;
        } catch (java.io.IOException exc) {
            exc.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (Exception exc) {
            }
            try {
                out.close();
            } catch (Exception exc) {
            }
        }
        return success;
    }
} </s>
<s>class temp {    private void loadDefaultDrivers() {
        final URL url = _app.getResources().getDefaultDriversUrl();
        try {
            InputStreamReader isr = new InputStreamReader(url.openStream());
            try {
                _cache.load(isr);
            } finally {
                isr.close();
            }
        } catch (Exception ex) {
            final Logger logger = _app.getLogger();
            logger.showMessage(Logger.ILogTypes.ERROR, "Error loading default driver file: " + url != null ? url.toExternalForm() : "");
            logger.showMessage(Logger.ILogTypes.ERROR, ex);
        }
    }
} </s>
<s>class temp {    public void run() {
        Thread.currentThread().setName("zhongwen.com watcher");
        String url = getURL();
        try {
            while (m_shouldBeRunning) {
                try {
                    BufferedReader reader = new BufferedReader(new InputStreamReader(new URL(url).openStream(), "ISO8859_1"));
                    String line;
                    Vector chatLines = new Vector();
                    boolean startGrabbing = false;
                    while ((line = reader.readLine()) != null) {
                        if (line.indexOf("</style>") >= 0) {
                            startGrabbing = true;
                        } else if (startGrabbing) {
                            if (line.equals(m_mostRecentKnownLine)) {
                                break;
                            }
                            chatLines.addElement(line);
                        }
                    }
                    reader.close();
                    for (int i = chatLines.size() - 1; i >= 0; --i) {
                        String chatLine = (String) chatLines.elementAt(i);
                        m_mostRecentKnownLine = chatLine;
                        if (chatLine.indexOf(":") >= 0) {
                            String from = chatLine.substring(0, chatLine.indexOf(":"));
                            String message = stripTags(chatLine.substring(chatLine.indexOf(":")));
                            m_source.pushMessage(new ZhongWenMessage(m_source, from, message));
                        } else {
                            m_source.pushMessage(new ZhongWenMessage(m_source, null, stripTags(chatLine)));
                        }
                    }
                    Thread.sleep(SLEEP_TIME);
                } catch (InterruptedIOException e) {
                } catch (InterruptedException e) {
                }
            }
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (RuntimeException e) {
            m_source.disconnect();
            throw e;
        } catch (Error e) {
            m_source.disconnect();
            throw e;
        }
    }
} </s>
<s>class temp {    public static Document ByURL(String urlstr) throws IOException {
        String uri = urlstr;
        URL url = new URL(uri);
        URLConnection connection = url.openConnection();
        InputStream in = connection.getInputStream();
        Reader reader = new InputStreamReader(in);
        InputSource is = new InputSourceImpl(reader, uri);
        System.out.println(is.toString());
        Document document = new Document() {

            @Override
            public Node adoptNode(Node source) throws DOMException {
                return null;
            }

            @Override
            public Attr createAttribute(String name) throws DOMException {
                return null;
            }

            @Override
            public Attr createAttributeNS(String namespaceURI, String qualifiedName) throws DOMException {
                return null;
            }

            @Override
            public CDATASection createCDATASection(String data) throws DOMException {
                return null;
            }

            @Override
            public Comment createComment(String data) {
                return null;
            }

            @Override
            public DocumentFragment createDocumentFragment() {
                return null;
            }

            @Override
            public Element createElement(String tagName) throws DOMException {
                return null;
            }

            @Override
            public Element createElementNS(String namespaceURI, String qualifiedName) throws DOMException {
                return null;
            }

            @Override
            public EntityReference createEntityReference(String name) throws DOMException {
                return null;
            }

            @Override
            public ProcessingInstruction createProcessingInstruction(String target, String data) throws DOMException {
                return null;
            }

            @Override
            public Text createTextNode(String data) {
                return null;
            }

            @Override
            public DocumentType getDoctype() {
                return null;
            }

            @Override
            public Element getDocumentElement() {
                return null;
            }

            @Override
            public String getDocumentURI() {
                return null;
            }

            @Override
            public DOMConfiguration getDomConfig() {
                return null;
            }

            @Override
            public Element getElementById(String elementId) {
                return null;
            }

            @Override
            public NodeList getElementsByTagName(String tagname) {
                return null;
            }

            @Override
            public NodeList getElementsByTagNameNS(String namespaceURI, String localName) {
                return null;
            }

            @Override
            public DOMImplementation getImplementation() {
                return null;
            }

            @Override
            public String getInputEncoding() {
                return null;
            }

            @Override
            public boolean getStrictErrorChecking() {
                return false;
            }

            @Override
            public String getXmlEncoding() {
                return null;
            }

            @Override
            public boolean getXmlStandalone() {
                return false;
            }

            @Override
            public String getXmlVersion() {
                return null;
            }

            @Override
            public Node importNode(Node importedNode, boolean deep) throws DOMException {
                return null;
            }

            @Override
            public void normalizeDocument() {
            }

            @Override
            public Node renameNode(Node n, String namespaceURI, String qualifiedName) throws DOMException {
                return null;
            }

            @Override
            public void setDocumentURI(String documentURI) {
            }

            @Override
            public void setStrictErrorChecking(boolean strictErrorChecking) {
            }

            @Override
            public void setXmlStandalone(boolean xmlStandalone) throws DOMException {
            }

            @Override
            public void setXmlVersion(String xmlVersion) throws DOMException {
            }

            public Node appendChild(Node arg0) throws DOMException {
                return null;
            }

            public Node cloneNode(boolean arg0) {
                return null;
            }

            public short compareDocumentPosition(Node arg0) throws DOMException {
                return 0;
            }

            public NamedNodeMap getAttributes() {
                return null;
            }

            public String getBaseURI() {
                return null;
            }

            public NodeList getChildNodes() {
                return null;
            }

            public Object getFeature(String arg0, String arg1) {
                return null;
            }

            public Node getFirstChild() {
                return null;
            }

            public Node getLastChild() {
                return null;
            }

            public String getLocalName() {
                return null;
            }

            public String getNamespaceURI() {
                return null;
            }

            public Node getNextSibling() {
                return null;
            }

            public String getNodeName() {
                return null;
            }

            public short getNodeType() {
                return 0;
            }

            public String getNodeValue() throws DOMException {
                return null;
            }

            public Document getOwnerDocument() {
                return null;
            }

            public Node getParentNode() {
                return null;
            }

            public String getPrefix() {
                return null;
            }

            public Node getPreviousSibling() {
                return null;
            }

            public String getTextContent() throws DOMException {
                return null;
            }

            public Object getUserData(String arg0) {
                return null;
            }

            public boolean hasAttributes() {
                return false;
            }

            public boolean hasChildNodes() {
                return false;
            }

            public Node insertBefore(Node arg0, Node arg1) throws DOMException {
                return null;
            }

            public boolean isDefaultNamespace(String arg0) {
                return false;
            }

            public boolean isEqualNode(Node arg0) {
                return false;
            }

            public boolean isSameNode(Node arg0) {
                return false;
            }

            public boolean isSupported(String arg0, String arg1) {
                return false;
            }

            public String lookupNamespaceURI(String arg0) {
                return null;
            }

            public String lookupPrefix(String arg0) {
                return null;
            }

            public void normalize() {
            }

            public Node removeChild(Node arg0) throws DOMException {
                return null;
            }

            public Node replaceChild(Node arg0, Node arg1) throws DOMException {
                return null;
            }

            public void setNodeValue(String arg0) throws DOMException {
            }

            public void setPrefix(String arg0) throws DOMException {
            }

            public void setTextContent(String arg0) throws DOMException {
            }

            public Object setUserData(String arg0, Object arg1, UserDataHandler arg2) {
                return null;
            }
        };
        return document;
    }
} </s>
<s>class temp {    private static void extract(ZipFile zipFile) throws Exception {
        FileUtils.deleteQuietly(WEBKIT_DIR);
        WEBKIT_DIR.mkdirs();
        Enumeration<? extends ZipEntry> entries = zipFile.entries();
        while (entries.hasMoreElements()) {
            ZipEntry entry = entries.nextElement();
            if (entry.isDirectory()) {
                new File(WEBKIT_DIR, entry.getName()).mkdirs();
                continue;
            }
            InputStream inputStream = zipFile.getInputStream(entry);
            File outputFile = new File(WEBKIT_DIR, entry.getName());
            FileOutputStream outputStream = new FileOutputStream(outputFile);
            IOUtils.copy(inputStream, outputStream);
            IOUtils.closeQuietly(inputStream);
            IOUtils.closeQuietly(outputStream);
        }
    }
} </s>
<s>class temp {    private File writeResourceToFile(String resource) throws IOException {
        File tmp = File.createTempFile("zfppt" + resource, null);
        InputStream res = Thread.currentThread().getContextClassLoader().getResourceAsStream(resource);
        OutputStream out = new FileOutputStream(tmp);
        IOUtils.copy(res, out);
        out.close();
        return tmp;
    }
} </s>
<s>class temp {    private void streamContains(String in, InputStream stream) throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        IOUtils.copy(stream, baos);
        byte[] bytes = baos.toByteArray();
        String cmp = new String(bytes, "UTF-8");
        assertTrue(cmp.contains(in));
        baos.close();
    }
} </s>
<s>class temp {    private void checkInputStream(InputStream in, byte[] cmp, boolean all) throws IOException {
        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        IOUtils.copy(in, stream);
        byte[] out = stream.toByteArray();
        if (all) assertEquals(cmp.length, out.length);
        for (int i = 0; i < cmp.length; i++) assertEquals(cmp[i], out[i]);
    }
} </s>
<s>class temp {    public void write(File file) throws Exception {
        if (getGEDCOMFile() != null) {
            size = getGEDCOMFile().length();
            if (!getGEDCOMFile().renameTo(file)) {
                BufferedInputStream in = null;
                BufferedOutputStream out = null;
                try {
                    in = new BufferedInputStream(new FileInputStream(getGEDCOMFile()));
                    out = new BufferedOutputStream(new FileOutputStream(file));
                    IOUtils.copy(in, out);
                } finally {
                    if (in != null) {
                        try {
                            in.close();
                        } catch (IOException e) {
                        }
                    }
                    if (out != null) {
                        try {
                            out.close();
                        } catch (IOException e) {
                        }
                    }
                }
            }
        } else {
            throw new FileUploadException("Cannot write uploaded file to disk!");
        }
    }
} </s>
<s>class temp {    private InputStream getInputStream(URI uri) throws IOException {
        if (Logging.SHOW_FINE && LOG.isLoggable(Level.FINE)) {
            LOG.fine("Loading ACL : " + uri.toString());
        }
        URL url = uri.toURL();
        URLConnection connection = url.openConnection();
        connection.setDoInput(true);
        return connection.getInputStream();
    }
} </s>
<s>class temp {    public void runWeb(String beginURL, String contextRoot, String pageURI) {
        if (bDebug) System.out.println("WEB Path");
        List<String> vtURLs = new ArrayList<String>();
        List<String> vtRobots = getRobots(beginURL, contextRoot);
        vtURLs.add("/" + contextRoot + "/" + pageURI);
        Indexer indexer = null;
        IndexDocument indexDoc = null;
        try {
            indexer = new Indexer("/tmp/tmp/index");
            for (String sxURL : vtURLs) {
                if (bDebug) System.out.println("\n\n*** INDEXING " + sxURL);
                if (bDebug) System.out.println("Have - " + sxURL);
                boolean bIndexPage = true;
                if (vtRobots != null) {
                    for (String sxRobotURL : vtRobots) {
                        if (bDebug) System.out.println("Comparing to - " + sxRobotURL);
                        if (sxURL.startsWith(sxRobotURL)) {
                            if (bDebug) System.out.println("Found URL - " + sxRobotURL + " - " + sxURL);
                            bIndexPage = false;
                            break;
                        }
                    }
                } else {
                    bIndexPage = true;
                }
                sxURL = beginURL + sxURL;
                ParserDelegator pd = new ParserDelegator();
                CallbackHandler cb = new CallbackHandler(vtURLs, bIndexPage, contextRoot);
                try {
                    URLConnection urlConn = new URL(sxURL).openConnection();
                    urlConn.setUseCaches(false);
                    Date modDate = new Date(urlConn.getLastModified());
                    if (bDebug) System.out.println("\nMatch - " + sxURL + " - Modified Date - " + modDate);
                    BufferedReader bfReader = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));
                    pd.parse(bfReader, cb, true);
                    if (bIndexPage) {
                        if (bDebug) System.out.println("Adding Index - " + sxURL + "\nContent:" + cb.getText() + "\nSummary:" + cb.getSummary() + "\nTitle:" + cb.getTitle());
                        indexDoc = new IndexDocument();
                        indexDoc.setUID(sxURL + modDate.toString());
                        indexDoc.setPageURL(sxURL);
                        indexDoc.setModifiedDate(modDate.toString());
                        indexDoc.setContents(cb.getText());
                        indexDoc.setTitle(cb.getTitle());
                        indexDoc.setSummary(cb.getSummary());
                        indexer.addDocument(indexDoc);
                    }
                } catch (Exception ee) {
                    PetstoreUtil.getLogger().log(Level.SEVERE, "Inner Exception" + ee);
                }
            }
        } catch (Exception e) {
            PetstoreUtil.getLogger().log(Level.SEVERE, "Outer Exception" + e);
        } finally {
            try {
                if (indexer != null) {
                    indexer.close();
                }
            } catch (Exception ee) {
                ee.printStackTrace();
            }
        }
    }
} </s>
<s>class temp {    private List<String> getRobots(String beginURL, String contextRoot) {
        List<String> vtRobots = new ArrayList<String>();
        BufferedReader bfReader = null;
        try {
            URL urlx = new URL(beginURL + "/" + contextRoot + "/" + "robots.txt");
            URLConnection urlConn = urlx.openConnection();
            urlConn.setUseCaches(false);
            bfReader = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));
            String sxLine = "";
            while ((sxLine = bfReader.readLine()) != null) {
                if (sxLine.startsWith("Disallow:")) {
                    vtRobots.add(sxLine.substring(10));
                }
            }
        } catch (Exception e) {
            PetstoreUtil.getLogger().log(Level.SEVERE, "Exception" + e);
            vtRobots = null;
        } finally {
            try {
                if (bfReader != null) {
                    bfReader.close();
                }
            } catch (Exception ee) {
            }
        }
        return vtRobots;
    }
} </s>
<s>class temp {            @Override
            public void onClick(View v) {
                Log.d(Config.SS_TAG, "Sending POST request to server...");
                DefaultHttpClient httpClient = new DefaultHttpClient();
                HttpPost httpPost = new HttpPost(Config.RPC_SERVLET_URL);
                JSONObject requestJson = new JSONObject();
                JSONArray callsJson = new JSONArray();
                try {
                    JSONObject callJson = new JSONObject();
                    callJson.put("method", "ping");
                    callJson.put("void", "null");
                    callsJson.put(0, callJson);
                    requestJson.put("calls", callsJson);
                    httpPost.setEntity(new StringEntity(requestJson.toString(), "UTF-8"));
                    HttpResponse httpResponse = httpClient.execute(httpPost);
                    final int responseStatusCode = httpResponse.getStatusLine().getStatusCode();
                    if (200 <= responseStatusCode && responseStatusCode < 300) {
                        Log.d(Config.SS_TAG, "Successful ping - status code: " + responseStatusCode);
                        BufferedReader reader = new BufferedReader(new InputStreamReader(httpResponse.getEntity().getContent(), "UTF-8"), 8 * 1024);
                        StringBuilder sb = new StringBuilder();
                        String line;
                        while ((line = reader.readLine()) != null) {
                            sb.append(line).append("\n");
                        }
                        JSONTokener tokener = new JSONTokener(sb.toString());
                        JSONObject responseJson = new JSONObject(tokener);
                        JSONArray resultsJson = responseJson.getJSONArray("results");
                        JSONObject result = resultsJson.getJSONObject(0);
                        String returnValue = result.getJSONObject("data").getString("return");
                        Log.d(Config.SS_TAG, "Response message: " + returnValue);
                    } else {
                        Log.e(Config.SS_TAG, "Unsuccessful ping...");
                    }
                } catch (Exception e) {
                    Log.e(Config.SS_TAG, "Error while trying to ping rpc servlet");
                    e.printStackTrace();
                }
            }
} </s>
<s>class temp {    public static final boolean copy(File source, File target, boolean overwrite) {
        if (!overwrite && target.exists()) {
            LOGGER.error("Target file exist and it not permitted to overwrite it !");
            return false;
        }
        FileChannel in = null;
        FileChannel out = null;
        try {
            in = new FileInputStream(source).getChannel();
            out = new FileOutputStream(target).getChannel();
            in.transferTo(0, in.size(), out);
        } catch (FileNotFoundException e) {
            LOGGER.error(e.getLocalizedMessage());
            if (LOGGER.isDebugEnabled()) e.printStackTrace();
            return false;
        } catch (IOException e) {
            LOGGER.error(e.getLocalizedMessage());
            if (LOGGER.isDebugEnabled()) e.printStackTrace();
            return false;
        } finally {
            try {
                in.close();
            } catch (Exception e) {
            }
            try {
                out.close();
            } catch (Exception e) {
            }
        }
        return true;
    }
} </s>
<s>class temp {    private static InputStream openStream(final URL url) throws IOException {
        try {
            return (InputStream) AccessController.doPrivileged(new PrivilegedExceptionAction() {

                public Object run() throws IOException {
                    return url.openStream();
                }
            });
        } catch (PrivilegedActionException e) {
            throw (IOException) e.getException();
        }
    }
} </s>
<s>class temp {    public static int zipFile(File file_input, File dir_output) {
        File zip_output = new File(dir_output, file_input.getName() + ".zip");
        ZipOutputStream zip_out_stream;
        try {
            FileOutputStream out = new FileOutputStream(zip_output);
            zip_out_stream = new ZipOutputStream(new BufferedOutputStream(out));
        } catch (IOException e) {
            return STATUS_OUT_FAIL;
        }
        byte[] input_buffer = new byte[BUF_SIZE];
        int len = 0;
        try {
            ZipEntry zip_entry = new ZipEntry(file_input.getName());
            zip_out_stream.putNextEntry(zip_entry);
            FileInputStream in = new FileInputStream(file_input);
            BufferedInputStream source = new BufferedInputStream(in, BUF_SIZE);
            while ((len = source.read(input_buffer, 0, BUF_SIZE)) != -1) zip_out_stream.write(input_buffer, 0, len);
            in.close();
        } catch (IOException e) {
            return STATUS_ZIP_FAIL;
        }
        try {
            zip_out_stream.close();
        } catch (IOException e) {
        }
        return STATUS_OK;
    }
} </s>
<s>class temp {    public static int gzipFile(File file_input, String file_output) {
        File gzip_output = new File(file_output);
        GZIPOutputStream gzip_out_stream;
        try {
            FileOutputStream out = new FileOutputStream(gzip_output);
            gzip_out_stream = new GZIPOutputStream(new BufferedOutputStream(out));
        } catch (IOException e) {
            return STATUS_OUT_FAIL;
        }
        byte[] input_buffer = new byte[BUF_SIZE];
        int len = 0;
        try {
            FileInputStream in = new FileInputStream(file_input);
            BufferedInputStream source = new BufferedInputStream(in, BUF_SIZE);
            while ((len = source.read(input_buffer, 0, BUF_SIZE)) != -1) gzip_out_stream.write(input_buffer, 0, len);
            in.close();
        } catch (IOException e) {
            return STATUS_GZIP_FAIL;
        }
        try {
            gzip_out_stream.close();
        } catch (IOException e) {
        }
        return STATUS_OK;
    }
} </s>
<s>class temp {    public static int unzipFile(File file_input, File dir_output) {
        ZipInputStream zip_in_stream;
        try {
            FileInputStream in = new FileInputStream(file_input);
            BufferedInputStream source = new BufferedInputStream(in);
            zip_in_stream = new ZipInputStream(source);
        } catch (IOException e) {
            return STATUS_IN_FAIL;
        }
        byte[] input_buffer = new byte[BUF_SIZE];
        int len = 0;
        do {
            try {
                ZipEntry zip_entry = zip_in_stream.getNextEntry();
                if (zip_entry == null) break;
                File output_file = new File(dir_output, zip_entry.getName());
                FileOutputStream out = new FileOutputStream(output_file);
                BufferedOutputStream destination = new BufferedOutputStream(out, BUF_SIZE);
                while ((len = zip_in_stream.read(input_buffer, 0, BUF_SIZE)) != -1) destination.write(input_buffer, 0, len);
                destination.flush();
                out.close();
            } catch (IOException e) {
                return STATUS_GUNZIP_FAIL;
            }
        } while (true);
        try {
            zip_in_stream.close();
        } catch (IOException e) {
        }
        return STATUS_OK;
    }
} </s>
<s>class temp {    public static int gunzipFile(File file_input, File dir_output) {
        GZIPInputStream gzip_in_stream;
        try {
            FileInputStream in = new FileInputStream(file_input);
            BufferedInputStream source = new BufferedInputStream(in);
            gzip_in_stream = new GZIPInputStream(source);
        } catch (IOException e) {
            return STATUS_IN_FAIL;
        }
        String file_input_name = file_input.getName();
        String file_output_name = file_input_name.substring(0, file_input_name.length() - 3);
        File output_file = new File(dir_output, file_output_name);
        byte[] input_buffer = new byte[BUF_SIZE];
        int len = 0;
        try {
            FileOutputStream out = new FileOutputStream(output_file);
            BufferedOutputStream destination = new BufferedOutputStream(out, BUF_SIZE);
            while ((len = gzip_in_stream.read(input_buffer, 0, BUF_SIZE)) != -1) destination.write(input_buffer, 0, len);
            destination.flush();
            out.close();
        } catch (IOException e) {
            return STATUS_GUNZIP_FAIL;
        }
        try {
            gzip_in_stream.close();
        } catch (IOException e) {
        }
        return STATUS_OK;
    }
} </s>
<s>class temp {    public HashCash(String cash) throws NoSuchAlgorithmException {
        myToken = cash;
        String[] parts = cash.split(":");
        myVersion = Integer.parseInt(parts[0]);
        if (myVersion < 0 || myVersion > 1) throw new IllegalArgumentException("Only supported versions are 0 and 1");
        if ((myVersion == 0 && parts.length != 6) || (myVersion == 1 && parts.length != 7)) throw new IllegalArgumentException("Improperly formed HashCash");
        try {
            int index = 1;
            if (myVersion == 1) myValue = Integer.parseInt(parts[index++]); else myValue = 0;
            SimpleDateFormat dateFormat = new SimpleDateFormat(dateFormatString);
            Calendar tempCal = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
            tempCal.setTime(dateFormat.parse(parts[index++]));
            myResource = parts[index++];
            myExtensions = deserializeExtensions(parts[index++]);
            MessageDigest md = MessageDigest.getInstance("SHA1");
            md.update(cash.getBytes());
            byte[] tempBytes = md.digest();
            int tempValue = numberOfLeadingZeros(tempBytes);
            if (myVersion == 0) myValue = tempValue; else if (myVersion == 1) myValue = (tempValue > myValue ? myValue : tempValue);
        } catch (java.text.ParseException ex) {
            throw new IllegalArgumentException("Improperly formed HashCash", ex);
        }
    }
} </s>
<s>class temp {    public static HashCash mintCash(String resource, Map<String, List<String>> extensions, Calendar date, int value, int version) throws NoSuchAlgorithmException {
        if (version < 0 || version > 1) throw new IllegalArgumentException("Only supported versions are 0 and 1");
        if (value < 0 || value > hashLength) throw new IllegalArgumentException("Value must be between 0 and " + hashLength);
        if (resource.contains(":")) throw new IllegalArgumentException("Resource must not contain ':'");
        HashCash result = new HashCash();
        MessageDigest md = MessageDigest.getInstance("SHA1");
        result.myResource = resource;
        result.myExtensions = (null == extensions ? new HashMap<String, List<String>>() : extensions);
        result.myDate = date;
        result.myVersion = version;
        String prefix;
        SimpleDateFormat dateFormat = new SimpleDateFormat(dateFormatString);
        switch(version) {
            case 0:
                prefix = version + ":" + dateFormat.format(date.getTime()) + ":" + resource + ":" + serializeExtensions(extensions) + ":";
                result.myToken = generateCash(prefix, value, md);
                md.reset();
                md.update(result.myToken.getBytes());
                result.myValue = numberOfLeadingZeros(md.digest());
                break;
            case 1:
                result.myValue = value;
                prefix = version + ":" + value + ":" + dateFormat.format(date.getTime()) + ":" + resource + ":" + serializeExtensions(extensions) + ":";
                result.myToken = generateCash(prefix, value, md);
                break;
            default:
                throw new IllegalArgumentException("Only supported versions are 0 and 1");
        }
        return result;
    }
} </s>
<s>class temp {    public static String getBiopaxId(Reaction reaction) {
        String id = null;
        if (reaction.getId() > Reaction.NO_ID_ASSIGNED) {
            id = reaction.getId().toString();
        } else {
            try {
                MessageDigest md = MessageDigest.getInstance("MD5");
                md.update(reaction.getTextualRepresentation().getBytes());
                byte[] digestBytes = md.digest();
                StringBuilder digesterSb = new StringBuilder(32);
                for (int i = 0; i < digestBytes.length; i++) {
                    int intValue = digestBytes[i] & 0xFF;
                    if (intValue < 0x10) digesterSb.append('0');
                    digesterSb.append(Integer.toHexString(intValue));
                }
                id = digesterSb.toString();
            } catch (NoSuchAlgorithmException e) {
            }
        }
        return id;
    }
} </s>
<s>class temp {    public <T extends FetionResponse> T executeAction(FetionAction<T> fetionAction) throws IOException {
        URL url = new URL(fetionAction.getProtocol().name().toLowerCase() + "://" + fetionUrl + fetionAction.getRequestData());
        URLConnection connection = url.openConnection();
        InputStream in = connection.getInputStream();
        byte[] buffer = new byte[10240];
        ByteArrayOutputStream bout = new ByteArrayOutputStream();
        int read = 0;
        while ((read = in.read(buffer)) > 0) {
            bout.write(buffer, 0, read);
        }
        return fetionAction.processResponse(parseRawResponse(bout.toByteArray()));
    }
} </s>
<s>class temp {    private void analyseCorpus(final IStatusDisplayer fStatus) {
        final String sDistrosFile = "Distros.tmp";
        final String sSymbolsFile = "Symbols.tmp";
        Chunker = new EntropyChunker();
        int Levels = 2;
        sgOverallGraph = new SymbolicGraph(1, Levels);
        siIndex = new SemanticIndex(sgOverallGraph);
        try {
            siIndex.MeaningExtractor = new LocalWordNetMeaningExtractor();
        } catch (IOException ioe) {
            siIndex.MeaningExtractor = null;
        }
        try {
            DocumentSet dsSet = new DocumentSet(FilePathEdt.getText(), 1.0);
            dsSet.createSets(true, (double) 100 / 100);
            int iCurCnt, iTotal;
            String sFile = "";
            Iterator iIter = dsSet.getTrainingSet().iterator();
            iTotal = dsSet.getTrainingSet().size();
            if (iTotal == 0) {
                appendToLog("No input documents.\n");
                appendToLog("======DONE=====\n");
                return;
            }
            appendToLog("Training chunker...");
            Chunker.train(dsSet.toFilenameSet(DocumentSet.FROM_WHOLE_SET));
            appendToLog("Setting delimiters...");
            setDelimiters(Chunker.getDelimiters());
            iCurCnt = 0;
            cdDoc = new DistributionDocument[Levels];
            for (int iCnt = 0; iCnt < Levels; iCnt++) cdDoc[iCnt] = new DistributionDocument(1, MinLevel + iCnt);
            fStatus.setVisible(true);
            ThreadList t = new ThreadList(Runtime.getRuntime().availableProcessors() + 1);
            appendToLog("(Pass 1/3) Loading files..." + sFile);
            TreeSet tsOverallSymbols = new TreeSet();
            while (iIter.hasNext()) {
                sFile = ((CategorizedFileEntry) iIter.next()).getFileName();
                fStatus.setStatus("(Pass 1/3) Loading file..." + sFile, (double) iCurCnt / iTotal);
                final DistributionDocument[] cdDocArg = cdDoc;
                final String sFileArg = sFile;
                for (int iCnt = 0; iCnt < cdDoc.length; iCnt++) {
                    final int iCntArg = iCnt;
                    while (!t.addThreadFor(new Runnable() {

                        public void run() {
                            if (!RightToLeftText) cdDocArg[iCntArg].loadDataStringFromFile(sFileArg, false); else {
                                cdDocArg[iCntArg].setDataString(utils.reverseString(utils.loadFileToString(sFileArg)), iCntArg, false);
                            }
                        }
                    })) Thread.yield();
                }
                try {
                    t.waitUntilCompletion();
                } catch (InterruptedException ex) {
                    ex.printStackTrace(System.err);
                    appendToLog("Interrupted...");
                    sgOverallGraph.removeNotificationListener();
                    return;
                }
                sgOverallGraph.setDataString(((new StringBuffer().append((char) StreamTokenizer.TT_EOF))).toString());
                sgOverallGraph.loadFromFile(sFile);
                fStatus.setStatus("Loaded file..." + sFile, (double) ++iCurCnt / iTotal);
                Thread.yield();
            }
            Set sSymbols = null;
            File fPreviousSymbols = new File(sSymbolsFile);
            boolean bSymbolsLoadedOK = false;
            if (fPreviousSymbols.exists()) {
                System.err.println("ATTENTION: Using previous symbols...");
                try {
                    FileInputStream fis = new FileInputStream(fPreviousSymbols);
                    ObjectInputStream ois = new ObjectInputStream(fis);
                    sSymbols = (Set) ois.readObject();
                    ois.close();
                    bSymbolsLoadedOK = true;
                } catch (FileNotFoundException ex) {
                    ex.printStackTrace(System.err);
                } catch (IOException ex) {
                    ex.printStackTrace(System.err);
                } catch (ClassNotFoundException ex) {
                    ex.printStackTrace(System.err);
                }
            }
            if (!bSymbolsLoadedOK) sSymbols = getSymbolsByProbabilities(sgOverallGraph.getDataString(), fStatus);
            int iMinSymbolSize = Integer.MAX_VALUE;
            int iMaxSymbolSize = Integer.MIN_VALUE;
            Iterator iSymbol = sSymbols.iterator();
            while (iSymbol.hasNext()) {
                String sCurSymbol = (String) iSymbol.next();
                if (iMaxSymbolSize < sCurSymbol.length()) iMaxSymbolSize = sCurSymbol.length();
                if (iMinSymbolSize > sCurSymbol.length()) iMinSymbolSize = sCurSymbol.length();
            }
            try {
                FileOutputStream fos = new FileOutputStream(sSymbolsFile);
                ObjectOutputStream oos = new ObjectOutputStream(fos);
                oos.writeObject(sSymbols);
                oos.close();
            } catch (FileNotFoundException ex) {
                ex.printStackTrace(System.err);
            } catch (IOException ex) {
                ex.printStackTrace(System.err);
            }
            appendToLog("(Pass 2/3) Determining symbol distros per n-gram size...");
            iIter = dsSet.getTrainingSet().iterator();
            iTotal = dsSet.getTrainingSet().size();
            if (iTotal == 0) {
                appendToLog("No input documents.\n");
                appendToLog("======DONE=====\n");
                return;
            }
            iCurCnt = 0;
            Distribution dSymbolsPerSize = new Distribution();
            Distribution dNonSymbolsPerSize = new Distribution();
            Distribution dSymbolSizes = new Distribution();
            File fPreviousRun = new File(sDistrosFile);
            boolean bDistrosLoadedOK = false;
            if (fPreviousRun.exists()) {
                System.err.println("ATTENTION: Using previous distros...");
                try {
                    FileInputStream fis = new FileInputStream(fPreviousRun);
                    ObjectInputStream ois = new ObjectInputStream(fis);
                    dSymbolsPerSize = (Distribution) ois.readObject();
                    dNonSymbolsPerSize = (Distribution) ois.readObject();
                    dSymbolSizes = (Distribution) ois.readObject();
                    ois.close();
                    bDistrosLoadedOK = true;
                } catch (FileNotFoundException ex) {
                    ex.printStackTrace(System.err);
                } catch (IOException ex) {
                    ex.printStackTrace(System.err);
                    dSymbolsPerSize = new Distribution();
                    dNonSymbolsPerSize = new Distribution();
                    dSymbolSizes = new Distribution();
                } catch (ClassNotFoundException ex) {
                    ex.printStackTrace(System.err);
                    dSymbolsPerSize = new Distribution();
                    dNonSymbolsPerSize = new Distribution();
                    dSymbolSizes = new Distribution();
                }
            }
            if (!bDistrosLoadedOK) while (iIter.hasNext()) {
                fStatus.setStatus("(Pass 2/3) Parsing file..." + sFile, (double) iCurCnt++ / iTotal);
                sFile = ((CategorizedFileEntry) iIter.next()).getFileName();
                String sDataString = "";
                try {
                    ByteArrayOutputStream bsOut = new ByteArrayOutputStream();
                    FileInputStream fiIn = new FileInputStream(sFile);
                    int iData = 0;
                    while ((iData = fiIn.read()) > -1) bsOut.write(iData);
                    sDataString = bsOut.toString();
                } catch (IOException ioe) {
                    ioe.printStackTrace(System.err);
                }
                final Distribution dSymbolsPerSizeArg = dSymbolsPerSize;
                final Distribution dNonSymbolsPerSizeArg = dNonSymbolsPerSize;
                final Distribution dSymbolSizesArg = dSymbolSizes;
                final String sDataStringArg = sDataString;
                final Set sSymbolsArg = sSymbols;
                for (int iSymbolSize = iMinSymbolSize; iSymbolSize <= iMaxSymbolSize; iSymbolSize++) {
                    final int iSymbolSizeArg = iSymbolSize;
                    while (!t.addThreadFor(new Runnable() {

                        public void run() {
                            NGramDocument ndCur = new NGramDocument(iSymbolSizeArg, iSymbolSizeArg, 1, iSymbolSizeArg, iSymbolSizeArg);
                            ndCur.setDataString(sDataStringArg);
                            int iSymbolCnt = 0;
                            int iNonSymbolCnt = 0;
                            Iterator iExtracted = ndCur.getDocumentGraph().getGraphLevel(0).getVertexSet().iterator();
                            while (iExtracted.hasNext()) {
                                String sCur = ((Vertex) iExtracted.next()).toString();
                                if (sSymbolsArg.contains(sCur)) {
                                    iSymbolCnt++;
                                    synchronized (dSymbolSizesArg) {
                                        dSymbolSizesArg.setValue(sCur.length(), dSymbolSizesArg.getValue(sCur.length()) + 1.0);
                                    }
                                } else iNonSymbolCnt++;
                            }
                            synchronized (dSymbolsPerSizeArg) {
                                dSymbolsPerSizeArg.setValue(iSymbolSizeArg, dSymbolsPerSizeArg.getValue(iSymbolSizeArg) + iSymbolCnt);
                            }
                            synchronized (dNonSymbolsPerSizeArg) {
                                dNonSymbolsPerSizeArg.setValue(iSymbolSizeArg, dNonSymbolsPerSizeArg.getValue(iSymbolSizeArg) + iNonSymbolCnt);
                            }
                        }
                    })) Thread.yield();
                }
            }
            if (!bDistrosLoadedOK) try {
                t.waitUntilCompletion();
                try {
                    FileOutputStream fos = new FileOutputStream(sDistrosFile);
                    ObjectOutputStream oos = new ObjectOutputStream(fos);
                    oos.writeObject(dSymbolsPerSize);
                    oos.writeObject(dNonSymbolsPerSize);
                    oos.writeObject(dSymbolSizes);
                    oos.close();
                } catch (FileNotFoundException ex) {
                    ex.printStackTrace(System.err);
                } catch (IOException ex) {
                    ex.printStackTrace(System.err);
                }
            } catch (InterruptedException ex) {
                appendToLog("Interrupted...");
                sgOverallGraph.removeNotificationListener();
                return;
            }
            appendToLog("\n(Pass 3/3) Determining optimal n-gram range...\n");
            NGramSizeEstimator nseEstimator = new NGramSizeEstimator(dSymbolsPerSize, dNonSymbolsPerSize);
            IntegerPair p = nseEstimator.getOptimalRange();
            appendToLog("\nProposed n-gram sizes:" + p.first() + "," + p.second());
            fStatus.setStatus("Determining optimal distance...", 0.0);
            DistanceEstimator de = new DistanceEstimator(dSymbolsPerSize, dNonSymbolsPerSize, nseEstimator);
            int iBestDist = de.getOptimalDistance(1, nseEstimator.getMaxRank() * 2, p.first(), p.second());
            fStatus.setStatus("Determining optimal distance...", 1.0);
            appendToLog("\nOptimal distance:" + iBestDist);
            appendToLog("======DONE=====\n");
        } finally {
            sgOverallGraph.removeNotificationListener();
        }
    }
} </s>
<s>class temp {    private static void readAndRewrite(File inFile, File outFile) throws IOException {
        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));
        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);
        Dataset ds = DcmObjectFactory.getInstance().newDataset();
        dcmParser.setDcmHandler(ds.getDcmHandler());
        dcmParser.parseDcmFile(null, Tags.PixelData);
        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        System.out.println("reading " + inFile + "...");
        pdReader.readPixelData(false);
        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));
        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;
        ds.writeDataset(out, dcmEncParam);
        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());
        System.out.println("writing " + outFile + "...");
        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        pdWriter.writePixelData();
        out.flush();
        out.close();
        System.out.println("done!");
    }
} </s>
<s>class temp {    private void getRandomGUID(boolean secure) {
        MessageDigest md5 = null;
        StringBuffer sbValueBeforeMD5 = new StringBuffer(128);
        try {
            md5 = MessageDigest.getInstance("MD5");
        } catch (NoSuchAlgorithmException e) {
            logger.error("Error: " + e);
        }
        try {
            long time = System.currentTimeMillis();
            long rand = 0;
            if (secure) {
                rand = mySecureRand.nextLong();
            } else {
                rand = myRand.nextLong();
            }
            sbValueBeforeMD5.append(s_id);
            sbValueBeforeMD5.append(":");
            sbValueBeforeMD5.append(Long.toString(time));
            sbValueBeforeMD5.append(":");
            sbValueBeforeMD5.append(Long.toString(rand));
            valueBeforeMD5 = sbValueBeforeMD5.toString();
            md5.update(valueBeforeMD5.getBytes());
            byte[] array = md5.digest();
            StringBuffer sb = new StringBuffer(32);
            for (int j = 0; j < array.length; ++j) {
                int b = array[j] & TWO_BYTES;
                if (b < PAD_BELOW) sb.append('0');
                sb.append(Integer.toHexString(b));
            }
            valueAfterMD5 = sb.toString();
        } catch (Exception e) {
            logger.error("Error:" + e);
        }
    }
} </s>
<s>class temp {    void ProcessRequests(DataInputStream in, PrintStream out) {
        String sQuery;
        while (true) {
            try {
                sQuery = in.readLine();
                if (sQuery == null) return;
                if (sQuery.startsWith("select")) {
                    ProcessQuery(sQuery, out);
                } else if (sQuery.startsWith("insert")) {
                    Statement stmt = con.createStatement();
                    stmt.executeUpdate(sQuery);
                } else if (sQuery.startsWith("update")) {
                    Statement stmt = con.createStatement();
                    stmt.executeUpdate(sQuery);
                } else if (sQuery.startsWith("commit")) {
                    con.commit();
                } else if (sQuery.startsWith("autocommit true")) {
                    con.setAutoCommit(true);
                } else if (sQuery.startsWith("autocommit false")) {
                    con.setAutoCommit(false);
                } else if (sQuery.startsWith("delete")) {
                    Statement stmt = con.createStatement();
                    stmt.executeUpdate(sQuery);
                } else if (sQuery.startsWith("rollback")) {
                    con.rollback();
                } else {
                    out.println("What ?");
                }
                out.println(">");
            } catch (SQLException ex) {
                out.println("\n*** SQLException caught ***\n");
                while (ex != null) {
                    out.println("SQLState: " + ex.getSQLState());
                    out.println("Message:  " + ex.getMessage());
                    out.println("Vendor:   " + ex.getErrorCode());
                    ex = ex.getNextException();
                    out.println("");
                }
            } catch (java.lang.Exception ex) {
                ex.printStackTrace();
            }
        }
    }
} </s>
<s>class temp {    @Override
    public KeySelectorResult select(KeyInfo keyInfo, Purpose purpose, AlgorithmMethod method, XMLCryptoContext context) throws KeySelectorException {
        try {
            return super.select(keyInfo, purpose, method, context);
        } catch (KeySelectorException e) {
            LOG.debug("no key found via ds:KeyInfo key selector");
        }
        LOG.debug("signature resource name: " + this.signatureResourceName);
        String signatureSegment = this.signatureResourceName.substring(0, this.signatureResourceName.lastIndexOf("/"));
        LOG.debug("signature segment: " + signatureSegment);
        String signatureBase = this.signatureResourceName.substring(this.signatureResourceName.lastIndexOf("/") + 1);
        LOG.debug("signature base: " + signatureBase);
        String signatureRelationshipResourceName = signatureSegment + "/_rels/" + signatureBase + ".rels";
        LOG.debug("signature relationship resource name: " + signatureRelationshipResourceName);
        ZipArchiveInputStream zipInputStream;
        try {
            zipInputStream = new ZipArchiveInputStream(this.opcUrl.openStream(), "UTF8", true, true);
        } catch (IOException e) {
            throw new KeySelectorException(e);
        }
        ZipArchiveEntry zipEntry;
        try {
            while (null != (zipEntry = zipInputStream.getNextZipEntry())) {
                if (signatureRelationshipResourceName.equals(zipEntry.getName())) {
                    break;
                }
            }
        } catch (IOException e) {
            throw new KeySelectorException(e);
        }
        if (null == zipEntry) {
            LOG.warn("relationship part not present: " + signatureRelationshipResourceName);
            throw new KeySelectorException("no key found");
        }
        LOG.debug("signature relationship part found");
        JAXBElement<CTRelationships> signatureRelationshipsElement;
        try {
            signatureRelationshipsElement = (JAXBElement<CTRelationships>) this.relationshipsUnmarshaller.unmarshal(zipInputStream);
        } catch (JAXBException e) {
            throw new KeySelectorException(e);
        }
        CTRelationships signatureRelationships = signatureRelationshipsElement.getValue();
        List<CTRelationship> signatureRelationshipList = signatureRelationships.getRelationship();
        List<String> certificateResourceNames = new LinkedList<String>();
        for (CTRelationship signatureRelationship : signatureRelationshipList) {
            if (DIGITAL_SIGNATURE_CERTIFICATE_REL_TYPE.equals(signatureRelationship.getType())) {
                String certificateResourceName = signatureRelationship.getTarget().substring(1);
                certificateResourceNames.add(certificateResourceName);
            }
        }
        X509Certificate endEntityCertificate = null;
        for (String certificateResourceName : certificateResourceNames) {
            try {
                zipInputStream = new ZipArchiveInputStream(this.opcUrl.openStream(), "UTF8", true, true);
            } catch (IOException e) {
                throw new KeySelectorException(e);
            }
            try {
                while (null != (zipEntry = zipInputStream.getNextZipEntry())) {
                    if (certificateResourceName.equals(zipEntry.getName())) {
                        break;
                    }
                }
            } catch (IOException e) {
                throw new KeySelectorException(e);
            }
            if (null == zipEntry) {
                LOG.warn("certificate part not present: " + certificateResourceName);
                continue;
            }
            X509Certificate certificate;
            try {
                certificate = (X509Certificate) this.certificateFactory.generateCertificate(zipInputStream);
            } catch (CertificateException e) {
                throw new KeySelectorException(e);
            }
            LOG.debug("certificate subject: " + certificate.getSubjectX500Principal());
            if (-1 != certificate.getBasicConstraints()) {
                LOG.debug("skipping CA certificate");
                continue;
            }
            if (null != endEntityCertificate) {
                throw new KeySelectorException("two possible end entity certificates");
            }
            endEntityCertificate = certificate;
        }
        if (null == endEntityCertificate) {
            throw new KeySelectorException("no key found");
        }
        this.certificate = endEntityCertificate;
        return this;
    }
} </s>
<s>class temp {    public static void readDefault() {
        ClassLoader l = Skeleton.class.getClassLoader();
        URL url;
        if (l != null) {
            url = l.getResource(DEFAULT_LOC);
        } else {
            url = ClassLoader.getSystemResource(DEFAULT_LOC);
        }
        if (url == null) {
            Out.error(ErrorMessages.SKEL_IO_ERROR_DEFAULT);
            throw new GeneratorException();
        }
        try {
            InputStreamReader reader = new InputStreamReader(url.openStream());
            readSkel(new BufferedReader(reader));
        } catch (IOException e) {
            Out.error(ErrorMessages.SKEL_IO_ERROR_DEFAULT);
            throw new GeneratorException();
        }
    }
} </s>
<s>class temp {    private static InputStream getCMSResultAsStream(String rqlQuery) throws RQLException {
        OutputStreamWriter osr = null;
        try {
            URL url = new URL("http", HOST, FILE);
            URLConnection conn = url.openConnection();
            conn.setDoOutput(true);
            osr = new OutputStreamWriter(conn.getOutputStream());
            osr.write(rqlQuery);
            osr.flush();
            return conn.getInputStream();
        } catch (IOException ioe) {
            throw new RQLException("IO Exception reading result from server", ioe);
        } finally {
            if (osr != null) {
                try {
                    osr.close();
                } catch (IOException ioe) {
                }
            }
        }
    }
} </s>
<s>class temp {    private boolean postCorrecao() {
        boolean valido = false;
        Integer newCodCorrecao = null;
        String sqlmaxac = "SELECT MAX(SEQAC) FROM PPOPACAOCORRET WHERE CODEMP=? AND CODFILIAL=? AND CODOP=? AND SEQOP=?";
        String sqlmaxcq = "SELECT MAX(SEQOPCQ) + 1 FROM PPOPCQ WHERE CODEMP=? AND CODFILIAL=? AND CODOP=? AND SEQOP=?";
        try {
            for (Entry<Integer, JCheckBoxPad> ek : analises.entrySet()) {
                JCheckBoxPad cb = ek.getValue();
                if ("S".equals(cb.getVlrString())) {
                    valido = true;
                    keysItens[2] = ek.getKey();
                    break;
                }
            }
            if (!valido) {
                Funcoes.mensagemInforma(this, "Selecione as analises para aplicar a corre  o!");
                return false;
            }
            if (txaCausa.getVlrString().trim().length() == 0) {
                Funcoes.mensagemInforma(this, "Informe as causas!");
                return false;
            }
            if (txaAcao.getVlrString().trim().length() == 0) {
                Funcoes.mensagemInforma(this, "Detalhe a a  o corretiva!");
                return false;
            }
            PreparedStatement ps = con.prepareStatement(sqlmaxac);
            ps.setInt(1, Aplicativo.iCodEmp);
            ps.setInt(2, ListaCampos.getMasterFilial("PPOPACAOCORRET"));
            ps.setInt(3, txtCodOP.getVlrInteger());
            ps.setInt(4, txtSeqOP.getVlrInteger());
            ResultSet rs = ps.executeQuery();
            if (rs.next()) {
                newCodCorrecao = rs.getInt(1) + 1;
                keysItens[3] = newCodCorrecao;
            }
            rs.close();
            ps.close();
            if (newCodCorrecao != null) {
                StringBuilder sql = new StringBuilder();
                sql.append("INSERT INTO PPOPACAOCORRET ");
                sql.append("( CODEMP, CODFILIAL, CODOP, SEQOP, SEQAC, TPCAUSA, OBSCAUSA, TPACAO, OBSACAO ) ");
                sql.append("VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ? )");
                ps = con.prepareStatement(sql.toString());
                ps.setInt(1, Aplicativo.iCodEmp);
                ps.setInt(2, ListaCampos.getMasterFilial("PPOPACAOCORRET"));
                ps.setInt(3, txtCodOP.getVlrInteger());
                ps.setInt(4, txtSeqOP.getVlrInteger());
                ps.setInt(5, newCodCorrecao);
                ps.setString(6, m.getCode());
                ps.setString(7, txaCausa.getVlrString());
                ps.setString(8, rgSolucao.getVlrString());
                ps.setString(9, txaAcao.getVlrString());
                ps.execute();
                ps.close();
                String strAnalises = "";
                for (Entry<Integer, JCheckBoxPad> ek : analises.entrySet()) {
                    JCheckBoxPad cb = ek.getValue();
                    if ("S".equals(cb.getVlrString())) {
                        if (strAnalises.trim().length() > 0) {
                            strAnalises += ",";
                        }
                        strAnalises += String.valueOf(ek.getKey());
                    }
                }
                sql = new StringBuilder();
                sql.append("UPDATE PPOPCQ SET SEQAC=? ");
                sql.append("WHERE CODEMP=? AND CODFILIAL=? AND CODOP=? AND SEQOP=? AND SEQOPCQ IN ( " + strAnalises + " )");
                ps = con.prepareStatement(sql.toString());
                ps.setInt(1, newCodCorrecao);
                ps.setInt(2, Aplicativo.iCodEmp);
                ps.setInt(3, ListaCampos.getMasterFilial("PPOPACAOCORRET"));
                ps.setInt(4, txtCodOP.getVlrInteger());
                ps.setInt(5, txtSeqOP.getVlrInteger());
                ps.executeUpdate();
                ps.close();
                sql.delete(0, sql.length());
                sql.append("INSERT INTO PPOPCQ (CODEMP,CODFILIAL,CODOP,SEQOP,SEQOPCQ,");
                sql.append("CODEMPEA,CODFILIALEA,CODESTANALISE) ");
                sql.append("SELECT CODEMP,CODFILIAL,CODOP,SEQOP,(");
                sql.append(sqlmaxcq);
                sql.append("),CODEMPEA,CODFILIALEA,CODESTANALISE ");
                sql.append("FROM PPOPCQ ");
                sql.append("WHERE CODEMP=? AND CODFILIAL=? AND CODOP=? AND ");
                sql.append("SEQOP=? AND SEQOPCQ IN ( " + strAnalises + " )");
                System.out.println(sql.toString());
                ps = con.prepareStatement(sql.toString());
                ps = con.prepareStatement(sql.toString());
                ps.setInt(1, Aplicativo.iCodEmp);
                ps.setInt(2, ListaCampos.getMasterFilial("PPOPCQ"));
                ps.setInt(3, txtCodOP.getVlrInteger());
                ps.setInt(4, txtSeqOP.getVlrInteger());
                ps.setInt(5, Aplicativo.iCodEmp);
                ps.setInt(6, ListaCampos.getMasterFilial("PPOPCQ"));
                ps.setInt(7, txtCodOP.getVlrInteger());
                ps.setInt(8, txtSeqOP.getVlrInteger());
                ps.executeUpdate();
                ps.close();
                montaAnalises();
                Funcoes.mensagemInforma(this, "A  o corretiva aplicada com sucesso!");
            }
            con.commit();
        } catch (Exception err) {
            try {
                con.rollback();
            } catch (SQLException e) {
                System.out.println("Erro ao realizar rollback!\n" + err.getMessage());
            }
            err.printStackTrace();
            Funcoes.mensagemErro(this, "Erro ao atualizar analises!\n" + err.getMessage(), true, con, err);
            valido = false;
        }
        return valido;
    }
} </s>
<s>class temp {    public ContourGenerator(URL url, float modelMean, float modelStddev) throws IOException {
        this.modelMean = modelMean;
        this.modelStddev = modelStddev;
        List termsList = new ArrayList();
        String line;
        BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));
        line = reader.readLine();
        while (line != null) {
            if (!line.startsWith("***")) {
                parseAndAdd(termsList, line);
            }
            line = reader.readLine();
        }
        terms = (F0ModelTerm[]) termsList.toArray(terms);
        reader.close();
    }
} </s>
<s>class temp {    private LSInput resolveResource(String aPublicId, String aSystemId, String aBaseURI, boolean baseUsed) {
        LSInput lsInput = new DefaultLSInput();
        lsInput.setPublicId(aPublicId);
        lsInput.setSystemId(aSystemId);
        String base = null;
        try {
            int baseEndPos = -1;
            if (aBaseURI != null) {
                baseEndPos = aBaseURI.lastIndexOf("/");
            }
            if (baseEndPos <= 0) {
                if (baseUsed) {
                    return null;
                } else {
                    return resolveResource(aPublicId, aSystemId, schemaBasePath + "/" + aSystemId, true);
                }
            }
            base = aBaseURI.substring(0, baseEndPos);
            URL url = new URL(base + "/" + aSystemId);
            lsInput.setByteStream(url.openConnection().getInputStream());
            return lsInput;
        } catch (IOException e) {
            return resolveResource(aPublicId, aSystemId, base, baseUsed);
        }
    }
} </s>
<s>class temp {    public static void copyFile(File src, File dst) throws IOException {
        InputStream in = new FileInputStream(src);
        OutputStream out = new FileOutputStream(dst);
        byte[] buf = new byte[1024];
        int len;
        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);
        in.close();
        out.close();
    }
} </s>
<s>class temp {    public byte[] computeMD5(String plainText) throws VHException {
        MessageDigest md = null;
        try {
            md = MessageDigest.getInstance("MD5");
        } catch (NoSuchAlgorithmException ex) {
            throw new VHException("The MD5 hash algorithm is not available.", ex);
        }
        try {
            md.update(plainText.getBytes("UTF-8"));
        } catch (UnsupportedEncodingException ex) {
            throw new VHException("The UTF-8 encoding is not supported.", ex);
        }
        return md.digest();
    }
} </s>
<s>class temp {    @Override
    public int run() {
        Enumeration<?> e;
        try {
            e = About.class.getClassLoader().getResources("META-INF/MANIFEST.MF");
            while (e.hasMoreElements()) {
                final URL url = (URL) e.nextElement();
                if (url.toString().indexOf("renaissance") != -1) {
                    final InputStream is = url.openStream();
                    Properties p = new Properties();
                    p.load(is);
                    for (Entry<?, ?> entry : p.entrySet()) {
                        System.err.println(entry);
                    }
                }
            }
        } catch (IOException e1) {
            logger.fatal("Caught an exception " + e1);
            return 1;
        }
        System.err.println("Classpath is " + System.getProperty("java.class.path"));
        return 0;
    }
} </s>
<s>class temp {    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String target = null;
        boolean allowedToAccess = false;
        try {
            URL requestUrl = new URL("http:/" + request.getPathInfo());
            for (Enumeration en = allowedUrls.elements(); en.hasMoreElements(); ) {
                URL nextUrl = (URL) en.nextElement();
                if ((nextUrl).getHost().equalsIgnoreCase(requestUrl.getHost())) {
                    allowedToAccess = true;
                }
            }
        } catch (MalformedURLException ex) {
            System.err.println("Error in url: " + "http:/" + request.getPathInfo());
            return;
        }
        if (!allowedToAccess) {
            response.setStatus(407);
            return;
        }
        if (request.getPathInfo() != null && !request.getPathInfo().equals("")) {
            target = "http:/" + request.getPathInfo() + "?" + request.getQueryString();
        } else {
            response.setStatus(404);
            return;
        }
        InputStream is = null;
        ServletOutputStream out = null;
        try {
            URL url = new URL(target);
            URLConnection uc = url.openConnection();
            response.setContentType(uc.getContentType());
            is = uc.getInputStream();
            out = response.getOutputStream();
            byte[] buf = new byte[4096];
            int bytesRead;
            while ((bytesRead = is.read(buf)) != -1) {
                out.write(buf, 0, bytesRead);
            }
        } catch (MalformedURLException e) {
            response.setStatus(404);
        } catch (IOException e) {
            response.setStatus(404);
        } finally {
            if (is != null) {
                is.close();
            }
            if (out != null) {
                out.close();
            }
        }
    }
} </s>
<s>class temp {    private List<String> createProjectInfoFile() throws SocketException, IOException {
        FTPClient client = new FTPClient();
        Set<String> projects = new HashSet<String>();
        client.connect("ftp.drupal.org");
        System.out.println("Connected to ftp.drupal.org");
        System.out.println(client.getReplyString());
        boolean loggedIn = client.login("anonymous", "info@regilo.org");
        if (loggedIn) {
            FTPFile[] files = client.listFiles("pub/drupal/files/projects");
            for (FTPFile file : files) {
                String name = file.getName();
                Pattern p = Pattern.compile("([a-zAZ_]*)-(\\d.x)-(.*)");
                Matcher m = p.matcher(name);
                if (m.matches()) {
                    String projectName = m.group(1);
                    String version = m.group(2);
                    if (version.equals("6.x")) {
                        projects.add(projectName);
                    }
                }
            }
        }
        List<String> projectList = new ArrayList<String>();
        for (String project : projects) {
            projectList.add(project);
        }
        Collections.sort(projectList);
        return projectList;
    }
} </s>
<s>class temp {    public String getContentAsString(String url) {
        StringBuffer sb = new StringBuffer("");
        try {
            URL urlmy = new URL(url);
            HttpURLConnection con = (HttpURLConnection) urlmy.openConnection();
            HttpURLConnection.setFollowRedirects(true);
            con.setInstanceFollowRedirects(false);
            con.connect();
            BufferedReader br = new BufferedReader(new InputStreamReader(con.getInputStream(), "UTF-8"));
            String s = "";
            while ((s = br.readLine()) != null) {
                sb.append(s + "\r\n");
            }
            con.disconnect();
        } catch (Exception ex) {
            this.logException(ex);
        }
        return sb.toString();
    }
} </s>
<s>class temp {        public void actionPerformed(ActionEvent e) {
            try {
                URL url = new URL("http://mailsomething.sf.net/helppages.xml");
                try {
                    File file = File.createTempFile("temp", "xml");
                    InputStream in = new BufferedInputStream(url.openStream());
                    OutputStream out = new FileOutputStream(file);
                    byte[] buf = new byte[1024];
                    int n;
                    while ((n = in.read(buf)) > 0) out.write(buf, 0, n);
                    out.flush();
                    out.close();
                    module.merge(file);
                } catch (IOException f) {
                }
            } catch (MalformedURLException f) {
            }
        }
} </s>
<s>class temp {    public static String encrypt(String message) {
        try {
            MessageDigest digest = MessageDigest.getInstance("MD5");
            digest.update(message.getBytes());
            BASE64Encoder encoder = new BASE64Encoder();
            return encoder.encode(digest.digest());
        } catch (NoSuchAlgorithmException ex) {
            ex.printStackTrace();
            return null;
        }
    }
} </s>
<s>class temp {    private Properties loadProperties(final String propertiesName) throws IOException {
        Properties bundle = null;
        final ClassLoader loader = Thread.currentThread().getContextClassLoader();
        final URL url = loader.getResource(propertiesName);
        if (url == null) {
            throw new IOException("Properties file " + propertiesName + " not found");
        }
        final InputStream is = url.openStream();
        if (is != null) {
            bundle = new Properties();
            bundle.load(is);
        } else {
            throw new IOException("Properties file " + propertiesName + " not avilable");
        }
        return bundle;
    }
} </s>
<s>class temp {    public void render(final HttpServletRequest request, final HttpServletResponse response, final byte[] bytes, final Throwable t, final String contentType, final String encoding) throws Exception {
        if (contentType != null) {
            response.setContentType(contentType);
        }
        if (encoding != null) {
            response.setCharacterEncoding(encoding);
        }
        response.setContentLength(bytes.length);
        IOUtils.copy(new ByteArrayInputStream(bytes), response.getOutputStream());
    }
} </s>
<s>class temp {    private File extractSiteFile() {
        final URL url = TestCrueCONF.class.getResource(CONFIG_SITE);
        final File confFile = new File(createTempDir(), "FudaaCrue_Site.xml");
        try {
            CtuluLibFile.copyStream(url.openStream(), new FileOutputStream(confFile), true, true);
        } catch (Exception e) {
            Logger.getLogger(TestCrueCONF.class.getName()).log(Level.SEVERE, "erreur while extracting FudaaCrue_Site.xml", e);
            fail(e.getMessage());
        }
        return confFile;
    }
} </s>
<s>class temp {    @Test
    public void testMark() throws IllegalArgumentException, IOException {
        Assert.assertNotNull(this.m_detector);
        File f = new File("testdocuments/voiddocument/Voiderror.htm");
        Assert.assertTrue("Test file " + f.getAbsolutePath() + " does not exist. ", f.exists());
        URL url = f.toURL();
        this.m_detector.detectCodepage(url.openStream(), 200);
    }
} </s>
<s>class temp {    @SuppressWarnings("unchecked")
    public static void createInstance(ExternProtoDeclare externProtoDeclare) {
        ExternProtoDeclareImport epdi = new ExternProtoDeclareImport();
        HashMap<String, ProtoDeclareImport> protoMap = X3DImport.getTheImport().getCurrentParser().getProtoMap();
        boolean loadedFromWeb = false;
        File f = null;
        URL url = null;
        List<String> urls = externProtoDeclare.getUrl();
        String tmpUrls = urls.toString();
        urls = Util.splitStringToListOfStrings(tmpUrls);
        String protoName = null;
        int urlCount = urls.size();
        for (int urlIndex = 0; urlIndex < urlCount; urlIndex++) {
            try {
                String path = urls.get(urlIndex);
                if (path.startsWith("\"") && path.endsWith("\"")) path = path.substring(1, path.length() - 1);
                int hashMarkPos = path.indexOf("#");
                int urlLength = path.length();
                if (hashMarkPos == -1) path = path.substring(0, urlLength); else {
                    protoName = path.substring(hashMarkPos + 1, urlLength);
                    path = path.substring(0, hashMarkPos);
                }
                if (path.toLowerCase().startsWith("http://")) {
                    String filename = path.substring(path.lastIndexOf("/") + 1, path.lastIndexOf("."));
                    String fileext = path.substring(path.lastIndexOf("."), path.length());
                    f = File.createTempFile(filename, fileext);
                    url = new URL(path);
                    InputStream is = url.openStream();
                    FileOutputStream os = new FileOutputStream(f);
                    byte[] buffer = new byte[0xFFFF];
                    for (int len; (len = is.read(buffer)) != -1; ) os.write(buffer, 0, len);
                    is.close();
                    os.close();
                    url = f.toURI().toURL();
                    loadedFromWeb = true;
                } else {
                    if (path.startsWith("/") || (path.charAt(1) == ':')) {
                    } else {
                        File x3dfile = X3DImport.getTheImport().getCurrentParser().getFile();
                        path = Util.getRealPath(x3dfile) + path;
                    }
                    f = new File(path);
                    url = f.toURI().toURL();
                    Object testContent = url.getContent();
                    if (testContent == null) continue;
                    loadedFromWeb = false;
                }
                X3DDocument x3dDocument = null;
                try {
                    x3dDocument = X3DDocument.Factory.parse(f);
                } catch (XmlException e) {
                    e.printStackTrace();
                    return;
                } catch (IOException e) {
                    e.printStackTrace();
                    return;
                }
                Scene scene = x3dDocument.getX3D().getScene();
                ProtoDeclare[] protos = scene.getProtoDeclareArray();
                ProtoDeclare protoDeclare = null;
                if (protoName == null) {
                    protoDeclare = protos[0];
                } else {
                    for (ProtoDeclare proto : protos) {
                        if (proto.getName().equals(protoName)) {
                            protoDeclare = proto;
                            break;
                        }
                    }
                }
                if (protoDeclare == null) continue;
                ProtoBody protoBody = protoDeclare.getProtoBody();
                epdi.protoBody = protoBody;
                protoMap.put(externProtoDeclare.getName(), epdi);
                break;
            } catch (MalformedURLException e) {
            } catch (IOException e) {
            } finally {
                if (loadedFromWeb && f != null) {
                    f.delete();
                }
            }
        }
    }
} </s>
<s>class temp {    public static String addWeibo(String weibo, File pic, String uid) throws Throwable {
        List<NameValuePair> qparams = new ArrayList<NameValuePair>();
        qparams.add(new BasicNameValuePair("_surl", ""));
        qparams.add(new BasicNameValuePair("_t", "0"));
        qparams.add(new BasicNameValuePair("location", "home"));
        qparams.add(new BasicNameValuePair("module", "stissue"));
        if (pic != null) {
            String picId = upLoadImg(pic, uid);
            qparams.add(new BasicNameValuePair("pic_id", picId));
        }
        qparams.add(new BasicNameValuePair("rank", "weibo"));
        qparams.add(new BasicNameValuePair("text", weibo));
        HttpPost post = getHttpPost("http://weibo.com/aj/mblog/add?__rnd=1333611402611", uid);
        UrlEncodedFormEntity params = new UrlEncodedFormEntity(qparams, HTTP.UTF_8);
        post.setEntity(params);
        HttpResponse response = client.execute(post);
        HttpEntity entity = response.getEntity();
        String content = EntityUtils.toString(entity, HTTP.UTF_8);
        post.abort();
        return content;
    }
} </s>
<s>class temp {    public static String upLoadImg(File pic, String uid) throws Throwable {
        System.out.println("开始上传=======================================================");
        HttpPost post = getHttpPost(getUploadUrl(uid), uid);
        FileBody file = new FileBody(pic, "image/jpg");
        MultipartEntity reqEntity = new MultipartEntity();
        reqEntity.addPart("pic1", file);
        post.setEntity(reqEntity);
        HttpResponse response = client.execute(post);
        int status = response.getStatusLine().getStatusCode();
        post.abort();
        if (status == HttpStatus.SC_MOVED_TEMPORARILY || status == HttpStatus.SC_MOVED_PERMANENTLY) {
            String newuri = response.getHeaders("location")[0].getValue();
            System.out.println(newuri);
            return newuri.substring(newuri.indexOf("pid=") + 4, newuri.indexOf("&token="));
        }
        return null;
    }
} </s>
<s>class temp {    protected void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        response.setContentType("application/zip");
        response.setHeader("Content-Disposition", "inline; filename=c:/server1.zip");
        try {
            BufferedInputStream origin = null;
            FileOutputStream dest = new FileOutputStream("server.zip");
            ZipOutputStream zipOut = new ZipOutputStream(new BufferedOutputStream(dest));
            byte data[] = new byte[BUFFER];
            java.util.Properties props = new java.util.Properties();
            props.load(new java.io.FileInputStream(ejb.bprocess.util.NewGenLibRoot.getRoot() + "/SystemFiles/ENV_VAR.txt"));
            String jbossHomePath = props.getProperty("JBOSS_HOME");
            jbossHomePath = jbossHomePath.replaceAll("deploy", "log");
            FileInputStream fis = new FileInputStream(new File(jbossHomePath + "/server.log"));
            origin = new BufferedInputStream(fis, BUFFER);
            ZipEntry entry = new ZipEntry(jbossHomePath + "/server.log");
            zipOut.putNextEntry(entry);
            int count;
            while ((count = origin.read(data, 0, BUFFER)) != -1) {
                zipOut.write(data, 0, count);
            }
            origin.close();
            zipOut.closeEntry();
            java.io.FileInputStream fis1 = new java.io.FileInputStream(new java.io.File("server.zip"));
            java.nio.channels.FileChannel fc1 = fis1.getChannel();
            int length1 = (int) fc1.size();
            byte buffer[] = new byte[length1];
            System.out.println("size of zip file = " + length1);
            fis1.read(buffer);
            OutputStream out1 = response.getOutputStream();
            out1.write(buffer);
            fis1.close();
            out1.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
} </s>
<s>class temp {    private static void _readAllRegionMDFiles(ClassLoader loader, RegionMetadata bean, String regionMDFile) {
        if (_LOG.isFinest()) {
            _LOG.finest("searching for region-metadata with resource:{0}", regionMDFile);
        }
        try {
            Enumeration<URL> files = loader.getResources(regionMDFile);
            while (files.hasMoreElements()) {
                URL url = files.nextElement();
                String publicId = url.toString();
                try {
                    InputStream in = url.openStream();
                    _readRegionMetadata(bean, in, publicId);
                    in.close();
                } catch (IOException e) {
                    _error(publicId, e);
                }
            }
        } catch (IOException e) {
            _LOG.warning("ERR_GET_REGION_METADATA_FILE", __CONFIG_FILE_OTHER);
            _LOG.warning(e);
        }
    }
} </s>
<s>class temp {    public void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
        String version = req.getParameter("version");
        String cdn = req.getParameter("cdn");
        String dependencies = req.getParameter("dependencies");
        String optimize = req.getParameter("optimize");
        String cacheFile = null;
        String result = null;
        boolean isCached = false;
        Boolean isError = true;
        if (!version.equals("1.3.2")) {
            result = "invalid version: " + version;
        }
        if (!cdn.equals("google") && !cdn.equals("aol")) {
            result = "invalide CDN type: " + cdn;
        }
        if (!optimize.equals("comments") && !optimize.equals("shrinksafe") && !optimize.equals("none") && !optimize.equals("shrinksafe.keepLines")) {
            result = "invalid optimize type: " + optimize;
        }
        if (!dependencies.matches("^[\\w\\-\\,\\s\\.]+$")) {
            result = "invalid dependency list: " + dependencies;
        }
        try {
            MessageDigest md = null;
            try {
                md = MessageDigest.getInstance("SHA");
            } catch (NoSuchAlgorithmException e) {
                result = e.getMessage();
            }
            if (result == null) {
                md.update(dependencies.getBytes());
                String digest = (new BASE64Encoder()).encode(md.digest()).replace('+', '~').replace('/', '_').replace('=', '_');
                cacheFile = cachePath + "/" + version + "/" + cdn + "/" + digest + "/" + optimize + ".js";
                File file = new File(cacheFile);
                if (file.exists()) {
                    isCached = true;
                    isError = false;
                }
            }
            if (result == null && !isCached) {
                BuilderContextAction contextAction = new BuilderContextAction(builderPath, version, cdn, dependencies, optimize);
                ContextFactory.getGlobal().call(contextAction);
                Exception exception = contextAction.getException();
                if (exception != null) {
                    result = exception.getMessage();
                } else {
                    result = contextAction.getResult();
                    FileUtil.writeToFile(cacheFile, result, null, true);
                    isError = false;
                }
            }
        } catch (Exception e) {
            result = e.getMessage();
        }
        res.setCharacterEncoding("utf-8");
        if (isError) {
            result = result.replaceAll("\\\"", "\\\"");
            result = "<html><head><script type=\"text/javascript\">alert(\"" + result + "\");</script></head><body></body></html>";
            PrintWriter writer = res.getWriter();
            writer.append(result);
        } else {
            res.setHeader("Content-Type", "application/x-javascript");
            res.setHeader("Content-disposition", "attachment; filename=dojo.js");
            res.setHeader("Content-Encoding", "gzip");
            File file = new File(cacheFile);
            BufferedInputStream in = new java.io.BufferedInputStream(new DataInputStream(new FileInputStream(file)));
            OutputStream out = res.getOutputStream();
            byte[] bytes = new byte[64000];
            int bytesRead = 0;
            while (bytesRead != -1) {
                bytesRead = in.read(bytes);
                if (bytesRead != -1) {
                    out.write(bytes, 0, bytesRead);
                }
            }
        }
    }
} </s>
<s>class temp {    public static void main(String[] args) throws IOException {
        ReadableByteChannel in = Channels.newChannel((new FileInputStream("/home/sannies/suckerpunch-distantplanet_h1080p/suckerpunch-distantplanet_h1080p.mov")));
        Movie movie = MovieCreator.build(in);
        in.close();
        List<Track> tracks = movie.getTracks();
        movie.setTracks(new LinkedList<Track>());
        double startTime = 35.000;
        double endTime = 145.000;
        boolean timeCorrected = false;
        for (Track track : tracks) {
            if (track.getSyncSamples() != null && track.getSyncSamples().length > 0) {
                if (timeCorrected) {
                    throw new RuntimeException("The startTime has already been corrected by another track with SyncSample. Not Supported.");
                }
                startTime = correctTimeToNextSyncSample(track, startTime);
                endTime = correctTimeToNextSyncSample(track, endTime);
                timeCorrected = true;
            }
        }
        for (Track track : tracks) {
            long currentSample = 0;
            double currentTime = 0;
            long startSample = -1;
            long endSample = -1;
            for (int i = 0; i < track.getDecodingTimeEntries().size(); i++) {
                TimeToSampleBox.Entry entry = track.getDecodingTimeEntries().get(i);
                for (int j = 0; j < entry.getCount(); j++) {
                    if (currentTime <= startTime) {
                        startSample = currentSample;
                    }
                    if (currentTime <= endTime) {
                        endSample = currentSample;
                    } else {
                        break;
                    }
                    currentTime += (double) entry.getDelta() / (double) track.getTrackMetaData().getTimescale();
                    currentSample++;
                }
            }
            movie.addTrack(new CroppedTrack(track, startSample, endSample));
        }
        long start1 = System.currentTimeMillis();
        IsoFile out = new DefaultMp4Builder().build(movie);
        long start2 = System.currentTimeMillis();
        FileOutputStream fos = new FileOutputStream(String.format("output-%f-%f.mp4", startTime, endTime));
        FileChannel fc = fos.getChannel();
        out.getBox(fc);
        fc.close();
        fos.close();
        long start3 = System.currentTimeMillis();
        System.err.println("Building IsoFile took : " + (start2 - start1) + "ms");
        System.err.println("Writing IsoFile took  : " + (start3 - start2) + "ms");
        System.err.println("Writing IsoFile speed : " + (new File(String.format("output-%f-%f.mp4", startTime, endTime)).length() / (start3 - start2) / 1000) + "MB/s");
    }
} </s>
<s>class temp {    public ABIFile(URL url) throws FileFormatException, IOException {
        URLConnection connection = url.openConnection();
        int contentLength = connection.getContentLength();
        if (contentLength <= 0) throw new RuntimeException(url + " contained no content");
        byte[] content = new byte[contentLength];
        DataInputStream dis = new DataInputStream(connection.getInputStream());
        dis.readFully(content);
        dis.close();
        dis = new DataInputStream(new ByteArrayInputStream(content));
        if (!isABI(dis)) {
            throw new FileFormatException(url + " is not an ABI trace file");
        }
        char[] fwo = null;
        dis.reset();
        dis.skipBytes(18);
        int len = dis.readInt();
        dis.skipBytes(4);
        int off = dis.readInt();
        ABIRecord[] data = new ABIRecord[12];
        ABIRecord[] pbas = new ABIRecord[2];
        ABIRecord[] ploc = new ABIRecord[2];
        dis.reset();
        dis.skipBytes(off);
        for (; len > 0; len--) {
            ABIRecord rec = new ABIRecord(dis);
            if (rec.tag.equals("DATA")) {
                try {
                    data[rec.n - 1] = rec;
                } catch (ArrayIndexOutOfBoundsException e) {
                    System.err.println("ABI record contains erroneous n field");
                }
            } else if (rec.tag.equals("FWO_")) {
                fwo = ((String) rec.data).toCharArray();
            } else if (rec.tag.equals("PBAS")) {
                pbas[rec.n - 1] = rec;
            } else if (rec.tag.equals("PLOC")) {
                ploc[rec.n - 1] = rec;
            }
        }
        traceLength = data[8].len;
        sequenceLength = pbas[1].len;
        A = new short[traceLength];
        C = new short[traceLength];
        G = new short[traceLength];
        T = new short[traceLength];
        max = Short.MIN_VALUE;
        for (int i = 0; i < 4; i++) {
            dis.reset();
            dis.skipBytes(data[8 + i].off);
            short[] current = traceArray(fwo[i]);
            for (int j = 0; j < traceLength; j++) {
                current[j] = dis.readShort();
                if (current[j] > max) max = current[j];
            }
        }
        byte[] buf = new byte[sequenceLength];
        dis.reset();
        dis.skipBytes(pbas[1].off);
        dis.readFully(buf);
        sequence = new String(buf);
        centers = new short[sequenceLength];
        dis.reset();
        dis.skipBytes(ploc[1].off);
        for (int i = 0; i < sequenceLength; i++) centers[i] = dis.readShort();
    }
} </s>
<s>class temp {    private void _resetLanguages(ActionRequest req, ActionResponse res, PortletConfig config, ActionForm form) throws Exception {
        List list = (List) req.getAttribute(WebKeys.LANGUAGE_MANAGER_LIST);
        for (int i = 0; i < list.size(); i++) {
            long langId = ((Language) list.get(i)).getId();
            try {
                String filePath = getGlobalVariablesPath() + "cms_language_" + langId + ".properties";
                File from = new java.io.File(filePath);
                from.createNewFile();
                String tmpFilePath = getTemporyDirPath() + "cms_language_" + langId + "_properties.tmp";
                File to = new java.io.File(tmpFilePath);
                to.createNewFile();
                FileChannel srcChannel = new FileInputStream(from).getChannel();
                FileChannel dstChannel = new FileOutputStream(to).getChannel();
                dstChannel.transferFrom(srcChannel, 0, srcChannel.size());
                srcChannel.close();
                dstChannel.close();
            } catch (IOException e) {
                Logger.debug(this, "Property File copy Failed " + e, e);
            }
        }
    }
} </s>
<s>class temp {    private void _checkLanguagesFiles(ActionRequest req, ActionResponse res, PortletConfig config, ActionForm form) throws Exception {
        List list = (List) req.getAttribute(WebKeys.LANGUAGE_MANAGER_LIST);
        for (int i = 0; i < list.size(); i++) {
            long langId = ((Language) list.get(i)).getId();
            try {
                String filePath = getGlobalVariablesPath() + "cms_language_" + langId + ".properties";
                boolean copy = false;
                File from = new java.io.File(filePath);
                if (!from.exists()) {
                    from.createNewFile();
                    copy = true;
                }
                String tmpFilePath = getTemporyDirPath() + "cms_language_" + langId + "_properties.tmp";
                File to = new java.io.File(tmpFilePath);
                if (!to.exists()) {
                    to.createNewFile();
                    copy = true;
                }
                if (copy) {
                    FileChannel srcChannel = new FileInputStream(from).getChannel();
                    FileChannel dstChannel = new FileOutputStream(to).getChannel();
                    dstChannel.transferFrom(srcChannel, 0, srcChannel.size());
                    srcChannel.close();
                    dstChannel.close();
                }
            } catch (IOException e) {
                Logger.error(this, "_checkLanguagesFiles:Property File Copy Failed " + e, e);
            }
        }
    }
} </s>
<s>class temp {    private void _save(ActionRequest req, ActionResponse res, PortletConfig config, ActionForm form) throws Exception {
        List list = (List) req.getAttribute(WebKeys.LANGUAGE_MANAGER_LIST);
        for (int i = 0; i < list.size(); i++) {
            long langId = ((Language) list.get(i)).getId();
            try {
                String filePath = getGlobalVariablesPath() + "cms_language_" + langId + ".properties";
                String tmpFilePath = getTemporyDirPath() + "cms_language_" + langId + "_properties.tmp";
                File from = new java.io.File(tmpFilePath);
                from.createNewFile();
                File to = new java.io.File(filePath);
                to.createNewFile();
                FileChannel srcChannel = new FileInputStream(from).getChannel();
                FileChannel dstChannel = new FileOutputStream(to).getChannel();
                dstChannel.transferFrom(srcChannel, 0, srcChannel.size());
                srcChannel.close();
                dstChannel.close();
            } catch (NonWritableChannelException we) {
            } catch (IOException e) {
                Logger.error(this, "Property File save Failed " + e, e);
            }
        }
        SessionMessages.add(req, "message", "message.languagemanager.save");
    }
} </s>
<s>class temp {    @Test
    public void behaveTest() {
        InputStream is = this.getClass().getResourceAsStream("safetyCaseTest.mdf");
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        try {
            IOUtils.copy(is, out);
        } catch (IOException e) {
            throw new RuntimeException("Unable to read mdf", e);
        }
        TrafficSimulationEngine engine = new TrafficSimulationEngine();
        TrafficModelDefinition def = MDFReader.read(out.toByteArray());
        engine.init(def);
        Map<Integer, Set<Integer>> linkSegments = new HashMap<Integer, Set<Integer>>();
        Set<Integer> segments = new HashSet<Integer>();
        segments.add(0);
        linkSegments.put(0, segments);
        FrameProperties frameProperties = new FrameProperties(linkSegments, new HashSet<Integer>());
        engine.setFrameProperties(frameProperties);
        RegularVehicle vehicle = (RegularVehicle) engine.getDynamicObjects().iterator().next();
        CompositeDriver driver = (CompositeDriver) vehicle.getDriver();
        driver.drive(0.1f);
        SafetyCase safety = new SafetyCase(driver);
        RectangleCCRange ccRange = (RectangleCCRange) safety.behave(0.1f);
        HandRange turnRange = ccRange.getTurnRange();
        HandRange probeRange = new HandRange();
        probeRange.remove(Hand.Left);
        assertTrue(turnRange.equals(probeRange));
        assertTrue(ccRange.getPriority() == Priority.SafetyCase);
    }
} </s>
<s>class temp {    private static boolean moveFiles(String sourceDir, String targetDir) {
        boolean isFinished = false;
        boolean fileMoved = false;
        File stagingDir = new File(sourceDir);
        if (!stagingDir.exists()) {
            System.out.println(getTimeStamp() + "ERROR - source directory does not exist.");
            return true;
        }
        if (stagingDir.listFiles() == null) {
            System.out.println(getTimeStamp() + "ERROR - Empty file list. Possible permission error on source directory " + sourceDir);
            return true;
        }
        File[] fileList = stagingDir.listFiles();
        for (int x = 0; x < fileList.length; x++) {
            File f = fileList[x];
            if (f.getName().startsWith(".")) {
                continue;
            }
            String targetFileName = targetDir + File.separator + f.getName();
            String operation = "move";
            boolean success = f.renameTo(new File(targetFileName));
            if (success) {
                fileMoved = true;
            } else {
                operation = "mv";
                try {
                    Process process = Runtime.getRuntime().exec(new String[] { "mv", f.getCanonicalPath(), targetFileName });
                    process.waitFor();
                    process.destroy();
                    if (!new File(targetFileName).exists()) {
                        success = false;
                    } else {
                        success = true;
                        fileMoved = true;
                    }
                } catch (Exception e) {
                    success = false;
                }
                if (!success) {
                    operation = "copy";
                    FileChannel in = null;
                    FileChannel out = null;
                    try {
                        in = new FileInputStream(f).getChannel();
                        File outFile = new File(targetFileName);
                        out = new FileOutputStream(outFile).getChannel();
                        in.transferTo(0, in.size(), out);
                        in.close();
                        in = null;
                        out.close();
                        out = null;
                        f.delete();
                        success = true;
                    } catch (Exception e) {
                        success = false;
                    } finally {
                        if (in != null) {
                            try {
                                in.close();
                            } catch (Exception e) {
                            }
                        }
                        if (out != null) {
                            try {
                                out.close();
                            } catch (Exception e) {
                            }
                        }
                    }
                }
            }
            if (success) {
                System.out.println(getTimeStamp() + operation + " " + f.getAbsolutePath() + " to " + targetDir);
                fileMoved = true;
            } else {
                System.out.println(getTimeStamp() + "ERROR - " + operation + " " + f.getName() + " to " + targetFileName + " failed.");
                isFinished = true;
            }
        }
        if (fileMoved && !isFinished) {
            try {
                currentLastActivity = System.currentTimeMillis();
                updateLastActivity(currentLastActivity);
            } catch (NumberFormatException e) {
                System.out.println(getTimeStamp() + "ERROR: NumberFormatException when trying to update lastActivity.");
                isFinished = true;
            } catch (IOException e) {
                System.out.println(getTimeStamp() + "ERROR: IOException when trying to update lastActivity. " + e.toString());
                isFinished = true;
            }
        }
        return isFinished;
    }
} </s>
<s>class temp {    protected Resolver queryResolver(String resolver, String command, String arg1, String arg2) {
        InputStream iStream = null;
        String RFC2483 = resolver + "?command=" + command + "&format=tr9401&uri=" + arg1 + "&uri2=" + arg2;
        String line = null;
        try {
            URL url = new URL(RFC2483);
            URLConnection urlCon = url.openConnection();
            urlCon.setUseCaches(false);
            Resolver r = (Resolver) newCatalog();
            String cType = urlCon.getContentType();
            if (cType.indexOf(";") > 0) {
                cType = cType.substring(0, cType.indexOf(";"));
            }
            r.parseCatalog(cType, urlCon.getInputStream());
            return r;
        } catch (CatalogException cex) {
            if (cex.getExceptionType() == CatalogException.UNPARSEABLE) {
                catalogManager.debug.message(1, "Unparseable catalog: " + RFC2483);
            } else if (cex.getExceptionType() == CatalogException.UNKNOWN_FORMAT) {
                catalogManager.debug.message(1, "Unknown catalog format: " + RFC2483);
            }
            return null;
        } catch (MalformedURLException mue) {
            catalogManager.debug.message(1, "Malformed resolver URL: " + RFC2483);
            return null;
        } catch (IOException ie) {
            catalogManager.debug.message(1, "I/O Exception opening resolver: " + RFC2483);
            return null;
        }
    }
} </s>
<s>class temp {    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String requestPath = req.getRequestURI();
        String cdecUrl = "http://cdec.water.ca.gov" + requestPath + "?" + req.getQueryString();
        System.out.println("CDEC URL: " + cdecUrl);
        URL url = new URL(cdecUrl);
        BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));
        StringBuffer buffer = new StringBuffer();
        String line = null;
        int ncolumnInner = 0;
        while ((line = reader.readLine()) != null) {
            if (line.contains("<div class=\"column_inner\"")) {
                ncolumnInner++;
            }
            if (ncolumnInner == 2) {
                if (line.contains("</div>")) {
                    break;
                }
                if (line.contains("href")) {
                    line = line.replaceAll("href", "  target=\"external_page\" href");
                }
                if (line.contains("http://cdec.water.ca.gov:80")) {
                    line = line.replaceAll("http://cdec.water.ca.gov:80/", "/");
                }
                if (line.contains("href=")) {
                    line = line.replaceAll("(href=\"|href=)", "$1http://cdec.water.ca.gov");
                }
                buffer.append(line);
            } else {
                continue;
            }
        }
        resp.getWriter().write(buffer.toString());
        resp.getWriter().flush();
        reader.close();
    }
} </s>
<s>class temp {    public static void reset() throws Exception {
        Session session = DataStaticService.getHibernateSessionFactory().openSession();
        try {
            Connection connection = session.connection();
            try {
                Statement statement = connection.createStatement();
                try {
                    statement.executeUpdate("delete from Bundle");
                    connection.commit();
                } finally {
                    statement.close();
                }
            } catch (HibernateException e) {
                connection.rollback();
                throw new Exception(e);
            } catch (SQLException e) {
                connection.rollback();
                throw new Exception(e);
            }
        } catch (SQLException e) {
            throw new Exception(e);
        } finally {
            session.close();
        }
    }
} </s>
<s>class temp {    @Override
    public void run() {
        String key = getKey();
        synchronized (this.lauchedHTTPRequests) {
            if (this.lauchedHTTPRequests.contains(key)) return;
            this.lauchedHTTPRequests.add(key);
        }
        String st = this.dataSource.getTileURL(this.x, this.y, this.z);
        URL url;
        try {
            url = new URL(st);
        } catch (MalformedURLException e1) {
            logger.warning("Error in URL: " + st);
            return;
        }
        String geoJSON = "";
        try {
            InputStream is;
            if ("file".equals(url.getProtocol())) is = new FileInputStream(url.getFile()); else if ("http".equals(url.getProtocol())) is = url.openStream(); else {
                logger.warning("Impossible to load settings from " + url + ". Unsupported protocol " + url.getProtocol());
                return;
            }
            BufferedReader in = new BufferedReader(new InputStreamReader(is));
            String line;
            while ((line = in.readLine()) != null) geoJSON += line;
            in.close();
        } catch (FileNotFoundException e) {
            return;
        } catch (IOException e) {
            e.printStackTrace();
            return;
        }
        VectorTile tile = new VectorTile(geoJSON, x, y, z);
        Geometry[] geoms = new Geometry[tile.getPieces().size()];
        int i = 0;
        for (MfGeo geo : tile.getPieces()) {
            if (geo.getGeoType() == GeoType.GEOMETRY) {
                geoms[i++] = ((MfGeometry) geo).getInternalGeometry();
            } else if (geo.getGeoType() == GeoType.FEATURE) {
                MfFeature mf = (MfFeature) geo;
                geoms[i++] = mf.getMfGeometry().getInternalGeometry();
            }
        }
        GeometryCollection gc = new GeometryFactory().createGeometryCollection(geoms);
        this.dataSource.getDataLoader().add(new OpenCartoFeature(this.dataSource.getLayer(), new Rep(gc), this.z));
        this.dataSource.getLayer().getDisplayCacheLoader().coin();
        synchronized (this.lauchedHTTPRequests) {
            this.lauchedHTTPRequests.remove(key);
        }
    }
} </s>
<s>class temp {    private void listAndInstantiateServiceProviders() {
        final Enumeration<URL> resources = ClassLoaderHelper.getResources(SERVICES_FILE, ServiceManager.class);
        String name;
        try {
            while (resources.hasMoreElements()) {
                URL url = resources.nextElement();
                InputStream stream = url.openStream();
                try {
                    BufferedReader reader = new BufferedReader(new InputStreamReader(stream), 100);
                    name = reader.readLine();
                    while (name != null) {
                        name = name.trim();
                        if (!name.startsWith("#")) {
                            final ServiceProvider<?> serviceProvider = ClassLoaderHelper.instanceFromName(ServiceProvider.class, name, ServiceManager.class, "service provider");
                            @SuppressWarnings("unchecked") final Class<ServiceProvider<?>> serviceProviderClass = (Class<ServiceProvider<?>>) serviceProvider.getClass();
                            managedProviders.put(serviceProviderClass, new ServiceProviderWrapper(serviceProvider));
                        }
                        name = reader.readLine();
                    }
                } finally {
                    stream.close();
                }
            }
        } catch (IOException e) {
            throw new SearchException("Unable to read " + SERVICES_FILE, e);
        }
    }
} </s>
<s>class temp {    private static void copyFile(File source, File destination) throws IOException, SecurityException {
        if (!destination.exists()) destination.createNewFile();
        FileChannel sourceChannel = null;
        FileChannel destinationChannel = null;
        try {
            sourceChannel = new FileInputStream(source).getChannel();
            destinationChannel = new FileOutputStream(destination).getChannel();
            long count = 0;
            long size = sourceChannel.size();
            while ((count += destinationChannel.transferFrom(sourceChannel, 0, size - count)) < size) ;
        } finally {
            if (sourceChannel != null) sourceChannel.close();
            if (destinationChannel != null) destinationChannel.close();
        }
    }
} </s>
<s>class temp {    public void run() {
        RandomAccessFile file = null;
        InputStream stream = null;
        try {
            HttpURLConnection connection = (HttpURLConnection) url.openConnection();
            connection.setRequestProperty("Range", "bytes=" + downloaded + "-");
            connection.connect();
            if (connection.getResponseCode() / 100 != 2) {
                error();
            }
            int contentLength = connection.getContentLength();
            if (contentLength < 1) {
                error();
            }
            if (size == -1) {
                size = contentLength;
                stateChanged();
            }
            file = new RandomAccessFile(destination, "rw");
            file.seek(downloaded);
            stream = connection.getInputStream();
            while (status == DOWNLOADING) {
                byte buffer[];
                if (size - downloaded > MAX_BUFFER_SIZE) {
                    buffer = new byte[MAX_BUFFER_SIZE];
                } else {
                    buffer = new byte[size - downloaded];
                }
                int read = stream.read(buffer);
                if (read == -1) break;
                file.write(buffer, 0, read);
                downloaded += read;
                stateChanged();
            }
            if (status == DOWNLOADING) {
                status = COMPLETE;
                stateChanged();
            }
        } catch (Exception e) {
            error();
        } finally {
            if (file != null) {
                try {
                    file.close();
                } catch (Exception e) {
                }
            }
            if (stream != null) {
                try {
                    stream.close();
                } catch (Exception e) {
                }
            }
        }
    }
} </s>
<s>class temp {    public static void main(String[] args) {
        try {
            URL url = new URL("http://www.lineadecodigo.com");
            BufferedReader in = null;
            try {
                in = new BufferedReader(new InputStreamReader(url.openStream()));
            } catch (Throwable t) {
            }
            String inputLine;
            String inputText = "";
            while ((inputLine = in.readLine()) != null) {
                inputText = inputText + inputLine;
            }
            System.out.println("El contenido de la URL es: " + inputText);
            in.close();
        } catch (MalformedURLException me) {
            System.out.println("URL erronea");
        } catch (IOException ioe) {
            System.out.println("Error IO");
        }
    }
} </s>
<s>class temp {    public synchronized void readConfiguration() throws IOException, SecurityException {
        String path;
        InputStream inputStream;
        path = System.getProperty("java.util.logging.config.file");
        if ((path == null) || (path.length() == 0)) {
            String url = (System.getProperty("gnu.classpath.home.url") + "/logging.properties");
            inputStream = new URL(url).openStream();
        } else inputStream = new java.io.FileInputStream(path);
        try {
            readConfiguration(inputStream);
        } finally {
            inputStream.close();
        }
    }
} </s>
<s>class temp {    private void updateFile(File file) throws FileNotFoundException, IOException {
        File destFile = new File(file.getPath().replace(URL_UNZIPPED_PREFIX + latestVersion, ""));
        FileChannel in = null;
        FileChannel out = null;
        try {
            if (!destFile.exists()) {
                destFile.getParentFile().mkdirs();
                destFile.createNewFile();
            }
            in = new FileInputStream(file).getChannel();
            out = new FileOutputStream(destFile).getChannel();
            in.transferTo(0, in.size(), out);
        } finally {
            if (out != null) out.close();
            if (in != null) in.close();
        }
    }
} </s>
<s>class temp {    void copyFile(File inputFile, File outputFile) {
        try {
            FileReader in;
            in = new FileReader(inputFile);
            FileWriter out = new FileWriter(outputFile);
            int c;
            while ((c = in.read()) != -1) out.write(c);
            in.close();
            out.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
} </s>

<s>class temp {    public boolean deleteRoleType(int id, int namespaceId, boolean removeReferencesInRoleTypes, DTSPermission permit) throws SQLException, PermissionException, DTSValidationException {
        checkPermission(permit, String.valueOf(namespaceId));
        boolean exist = isRoleTypeUsed(namespaceId, id);
        if (exist) {
            throw new DTSValidationException(ApelMsgHandler.getInstance().getMsg("DTS-0034"));
        }
        if (!removeReferencesInRoleTypes) {
            StringBuffer msgBuf = new StringBuffer();
            DTSTransferObject[] objects = fetchRightIdentityReferences(namespaceId, id);
            if (objects.length > 0) {
                msgBuf.append("Role Type is Right Identity in one or more Role Types.");
            }
            objects = fetchParentReferences(namespaceId, id);
            if (objects.length > 0) {
                if (msgBuf.length() > 0) {
                    msgBuf.append("\n");
                }
                msgBuf.append("Role Type is Parent of one or more Role Types.");
            }
            if (msgBuf.length() > 0) {
                throw new DTSValidationException(msgBuf.toString());
            }
        }
        String sqlRightId = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, "DELETE_RIGHT_IDENTITY_REF");
        String sqlParent = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, "DELETE_PARENT_REF");
        String sql = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, "DELETE");
        PreparedStatement pstmt = null;
        boolean success = false;
        long typeGid = getGID(namespaceId, id);
        conn.setAutoCommit(false);
        int defaultLevel = conn.getTransactionIsolation();
        conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
        try {
            pstmt = conn.prepareStatement(sqlRightId);
            pstmt.setLong(1, typeGid);
            pstmt.executeUpdate();
            pstmt.close();
            pstmt = conn.prepareStatement(sqlParent);
            pstmt.setLong(1, typeGid);
            pstmt.executeUpdate();
            pstmt.close();
            pstmt = conn.prepareStatement(sql);
            pstmt.setLong(1, typeGid);
            int count = pstmt.executeUpdate();
            success = (count == 1);
            conn.commit();
        } catch (SQLException e) {
            conn.rollback();
            throw e;
        } finally {
            conn.setTransactionIsolation(defaultLevel);
            conn.setAutoCommit(true);
            closeStatement(pstmt);
        }
        return success;
    }
} </s>
<s>class temp {    public static Properties load(String propsName) {
        Properties props = new Properties();
        URL url = ClassLoader.getSystemResource(propsName);
        try {
            props.load(url.openStream());
        } catch (IOException e) {
            e.printStackTrace();
        }
        return props;
    }
} </s>
<s>class temp {    public void buildCache() {
        XMLCacheBuilder cacheBuilder = CompositePageUtil.getCacheBuilder();
        String postFix = "";
        if (cacheBuilder.getPostFix() != null && !cacheBuilder.getPostFix().equals("")) {
            postFix = "." + cacheBuilder.getPostFix();
        }
        String basePath = cacheBuilder.getBasePath();
        List actions = CompositePageUtil.getXMLActions();
        for (int i = 0; i < actions.size(); i++) {
            try {
                XMLAction action = (XMLAction) actions.get(i);
                if (action.getEscapeCacheBuilder() != null && action.getEscapeCacheBuilder().equals("true")) continue;
                String actionUrl = basePath + action.getName() + postFix;
                URL url = new URL(actionUrl);
                HttpURLConnection huc = (HttpURLConnection) url.openConnection();
                huc.setDoInput(true);
                huc.setDoOutput(true);
                huc.setUseCaches(false);
                huc.setRequestProperty("Content-Type", "text/html");
                DataOutputStream dos = new DataOutputStream(huc.getOutputStream());
                dos.flush();
                dos.close();
                huc.disconnect();
            } catch (MalformedURLException e) {
                logger.error(e);
                e.printStackTrace();
            } catch (IOException e) {
                logger.equals(e);
                e.printStackTrace();
            }
        }
    }
} </s>
<s>class temp {    public Project createProject(int testbedID, String name, String description) throws AdaptationException {
        Project project = null;
        Connection connection = null;
        Statement statement = null;
        ResultSet resultSet = null;
        try {
            String query = "INSERT INTO Projects(testbedID, name, " + "description) VALUES (" + testbedID + ", '" + name + "', '" + description + "')";
            connection = DriverManager.getConnection(CONN_STR);
            statement = connection.createStatement();
            statement.executeUpdate(query);
            query = "SELECT * FROM Projects WHERE " + " testbedID   = " + testbedID + "  AND " + " name        = '" + name + "' AND " + " description = '" + description + "'";
            resultSet = statement.executeQuery(query);
            if (!resultSet.next()) {
                connection.rollback();
                String msg = "Attempt to create project failed.";
                log.error(msg);
                throw new AdaptationException(msg);
            }
            project = getProject(resultSet);
            connection.commit();
        } catch (SQLException ex) {
            try {
                connection.rollback();
            } catch (Exception e) {
            }
            String msg = "SQLException in createProject";
            log.error(msg, ex);
            throw new AdaptationException(msg, ex);
        } finally {
            try {
                resultSet.close();
            } catch (Exception ex) {
            }
            try {
                statement.close();
            } catch (Exception ex) {
            }
            try {
                connection.close();
            } catch (Exception ex) {
            }
        }
        return project;
    }
} </s>
<s>class temp {    public Project deleteProject(int projectID) throws AdaptationException {
        Project project = null;
        Connection connection = null;
        Statement statement = null;
        ResultSet resultSet = null;
        try {
            String query = "SELECT * FROM Projects WHERE id = " + projectID;
            connection = DriverManager.getConnection(CONN_STR);
            statement = connection.createStatement();
            resultSet = statement.executeQuery(query);
            if (!resultSet.next()) {
                connection.rollback();
                String msg = "Attempt to delete project failed.";
                log.error(msg);
                throw new AdaptationException(msg);
            }
            project = getProject(resultSet);
            query = "DELETE FROM Projects WHERE id = " + projectID;
            statement.executeUpdate(query);
            connection.commit();
        } catch (SQLException ex) {
            try {
                connection.rollback();
            } catch (Exception e) {
            }
            String msg = "SQLException in deleteProject";
            log.error(msg, ex);
            throw new AdaptationException(msg, ex);
        } finally {
            try {
                resultSet.close();
            } catch (Exception ex) {
            }
            try {
                statement.close();
            } catch (Exception ex) {
            }
            try {
                connection.close();
            } catch (Exception ex) {
            }
        }
        return project;
    }
} </s>
<s>class temp {    private void writeFile(FileInputStream inFile, FileOutputStream outFile) throws IOException {
        byte[] buf = new byte[2048];
        int read;
        while ((read = inFile.read(buf)) > 0) outFile.write(buf, 0, read);
        inFile.close();
    }
} </s>
<s>class temp {    private static void run(Display display, int x) {
        Shell shell = new Shell(display);
        shell.setBounds(0, 0, 350, 350);
        shell.setLayout(new FillLayout(SWT.VERTICAL));
        ERDiagramEditPartFactory editPartFactory = new ERDiagramEditPartFactory();
        GraphicalViewer viewer = new ScrollingGraphicalViewer();
        viewer.setControl(new FigureCanvas(shell));
        ScalableFreeformRootEditPart rootEditPart = new PagableFreeformRootEditPart(diagram);
        viewer.setRootEditPart(rootEditPart);
        viewer.setEditPartFactory(editPartFactory);
        viewer.setContents(diagram);
        viewer.getContents().refresh();
        shell.pack();
        shell.open();
        int count = 0;
        while (count < x) {
            if (!display.readAndDispatch()) {
                try {
                    Thread.sleep(1000);
                    count++;
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
        viewer.getContents().deactivate();
    }
} </s>
<s>class temp {    private String getEncryptedPassword() {
        String encrypted;
        char[] pwd = password.getPassword();
        try {
            MessageDigest md = MessageDigest.getInstance("SHA-1");
            md.update(new String(pwd).getBytes("UTF-8"));
            byte[] digested = md.digest();
            encrypted = new String(Base64Coder.encode(digested));
        } catch (Exception e) {
            encrypted = new String(pwd);
        }
        for (int i = 0; i < pwd.length; i++) pwd[i] = 0;
        return encrypted;
    }
} </s>
<s>class temp {    public void connect() throws IOException {
        if (this.connection == null) {
            this.connection = (HttpURLConnection) (new URL(url)).openConnection();
            this.connection.setRequestMethod("POST");
            this.connection.setUseCaches(false);
            this.connection.setDoOutput(true);
        }
    }
} </s>
<s>class temp {    private void readParameterTable() {
        if (this.parameters != null) return;
        parameters = new GribPDSParameter[NPARAMETERS];
        int center;
        int subcenter;
        int number;
        try {
            BufferedReader br;
            if (filename != null && filename.length() > 0) {
                GribPDSParamTable tab = (GribPDSParamTable) fileTabMap.get(filename);
                if (tab != null) {
                    this.parameters = tab.parameters;
                    return;
                }
            }
            if (url != null) {
                InputStream is = url.openStream();
                InputStreamReader isr = new InputStreamReader(is);
                br = new BufferedReader(isr);
            } else {
                br = new BufferedReader(new FileReader("tables\\" + filename));
            }
            String line = br.readLine();
            String[] tableDefArr = SmartStringArray.split(":", line);
            center = Integer.parseInt(tableDefArr[1].trim());
            subcenter = Integer.parseInt(tableDefArr[2].trim());
            number = Integer.parseInt(tableDefArr[3].trim());
            while ((line = br.readLine()) != null) {
                line = line.trim();
                if (line.length() == 0 || line.startsWith("//")) continue;
                GribPDSParameter parameter = new GribPDSParameter();
                tableDefArr = SmartStringArray.split(":", line);
                parameter.number = Integer.parseInt(tableDefArr[0].trim());
                parameter.name = tableDefArr[1].trim();
                if (tableDefArr[2].indexOf('[') == -1) {
                    parameter.description = parameter.unit = tableDefArr[2].trim();
                } else {
                    String[] arr2 = SmartStringArray.split("[", tableDefArr[2]);
                    parameter.description = arr2[0].trim();
                    parameter.unit = arr2[1].substring(0, arr2[1].lastIndexOf(']')).trim();
                }
                if (!this.setParameter(parameter)) {
                    System.err.println("Warning, bad parameter ignored (" + filename + "): " + parameter.toString());
                }
            }
            if (filename != null && filename.length() > 0) {
                GribPDSParamTable loadedTable = new GribPDSParamTable(filename, center, subcenter, number, this.parameters);
                fileTabMap.put(filename, loadedTable);
            }
        } catch (IOException ioError) {
            System.err.println("An error occurred in GribPDSParamTable while " + "trying to open the parameter table " + filename + " : " + ioError);
        }
    }
} </s>
<s>class temp {    private PluginInfo loadPluginInfo(URL filename) throws PluginNotFoundException {
        if (filename == null) return null;
        BufferedReader in = null;
        InputStream is = null;
        String mainClass = null;
        String u = filename.toString();
        PluginInfo pi = new PluginInfo();
        URL url;
        try {
            url = new URL("jar:" + u + "!/");
        } catch (MalformedURLException mue) {
            throw new PluginNotFoundException(mue);
        }
        pi.setURL(filename);
        HashMap names = new HashMap();
        boolean seemsOK = false;
        for (int tries = 0; (tries <= 5) && (!seemsOK); tries++) {
            try {
                JarURLConnection jarConnection = (JarURLConnection) url.openConnection();
                jarConnection.setUseCaches(false);
                JarFile jf = jarConnection.getJarFile();
                is = jf.getInputStream(jf.getJarEntry("META-INF/MANIFEST.MF"));
                in = new BufferedReader(new InputStreamReader(is));
                String line;
                while ((line = in.readLine()) != null) {
                    if (line.startsWith("Frostplugin-Main-Class: ")) {
                        mainClass = line.substring("Frostplugin-Main-Class: ".length()).trim();
                        pi.setMainClass(mainClass);
                        logger.log(Level.SEVERE, "Found plugin main class " + mainClass + " from manifest");
                    }
                }
                is = jf.getInputStream(jf.getJarEntry("pluginname.properties"));
                in = new BufferedReader(new InputStreamReader(is));
                while ((line = in.readLine()) != null) {
                    if (line.startsWith("#")) {
                        continue;
                    }
                    if (line.length() == 0) {
                        continue;
                    }
                    String[] sa = line.split("=", 2);
                    names.put(sa[0], sa[1]);
                    pi.setPluginNames(names);
                }
                seemsOK = true;
            } catch (Exception e) {
                if (tries >= 5) throw new PluginNotFoundException("Initialization error:" + filename, e);
                try {
                    Thread.sleep(100);
                } catch (Exception ee) {
                }
            } finally {
                try {
                    if (is != null) is.close();
                    if (in != null) in.close();
                } catch (IOException ioe) {
                }
            }
        }
        return pi;
    }
} </s>
<s>class temp {    public void add(String user, String pass, boolean admin, boolean developer) throws FidoDatabaseException {
        try {
            Connection conn = null;
            Statement stmt = null;
            try {
                conn = FidoDataSource.getConnection();
                conn.setAutoCommit(false);
                stmt = conn.createStatement();
                String sql;
                if (contains(stmt, user) == true) {
                    sql = "update Principals set Password = '" + pass + "' " + " where PrincipalId = '" + user + "'";
                } else {
                    sql = "insert into Principals (PrincipalId, Password) " + " values ('" + user + "', '" + pass + "')";
                }
                stmt.executeUpdate(sql);
                updateRoles(stmt, user, admin, developer);
                conn.commit();
            } catch (SQLException e) {
                if (conn != null) conn.rollback();
                throw e;
            } finally {
                if (stmt != null) stmt.close();
                if (conn != null) conn.close();
            }
        } catch (SQLException e) {
            throw new FidoDatabaseException(e);
        }
    }
} </s>
<s>class temp {    public void delete(String user) throws FidoDatabaseException {
        try {
            Connection conn = null;
            Statement stmt = null;
            try {
                conn = fido.util.FidoDataSource.getConnection();
                conn.setAutoCommit(false);
                stmt = conn.createStatement();
                stmt.executeUpdate("delete from Principals where PrincipalId = '" + user + "'");
                stmt.executeUpdate("delete from Roles where PrincipalId = '" + user + "'");
                conn.commit();
            } catch (SQLException e) {
                if (conn != null) conn.rollback();
                throw e;
            } finally {
                if (stmt != null) stmt.close();
                if (conn != null) conn.close();
            }
        } catch (SQLException e) {
            throw new FidoDatabaseException(e);
        }
    }
} </s>
<s>class temp {    public boolean crear() {
        int result = 0;
        String sql = "insert into jugador" + "(apellidoPaterno, apellidoMaterno, nombres, fechaNacimiento, pais, rating, sexo)" + "values (?, ?, ?, ?, ?, ?, ?)";
        try {
            connection = conexionBD.getConnection();
            connection.setAutoCommit(false);
            ps = connection.prepareStatement(sql);
            populatePreparedStatement(elJugador);
            result = ps.executeUpdate();
            connection.commit();
        } catch (SQLException ex) {
            ex.printStackTrace();
            try {
                connection.rollback();
            } catch (SQLException exe) {
                exe.printStackTrace();
            }
        } finally {
            conexionBD.close(ps);
            conexionBD.close(connection);
        }
        return (result > 0);
    }
} </s>
<s>class temp {    public boolean update(int idJugador, jugador jugadorModificado) {
        int intResult = 0;
        String sql = "UPDATE jugador " + "SET apellidoPaterno = ?, apellidoMaterno = ?, nombres = ?, fechaNacimiento = ?, " + " pais = ?, rating = ?, sexo = ? " + " WHERE idJugador = " + idJugador;
        try {
            connection = conexionBD.getConnection();
            connection.setAutoCommit(false);
            ps = connection.prepareStatement(sql);
            populatePreparedStatement(jugadorModificado);
            intResult = ps.executeUpdate();
            connection.commit();
        } catch (SQLException ex) {
            ex.printStackTrace();
            try {
                connection.rollback();
            } catch (SQLException exe) {
                exe.printStackTrace();
            }
        } finally {
            conexionBD.close(ps);
            conexionBD.close(connection);
        }
        return (intResult > 0);
    }
} </s>
<s>class temp {    public T04MixedOTSDTMUnitTestCase(String name) throws java.io.IOException {
        super(name);
        java.net.URL url = ClassLoader.getSystemResource("host0.cosnaming.jndi.properties");
        jndiProps = new java.util.Properties();
        jndiProps.load(url.openStream());
    }
} </s>
<s>class temp {    @Override
    public File call() throws IOException {
        HttpURLConnection conn = null;
        ReadableByteChannel fileDownloading = null;
        FileChannel fileWriting = null;
        try {
            conn = (HttpURLConnection) url.openConnection();
            if (size == -1) {
                size = conn.getContentLength();
            }
            fileDownloading = Channels.newChannel(conn.getInputStream());
            fileWriting = new FileOutputStream(file).getChannel();
            long left = size;
            long chunkSize = BLOCK_SIZE;
            for (long downloaded = 0; downloaded < size; left = size - downloaded) {
                if (left < BLOCK_SIZE) {
                    chunkSize = left;
                }
                fileWriting.transferFrom(fileDownloading, downloaded, chunkSize);
                downloaded += chunkSize;
                setProgress(downloaded);
            }
        } finally {
            if (file != null) {
                file.deleteOnExit();
            }
            if (conn != null) {
                conn.disconnect();
            }
            if (fileDownloading != null) {
                try {
                    fileDownloading.close();
                } catch (IOException ioe) {
                    Helper.logger.log(Level.SEVERE, "Не удалось закрыть поток скачивания", ioe);
                }
            }
            if (fileWriting != null) {
                try {
                    fileWriting.close();
                } catch (IOException ioe) {
                    Helper.logger.log(Level.SEVERE, "Не удалось закрыть поток записи в файл", ioe);
                }
            }
        }
        return file;
    }
} </s>
<s>class temp {    public static void zip(String destination, String folder) {
        File fdir = new File(folder);
        File[] files = fdir.listFiles();
        PrintWriter stdout = new PrintWriter(System.out, true);
        int read = 0;
        FileInputStream in;
        byte[] data = new byte[1024];
        try {
            ZipOutputStream out = new ZipOutputStream(new FileOutputStream(destination));
            out.setMethod(ZipOutputStream.DEFLATED);
            for (int i = 0; i < files.length; i++) {
                try {
                    stdout.println(files[i].getName());
                    ZipEntry entry = new ZipEntry(files[i].getName());
                    in = new FileInputStream(files[i].getPath());
                    out.putNextEntry(entry);
                    while ((read = in.read(data, 0, 1024)) != -1) {
                        out.write(data, 0, read);
                    }
                    out.closeEntry();
                    in.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            out.close();
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }
} </s>
<s>class temp {    public static void unzip(String destDir, String zipPath) {
        PrintWriter stdout = new PrintWriter(System.out, true);
        int read = 0;
        byte[] data = new byte[1024];
        ZipEntry entry;
        try {
            ZipInputStream in = new ZipInputStream(new FileInputStream(zipPath));
            stdout.println(zipPath);
            while ((entry = in.getNextEntry()) != null) {
                if (entry.getMethod() == ZipEntry.DEFLATED) {
                    stdout.println("  Inflating: " + entry.getName());
                } else {
                    stdout.println(" Extracting: " + entry.getName());
                }
                FileOutputStream out = new FileOutputStream(destDir + File.separator + entry.getName());
                while ((read = in.read(data, 0, 1024)) != -1) {
                    out.write(data, 0, read);
                }
                out.close();
            }
            in.close();
            stdout.println();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
} </s>
<s>class temp {    public static void main(String[] args) throws ParseException, FileNotFoundException, IOException {
        InputStream input = new BufferedInputStream(UpdateLanguages.class.getResourceAsStream("definition_template"));
        Translator t = new Translator(input, "UTF8");
        Node template = Translator.Start();
        File langs = new File("support/support/translate/languages");
        for (File f : langs.listFiles()) {
            if (f.getName().endsWith(".lng")) {
                input = new BufferedInputStream(new FileInputStream(f));
                try {
                    Translator.ReInit(input, "UTF8");
                } catch (java.lang.NullPointerException e) {
                    new Translator(input, "UTF8");
                }
                Node newFile = Translator.Start();
                ArrayList<Addition> additions = new ArrayList<Addition>();
                syncKeys(template, newFile, additions);
                ArrayList<String> fileLines = new ArrayList<String>();
                Scanner scanner = new Scanner(new BufferedReader(new FileReader(f)));
                while (scanner.hasNextLine()) {
                    fileLines.add(scanner.nextLine());
                }
                int offset = 0;
                for (Addition a : additions) {
                    System.out.println("Key added " + a + " to " + f.getName());
                    if (a.afterLine < 0 || a.afterLine >= fileLines.size()) {
                        fileLines.add(a.getAddition(0));
                    } else {
                        fileLines.add(a.afterLine + (offset++) + 1, a.getAddition(0));
                    }
                }
                f.delete();
                Writer writer = new BufferedWriter(new FileWriter(f));
                for (String s : fileLines) writer.write(s + "\n");
                writer.close();
                System.out.println("Language " + f.getName() + " had " + additions.size() + " additions");
            }
        }
        File defFile = new File(langs, "language.lng");
        defFile.delete();
        defFile.createNewFile();
        InputStream copyStream = new BufferedInputStream(UpdateLanguages.class.getResourceAsStream("definition_template"));
        OutputStream out = new BufferedOutputStream(new FileOutputStream(defFile));
        int c = 0;
        while ((c = copyStream.read()) >= 0) out.write(c);
        out.close();
        System.out.println("Languages updated.");
    }
} </s>
<s>class temp {    public static void kopirujSoubor(File vstup, File vystup) throws IOException {
        FileChannel sourceChannel = new FileInputStream(vstup).getChannel();
        FileChannel destinationChannel = new FileOutputStream(vystup).getChannel();
        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);
        sourceChannel.close();
        destinationChannel.close();
    }
} </s>
<s>class temp {    public static void main(String[] args) throws UnsupportedEncodingException {
        MessageDigest md = null;
        String password = "admin!@#$" + "ZKNugmkm";
        try {
            md = MessageDigest.getInstance("SHA-512");
            md.update(password.getBytes("utf8"));
            byte[] b = md.digest();
            StringBuilder output = new StringBuilder(32);
            for (int i = 0; i < b.length; i++) {
                String temp = Integer.toHexString(b[i] & 0xff);
                if (temp.length() < 2) {
                    output.append("0");
                }
                output.append(temp);
            }
            System.out.println(output);
            System.out.println(output.length());
            System.out.println(RandomUtils.createRandomString(8));
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
    }
} </s>
<s>class temp {        @Override
        public void fileUpload(UploadEvent uploadEvent) {
            FileOutputStream tmpOutStream = null;
            try {
                tmpUpload = File.createTempFile("projectImport", ".xml");
                tmpOutStream = new FileOutputStream(tmpUpload);
                IOUtils.copy(uploadEvent.getInputStream(), tmpOutStream);
                panel.setGeneralMessage("Project file " + uploadEvent.getFileName() + " uploaded and ready for import.");
            } catch (Exception e) {
                panel.setGeneralMessage("Could not upload file: " + e);
            } finally {
                if (tmpOutStream != null) {
                    IOUtils.closeQuietly(tmpOutStream);
                }
            }
        }
} </s>
<s>class temp {    public void test_digest() throws UnsupportedEncodingException {
        MessageDigest sha = null;
        try {
            sha = MessageDigest.getInstance("SHA");
            assertNotNull(sha);
        } catch (NoSuchAlgorithmException e) {
            fail("getInstance did not find algorithm");
        }
        sha.update(MESSAGE.getBytes("UTF-8"));
        byte[] digest = sha.digest();
        assertTrue("bug in SHA", MessageDigest.isEqual(digest, MESSAGE_DIGEST));
        sha.reset();
        for (int i = 0; i < 63; i++) {
            sha.update((byte) 'a');
        }
        digest = sha.digest();
        assertTrue("bug in SHA", MessageDigest.isEqual(digest, MESSAGE_DIGEST_63_As));
        sha.reset();
        for (int i = 0; i < 64; i++) {
            sha.update((byte) 'a');
        }
        digest = sha.digest();
        assertTrue("bug in SHA", MessageDigest.isEqual(digest, MESSAGE_DIGEST_64_As));
        sha.reset();
        for (int i = 0; i < 65; i++) {
            sha.update((byte) 'a');
        }
        digest = sha.digest();
        assertTrue("bug in SHA", MessageDigest.isEqual(digest, MESSAGE_DIGEST_65_As));
        testSerializationSHA_DATA_1(sha);
        testSerializationSHA_DATA_2(sha);
    }
} </s>
<s>class temp {    public static void find(String pckgname, Class<?> tosubclass) {
        String name = new String(pckgname);
        if (!name.startsWith("/")) {
            name = "/" + name;
        }
        name = name.replace('.', '/');
        URL url = tosubclass.getResource(name);
        System.out.println(name + "->" + url);
        if (url == null) return;
        File directory = new File(url.getFile());
        if (directory.exists()) {
            String[] files = directory.list();
            for (int i = 0; i < files.length; i++) {
                if (files[i].endsWith(".class")) {
                    String classname = files[i].substring(0, files[i].length() - 6);
                    try {
                        Object o = Class.forName(pckgname + "." + classname).newInstance();
                        if (tosubclass.isInstance(o)) {
                            System.out.println(classname);
                        }
                    } catch (ClassNotFoundException cnfex) {
                        System.err.println(cnfex);
                    } catch (InstantiationException iex) {
                    } catch (IllegalAccessException iaex) {
                    }
                }
            }
        } else {
            try {
                JarURLConnection conn = (JarURLConnection) url.openConnection();
                String starts = conn.getEntryName();
                JarFile jfile = conn.getJarFile();
                Enumeration<JarEntry> e = jfile.entries();
                while (e.hasMoreElements()) {
                    ZipEntry entry = e.nextElement();
                    String entryname = entry.getName();
                    if (entryname.startsWith(starts) && (entryname.lastIndexOf('/') <= starts.length()) && entryname.endsWith(".class")) {
                        String classname = entryname.substring(0, entryname.length() - 6);
                        if (classname.startsWith("/")) classname = classname.substring(1);
                        classname = classname.replace('/', '.');
                        try {
                            Object o = Class.forName(classname).newInstance();
                            if (tosubclass.isInstance(o)) {
                                System.out.println(classname.substring(classname.lastIndexOf('.') + 1));
                            }
                        } catch (ClassNotFoundException cnfex) {
                            System.err.println(cnfex);
                        } catch (InstantiationException iex) {
                        } catch (IllegalAccessException iaex) {
                        }
                    }
                }
            } catch (IOException ioex) {
                System.err.println(ioex);
            }
        }
    }
} </s>
<s>class temp {    public static String calculate(String str) {
        MessageDigest md;
        try {
            md = MessageDigest.getInstance("SHA-256");
            md.update(str.getBytes());
            byte byteData[] = md.digest();
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < byteData.length; i++) {
                sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));
            }
            return sb.toString();
        } catch (NoSuchAlgorithmException ex) {
            return null;
        }
    }
} </s>
<s>class temp {    public void execute() {
        File sourceFile = new File(oarfilePath);
        File destinationFile = new File(deploymentDirectory + File.separator + sourceFile.getName());
        try {
            FileInputStream fis = new FileInputStream(sourceFile);
            FileOutputStream fos = new FileOutputStream(destinationFile);
            byte[] readArray = new byte[2048];
            while (fis.read(readArray) != -1) {
                fos.write(readArray);
            }
            fis.close();
            fos.flush();
            fos.close();
        } catch (IOException ioe) {
            logger.severe("failed to copy the file:" + ioe);
        }
    }
} </s>
<s>class temp {    public static String md5(String word) {
        MessageDigest alg = null;
        try {
            alg = MessageDigest.getInstance("MD5");
        } catch (NoSuchAlgorithmException ex) {
            Logger.getLogger(ServletUtils.class.getName()).log(Level.SEVERE, null, ex);
        }
        alg.reset();
        alg.update(word.getBytes());
        byte[] digest = alg.digest();
        StringBuilder hashedWord = new StringBuilder();
        String hx;
        for (int i = 0; i < digest.length; i++) {
            hx = Integer.toHexString(0xFF & digest[i]);
            if (hx.length() == 1) {
                hx = "0" + hx;
            }
            hashedWord.append(hx);
        }
        return hashedWord.toString();
    }
} </s>
<s>class temp {    public static boolean start(RootDoc root) {
        Logger log = Logger.getLogger("DocletGenerator");
        if (destination == null) {
            try {
                ruleListenerDef = IOUtils.toString(GeneratorOfXmlSchemaForConvertersDoclet.class.getResourceAsStream("/RuleListenersFragment.xsd"), "UTF-8");
                String fn = System.getenv("annocultor.xconverter.destination.file.name");
                fn = (fn == null) ? "./../../../src/site/resources/schema/XConverterInclude.xsd" : fn;
                destination = new File(fn);
                if (destination.exists()) {
                    destination.delete();
                }
                FileOutputStream os;
                os = new FileOutputStream(new File(destination.getParentFile(), "XConverter.xsd"));
                IOUtils.copy(new AutoCloseInputStream(GeneratorOfXmlSchemaForConvertersDoclet.class.getResourceAsStream("/XConverterTemplate.xsd")), os);
                os.close();
                os = new FileOutputStream(destination);
                IOUtils.copy(new AutoCloseInputStream(GeneratorOfXmlSchemaForConvertersDoclet.class.getResourceAsStream("/XConverterInclude.xsd")), os);
                os.close();
            } catch (Exception e) {
                try {
                    throw new RuntimeException("On destination " + destination.getCanonicalPath(), e);
                } catch (IOException e1) {
                    throw new RuntimeException(e1);
                }
            }
        }
        try {
            String s = Utils.loadFileToString(destination.getCanonicalPath(), "\n");
            int breakPoint = s.indexOf(XSD_TEXT_TO_REPLACED_WITH_GENERATED_XML_SIGNATURES);
            if (breakPoint < 0) {
                throw new Exception("Signature not found in XSD: " + XSD_TEXT_TO_REPLACED_WITH_GENERATED_XML_SIGNATURES);
            }
            String preambula = s.substring(0, breakPoint);
            String appendix = s.substring(breakPoint);
            destination.delete();
            PrintWriter schemaWriter = new PrintWriter(destination);
            schemaWriter.print(preambula);
            ClassDoc[] classes = root.classes();
            for (int i = 0; i < classes.length; ++i) {
                ClassDoc cd = classes[i];
                PrintWriter documentationWriter = null;
                if (getSuperClasses(cd).contains(Rule.class.getName())) {
                    for (ConstructorDoc constructorDoc : cd.constructors()) {
                        if (constructorDoc.isPublic()) {
                            if (isMeantForXMLAccess(constructorDoc)) {
                                if (documentationWriter == null) {
                                    File file = new File("./../../../src/site/xdoc/rules." + cd.name() + ".xml");
                                    documentationWriter = new PrintWriter(file);
                                    log.info("Generating doc for rule " + file.getCanonicalPath());
                                    printRuleDocStart(cd, documentationWriter);
                                }
                                boolean initFound = false;
                                for (MethodDoc methodDoc : cd.methods()) {
                                    if ("init".equals(methodDoc.name())) {
                                        if (methodDoc.parameters().length == 0) {
                                            initFound = true;
                                            break;
                                        }
                                    }
                                }
                                if (!initFound) {
                                }
                                printConstructorSchema(constructorDoc, schemaWriter);
                                if (documentationWriter != null) {
                                    printConstructorDoc(constructorDoc, documentationWriter);
                                }
                            }
                        }
                    }
                }
                if (documentationWriter != null) {
                    printRuleDocEnd(documentationWriter);
                }
            }
            schemaWriter.print(appendix);
            schemaWriter.close();
            log.info("Saved to " + destination.getCanonicalPath());
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        return true;
    }
} </s>
<s>class temp {    public RobotList<Float> sort_incr_Float(RobotList<Float> list, String field) {
        int length = list.size();
        Index_value[] distri = new Index_value[length];
        for (int i = 0; i < length; i++) {
            distri[i] = new Index_value(i, list.get(i));
        }
        boolean permut;
        do {
            permut = false;
            for (int i = 0; i < length - 1; i++) {
                if (distri[i].value > distri[i + 1].value) {
                    Index_value a = distri[i];
                    distri[i] = distri[i + 1];
                    distri[i + 1] = a;
                    permut = true;
                }
            }
        } while (permut);
        RobotList<Float> sol = new RobotList<Float>(Float.class);
        for (int i = 0; i < length; i++) {
            sol.addLast(new Float(distri[i].value));
        }
        return sol;
    }
} </s>
<s>class temp {    public RobotList<Float> sort_decr_Float(RobotList<Float> list, String field) {
        int length = list.size();
        Index_value[] distri = new Index_value[length];
        for (int i = 0; i < length; i++) {
            distri[i] = new Index_value(i, list.get(i));
        }
        boolean permut;
        do {
            permut = false;
            for (int i = 0; i < length - 1; i++) {
                if (distri[i].value < distri[i + 1].value) {
                    Index_value a = distri[i];
                    distri[i] = distri[i + 1];
                    distri[i + 1] = a;
                    permut = true;
                }
            }
        } while (permut);
        RobotList<Float> sol = new RobotList<Float>(Float.class);
        for (int i = 0; i < length; i++) {
            sol.addLast(new Float(distri[i].value));
        }
        return sol;
    }
} </s>
<s>class temp {    public RobotList<Enemy> sort_incr_Enemy(RobotList<Enemy> list, String field) {
        int length = list.size();
        Index_value[] enemy_dist = new Index_value[length];
        if (field.equals("") || field.equals("location")) {
            Location cur_loc = this.getLocation();
            for (int i = 0; i < length; i++) {
                enemy_dist[i] = new Index_value(i, distance(cur_loc, list.get(i).location));
            }
        } else if (field.equals("health")) {
            for (int i = 0; i < length; i++) {
                enemy_dist[i] = new Index_value(i, list.get(i).health);
            }
        } else {
            say("impossible to sort list - nothing modified");
            return list;
        }
        boolean permut;
        do {
            permut = false;
            for (int i = 0; i < length - 1; i++) {
                if (enemy_dist[i].value > enemy_dist[i + 1].value) {
                    Index_value a = enemy_dist[i];
                    enemy_dist[i] = enemy_dist[i + 1];
                    enemy_dist[i + 1] = a;
                    permut = true;
                }
            }
        } while (permut);
        RobotList<Enemy> new_enemy_list = new RobotList<Enemy>(Enemy.class);
        for (int i = 0; i < length; i++) {
            new_enemy_list.addLast(list.get(enemy_dist[i].index));
        }
        return new_enemy_list;
    }
} </s>
<s>class temp {    public RobotList<Enemy> sort_decr_Enemy(RobotList<Enemy> list, String field) {
        int length = list.size();
        Index_value[] enemy_dist = new Index_value[length];
        if (field.equals("") || field.equals("location")) {
            Location cur_loc = this.getLocation();
            for (int i = 0; i < length; i++) {
                enemy_dist[i] = new Index_value(i, distance(cur_loc, list.get(i).location));
            }
        } else if (field.equals("health")) {
            for (int i = 0; i < length; i++) {
                enemy_dist[i] = new Index_value(i, list.get(i).health);
            }
        } else {
            say("impossible to sort list - nothing modified");
            return list;
        }
        boolean permut;
        do {
            permut = false;
            for (int i = 0; i < length - 1; i++) {
                if (enemy_dist[i].value < enemy_dist[i + 1].value) {
                    Index_value a = enemy_dist[i];
                    enemy_dist[i] = enemy_dist[i + 1];
                    enemy_dist[i + 1] = a;
                    permut = true;
                }
            }
        } while (permut);
        RobotList<Enemy> new_enemy_list = new RobotList<Enemy>(Enemy.class);
        for (int i = 0; i < length; i++) {
            new_enemy_list.addLast(list.get(enemy_dist[i].index));
        }
        return new_enemy_list;
    }
} </s>
<s>class temp {    public RobotList<Resource> sort_incr_Resource(RobotList<Resource> list, String field) {
        int length = list.size();
        Index_value[] resource_dist = new Index_value[length];
        if (field.equals("") || field.equals("location")) {
            Location cur_loc = this.getLocation();
            for (int i = 0; i < length; i++) {
                resource_dist[i] = new Index_value(i, distance(cur_loc, list.get(i).location));
            }
        } else if (field.equals("energy")) {
            for (int i = 0; i < length; i++) {
                resource_dist[i] = new Index_value(i, list.get(i).energy);
            }
        } else if (field.equals("ammostash")) {
            for (int i = 0; i < length; i++) {
                resource_dist[i] = new Index_value(i, list.get(i).ammostash);
            }
        } else if (field.equals("speed")) {
            for (int i = 0; i < length; i++) {
                resource_dist[i] = new Index_value(i, list.get(i).speed);
            }
        } else if (field.equals("health")) {
            for (int i = 0; i < length; i++) {
                resource_dist[i] = new Index_value(i, list.get(i).health);
            }
        } else {
            say("impossible to sort list - nothing modified");
            return list;
        }
        boolean permut;
        do {
            permut = false;
            for (int i = 0; i < length - 1; i++) {
                if (resource_dist[i].value > resource_dist[i + 1].value) {
                    Index_value a = resource_dist[i];
                    resource_dist[i] = resource_dist[i + 1];
                    resource_dist[i + 1] = a;
                    permut = true;
                }
            }
        } while (permut);
        RobotList<Resource> new_resource_list = new RobotList<Resource>(Resource.class);
        for (int i = 0; i < length; i++) {
            new_resource_list.addLast(list.get(resource_dist[i].index));
        }
        return new_resource_list;
    }
} </s>
<s>class temp {    public RobotList<Resource> sort_decr_Resource(RobotList<Resource> list, String field) {
        int length = list.size();
        Index_value[] resource_dist = new Index_value[length];
        if (field.equals("") || field.equals("location")) {
            Location cur_loc = this.getLocation();
            for (int i = 0; i < length; i++) {
                resource_dist[i] = new Index_value(i, distance(cur_loc, list.get(i).location));
            }
        } else if (field.equals("energy")) {
            for (int i = 0; i < length; i++) {
                resource_dist[i] = new Index_value(i, list.get(i).energy);
            }
        } else if (field.equals("ammostash")) {
            for (int i = 0; i < length; i++) {
                resource_dist[i] = new Index_value(i, list.get(i).ammostash);
            }
        } else if (field.equals("speed")) {
            for (int i = 0; i < length; i++) {
                resource_dist[i] = new Index_value(i, list.get(i).speed);
            }
        } else if (field.equals("health")) {
            for (int i = 0; i < length; i++) {
                resource_dist[i] = new Index_value(i, list.get(i).health);
            }
        } else {
            say("impossible to sort list - nothing modified");
            return list;
        }
        boolean permut;
        do {
            permut = false;
            for (int i = 0; i < length - 1; i++) {
                if (resource_dist[i].value < resource_dist[i + 1].value) {
                    Index_value a = resource_dist[i];
                    resource_dist[i] = resource_dist[i + 1];
                    resource_dist[i + 1] = a;
                    permut = true;
                }
            }
        } while (permut);
        RobotList<Resource> new_resource_list = new RobotList<Resource>(Resource.class);
        for (int i = 0; i < length; i++) {
            new_resource_list.addLast(list.get(resource_dist[i].index));
        }
        return new_resource_list;
    }
} </s>
<s>class temp {    public RobotList<Percentage> sort_incr_Percentage(RobotList<Percentage> list, String field) {
        int length = list.size();
        Index_value[] distri = new Index_value[length];
        for (int i = 0; i < length; i++) {
            distri[i] = new Index_value(i, list.get(i).percent);
        }
        boolean permut;
        do {
            permut = false;
            for (int i = 0; i < length - 1; i++) {
                if (distri[i].value > distri[i + 1].value) {
                    Index_value a = distri[i];
                    distri[i] = distri[i + 1];
                    distri[i + 1] = a;
                    permut = true;
                }
            }
        } while (permut);
        RobotList<Percentage> sol = new RobotList<Percentage>(Percentage.class);
        for (int i = 0; i < length; i++) {
            sol.addLast(new Percentage(distri[i].value));
        }
        return sol;
    }
} </s>
<s>class temp {    public RobotList<Percentage> sort_decr_Percentage(RobotList<Percentage> list, String field) {
        int length = list.size();
        Index_value[] distri = new Index_value[length];
        for (int i = 0; i < length; i++) {
            distri[i] = new Index_value(i, list.get(i).percent);
        }
        boolean permut;
        do {
            permut = false;
            for (int i = 0; i < length - 1; i++) {
                if (distri[i].value < distri[i + 1].value) {
                    Index_value a = distri[i];
                    distri[i] = distri[i + 1];
                    distri[i + 1] = a;
                    permut = true;
                }
            }
        } while (permut);
        RobotList<Percentage> sol = new RobotList<Percentage>(Percentage.class);
        for (int i = 0; i < length; i++) {
            sol.addLast(new Percentage(distri[i].value));
        }
        return sol;
    }
} </s>
<s>class temp {    public RobotList<Location> sort_incr_Location(RobotList<Location> list, String field) {
        int length = list.size();
        Index_value[] enemy_dist = new Index_value[length];
        Location cur_loc = this.getLocation();
        for (int i = 0; i < length; i++) {
            enemy_dist[i] = new Index_value(i, distance(cur_loc, list.get(i)));
        }
        boolean permut;
        do {
            permut = false;
            for (int i = 0; i < length - 1; i++) {
                if (enemy_dist[i].value > enemy_dist[i + 1].value) {
                    Index_value a = enemy_dist[i];
                    enemy_dist[i] = enemy_dist[i + 1];
                    enemy_dist[i + 1] = a;
                    permut = true;
                }
            }
        } while (permut);
        RobotList<Location> new_location_list = new RobotList<Location>(Location.class);
        for (int i = 0; i < length; i++) {
            new_location_list.addLast(list.get(enemy_dist[i].index));
        }
        return new_location_list;
    }
} </s>
<s>class temp {    public RobotList<Location> sort_decr_Location(RobotList<Location> list, String field) {
        int length = list.size();
        Index_value[] enemy_dist = new Index_value[length];
        if (field.equals("") || field.equals("location")) {
            Location cur_loc = this.getLocation();
            for (int i = 0; i < length; i++) {
                enemy_dist[i] = new Index_value(i, distance(cur_loc, list.get(i)));
            }
        } else if (field.equals("x")) {
            for (int i = 0; i < length; i++) {
                enemy_dist[i] = new Index_value(i, list.get(i).x);
            }
        } else if (field.equals("y")) {
            for (int i = 0; i < length; i++) {
                enemy_dist[i] = new Index_value(i, list.get(i).y);
            }
        } else {
            say("impossible to sort list - nothing modified");
            return list;
        }
        boolean permut;
        do {
            permut = false;
            for (int i = 0; i < length - 1; i++) {
                if (enemy_dist[i].value < enemy_dist[i + 1].value) {
                    Index_value a = enemy_dist[i];
                    enemy_dist[i] = enemy_dist[i + 1];
                    enemy_dist[i + 1] = a;
                    permut = true;
                }
            }
        } while (permut);
        RobotList<Location> new_location_list = new RobotList<Location>(Location.class);
        for (int i = 0; i < length; i++) {
            new_location_list.addLast(list.get(enemy_dist[i].index));
        }
        return new_location_list;
    }
} </s>
<s>class temp {    public static String getUserPass(String user) throws NoSuchAlgorithmException {
        MessageDigest digest = MessageDigest.getInstance("MD5");
        digest.update(user.getBytes());
        byte[] hash = digest.digest();
        System.out.println("Returning user pass:" + hash);
        return hash.toString();
    }
} </s>
<s>class temp {    public static String getMD5(String s) throws Exception {
        MessageDigest complete = MessageDigest.getInstance("MD5");
        complete.update(s.getBytes());
        byte[] b = complete.digest();
        String result = "";
        for (int i = 0; i < b.length; i++) {
            result += Integer.toString((b[i] & 0xff) + 0x100, 16).substring(1);
        }
        return result;
    }
} </s>
<s>class temp {    private void createWar() throws IOException, XMLStreamException {
        String appName = this.fileout.getName();
        int i = appName.indexOf(".");
        if (i != -1) appName = appName.substring(0, i);
        ZipOutputStream zout = new ZipOutputStream(new FileOutputStream(this.fileout));
        {
            ZipEntry entry = new ZipEntry("WEB-INF/web.xml");
            zout.putNextEntry(entry);
            XMLOutputFactory factory = XMLOutputFactory.newInstance();
            XMLStreamWriter w = factory.createXMLStreamWriter(zout, "ASCII");
            w.writeStartDocument("ASCII", "1.0");
            w.writeStartElement("web-app");
            w.writeAttribute("xsi", XSI, "schemaLocation", "http://java.sun.com/xml/ns/javaee http://java.sun.com/xml /ns/javaee/web-app_2_5.xsd");
            w.writeAttribute("version", "2.5");
            w.writeAttribute("xmlns", J2EE);
            w.writeAttribute("xmlns:xsi", XSI);
            w.writeStartElement("description");
            w.writeCharacters("Site maintenance for " + appName);
            w.writeEndElement();
            w.writeStartElement("display-name");
            w.writeCharacters(appName);
            w.writeEndElement();
            w.writeStartElement("servlet");
            w.writeStartElement("servlet-name");
            w.writeCharacters("down");
            w.writeEndElement();
            w.writeStartElement("jsp-file");
            w.writeCharacters("/WEB-INF/jsp/down.jsp");
            w.writeEndElement();
            w.writeEndElement();
            w.writeStartElement("servlet-mapping");
            w.writeStartElement("servlet-name");
            w.writeCharacters("down");
            w.writeEndElement();
            w.writeStartElement("url-pattern");
            w.writeCharacters("/*");
            w.writeEndElement();
            w.writeEndElement();
            w.writeEndElement();
            w.writeEndDocument();
            w.flush();
            zout.closeEntry();
        }
        {
            ZipEntry entry = new ZipEntry("WEB-INF/jsp/down.jsp");
            zout.putNextEntry(entry);
            PrintWriter w = new PrintWriter(zout);
            if (this.messageFile != null) {
                IOUtils.copyTo(new FileReader(this.messageFile), w);
            } else if (this.messageString != null) {
                w.print("<html><body>" + this.messageString + "</body></html>");
            } else {
                w.print("<html><body><div style='text-align:center;font-size:500%;'>Oh No !<br/><b>" + appName + "</b><br/>is down for maintenance!</div></body></html>");
            }
            w.flush();
            zout.closeEntry();
        }
        zout.finish();
        zout.flush();
        zout.close();
    }
} </s>
<s>class temp {    public static void copyFile(File in, File out) throws IOException {
        FileChannel inChannel = new FileInputStream(in).getChannel();
        FileChannel outChannel = new FileOutputStream(out).getChannel();
        try {
            inChannel.transferTo(0, inChannel.size(), outChannel);
        } catch (IOException e) {
            throw e;
        } finally {
            if (inChannel != null) inChannel.close();
            if (outChannel != null) outChannel.close();
        }
    }
} </s>
<s>class temp {    @org.junit.Test
    public void simpleRead() throws Exception {
        final InputStream istream = StatsInputStreamTest.class.getResourceAsStream("/testFile.txt");
        final StatsInputStream ris = new StatsInputStream(istream);
        assertEquals("read size", 0, ris.getSize());
        IOUtils.copy(ris, new NullOutputStream());
        assertEquals("in the end", 30, ris.getSize());
    }
} </s>
<s>class temp {    private static void doCopyFile(File srcFile, File destFile, boolean preserveFileDate) throws IOException {
        if (destFile.exists() && destFile.isDirectory()) {
            throw new IOException("Destination '" + destFile + "' exists but is a directory");
        }
        FileInputStream input = new FileInputStream(srcFile);
        try {
            FileOutputStream output = new FileOutputStream(destFile);
            try {
                IOUtils.copy(input, output);
            } finally {
                IOUtils.closeQuietly(output);
            }
        } finally {
            IOUtils.closeQuietly(input);
        }
        if (srcFile.length() != destFile.length()) {
            throw new IOException("Failed to copy full contents from '" + srcFile + "' to '" + destFile + "'");
        }
        if (preserveFileDate) {
            destFile.setLastModified(srcFile.lastModified());
        }
    }
} </s>
<s>class temp {    public void addGames(List<Game> games) throws StadiumException, SQLException {
        Connection conn = ConnectionManager.getManager().getConnection();
        conn.setAutoCommit(false);
        PreparedStatement stm = null;
        ResultSet rs = null;
        try {
            for (Game game : games) {
                stm = conn.prepareStatement(Statements.SELECT_STADIUM);
                stm.setString(1, game.getStadiumName());
                stm.setString(2, game.getStadiumCity());
                rs = stm.executeQuery();
                int stadiumId = -1;
                while (rs.next()) {
                    stadiumId = rs.getInt("stadiumID");
                }
                if (stadiumId == -1) throw new StadiumException("No such stadium");
                stm = conn.prepareStatement(Statements.INSERT_GAME);
                stm.setInt(1, stadiumId);
                stm.setDate(2, game.getGameDate());
                stm.setTime(3, game.getGameTime());
                stm.setString(4, game.getTeamA());
                stm.setString(5, game.getTeamB());
                stm.executeUpdate();
                int gameId = getMaxId();
                List<SectorPrice> sectorPrices = game.getSectorPrices();
                for (SectorPrice price : sectorPrices) {
                    stm = conn.prepareStatement(Statements.INSERT_TICKET_PRICE);
                    stm.setInt(1, gameId);
                    stm.setInt(2, price.getSectorId());
                    stm.setInt(3, price.getPrice());
                    stm.executeUpdate();
                }
            }
        } catch (SQLException e) {
            conn.rollback();
            throw e;
        } finally {
            rs.close();
            stm.close();
        }
        conn.commit();
        conn.setAutoCommit(true);
    }
} </s>
<s>class temp {    public void removeGames(List<Game> games) throws SQLException {
        Connection conn = ConnectionManager.getManager().getConnection();
        PreparedStatement stm = null;
        conn.setAutoCommit(false);
        try {
            for (Game game : games) {
                stm = conn.prepareStatement(Statements.DELETE_GAME);
                stm.setInt(1, game.getGameID());
                stm.executeUpdate();
            }
        } catch (SQLException e) {
            conn.rollback();
            throw e;
        } finally {
            if (stm != null) stm.close();
        }
        conn.commit();
        conn.setAutoCommit(true);
    }
} </s>
<s>class temp {    public static Vector webService(String siteUrl, String login, String password, String table, String station, String element, String dayFrom, String dayTo, String filePath) throws Exception {
        Service service = new Service();
        Call call = (Call) service.createCall();
        if (login != null) {
            call.setUsername(login);
            if (password != null) {
                call.setPassword(password);
            }
            System.err.println("Info: authentication user=" + login + " passwd=" + password + " at " + siteUrl);
        }
        call.setTargetEndpointAddress(new URL(siteUrl));
        call.setOperationName("syncData");
        Vector exportList = (Vector) call.invoke(new Object[] { table, station, element, dayFrom, dayTo });
        if (exportList != null) {
            for (int k = 0; k < exportList.size(); k++) {
                HashMap exportDescr = (HashMap) exportList.get(k);
                String url = (String) exportDescr.get("fileName");
                log.debug("result URL is " + url);
                String fileName = null;
                URL dataurl = new URL(url);
                String filePart = dataurl.getFile();
                if (filePart == null) {
                    throw new Exception("Error: file part in the data URL is null");
                } else {
                    fileName = filePart.substring(filePart.lastIndexOf("/") < 0 ? 0 : filePart.lastIndexOf("/") + 1);
                    if (filePath != null) {
                        fileName = filePath + fileName;
                    }
                    log.debug("local file name is " + fileName);
                }
                FileOutputStream fos = new FileOutputStream(fileName);
                if (fos == null) {
                    throw new Exception("Error: file output stream is null");
                }
                InputStream strm = dataurl.openStream();
                if (strm == null) {
                    throw new Exception("Error: data input stream is null");
                } else {
                    int c;
                    while ((c = strm.read()) != -1) {
                        fos.write(c);
                    }
                }
                strm.close();
                fos.close();
                File file = new File(fileName);
                exportDescr.put("fileName", file.getCanonicalPath());
            }
        }
        return exportList;
    }
} </s>
<s>class temp {    protected URLConnection openURLConnection() throws IOException {
        final String locator = getMediaLocator();
        if (locator == null) {
            return null;
        }
        final URL url;
        try {
            url = new URL(locator);
        } catch (MalformedURLException ex) {
            throw new IllegalArgumentException(ex);
        }
        final URLConnection connection = url.openConnection();
        connection.connect();
        return connection;
    }
} </s>
<s>class temp {    public static Document convertHtmlToXml(final InputStream htmlInputStream, final String classpathXsltResource, final String encoding) {
        Parser p = new Parser();
        javax.xml.parsers.DocumentBuilder db;
        try {
            db = javax.xml.parsers.DocumentBuilderFactory.newInstance().newDocumentBuilder();
        } catch (ParserConfigurationException e) {
            log.error("", e);
            throw new RuntimeException();
        }
        Document document = db.newDocument();
        InputStream is = htmlInputStream;
        if (log.isDebugEnabled()) {
            ByteArrayOutputStream baos;
            baos = new ByteArrayOutputStream();
            try {
                IOUtils.copy(is, baos);
            } catch (IOException e) {
                log.error("Fail to make input stream copy.", e);
            }
            IOUtils.closeQuietly(is);
            ByteArrayInputStream byteArrayInputStream;
            byteArrayInputStream = new ByteArrayInputStream(baos.toByteArray());
            try {
                IOUtils.toString(new ByteArrayInputStream(baos.toByteArray()), "UTF-8");
            } catch (IOException e) {
                log.error("", e);
            }
            IOUtils.closeQuietly(byteArrayInputStream);
            is = new ByteArrayInputStream(baos.toByteArray());
        }
        try {
            InputSource iSource = new InputSource(is);
            iSource.setEncoding(encoding);
            Source transformerSource = new SAXSource(p, iSource);
            Result result = new DOMResult(document);
            Transformer xslTransformer = getTransformerByName(classpathXsltResource, false);
            try {
                xslTransformer.transform(transformerSource, result);
            } catch (TransformerException e) {
                throw new RuntimeException(e);
            }
        } finally {
            try {
                is.close();
            } catch (Exception e) {
                log.warn("", e);
            }
        }
        return document;
    }
} </s>
<s>class temp {    private static void copyFile(String src, String target) throws IOException {
        FileChannel ic = new FileInputStream(src).getChannel();
        FileChannel oc = new FileOutputStream(target).getChannel();
        ic.transferTo(0, ic.size(), oc);
        ic.close();
        oc.close();
    }
} </s>
<s>class temp {    @Override
    protected URLConnection openConnection(URL url, Proxy proxy) throws IOException {
        if ((url == null) || (proxy == null)) {
            throw new IllegalArgumentException(Messages.getString("luni.1B"));
        }
        return new HttpsURLConnectionImpl(url, getDefaultPort(), proxy);
    }
} </s>
<s>class temp {    public static void loadMemcachedConfigFromURL(URL url, XMLInputFactory factory, List<MemcachedClientConfig> memcachedClientconfigs, List<MemcachedClientSocketPoolConfig> memcachedClientSocketPoolConfigs, List<MemcachedClientClusterConfig> memcachedClientClusterConfig) {
        MemcachedClientConfig node = null;
        MemcachedClientSocketPoolConfig socketnode = null;
        MemcachedClientClusterConfig clusternode = null;
        InputStream in = null;
        XMLEventReader r = null;
        try {
            in = url.openStream();
            r = factory.createXMLEventReader(in);
            String servers = null;
            String weights = null;
            while (r.hasNext()) {
                XMLEvent event = r.nextEvent();
                if (event.isStartElement()) {
                    StartElement start = event.asStartElement();
                    String tag = start.getName().getLocalPart();
                    if (tag.equalsIgnoreCase("client")) {
                        node = new MemcachedClientConfig();
                        if (start.getAttributeByName(new QName("", "name")) != null) node.setName(start.getAttributeByName(new QName("", "name")).getValue()); else throw new RuntimeException("memcached client name can't not be null!");
                        if (start.getAttributeByName(new QName("", "socketpool")) != null) node.setSocketPool(start.getAttributeByName(new QName("", "socketpool")).getValue()); else throw new RuntimeException("memcached client socketpool can't not be null!");
                        if (start.getAttributeByName(new QName("", "compressEnable")) != null) node.setCompressEnable(Boolean.parseBoolean(start.getAttributeByName(new QName("", "compressEnable")).getValue())); else node.setCompressEnable(true);
                        if (start.getAttributeByName(new QName("", "defaultEncoding")) != null) node.setDefaultEncoding(start.getAttributeByName(new QName("", "defaultEncoding")).getValue()); else node.setDefaultEncoding("UTF-8");
                        continue;
                    }
                    if (tag.equalsIgnoreCase("errorHandler") && node != null) {
                        event = r.peek();
                        if (event.isCharacters()) {
                            node.setErrorHandler(event.asCharacters().getData());
                            r.nextEvent();
                        }
                        continue;
                    }
                    if (tag.equalsIgnoreCase("socketpool")) {
                        socketnode = new MemcachedClientSocketPoolConfig();
                        servers = null;
                        weights = null;
                        if (start.getAttributeByName(new QName("", "name")) != null) socketnode.setName(start.getAttributeByName(new QName("", "name")).getValue()); else throw new RuntimeException("memcached client socketpool name can't not be null!");
                        if (start.getAttributeByName(new QName("", "failover")) != null) socketnode.setFailover(Boolean.parseBoolean(start.getAttributeByName(new QName("", "failover")).getValue()));
                        if (start.getAttributeByName(new QName("", "initConn")) != null) socketnode.setInitConn(Integer.parseInt(start.getAttributeByName(new QName("", "initConn")).getValue()));
                        if (start.getAttributeByName(new QName("", "minConn")) != null) socketnode.setMinConn(Integer.parseInt(start.getAttributeByName(new QName("", "minConn")).getValue()));
                        if (start.getAttributeByName(new QName("", "maxConn")) != null) socketnode.setMaxConn(Integer.parseInt(start.getAttributeByName(new QName("", "maxConn")).getValue()));
                        if (start.getAttributeByName(new QName("", "maintSleep")) != null) socketnode.setMaintSleep(Integer.parseInt(start.getAttributeByName(new QName("", "maintSleep")).getValue()));
                        if (start.getAttributeByName(new QName("", "nagle")) != null) socketnode.setNagle(Boolean.parseBoolean(start.getAttributeByName(new QName("", "nagle")).getValue()));
                        if (start.getAttributeByName(new QName("", "socketTO")) != null) socketnode.setSocketTo(Integer.parseInt(start.getAttributeByName(new QName("", "socketTO")).getValue()));
                        if (start.getAttributeByName(new QName("", "maxIdle")) != null) socketnode.setMaxIdle(Integer.parseInt(start.getAttributeByName(new QName("", "maxIdle")).getValue()));
                        if (start.getAttributeByName(new QName("", "aliveCheck")) != null) socketnode.setAliveCheck(Boolean.parseBoolean(start.getAttributeByName(new QName("", "aliveCheck")).getValue()));
                        continue;
                    }
                    if (tag.equalsIgnoreCase("servers") && socketnode != null) {
                        event = r.peek();
                        if (event.isCharacters()) {
                            servers = event.asCharacters().getData();
                            socketnode.setServers(servers);
                            r.nextEvent();
                        }
                        continue;
                    }
                    if (tag.equalsIgnoreCase("weights") && socketnode != null) {
                        event = r.peek();
                        if (event.isCharacters()) {
                            weights = event.asCharacters().getData();
                            socketnode.setWeights(weights);
                            r.nextEvent();
                        }
                        continue;
                    }
                    if (tag.equalsIgnoreCase("cluster")) {
                        clusternode = new MemcachedClientClusterConfig();
                        if (start.getAttributeByName(new QName("", "name")) != null) clusternode.setName(start.getAttributeByName(new QName("", "name")).getValue()); else throw new RuntimeException("memcached cluster name can't not be null!");
                        if (start.getAttributeByName(new QName("", "mode")) != null) clusternode.setMode(start.getAttributeByName(new QName("", "mode")).getValue());
                        continue;
                    }
                    if (tag.equalsIgnoreCase("memCachedClients") && clusternode != null) {
                        event = r.peek();
                        if (event.isCharacters()) {
                            String clients = event.asCharacters().getData();
                            if (clients != null && !clients.equals("")) {
                                clusternode.setMemCachedClients(clients.split(","));
                            }
                            r.nextEvent();
                        }
                        continue;
                    }
                }
                if (event.isEndElement()) {
                    EndElement end = event.asEndElement();
                    if (node != null && end.getName().getLocalPart().equalsIgnoreCase("client")) {
                        memcachedClientconfigs.add(node);
                        Logger.info(new StringBuilder().append(" add memcachedClient config :").append(node.getName()));
                        continue;
                    }
                    if (socketnode != null && end.getName().getLocalPart().equalsIgnoreCase("socketpool")) {
                        memcachedClientSocketPoolConfigs.add(socketnode);
                        Logger.info(new StringBuilder().append(" add socketpool config :").append(socketnode.getName()));
                        continue;
                    }
                    if (clusternode != null && end.getName().getLocalPart().equalsIgnoreCase("cluster")) {
                        memcachedClientClusterConfig.add(clusternode);
                        Logger.info(new StringBuilder().append(" add cluster config :").append(clusternode.getName()));
                        continue;
                    }
                }
            }
        } catch (Exception e) {
            Logger.error(new StringBuilder("MemcachedManager loadConfig error !").append(" config url :").append(url.getFile()).toString());
            node = null;
        } finally {
            try {
                if (r != null) r.close();
                if (in != null) in.close();
                r = null;
                in = null;
            } catch (Exception ex) {
                throw new RuntimeException("processConfigURL error !", ex);
            }
        }
    }
} </s>
<s>class temp {    FileCacheInputStreamFountain(FileCacheInputStreamFountainFactory factory, InputStream in) throws IOException {
        file = factory.createFile();
        OutputStream out = new FileOutputStream(file);
        IOUtils.copy(in, out);
        in.close();
        out.close();
    }
} </s>
<s>class temp {    String getOutputPage(String action, String XML, String xslFileName, InputStream pageS, HttpServletRequest request) throws NoSuchAlgorithmException, UnsupportedEncodingException, TransformerException {
        String sPage = null;
        Transformer transformer = null;
        String dig = null;
        CharArrayWriter page = new CharArrayWriter();
        if (this.nCachedPages > 0) {
            java.security.MessageDigest mess = java.security.MessageDigest.getInstance("SHA1");
            mess.update(XML.getBytes());
            mess.update(Long.toString(new File(basePath + xslFileName).lastModified()).getBytes());
            dig = new String(mess.digest());
            synchronized (pages) {
                if (pages.containsKey(dig)) {
                    sPage = pages.get(dig);
                }
            }
        }
        if (sPage == null && xslFileName.length() > 4) {
            try {
                long modifyTime = new File(basePath + xslFileName).lastModified();
                String path = basePath.replaceAll("\\\\", "/") + xslFileName;
                path = "file:///" + path;
                boolean add2cache = false;
                if (this.nCachedTransformers > 0) {
                    String cacheKey = action + xslFileName + modifyTime;
                    if (this.transformers.containsKey(cacheKey)) {
                        transformer = this.transformers.get(cacheKey);
                        synchronized (transformer) {
                            transformer.transform(new StreamSource(new ByteArrayInputStream(XML.getBytes("UTF-8"))), new StreamResult(page));
                        }
                    } else {
                        add2cache = true;
                    }
                }
                if (transformer == null) {
                    transformer = TransformerFactory.newInstance().newTransformer(new StreamSource(path));
                    transformer.transform(new StreamSource(new ByteArrayInputStream(XML.getBytes("UTF-8"))), new StreamResult(page));
                }
                sPage = page.toString();
                sPage = sPage.replaceAll("&lt;", "<");
                sPage = sPage.replaceAll("&gt;", ">");
                sPage = replaceLinks(sPage, request);
                if (this.nCachedPages > 0) {
                    synchronized (pages) {
                        pages.put(dig, sPage);
                        if (pages.size() > nCachedPages) {
                            Iterator<String> i = pages.values().iterator();
                            i.next();
                            i.remove();
                        }
                    }
                }
                if (add2cache) {
                    synchronized (this.transformers) {
                        this.transformers.put(action + xslFileName + modifyTime, transformer);
                        if (this.transformers.size() > this.nCachedTransformers) {
                            Iterator<Transformer> it = this.transformers.values().iterator();
                            it.next();
                            it.remove();
                        }
                    }
                }
            } catch (TransformerException ex) {
                Logger.getLogger(getClass().getName()).log(Level.SEVERE, "---------------------------------------------");
                Logger.getLogger(getClass().getName()).log(Level.SEVERE, null, ex);
                Logger.getLogger(getClass().getName()).log(Level.SEVERE, ("XSL file: " + xslFileName));
                Logger.getLogger(getClass().getName()).log(Level.SEVERE, XML);
                Logger.getLogger(getClass().getName()).log(Level.SEVERE, "---------------------------------------------");
                throw ex;
            }
        }
        return sPage;
    }
} </s>
<s>class temp {    public static void copy(File from_file, File to_file) throws IOException {
        if (!from_file.exists()) {
            throw new IOException("FileCopy: no such source file: " + from_file.getPath());
        }
        if (!from_file.isFile()) {
            throw new IOException("FileCopy: can't copy directory: " + from_file.getPath());
        }
        if (!from_file.canRead()) {
            throw new IOException("FileCopy: source file is unreadable: " + from_file.getPath());
        }
        if (to_file.isDirectory()) {
            to_file = new File(to_file, from_file.getName());
        }
        if (to_file.exists()) {
            if (!to_file.canWrite()) {
                throw new IOException("FileCopy: destination file is unwriteable: " + to_file.getPath());
            }
            int choice = JOptionPane.showConfirmDialog(null, "Overwrite existing file " + to_file.getPath(), "File Exists", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE);
            if (choice != JOptionPane.YES_OPTION) {
                throw new IOException("FileCopy: existing file was not overwritten.");
            }
        } else {
            String parent = to_file.getParent();
            if (parent == null) {
                parent = Globals.getDefaultPath();
            }
            File dir = new File(parent);
            if (!dir.exists()) {
                throw new IOException("FileCopy: destination directory doesn't exist: " + parent);
            }
            if (dir.isFile()) {
                throw new IOException("FileCopy: destination is not a directory: " + parent);
            }
            if (!dir.canWrite()) {
                throw new IOException("FileCopy: destination directory is unwriteable: " + parent);
            }
        }
        FileInputStream from = null;
        FileOutputStream to = null;
        try {
            from = new FileInputStream(from_file);
            to = new FileOutputStream(to_file);
            byte[] buffer = new byte[4096];
            int bytes_read;
            while ((bytes_read = from.read(buffer)) != -1) {
                to.write(buffer, 0, bytes_read);
            }
        } finally {
            if (from != null) {
                try {
                    from.close();
                } catch (IOException e) {
                }
            }
            if (to != null) {
                try {
                    to.close();
                } catch (IOException e) {
                }
            }
        }
    }
} </s>
<s>class temp {        public void run() {
            try {
                IOUtils.copy(is, os);
                os.flush();
            } catch (IOException ioe) {
                logger.error("Unable to copy", ioe);
            } finally {
                IOUtils.closeQuietly(is);
                IOUtils.closeQuietly(os);
            }
        }
} </s>
<s>class temp {    public static int convertImage(InputStream is, OutputStream os, String command) throws IOException, InterruptedException {
        if (logger.isInfoEnabled()) {
            logger.info(command);
        }
        Process p = Runtime.getRuntime().exec(command);
        ByteArrayOutputStream errOut = new ByteArrayOutputStream();
        StreamGobbler errGobbler = new StreamGobbler(p.getErrorStream(), errOut, "Convert Thread (err gobbler): " + command);
        errGobbler.start();
        StreamGobbler outGobbler = new StreamGobbler(new BufferedInputStream(is), p.getOutputStream(), "Convert Thread (out gobbler): " + command);
        outGobbler.start();
        try {
            IOUtils.copy(p.getInputStream(), os);
            os.flush();
            if (p.waitFor() != 0) {
                logger.error("Unable to convert, stderr: " + new String(errOut.toByteArray(), "UTF-8"));
            }
            return p.exitValue();
        } finally {
            IOUtils.closeQuietly(os);
        }
    }
} </s>
<s>class temp {    protected void unZip() throws PersistenceException {
        boolean newZip = false;
        try {
            if (null == backup) {
                mode = (String) context.get(Context.MODE);
                if (null == mode) mode = Context.MODE_NAME_RESTORE;
                backupDirectory = (File) context.get(Context.BACKUP_DIRECTORY);
                logger.debug("Got backup directory {" + backupDirectory.getAbsolutePath() + "}");
                if (!backupDirectory.exists() && mode.equals(Context.MODE_NAME_BACKUP)) {
                    newZip = true;
                    backupDirectory.mkdirs();
                } else if (!backupDirectory.exists()) {
                    throw new PersistenceException("Backup directory {" + backupDirectory.getAbsolutePath() + "} does not exist.");
                }
                backup = new File(backupDirectory + "/" + getBackupName() + ".zip");
                logger.debug("Got zip file {" + backup.getAbsolutePath() + "}");
            }
            File _explodedDirectory = File.createTempFile("exploded-" + backup.getName() + "-", ".zip");
            _explodedDirectory.mkdirs();
            _explodedDirectory.delete();
            backupDirectory = new File(_explodedDirectory.getParentFile(), _explodedDirectory.getName());
            backupDirectory.mkdirs();
            logger.debug("Created exploded directory {" + backupDirectory.getAbsolutePath() + "}");
            if (!backup.exists() && mode.equals(Context.MODE_NAME_BACKUP)) {
                newZip = true;
                backup.createNewFile();
            } else if (!backup.exists()) {
                throw new PersistenceException("Backup file {" + backup.getAbsolutePath() + "} does not exist.");
            }
            if (newZip) return;
            ZipFile zip = new ZipFile(backup);
            Enumeration zipFileEntries = zip.entries();
            while (zipFileEntries.hasMoreElements()) {
                ZipEntry entry = (ZipEntry) zipFileEntries.nextElement();
                String currentEntry = entry.getName();
                logger.debug("Inflating: " + entry);
                File destFile = new File(backupDirectory, currentEntry);
                File destinationParent = destFile.getParentFile();
                destinationParent.mkdirs();
                if (!entry.isDirectory()) {
                    InputStream in = null;
                    OutputStream out = null;
                    try {
                        in = zip.getInputStream(entry);
                        out = new FileOutputStream(destFile);
                        IOUtils.copy(in, out);
                    } finally {
                        if (null != out) out.close();
                        if (null != in) in.close();
                    }
                }
            }
        } catch (IOException e) {
            logger.error("Unable to unzip {" + backup + "}", e);
            throw new PersistenceException(e);
        }
    }
} </s>
<s>class temp {    public void zipUp() throws PersistenceException {
        ZipOutputStream out = null;
        try {
            if (!backup.exists()) backup.createNewFile();
            out = new ZipOutputStream(new FileOutputStream(backup));
            out.setLevel(Deflater.DEFAULT_COMPRESSION);
            for (String file : backupDirectory.list()) {
                logger.debug("Deflating: " + file);
                FileInputStream in = null;
                try {
                    in = new FileInputStream(new File(backupDirectory, file));
                    out.putNextEntry(new ZipEntry(file));
                    IOUtils.copy(in, out);
                } finally {
                    out.closeEntry();
                    if (null != in) in.close();
                }
            }
            FileUtils.deleteDirectory(backupDirectory);
        } catch (Exception ex) {
            logger.error("Unable to ZIP the backup {" + backupDirectory.getAbsolutePath() + "}.", ex);
            throw new PersistenceException(ex);
        } finally {
            try {
                if (null != out) out.close();
            } catch (IOException e) {
                logger.error("Unable to close ZIP output stream.", e);
            }
        }
    }
} </s>
<s>class temp {    public APIResponse delete(String id) throws Exception {
        APIResponse response = new APIResponse();
        connection = (HttpURLConnection) new URL(url + "/api/variable/delete/" + id).openConnection();
        connection.setRequestMethod("DELETE");
        connection.setConnectTimeout(TIMEOUT);
        connection.connect();
        if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {
            response.setDone(true);
            response.setMessage("Variable Deleted!");
        } else {
            response.setDone(false);
            response.setMessage("Delete Variable Error Code: Http (" + connection.getResponseCode() + ")");
        }
        connection.disconnect();
        return response;
    }
} </s>
<s>class temp {    public APIResponse update(Variable variable) throws Exception {
        APIResponse response = new APIResponse();
        connection = (HttpURLConnection) new URL(url + "/api/variable/update").openConnection();
        connection.setDoOutput(true);
        connection.setRequestMethod("PUT");
        connection.setRequestProperty("Content-Type", "application/json; charset=utf-8");
        connection.setUseCaches(false);
        connection.setConnectTimeout(TIMEOUT);
        connection.connect();
        marshaller.marshal(variable, new MappedXMLStreamWriter(new MappedNamespaceConvention(new Configuration()), new OutputStreamWriter(connection.getOutputStream(), "utf-8")));
        connection.getOutputStream().flush();
        connection.getOutputStream().close();
        if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {
            JSONObject obj = new JSONObject(new String(new BufferedReader(new InputStreamReader(connection.getInputStream(), "utf-8")).readLine()));
            response.setDone(true);
            response.setMessage(unmarshaller.unmarshal(new MappedXMLStreamReader(obj, new MappedNamespaceConvention(new Configuration()))));
            connection.getInputStream().close();
        } else {
            response.setDone(false);
            response.setMessage("Update Variable Error Code: Http (" + connection.getResponseCode() + ")");
        }
        connection.disconnect();
        return response;
    }
} </s>
<s>class temp {    private static void readAndRewrite(File inFile, File outFile) throws IOException {
        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));
        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);
        Dataset ds = DcmObjectFactory.getInstance().newDataset();
        dcmParser.setDcmHandler(ds.getDcmHandler());
        dcmParser.parseDcmFile(null, Tags.PixelData);
        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        System.out.println("reading " + inFile + "...");
        pdReader.readPixelData(false);
        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));
        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;
        ds.writeDataset(out, dcmEncParam);
        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());
        System.out.println("writing " + outFile + "...");
        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        pdWriter.writePixelData();
        out.flush();
        out.close();
        System.out.println("done!");
    }
} </s>
<s>class temp {    private static URL searchForBundle(String name, String parent) throws MalformedURLException {
        URL url = null;
        File fileLocation = null;
        boolean reference = false;
        try {
            URL child = new URL(name);
            url = new URL(new File(parent).toURL(), name);
        } catch (MalformedURLException e) {
            File child = new File(name);
            fileLocation = child.isAbsolute() ? child : new File(parent, name);
            url = new URL(REFERENCE_PROTOCOL, null, fileLocation.toURL().toExternalForm());
            reference = true;
        }
        if (!reference) {
            URL baseURL = url;
            if (url.getProtocol().equals(REFERENCE_PROTOCOL)) {
                reference = true;
                String baseSpec = url.getFile();
                if (baseSpec.startsWith(FILE_SCHEME)) {
                    File child = new File(baseSpec.substring(5));
                    baseURL = child.isAbsolute() ? child.toURL() : new File(parent, child.getPath()).toURL();
                } else baseURL = new URL(baseSpec);
            }
            fileLocation = new File(baseURL.getFile());
            if (!fileLocation.isAbsolute()) fileLocation = new File(parent, fileLocation.toString());
        }
        if (reference) {
            String result = searchFor(fileLocation.getName(), new File(fileLocation.getParent()).getAbsolutePath());
            if (result != null) url = new URL(REFERENCE_PROTOCOL, null, FILE_SCHEME + result); else return null;
        }
        try {
            URLConnection result = url.openConnection();
            result.connect();
            return url;
        } catch (IOException e) {
            return null;
        }
    }
} </s>
<s>class temp {    public static void main(String[] argv) throws IOException {
        int i;
        for (i = 0; i < argv.length; i++) {
            if (argv[i].charAt(0) != '-') break;
            ++i;
            switch(argv[i - 1].charAt(1)) {
                case 'b':
                    try {
                        flag_predict_probability = (atoi(argv[i]) != 0);
                    } catch (NumberFormatException e) {
                        exit_with_help();
                    }
                    break;
                default:
                    System.err.printf("unknown option: -%d%n", argv[i - 1].charAt(1));
                    exit_with_help();
                    break;
            }
        }
        if (i >= argv.length || argv.length <= i + 2) {
            exit_with_help();
        }
        BufferedReader reader = null;
        Writer writer = null;
        try {
            reader = new BufferedReader(new InputStreamReader(new FileInputStream(argv[i]), Linear.FILE_CHARSET));
            writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(argv[i + 2]), Linear.FILE_CHARSET));
            Model model = Linear.loadModel(new File(argv[i + 1]));
            doPredict(reader, writer, model);
        } finally {
            closeQuietly(reader);
            closeQuietly(writer);
        }
    }
} </s>
<s>class temp {    private static String getProviderName(URL url, PrintStream err) {
        InputStream in = null;
        try {
            in = url.openStream();
            BufferedReader reader = new BufferedReader(new InputStreamReader(in, "utf-8"));
            String result = null;
            while (true) {
                String line = reader.readLine();
                if (line == null) {
                    break;
                }
                int commentPos = line.indexOf('#');
                if (commentPos >= 0) {
                    line = line.substring(0, commentPos);
                }
                line = line.trim();
                int len = line.length();
                if (len != 0) {
                    if (result != null) {
                        print(err, "checkconfig.multiproviders", url.toString());
                        return null;
                    }
                    result = line;
                }
            }
            if (result == null) {
                print(err, "checkconfig.missingprovider", url.toString());
                return null;
            }
            return result;
        } catch (IOException e) {
            print(err, "configconfig.read", url.toString(), e);
            return null;
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException e) {
                }
            }
        }
    }
} </s>
<s>class temp {        protected void onSubmit() {
            super.onSubmit();
            if (!this.hasError()) {
                final FileUpload upload = fileUploadField.getFileUpload();
                if (upload != null) {
                    try {
                        StringWriter xmlSourceWriter = new StringWriter();
                        IOUtils.copy(upload.getInputStream(), xmlSourceWriter);
                        processSubmittedDoap(xmlSourceWriter.toString());
                    } catch (IOException e) {
                        setResponsePage(new ErrorReportPage(new UserReportableException("Unable to add doap using RDF supplied", DoapFormPage.class, e)));
                    }
                }
            }
        }
} </s>
<s>class temp {        protected void processAddByURLSubmit(URL url, String invalidUrlMsg) {
            if (!this.hasError()) {
                try {
                    StringWriter xmlSourceWriter = new StringWriter();
                    IOUtils.copy(url.openStream(), xmlSourceWriter);
                    processSubmittedDoap(xmlSourceWriter.toString());
                } catch (FileNotFoundException e) {
                    Session.get().error(invalidUrlMsg);
                    logger.warn("Error processing URL: " + invalidUrlMsg);
                } catch (IOException e) {
                    setResponsePage(new ErrorReportPage(new UserReportableException("Unable to add doap using RDF supplied", DoapFormPage.class, e)));
                    logger.warn("Error processing URL: " + url + "; " + e.getMessage(), e);
                }
            }
        }
} </s>
<s>class temp {    public String kodetu(String testusoila) {
        MessageDigest md = null;
        try {
            md = MessageDigest.getInstance("SHA");
            md.update(testusoila.getBytes("UTF-8"));
        } catch (NoSuchAlgorithmException e) {
            new MezuLeiho("Ez da zifraketa algoritmoa aurkitu", "Ados", "Zifraketa Arazoa", JOptionPane.ERROR_MESSAGE);
            e.printStackTrace();
        } catch (UnsupportedEncodingException e) {
            new MezuLeiho("Errorea kodetzerakoan", "Ados", "Kodeketa Errorea", JOptionPane.ERROR_MESSAGE);
            e.printStackTrace();
        }
        byte raw[] = md.digest();
        String hash = (new BASE64Encoder()).encode(raw);
        return hash;
    }
} </s>
<s>class temp {    private void transform(CommandLine commandLine) throws IOException {
        Reader reader;
        if (commandLine.hasOption('i')) {
            reader = createFileReader(commandLine.getOptionValue('i'));
        } else {
            reader = createStandardInputReader();
        }
        Writer writer;
        if (commandLine.hasOption('o')) {
            writer = createFileWriter(commandLine.getOptionValue('o'));
        } else {
            writer = createStandardOutputWriter();
        }
        String mapRule = commandLine.getOptionValue("m");
        try {
            SrxTransformer transformer = new SrxAnyTransformer();
            Map<String, Object> parameterMap = new HashMap<String, Object>();
            if (mapRule != null) {
                parameterMap.put(Srx1Transformer.MAP_RULE_NAME, mapRule);
            }
            transformer.transform(reader, writer, parameterMap);
        } finally {
            cleanupReader(reader);
            cleanupWriter(writer);
        }
    }
} </s>
<s>class temp {    public void testTransactions() throws Exception {
        con = TestUtil.openDB();
        Statement st;
        ResultSet rs;
        con.setAutoCommit(false);
        assertTrue(!con.getAutoCommit());
        con.setAutoCommit(true);
        assertTrue(con.getAutoCommit());
        st = con.createStatement();
        st.executeUpdate("insert into test_a (imagename,image,id) values ('comttest',1234,5678)");
        con.setAutoCommit(false);
        st.executeUpdate("update test_a set image=9876 where id=5678");
        con.commit();
        rs = st.executeQuery("select image from test_a where id=5678");
        assertTrue(rs.next());
        assertEquals(9876, rs.getInt(1));
        rs.close();
        st.executeUpdate("update test_a set image=1111 where id=5678");
        con.rollback();
        rs = st.executeQuery("select image from test_a where id=5678");
        assertTrue(rs.next());
        assertEquals(9876, rs.getInt(1));
        rs.close();
        TestUtil.closeDB(con);
    }
} </s>
<s>class temp {    public boolean isPasswordValid(String encPass, String rawPass, Object salt) throws DataAccessException {
        boolean bMatch = false;
        try {
            String strSalt = (String) salt;
            byte[] baSalt = Hex.decodeHex(strSalt.toCharArray());
            MessageDigest md = MessageDigest.getInstance(HASH_ALGORITHM);
            md.update(rawPass.getBytes(CHAR_ENCODING));
            md.update(baSalt);
            byte[] baCalculatedHash = md.digest();
            byte[] baStoredHash = Hex.decodeHex(encPass.toCharArray());
            bMatch = MessageDigest.isEqual(baCalculatedHash, baStoredHash);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return bMatch;
    }
} </s>
<s>class temp {    protected boolean checkResource(final String resourceName) {
        boolean isValid = true;
        HttpURLConnection.setFollowRedirects(false);
        try {
            final URL url = new URL(buildUrl(new Resource(resourceName).getName()));
            logger.debug("check url: " + url.toString());
            final HttpURLConnection headConnection = (HttpURLConnection) url.openConnection();
            addHeaders(headConnection);
            headConnection.setRequestMethod("HEAD");
            headConnection.setDoOutput(true);
            int statusCode = headConnection.getResponseCode();
            if (statusCode == HttpURLConnection.HTTP_MOVED_PERM) {
                isValid = false;
                logger.debug("responseCode: " + statusCode);
            } else {
                logger.debug("responseCode: " + statusCode);
            }
        } catch (MalformedURLException e) {
            logger.error(e.toString());
            isValid = false;
        } catch (ProtocolException e) {
            logger.error(e.toString());
            isValid = false;
        } catch (IOException e) {
            logger.error(e.toString());
            isValid = false;
        }
        HttpURLConnection.setFollowRedirects(true);
        return isValid;
    }
} </s>
<s>class temp {    public APIResponse create(Application application) throws Exception {
        APIResponse response = new APIResponse();
        connection = (HttpURLConnection) new URL(url + "/api/application/create").openConnection();
        connection.setDoOutput(true);
        connection.setRequestMethod("POST");
        connection.setRequestProperty("Content-Type", "application/json; charset=utf-8");
        connection.setUseCaches(false);
        connection.setConnectTimeout(TIMEOUT);
        connection.connect();
        marshaller.marshal(application, new MappedXMLStreamWriter(new MappedNamespaceConvention(new Configuration()), new OutputStreamWriter(connection.getOutputStream(), "utf-8")));
        connection.getOutputStream().flush();
        connection.getOutputStream().close();
        if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {
            JSONObject obj = new JSONObject(new String(new BufferedReader(new InputStreamReader(connection.getInputStream(), "utf-8")).readLine()));
            response.setDone(true);
            response.setMessage(unmarshaller.unmarshal(new MappedXMLStreamReader(obj, new MappedNamespaceConvention(new Configuration()))));
            connection.getInputStream().close();
        } else {
            response.setDone(false);
            response.setMessage("Create Application Error Code: Http (" + connection.getResponseCode() + ")");
        }
        connection.disconnect();
        return response;
    }
} </s>
<s>class temp {    public APIResponse delete(String id) throws Exception {
        APIResponse response = new APIResponse();
        connection = (HttpURLConnection) new URL(url + "/api/application/delete/" + id).openConnection();
        connection.setRequestMethod("DELETE");
        connection.setConnectTimeout(TIMEOUT);
        connection.connect();
        if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {
            response.setDone(true);
            response.setMessage("Application Deleted!");
        } else {
            response.setDone(false);
            response.setMessage("Delete Application Error Code: Http (" + connection.getResponseCode() + ")");
        }
        connection.disconnect();
        return response;
    }
} </s>
<s>class temp {    public APIResponse update(Application application) throws Exception {
        APIResponse response = new APIResponse();
        connection = (HttpURLConnection) new URL(url + "/api/application/update").openConnection();
        connection.setDoOutput(true);
        connection.setRequestMethod("PUT");
        connection.setRequestProperty("Content-Type", "application/json; charset=utf-8");
        connection.setUseCaches(false);
        connection.setConnectTimeout(TIMEOUT);
        connection.connect();
        marshaller.marshal(application, new MappedXMLStreamWriter(new MappedNamespaceConvention(new Configuration()), new OutputStreamWriter(connection.getOutputStream(), "utf-8")));
        connection.getOutputStream().flush();
        connection.getOutputStream().close();
        if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {
            JSONObject obj = new JSONObject(new String(new BufferedReader(new InputStreamReader(connection.getInputStream(), "utf-8")).readLine()));
            response.setDone(true);
            response.setMessage(unmarshaller.unmarshal(new MappedXMLStreamReader(obj, new MappedNamespaceConvention(new Configuration()))));
            connection.getInputStream().close();
        } else {
            response.setDone(false);
            response.setMessage("Update Application Error Code: Http (" + connection.getResponseCode() + ")");
        }
        connection.disconnect();
        return response;
    }
} </s>
<s>class temp {    private String readLine(final String urlStr) {
        BufferedReader reader;
        String line = null;
        try {
            URL url = new URL(urlStr);
            reader = new BufferedReader(new InputStreamReader(url.openStream()));
            line = reader.readLine();
        } catch (MalformedURLException e) {
            log.error(e, e);
        } catch (IOException e) {
            log.error(e, e);
        }
        return line;
    }
} </s>
<s>class temp {    protected void copyFile(final File in, final File out) throws IOException {
        final FileChannel inChannel = new FileInputStream(in).getChannel();
        final FileChannel outChannel = new FileOutputStream(out).getChannel();
        try {
            inChannel.transferTo(0, inChannel.size(), outChannel);
        } catch (final IOException e) {
            throw e;
        } finally {
            if (inChannel != null) {
                inChannel.close();
            }
            if (outChannel != null) {
                outChannel.close();
            }
        }
    }
} </s>
<s>class temp {    public static void replaceAll(File file, String substitute, String substituteReplacement) throws IOException {
        log.debug("Replace " + substitute + " by " + substituteReplacement);
        Pattern pattern = Pattern.compile(substitute);
        FileInputStream fis = new FileInputStream(file);
        FileChannel fc = fis.getChannel();
        int sz = (int) fc.size();
        MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);
        Charset charset = Charset.forName("ISO-8859-15");
        CharsetDecoder decoder = charset.newDecoder();
        CharBuffer cb = decoder.decode(bb);
        Matcher matcher = pattern.matcher(cb);
        String outString = matcher.replaceAll(substituteReplacement);
        log.debug(outString);
        FileOutputStream fos = new FileOutputStream(file.getAbsolutePath());
        PrintStream ps = new PrintStream(fos);
        ps.print(outString);
        ps.close();
        fos.close();
    }
} </s>
<s>class temp {    public void writeToStream(OutputStream out) throws IOException {
        InputStream result = null;
        if (tempFile != null) {
            InputStream input = new BufferedInputStream(new FileInputStream(tempFile));
            IOUtils.copy(input, out);
            IOUtils.closeQuietly(input);
        } else if (tempBuffer != null) {
            out.write(tempBuffer);
        }
    }
} </s>
<s>class temp {    private static void copyFile(File in, File out) throws IOException {
        FileChannel inChannel = new FileInputStream(in).getChannel();
        FileChannel outChannel = new FileOutputStream(out).getChannel();
        try {
            inChannel.transferTo(0, inChannel.size(), outChannel);
        } catch (IOException e) {
            throw e;
        } finally {
            if (inChannel != null) inChannel.close();
            if (outChannel != null) outChannel.close();
        }
    }
} </s>
<s>class temp {    private void initializeTree() {
        InputStreamReader reader = null;
        BufferedReader buffReader = null;
        try {
            for (int i = 0; i < ORDER.length; i++) {
                int index = ORDER[i];
                String indexName = index < 10 ? "0" + index : (index > 20 ? "big" : "" + index);
                URL url = EmptyClass.class.getResource("engchar" + indexName + ".dic");
                logger.info("... Loading: " + "engchar" + indexName + ".dic = {" + url + "}");
                reader = new InputStreamReader(url.openStream());
                buffReader = new BufferedReader(reader);
                String line = null;
                String word = null;
                do {
                    line = buffReader.readLine();
                    if (line != null) {
                        boolean plural = line.endsWith("/S");
                        boolean forbidden = line.endsWith("/X");
                        if (plural) {
                            int stringIndex = line.indexOf("/S");
                            word = new String(line.substring(0, stringIndex));
                        } else if (forbidden) {
                            int stringIndex = line.indexOf("/X");
                            word = new String(line.substring(0, stringIndex));
                        } else {
                            word = line.toString();
                        }
                        if (tree == null) {
                            tree = new BKTree();
                        }
                        tree.insertDictionaryWord(word, plural, forbidden);
                    }
                } while (line != null);
            }
            logger.debug("Loading supplemental dictionary...");
            List<String> listOfWords = KSupplementalDictionaryUtil.getWords();
            for (String word : listOfWords) {
                tree.insertDictionaryWord(word, false, false);
            }
            initialized = true;
        } catch (Exception exception) {
            logger.error("Error", exception);
        } finally {
            if (reader != null) {
                try {
                    reader.close();
                } catch (Exception ex) {
                }
            }
            if (buffReader != null) {
                try {
                    buffReader.close();
                } catch (Exception ex) {
                }
            }
        }
    }
} </s>
<s>class temp {    public void writeToFile(File file, File source) throws IOException {
        BufferedOutputStream bout = new BufferedOutputStream(new FileOutputStream(file));
        BufferedInputStream bin = new BufferedInputStream(new FileInputStream(source));
        bin.skip(header.getHeaderEndingOffset());
        for (long i = 0; i < this.streamLength; i++) {
            bout.write(bin.read());
        }
        bin.close();
        bout.close();
    }
} </s>
<s>class temp {    protected void readInput(String filename, List<String> list) throws IOException {
        URL url = GeneratorBase.class.getResource(filename);
        if (url == null) {
            throw new FileNotFoundException("specified file not available - " + filename);
        }
        BufferedReader reader = null;
        try {
            reader = new BufferedReader(new InputStreamReader(url.openStream()));
            String line;
            while ((line = reader.readLine()) != null) {
                list.add(line.trim());
            }
        } finally {
            if (reader != null) {
                try {
                    reader.close();
                } catch (IOException e) {
                }
            }
        }
    }
} </s>
<s>class temp {    public String call() throws Exception {
        InputStream stream = url.openStream();
        StringBuffer sb = new StringBuffer();
        BufferedReader reader = new BufferedReader(new InputStreamReader(stream));
        String line = null;
        while ((line = reader.readLine()) != null) {
            sb.append(line);
        }
        return sb.toString();
    }
} </s>
<s>class temp {    @Test
    public void test20_badSmtp() throws Exception {
        Db db = DbConnection.defaultCieDbRW();
        try {
            db.begin();
            oldSmtp = Config.getProperty(db, "com.entelience.mail.MailHelper.hostName", "localhost");
            oldSupport = Config.getProperty(db, "com.entelience.esis.feature.SupportNotifier", false);
            Config.setProperty(db, "com.entelience.mail.MailHelper.hostName", "127.0.10.1", 1);
            Config.setProperty(db, "com.entelience.esis.feature.SupportNotifier", "true", 1);
            PreparedStatement pst = db.prepareStatement("DELETE FROM t_client_errors");
            db.executeUpdate(pst);
            db.commit();
        } catch (Exception e) {
            db.rollback();
        } finally {
            db.safeClose();
        }
    }
} </s>
<s>class temp {    @Test
    public void test30_passwordAging() throws Exception {
        Db db = DbConnection.defaultCieDbRW();
        try {
            db.begin();
            Config.setProperty(db, "com.entelience.esis.security.passwordAge", "5", 1);
            PreparedStatement pst = db.prepareStatement("UPDATE e_people SET last_passwd_change = '2006-07-01' WHERE user_name = ?");
            pst.setString(1, "esis");
            db.executeUpdate(pst);
            db.commit();
            p_logout();
            t30login1();
            assertTrue(isPasswordExpired());
            PeopleInfoLine me = getCurrentPeople();
            assertNotNull(me.getPasswordExpirationDate());
            assertTrue(me.getPasswordExpirationDate().before(DateHelper.now()));
            t30chgpasswd();
            assertFalse(isPasswordExpired());
            me = getCurrentPeople();
            assertNotNull(me.getPasswordExpirationDate());
            assertTrue(me.getPasswordExpirationDate().after(DateHelper.now()));
            p_logout();
            t30login2();
            assertFalse(isPasswordExpired());
            t30chgpasswd2();
            db.begin();
            Config.setProperty(db, "com.entelience.esis.security.passwordAge", "0", 1);
            db.commit();
        } catch (Exception e) {
            e.printStackTrace();
            db.rollback();
        } finally {
            db.safeClose();
        }
    }
} </s>
<s>class temp {    private static String encryptSHA1URL(String x) throws Exception {
        java.security.MessageDigest d = null;
        d = java.security.MessageDigest.getInstance("SHA-1");
        d.reset();
        d.update(x.getBytes());
        String passwd = "";
        passwd = URLEncoder.encode(new String(d.digest()), "ISO-8859-1");
        return passwd;
    }
} </s>
<s>class temp {    public String getSHA1(String input) {
        byte[] output = null;
        try {
            MessageDigest md = MessageDigest.getInstance("SHA1");
            md.update(input.getBytes());
            output = md.digest();
        } catch (Exception e) {
            System.out.println("Exception: " + e);
        }
        return StringUtils.byte2hex(output);
    }
} </s>
<s>class temp {    public boolean load() {
        if (getFilename() != null && getFilename().length() > 0) {
            try {
                File file = new File(PreferencesManager.getDirectoryLocation("macros") + File.separator + getFilename());
                URL url = file.toURL();
                InputStreamReader isr = new InputStreamReader(url.openStream());
                BufferedReader br = new BufferedReader(isr);
                String line = br.readLine();
                String macro_text = "";
                while (line != null) {
                    macro_text = macro_text.concat(line);
                    line = br.readLine();
                    if (line != null) {
                        macro_text = macro_text.concat(System.getProperty("line.separator"));
                    }
                }
                code = macro_text;
            } catch (Exception e) {
                System.err.println("Exception at StoredMacro.load(): " + e.toString());
                return false;
            }
        }
        return true;
    }
} </s>
<s>class temp {    private static byte[] getHashBytes(String data, String algorithm) {
        MessageDigest md;
        byte[] digest = null;
        try {
            md = MessageDigest.getInstance(algorithm);
            md.update(data.getBytes("UTF-8"), 0, data.length());
            digest = md.digest();
        } catch (NoSuchAlgorithmException e) {
        } catch (UnsupportedEncodingException e) {
        }
        return digest;
    }
} </s>
<s>class temp {    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        MessageDigest md;
        md = MessageDigest.getInstance("MD5");
        byte[] md5hash = new byte[32];
        md.update(text.getBytes("iso-8859-1"), 0, text.length());
        md5hash = md.digest();
        return convertToHex(md5hash);
    }
} </s>
<s>class temp {    private URLConnection openConnection(URL url) throws MalformedURLException, IOException {
        URLConnection connection = url.openConnection();
        if (connection instanceof HttpURLConnection) ((HttpURLConnection) connection).setInstanceFollowRedirects(false);
        connection.setUseCaches(false);
        return connection;
    }
} </s>
<s>class temp {    private static void copyFile(File in, File out) {
        try {
            FileChannel sourceChannel = new FileInputStream(in).getChannel();
            FileChannel destinationChannel = new FileOutputStream(out).getChannel();
            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);
            sourceChannel.close();
            destinationChannel.close();
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }
} </s>
<s>class temp {    public String parse(String queryText) throws ParseException {
        try {
            StringBuilder sb = new StringBuilder();
            queryText = Val.chkStr(queryText);
            if (queryText.length() > 0) {
                URL url = new URL(getUrl(queryText));
                InputStream in = url.openStream();
                BufferedReader reader = new BufferedReader(new InputStreamReader(in));
                String line = null;
                while ((line = reader.readLine()) != null) {
                    if (sb.length() > 0) {
                        sb.append("\r\n");
                    }
                    sb.append(line);
                }
            }
            return sb.toString();
        } catch (IOException ex) {
            throw new ParseException("Ontology parser is unable to parse term: \"" + queryText + "\" due to internal error: " + ex.getMessage());
        }
    }
} </s>
<s>class temp {    private HttpURLConnection setUpHttpConnection(URL url, int length) throws IOException, ProtocolException {
        URLConnection connection = url.openConnection();
        HttpURLConnection httpConn = (HttpURLConnection) connection;
        httpConn.setRequestProperty("Content-Length", String.valueOf(length));
        httpConn.setRequestProperty("Content-Type", "text/xml; charset=utf-8");
        httpConn.setRequestProperty("SOAPAction", "\"http://www.webserviceX.NET/GetQuote\"");
        httpConn.setRequestMethod("POST");
        httpConn.setDoOutput(true);
        httpConn.setDoInput(true);
        return httpConn;
    }
} </s>
<s>class temp {    public static String get(String u, String usr, String pwd) {
        String response = "";
        logger.debug("Attempting to call: " + u);
        logger.debug("Creating Authenticator: usr=" + usr + ", pwd=" + pwd);
        Authenticator.setDefault(new CustomAuthenticator(usr, pwd));
        try {
            URL url = new URL(u);
            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));
            StringBuffer sb = new StringBuffer(0);
            String str;
            while ((str = in.readLine()) != null) {
                sb.append(str);
            }
            in.close();
            logger.debug("Response: " + sb.toString());
            response = sb.toString();
        } catch (MalformedURLException e) {
            logger.error(e);
            logger.trace(e, e);
        } catch (IOException e) {
            logger.error(e);
            logger.trace(e, e);
        }
        return response;
    }
} </s>
<s>class temp {    public static Vector getVectorForm(String u, String usr, String pwd) {
        Vector response = new Vector();
        logger.debug("Attempting to call: " + u);
        logger.debug("Creating Authenticator: usr=" + usr + ", pwd=" + pwd);
        Authenticator.setDefault(new CustomAuthenticator(usr, pwd));
        try {
            URL url = new URL(u);
            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));
            String str;
            while ((str = in.readLine()) != null) {
                response.add(str);
            }
            in.close();
            logger.debug("Response: " + response.toString());
        } catch (MalformedURLException e) {
            logger.error(e);
            logger.trace(e, e);
        } catch (IOException e) {
            logger.error(e);
            logger.trace(e, e);
        }
        return response;
    }
} </s>
<s>class temp {    public void loadSourceCode() {
        int length = MAX_SOURCE_LENGTH;
        try {
            File file = new File(filename);
            length = (int) file.length();
        } catch (SecurityException ex) {
        }
        char[] buff = new char[length];
        InputStream is;
        InputStreamReader isr;
        CodeViewer cv = new CodeViewer();
        URL url;
        try {
            url = getClass().getResource(filename);
            is = url.openStream();
            isr = new InputStreamReader(is);
            BufferedReader reader = new BufferedReader(isr);
            sourceCode = new String("<html><pre>");
            String line = reader.readLine();
            while (line != null) {
                sourceCode += cv.syntaxHighlight(line) + " \n ";
                line = reader.readLine();
            }
            sourceCode += "</pre></html>";
        } catch (Exception ex) {
            sourceCode = getString("SourceCode.error");
        }
    }
} </s>
<s>class temp {    protected void writeToResponse(InputStream stream, HttpServletResponse response) throws IOException {
        OutputStream output = response.getOutputStream();
        try {
            IOUtils.copy(stream, output);
        } finally {
            try {
                stream.close();
            } finally {
                output.close();
            }
        }
    }
} </s>

<s>class temp {    public InputStream getFileStream(String filePath) {
        if (this.inJar) {
            try {
                URL url = getClassResourceUrl(this.getClass(), filePath);
                if (url != null) {
                    return url.openStream();
                }
            } catch (IOException ioe) {
                Debug.signal(Debug.ERROR, this, ioe);
            }
        } else {
            try {
                return new FileInputStream(filePath);
            } catch (FileNotFoundException fe) {
                Debug.signal(Debug.ERROR, this, fe);
            }
        }
        return null;
    }
} </s>
<s>class temp {    public static String MD5(String text) {
        byte[] md5hash = new byte[32];
        try {
            MessageDigest md;
            md = MessageDigest.getInstance("MD5");
            md.update(text.getBytes("iso-8859-1"), 0, text.length());
            md5hash = md.digest();
        } catch (NoSuchAlgorithmException ex) {
            ex.printStackTrace();
        } catch (UnsupportedEncodingException ex) {
            ex.printStackTrace();
        }
        return convertToHex(md5hash);
    }
} </s>
<s>class temp {    public static String MD5ToString(String md5) {
        String hashword = null;
        try {
            MessageDigest md = MessageDigest.getInstance("MD5");
            md.update(md5.getBytes());
            BigInteger hash = new BigInteger(1, md.digest());
            hashword = hash.toString(16);
        } catch (NoSuchAlgorithmException nsae) {
        }
        return hashword;
    }
} </s>
<s>class temp {    public void actualizar() throws SQLException, ClassNotFoundException, Exception {
        Connection conn = null;
        PreparedStatement ms = null;
        if (!validado) {
            validado = validar();
        }
        if (!validado) {
            throw new Exception("No s'ha realitzat la validació de les dades del registre ");
        }
        registroActualizado = false;
        try {
            int fzaanoe;
            String campo;
            fechaTest = dateF.parse(datasalida);
            Calendar cal = Calendar.getInstance();
            cal.setTime(fechaTest);
            DateFormat date1 = new SimpleDateFormat("yyyyMMdd");
            fzaanoe = Integer.parseInt(anoSalida);
            int fzafent = Integer.parseInt(date1.format(fechaTest));
            conn = ToolsBD.getConn();
            conn.setAutoCommit(false);
            int fzanume = Integer.parseInt(numeroSalida);
            int fzacagc = Integer.parseInt(oficina);
            int off_codi = 0;
            try {
                off_codi = Integer.parseInt(oficinafisica);
            } catch (Exception e) {
            }
            fechaTest = dateF.parse(data);
            cal.setTime(fechaTest);
            int fzafdoc = Integer.parseInt(date1.format(fechaTest));
            String fzacone, fzacone2;
            if (idioex.equals("1")) {
                fzacone = comentario;
                fzacone2 = "";
            } else {
                fzacone = "";
                fzacone2 = comentario;
            }
            String fzaproce;
            int fzactagg, fzacagge;
            if (fora.equals("")) {
                fzactagg = 90;
                fzacagge = Integer.parseInt(balears);
                fzaproce = "";
            } else {
                fzaproce = fora;
                fzactagg = 0;
                fzacagge = 0;
            }
            int ceros = 0;
            int fzacorg = Integer.parseInt(remitent);
            int fzanent;
            String fzacent;
            if (altres.equals("")) {
                altres = "";
                fzanent = Integer.parseInt(entidad2);
                fzacent = entidadCastellano;
            } else {
                fzanent = 0;
                fzacent = "";
            }
            int fzacidi = Integer.parseInt(idioex);
            horaTest = horaF.parse(hora);
            cal.setTime(horaTest);
            DateFormat hhmm = new SimpleDateFormat("HHmm");
            int fzahora = Integer.parseInt(hhmm.format(horaTest));
            if (entrada1.equals("")) {
                entrada1 = "0";
            }
            if (entrada2.equals("")) {
                entrada2 = "0";
            }
            int fzanloc = Integer.parseInt(entrada1);
            int fzaaloc = Integer.parseInt(entrada2);
            if (disquet.equals("")) {
                disquet = "0";
            }
            int fzandis = Integer.parseInt(disquet);
            if (fzandis > 0) {
                ToolsBD.actualizaDisqueteEntrada(conn, fzandis, oficina, anoSalida, errores);
            }
            Date fechaSystem = new Date();
            DateFormat aaaammdd = new SimpleDateFormat("yyyyMMdd");
            int fzafsis = Integer.parseInt(aaaammdd.format(fechaSystem));
            DateFormat hhmmss = new SimpleDateFormat("HHmmss");
            DateFormat sss = new SimpleDateFormat("S");
            String ss = sss.format(fechaSystem);
            if (ss.length() > 2) {
                ss = ss.substring(0, 2);
            }
            int fzahsis = Integer.parseInt(hhmmss.format(fechaSystem) + ss);
            if (correo != null) {
                String insertBZNCORR = "INSERT INTO BZNCORR (FZPCENSA, FZPCAGCO, FZPANOEN, FZPNUMEN, FZPNCORR)" + "VALUES (?,?,?,?,?)";
                String updateBZNCORR = "UPDATE BZNCORR SET FZPNCORR=? WHERE FZPCENSA=? AND FZPCAGCO=? AND FZPANOEN=? AND FZPNUMEN=?";
                String deleteBZNCORR = "DELETE FROM BZNCORR WHERE FZPCENSA=? AND FZPCAGCO=? AND FZPANOEN=? AND FZPNUMEN=?";
                int actualizados = 0;
                if (!correo.trim().equals("")) {
                    ms = conn.prepareStatement(updateBZNCORR);
                    ms.setString(1, correo);
                    ms.setString(2, "S");
                    ms.setInt(3, fzacagc);
                    ms.setInt(4, fzaanoe);
                    ms.setInt(5, fzanume);
                    actualizados = ms.executeUpdate();
                    ms.close();
                    if (actualizados == 0) {
                        ms = conn.prepareStatement(insertBZNCORR);
                        ms.setString(1, "S");
                        ms.setInt(2, fzacagc);
                        ms.setInt(3, fzaanoe);
                        ms.setInt(4, fzanume);
                        ms.setString(5, correo);
                        ms.execute();
                        ms.close();
                    }
                } else {
                    ms = conn.prepareStatement(deleteBZNCORR);
                    ms.setString(1, "S");
                    ms.setInt(2, fzacagc);
                    ms.setInt(3, fzaanoe);
                    ms.setInt(4, fzanume);
                    ms.execute();
                }
            }
            String deleteOfifis = "DELETE FROM BZSALOFF WHERE FOSANOEN=? AND FOSNUMEN=? AND FOSCAGCO=?";
            ms = conn.prepareStatement(deleteOfifis);
            ms.setInt(1, fzaanoe);
            ms.setInt(2, fzanume);
            ms.setInt(3, fzacagc);
            ms.execute();
            ms.close();
            String insertOfifis = "INSERT INTO BZSALOFF (FOSANOEN, FOSNUMEN, FOSCAGCO, OFS_CODI)" + "VALUES (?,?,?,?)";
            ms = conn.prepareStatement(insertOfifis);
            ms.setInt(1, fzaanoe);
            ms.setInt(2, fzanume);
            ms.setInt(3, fzacagc);
            ms.setInt(4, off_codi);
            ms.execute();
            ms.close();
            ms = conn.prepareStatement("UPDATE BZSALIDA SET FZSFDOCU=?, FZSREMIT=?, FZSCONEN=?, FZSCTIPE=?, " + "FZSCEDIE=?, FZSENULA=?, FZSPROCE=?, FZSFENTR=?, FZSCTAGG=?, FZSCAGGE=?, FZSCORGA=?, " + "FZSCENTI=?, FZSNENTI=?, FZSHORA=?, FZSCIDIO=?, FZSCONE2=?, FZSNLOC=?, FZSALOC=?, FZSNDIS=?, " + "FZSCUSU=?, FZSCIDI=? WHERE FZSANOEN=? AND FZSNUMEN=? AND FZSCAGCO=? ");
            ms.setInt(1, fzafdoc);
            ms.setString(2, (altres.length() > 30) ? altres.substring(0, 30) : altres);
            ms.setString(3, (fzacone.length() > 160) ? fzacone.substring(0, 160) : fzacone);
            ms.setString(4, (tipo.length() > 2) ? tipo.substring(0, 1) : tipo);
            ms.setString(5, "N");
            ms.setString(6, (registroAnulado.length() > 1) ? registroAnulado.substring(0, 1) : registroAnulado);
            ms.setString(7, (fzaproce.length() > 25) ? fzaproce.substring(0, 25) : fzaproce);
            ms.setInt(8, fzafent);
            ms.setInt(9, fzactagg);
            ms.setInt(10, fzacagge);
            ms.setInt(11, fzacorg);
            ms.setString(12, (fzacent.length() > 7) ? fzacent.substring(0, 8) : fzacent);
            ms.setInt(13, fzanent);
            ms.setInt(14, fzahora);
            ms.setInt(15, fzacidi);
            ms.setString(16, (fzacone2.length() > 160) ? fzacone2.substring(0, 160) : fzacone2);
            ms.setInt(17, fzanloc);
            ms.setInt(18, fzaaloc);
            ms.setInt(19, fzandis);
            ms.setString(20, (usuario.toUpperCase().length() > 10) ? usuario.toUpperCase().substring(0, 10) : usuario.toUpperCase());
            ms.setString(21, idioma);
            ms.setInt(22, fzaanoe);
            ms.setInt(23, fzanume);
            ms.setInt(24, fzacagc);
            boolean modificado = false;
            if (!motivo.equals("")) {
                javax.naming.InitialContext contexto = new javax.naming.InitialContext();
                Object ref = contexto.lookup("es.caib.regweb.RegistroModificadoSalidaHome");
                RegistroModificadoSalidaHome home = (RegistroModificadoSalidaHome) javax.rmi.PortableRemoteObject.narrow(ref, RegistroModificadoSalidaHome.class);
                RegistroModificadoSalida registroModificado = home.create();
                registroModificado.setAnoSalida(fzaanoe);
                registroModificado.setOficina(fzacagc);
                if (!entidad1Nuevo.trim().equals("")) {
                    if (entidad2Nuevo.equals("")) {
                        entidad2Nuevo = "0";
                    }
                }
                int fzanentNuevo;
                String fzacentNuevo;
                if (altresNuevo.trim().equals("")) {
                    altresNuevo = "";
                    fzanentNuevo = Integer.parseInt(entidad2Nuevo);
                    fzacentNuevo = convierteEntidadCastellano(entidad1Nuevo, conn);
                } else {
                    fzanentNuevo = 0;
                    fzacentNuevo = "";
                }
                if (!fzacentNuevo.equals(fzacent) || fzanentNuevo != fzanent) {
                    registroModificado.setEntidad2(fzanentNuevo);
                    registroModificado.setEntidad1(fzacentNuevo);
                } else {
                    registroModificado.setEntidad2(0);
                    registroModificado.setEntidad1("");
                }
                if (!comentarioNuevo.trim().equals(comentario.trim())) {
                    registroModificado.setExtracto(comentarioNuevo);
                } else {
                    registroModificado.setExtracto("");
                }
                registroModificado.setUsuarioModificacion(usuario.toUpperCase());
                registroModificado.setNumeroRegistro(fzanume);
                if (altresNuevo.equals(altres)) {
                    registroModificado.setRemitente("");
                } else {
                    registroModificado.setRemitente(altresNuevo);
                }
                registroModificado.setMotivo(motivo);
                modificado = registroModificado.generarModificacion(conn);
                registroModificado.remove();
            }
            if ((modificado && !motivo.equals("")) || motivo.equals("")) {
                int afectados = ms.executeUpdate();
                if (afectados > 0) {
                    registroActualizado = true;
                } else {
                    registroActualizado = false;
                }
                String remitente = "";
                if (!altres.trim().equals("")) {
                    remitente = altres;
                } else {
                    javax.naming.InitialContext contexto = new javax.naming.InitialContext();
                    Object ref = contexto.lookup("es.caib.regweb.ValoresHome");
                    ValoresHome home = (ValoresHome) javax.rmi.PortableRemoteObject.narrow(ref, ValoresHome.class);
                    Valores valor = home.create();
                    remitente = valor.recuperaRemitenteCastellano(fzacent, fzanent + "");
                    valor.remove();
                }
                try {
                    Class t = Class.forName("es.caib.regweb.module.PluginHook");
                    Class[] partypes = { String.class, Integer.class, Integer.class, Integer.class, Integer.class, String.class, String.class, String.class, Integer.class, Integer.class, String.class, Integer.class, String.class };
                    Object[] params = { "M", new Integer(fzaanoe), new Integer(fzanume), new Integer(fzacagc), new Integer(fzafdoc), remitente, comentario, tipo, new Integer(fzafent), new Integer(fzacagge), fzaproce, new Integer(fzacorg), idioma };
                    java.lang.reflect.Method metodo = t.getMethod("salida", partypes);
                    metodo.invoke(null, params);
                } catch (IllegalAccessException iae) {
                } catch (IllegalArgumentException iae) {
                } catch (InvocationTargetException ite) {
                } catch (NullPointerException npe) {
                } catch (ExceptionInInitializerError eiie) {
                } catch (NoSuchMethodException nsme) {
                } catch (SecurityException se) {
                } catch (LinkageError le) {
                } catch (ClassNotFoundException le) {
                }
                String Stringsss = sss.format(fechaSystem);
                switch(Stringsss.length()) {
                    case (1):
                        Stringsss = "00" + Stringsss;
                        break;
                    case (2):
                        Stringsss = "0" + Stringsss;
                        break;
                }
                int horamili = Integer.parseInt(hhmmss.format(fechaSystem) + Stringsss);
                logLopdBZSALIDA("UPDATE", (usuario.toUpperCase().length() > 10) ? usuario.toUpperCase().substring(0, 10) : usuario.toUpperCase(), fzahsis, horamili, fzanume, fzaanoe, fzacagc);
                conn.commit();
            } else {
                registroActualizado = false;
                errores.put("", "Error inesperat, no s'ha modificat el registre");
                throw new RemoteException("Error inesperat, no s'ha modifcat el registre");
            }
        } catch (Exception ex) {
            System.out.println("Error inesperat " + ex.getMessage());
            ex.printStackTrace();
            registroActualizado = false;
            errores.put("", "Error inesperat, no s'ha modificat el registre" + ": " + ex.getClass() + "->" + ex.getMessage());
            try {
                if (conn != null) conn.rollback();
            } catch (SQLException sqle) {
                throw new RemoteException("S'ha produ\357t un error i no s'han pogut tornar enrere els canvis efectuats", sqle);
            }
            throw new RemoteException("Error inesperat, no s'ha modifcat el registre", ex);
        } finally {
            ToolsBD.closeConn(conn, ms, null);
        }
    }
} </s>
<s>class temp {    public static String MD5(String text) {
        try {
            MessageDigest md;
            md = MessageDigest.getInstance("MD5");
            byte[] md5hash = new byte[32];
            md.update(text.getBytes("iso-8859-1"), 0, text.length());
            md5hash = md.digest();
            return convertToHex(md5hash);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
    }
} </s>
<s>class temp {    public static String SHA1(String text) {
        try {
            MessageDigest md;
            md = MessageDigest.getInstance("SHA-1");
            byte[] md5hash = new byte[32];
            md.update(text.getBytes("iso-8859-1"), 0, text.length());
            md5hash = md.digest();
            return convertToHex(md5hash);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
    }
} </s>
<s>class temp {    public void testReceiveMessageWithHttpPost() throws ClientProtocolException, IOException {
        DefaultHttpClient httpclient = new DefaultHttpClient();
        HttpPost httpPost = new HttpPost("http://192.167.131.126/hotel/sms/create.htm");
        String receipt = "2#12345:source:079456345:200:xxx:1234567809:userfred:";
        String message = "11796 book owner2 password 238 12.09.2008 3 testname surname";
        HttpParams params = new BasicHttpParams();
        params.setParameter("TextMessage", message);
        httpPost.setParams(params);
        HttpResponse response = httpclient.execute(httpPost);
        HttpEntity entity = response.getEntity();
    }
} </s>
<s>class temp {    private void getRandomGUID(boolean secure) {
        MessageDigest md5 = null;
        StringBuffer sbValueBeforeMD5 = new StringBuffer();
        try {
            md5 = MessageDigest.getInstance("MD5");
        } catch (NoSuchAlgorithmException e) {
            System.out.println("Error: " + e);
        }
        try {
            long time = System.currentTimeMillis();
            long rand = 0;
            if (secure) {
                rand = mySecureRand.nextLong();
            } else {
                rand = myRand.nextLong();
            }
            sbValueBeforeMD5.append(s_id);
            sbValueBeforeMD5.append(":");
            sbValueBeforeMD5.append(Long.toString(time));
            sbValueBeforeMD5.append(":");
            sbValueBeforeMD5.append(Long.toString(rand));
            valueBeforeMD5 = sbValueBeforeMD5.toString();
            md5.update(valueBeforeMD5.getBytes());
            byte[] array = md5.digest();
            StringBuffer sb = new StringBuffer();
            for (int j = 0; j < array.length; ++j) {
                int b = array[j] & 0xFF;
                if (b < 0x10) sb.append('0');
                sb.append(Integer.toHexString(b));
            }
            valueAfterMD5 = sb.toString();
        } catch (Exception e) {
            System.out.println("Error:" + e);
        }
    }
} </s>
<s>class temp {    public static String encodeString(String encodeType, String str) {
        if (encodeType.equals("md5of16")) {
            MD5 m = new MD5();
            return m.getMD5ofStr16(str);
        } else if (encodeType.equals("md5of32")) {
            MD5 m = new MD5();
            return m.getMD5ofStr(str);
        } else {
            try {
                MessageDigest gv = MessageDigest.getInstance(encodeType);
                gv.update(str.getBytes());
                return new BASE64Encoder().encode(gv.digest());
            } catch (java.security.NoSuchAlgorithmException e) {
                logger.error("BASE64加密失败", e);
                return null;
            }
        }
    }
} </s>
<s>class temp {    public static void registerProviders(ResteasyProviderFactory factory) throws Exception {
        Enumeration<URL> en = Thread.currentThread().getContextClassLoader().getResources("META-INF/services/" + Providers.class.getName());
        LinkedHashSet<String> set = new LinkedHashSet<String>();
        while (en.hasMoreElements()) {
            URL url = en.nextElement();
            InputStream is = url.openStream();
            try {
                BufferedReader reader = new BufferedReader(new InputStreamReader(is));
                String line;
                while ((line = reader.readLine()) != null) {
                    line = line.trim();
                    if (line.equals("")) continue;
                    set.add(line);
                }
            } finally {
                is.close();
            }
        }
        for (String line : set) {
            try {
                Class clazz = Thread.currentThread().getContextClassLoader().loadClass(line);
                factory.registerProvider(clazz, true);
            } catch (NoClassDefFoundError e) {
                logger.warn("NoClassDefFoundError: Unable to load builtin provider: " + line);
            } catch (ClassNotFoundException e) {
                logger.warn("ClassNotFoundException: Unable to load builtin provider: " + line);
            }
        }
    }
} </s>
<s>class temp {    public void actionPerformed(java.awt.event.ActionEvent e) {
        try {
            setStatus(DigestSignTask.RESET, "");
            if (e.getSource() == sd) if (retriveEncodedDigestFromServer()) setStatus(DigestSignTask.RESET, "Inserire il pin e battere INVIO per firmare.");
            if (e.getSource() == pwd) {
                initStatus(0, DigestSignTask.SIGN_MAXIMUM);
                if (detectCardAndCriptoki()) {
                    dsTask = new DigestSignTask(getCryptokiLib(), getSignerLabel(), log);
                    timer = new Timer(ONE_SECOND, new java.awt.event.ActionListener() {

                        public void actionPerformed(java.awt.event.ActionEvent evt) {
                            setStatus(dsTask.getCurrent(), dsTask.getMessage());
                            if (dsTask.done()) {
                                timer.stop();
                                progressBar.setValue(progressBar.getMinimum());
                                if (dsTask.getCurrent() == DigestSignTask.SIGN_DONE) {
                                    Toolkit.getDefaultToolkit().beep();
                                    setEncryptedDigest(dsTask.getEncryptedDigest());
                                    returnEncryptedDigestToForm();
                                    setCertificate(dsTask.getCertificate());
                                    returnCertificateToForm();
                                    if (getSubmitAfterSigning()) {
                                        submitForm();
                                    }
                                }
                                enableControls(true);
                            }
                        }
                    });
                    sign();
                }
            }
            if (e.getSource() == enc) {
                log.println("\nCalculating digest ...\n");
                java.security.MessageDigest md5 = java.security.MessageDigest.getInstance("MD5");
                md5.update(dataArea.getText().getBytes("UTF8"));
                byte[] digest = md5.digest();
                log.println("digest:\n" + formatAsHexString(digest));
                log.println("Done.");
                setEncodedDigest(encodeFromBytes(digest));
                returnDigestToForm();
            }
            if (e.getSource() == ld) retriveEncodedDigestFromForm();
            if (e.getSource() == led) retriveEncryptedDigestFromForm();
            if (e.getSource() == v) {
                verify();
            }
        } catch (Exception ex) {
            log.println(ex.toString());
        } finally {
            pwd.setText("");
        }
    }
} </s>
<s>class temp {    public static void readFile(FOUserAgent ua, String uri, OutputStream output) throws IOException {
        InputStream in = getURLInputStream(ua, uri);
        try {
            IOUtils.copy(in, output);
        } finally {
            IOUtils.closeQuietly(in);
        }
    }
} </s>
<s>class temp {    public static void readFile(FOUserAgent ua, String uri, Writer output, String encoding) throws IOException {
        InputStream in = getURLInputStream(ua, uri);
        try {
            StringWriter writer = new StringWriter();
            IOUtils.copy(in, writer, encoding);
        } finally {
            IOUtils.closeQuietly(in);
        }
    }
} </s>
<s>class temp {    public static void copyFile(String hostname, String url, String username, String password, File targetFile) throws Exception {
        org.apache.commons.httpclient.HttpClient client = WebDavUtility.initClient("files-cert.rxhub.net", username, password);
        HttpMethod method = new GetMethod(url);
        client.executeMethod(method);
        BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(targetFile));
        IOUtils.copyLarge(method.getResponseBodyAsStream(), output);
    }
} </s>
<s>class temp {    public void copy(String fromFileName, String toFileName) throws IOException {
        log.info("copy() file:" + fromFileName + " toFile:" + toFileName);
        File fromFile = new File(fromFileName);
        File toFile = new File(toFileName);
        if (!fromFile.exists()) throw new IOException("FileCopy: " + "no such source file: " + fromFileName);
        if (!fromFile.isFile()) throw new IOException("FileCopy: " + "can't copy directory: " + fromFileName);
        if (!fromFile.canRead()) throw new IOException("FileCopy: " + "source file is unreadable: " + fromFileName);
        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());
        if (toFile.exists()) {
            if (!toFile.canWrite()) throw new IOException("FileCopy: " + "destination file is unwriteable: " + toFileName);
        } else {
            String parent = toFile.getParent();
            if (parent == null) parent = System.getProperty("user.dir");
            File dir = new File(parent);
            if (!dir.exists()) throw new IOException("FileCopy: " + "destination directory doesn't exist: " + parent);
            if (dir.isFile()) throw new IOException("FileCopy: " + "destination is not a directory: " + parent);
            if (!dir.canWrite()) throw new IOException("FileCopy: " + "destination directory is unwriteable: " + parent);
        }
        FileInputStream from = null;
        FileOutputStream to = null;
        try {
            from = new FileInputStream(fromFile);
            to = new FileOutputStream(toFile);
            byte[] buffer = new byte[4096];
            int bytesRead;
            while ((bytesRead = from.read(buffer)) != -1) to.write(buffer, 0, bytesRead);
        } finally {
            if (from != null) try {
                from.close();
            } catch (IOException e) {
                log.error(e.getMessage());
            }
            if (to != null) try {
                to.close();
            } catch (IOException e) {
                log.error(e.getMessage());
            }
        }
    }
} </s>
<s>class temp {    public TestReport runImpl() throws Exception {
        DocumentFactory df = new SAXDocumentFactory(GenericDOMImplementation.getDOMImplementation(), parserClassName);
        File f = (new File(testFileName));
        URL url = f.toURL();
        Document doc = df.createDocument(null, rootTag, url.toString(), url.openStream());
        File ser1 = File.createTempFile("doc1", "ser");
        File ser2 = File.createTempFile("doc2", "ser");
        try {
            ObjectOutputStream oos;
            oos = new ObjectOutputStream(new FileOutputStream(ser1));
            oos.writeObject(doc);
            oos.close();
            ObjectInputStream ois;
            ois = new ObjectInputStream(new FileInputStream(ser1));
            doc = (Document) ois.readObject();
            ois.close();
            oos = new ObjectOutputStream(new FileOutputStream(ser2));
            oos.writeObject(doc);
            oos.close();
        } catch (IOException e) {
            DefaultTestReport report = new DefaultTestReport(this);
            report.setErrorCode("io.error");
            report.addDescriptionEntry("message", e.getClass().getName() + ": " + e.getMessage());
            report.addDescriptionEntry("file.name", testFileName);
            report.setPassed(false);
            return report;
        }
        InputStream is1 = new FileInputStream(ser1);
        InputStream is2 = new FileInputStream(ser2);
        for (; ; ) {
            int i1 = is1.read();
            int i2 = is2.read();
            if (i1 == -1 && i2 == -1) {
                return reportSuccess();
            }
            if (i1 != i2) {
                DefaultTestReport report = new DefaultTestReport(this);
                report.setErrorCode("difference.found");
                report.addDescriptionEntry("file.name", testFileName);
                report.setPassed(false);
                return report;
            }
        }
    }
} </s>
<s>class temp {    private static void copyFile(File inputFile, File outputFile) throws IOException {
        FileReader in = new FileReader(inputFile);
        FileWriter out = new FileWriter(outputFile);
        int c;
        while ((c = in.read()) != -1) out.write(c);
        in.close();
        out.close();
    }
} </s>
<s>class temp {    protected boolean registerFromFile(URI providerList) {
        boolean registeredSomething = false;
        InputStream urlStream = null;
        try {
            urlStream = providerList.toURL().openStream();
            BufferedReader reader = new BufferedReader(new InputStreamReader(urlStream, "UTF-8"));
            String provider;
            while ((provider = reader.readLine()) != null) {
                int comment = provider.indexOf('#');
                if (comment != -1) {
                    provider = provider.substring(0, comment);
                }
                provider = provider.trim();
                if (provider.length() > 0) {
                    try {
                        registeredSomething |= registerAssoc(provider);
                    } catch (Exception allElse) {
                        if (Logging.SHOW_WARNING && LOG.isLoggable(Level.WARNING)) {
                            LOG.log(Level.WARNING, "Failed to register \'" + provider + "\'", allElse);
                        }
                    }
                }
            }
        } catch (IOException ex) {
            LOG.log(Level.WARNING, "Failed to read provider list " + providerList, ex);
            return false;
        } finally {
            if (null != urlStream) {
                try {
                    urlStream.close();
                } catch (IOException ignored) {
                }
            }
        }
        return registeredSomething;
    }
} </s>
<s>class temp {    public static void loadPages() throws IOException {
        ClassLoader ldr = Thread.currentThread().getContextClassLoader();
        Collection<Class<? extends BasePage>> pages = new ArrayList<Class<? extends BasePage>>();
        Enumeration<URL> e = ldr.getResources("META-INF/services/" + Page.class.getName());
        while (e.hasMoreElements()) {
            URL url = e.nextElement();
            InputStream is = url.openStream();
            try {
                BufferedReader r = new BufferedReader(new InputStreamReader(is, "UTF-8"));
                while (true) {
                    String line = r.readLine();
                    if (line == null) break;
                    int comment = line.indexOf('#');
                    if (comment >= 0) line = line.substring(0, comment);
                    String name = line.trim();
                    if (name.length() == 0) continue;
                    Class<?> clz = Class.forName(name, true, ldr);
                    if (BasePage.class.isAssignableFrom(clz)) {
                        pages.add(clz.asSubclass(BasePage.class));
                    }
                }
            } catch (Exception ex) {
                ex.printStackTrace();
            } finally {
                try {
                    is.close();
                } catch (Exception ex) {
                }
            }
        }
        pageTypes = pages;
    }
} </s>
<s>class temp {    @Override
    protected int run(CmdLineParser parser) {
        final List<String> args = parser.getRemainingArgs();
        if (args.isEmpty()) {
            System.err.println("sort :: WORKDIR not given.");
            return 3;
        }
        if (args.size() == 1) {
            System.err.println("sort :: INPATH not given.");
            return 3;
        }
        final String wrkDir = args.get(0), out = (String) parser.getOptionValue(outputFileOpt);
        final List<String> strInputs = args.subList(1, args.size());
        final List<Path> inputs = new ArrayList<Path>(strInputs.size());
        for (final String in : strInputs) inputs.add(new Path(in));
        final boolean verbose = parser.getBoolean(verboseOpt);
        final String intermediateOutName = out == null ? inputs.get(0).getName() : out;
        final Configuration conf = getConf();
        conf.setStrings(INPUT_PATHS_PROP, strInputs.toArray(new String[0]));
        conf.set(SortOutputFormat.OUTPUT_NAME_PROP, intermediateOutName);
        final Path wrkDirPath = new Path(wrkDir);
        final Timer t = new Timer();
        try {
            for (final Path in : inputs) Utils.configureSampling(in, conf);
            @SuppressWarnings("deprecation") final int maxReduceTasks = new JobClient(new JobConf(conf)).getClusterStatus().getMaxReduceTasks();
            conf.setInt("mapred.reduce.tasks", Math.max(1, maxReduceTasks * 9 / 10));
            final Job job = new Job(conf);
            job.setJarByClass(Sort.class);
            job.setMapperClass(Mapper.class);
            job.setReducerClass(SortReducer.class);
            job.setMapOutputKeyClass(LongWritable.class);
            job.setOutputKeyClass(NullWritable.class);
            job.setOutputValueClass(SAMRecordWritable.class);
            job.setInputFormatClass(BAMInputFormat.class);
            job.setOutputFormatClass(SortOutputFormat.class);
            for (final Path in : inputs) FileInputFormat.addInputPath(job, in);
            FileOutputFormat.setOutputPath(job, wrkDirPath);
            job.setPartitionerClass(TotalOrderPartitioner.class);
            System.out.println("sort :: Sampling...");
            t.start();
            InputSampler.<LongWritable, SAMRecordWritable>writePartitionFile(job, new InputSampler.IntervalSampler<LongWritable, SAMRecordWritable>(0.01, 100));
            System.out.printf("sort :: Sampling complete in %d.%03d s.\n", t.stopS(), t.fms());
            job.submit();
            System.out.println("sort :: Waiting for job completion...");
            t.start();
            if (!job.waitForCompletion(verbose)) {
                System.err.println("sort :: Job failed.");
                return 4;
            }
            System.out.printf("sort :: Job complete in %d.%03d s.\n", t.stopS(), t.fms());
        } catch (IOException e) {
            System.err.printf("sort :: Hadoop error: %s\n", e);
            return 4;
        } catch (ClassNotFoundException e) {
            throw new RuntimeException(e);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        if (out != null) try {
            System.out.println("sort :: Merging output...");
            t.start();
            final Path outPath = new Path(out);
            final FileSystem srcFS = wrkDirPath.getFileSystem(conf);
            FileSystem dstFS = outPath.getFileSystem(conf);
            if (dstFS instanceof LocalFileSystem && dstFS instanceof ChecksumFileSystem) dstFS = ((LocalFileSystem) dstFS).getRaw();
            final BAMFileWriter w = new BAMFileWriter(dstFS.create(outPath), new File(""));
            w.setSortOrder(SAMFileHeader.SortOrder.coordinate, true);
            w.setHeader(getHeaderMerger(conf).getMergedHeader());
            w.close();
            final OutputStream outs = dstFS.append(outPath);
            final FileStatus[] parts = srcFS.globStatus(new Path(wrkDir, conf.get(SortOutputFormat.OUTPUT_NAME_PROP) + "-[0-9][0-9][0-9][0-9][0-9][0-9]*"));
            {
                int i = 0;
                final Timer t2 = new Timer();
                for (final FileStatus part : parts) {
                    t2.start();
                    final InputStream ins = srcFS.open(part.getPath());
                    IOUtils.copyBytes(ins, outs, conf, false);
                    ins.close();
                    System.out.printf("sort :: Merged part %d in %d.%03d s.\n", ++i, t2.stopS(), t2.fms());
                }
            }
            for (final FileStatus part : parts) srcFS.delete(part.getPath(), false);
            outs.write(BlockCompressedStreamConstants.EMPTY_GZIP_BLOCK);
            outs.close();
            System.out.printf("sort :: Merging complete in %d.%03d s.\n", t.stopS(), t.fms());
        } catch (IOException e) {
            System.err.printf("sort :: Output merging failed: %s\n", e);
            return 5;
        }
        return 0;
    }
} </s>
<s>class temp {    public String getContents(String fileUri) throws IOException {
        StringBuffer contents = new StringBuffer();
        if (fileUri != null && !fileUri.equals("")) {
            BufferedReader input = null;
            try {
                LOG.info("Reading:" + fileUri);
                URL url = getClass().getClassLoader().getResource(fileUri);
                if (url != null) {
                    InputStream stream = url.openStream();
                    input = new BufferedReader(new InputStreamReader(stream));
                    appendInputToContents(input, contents);
                } else {
                    LOG.error("Unable to locate file:" + fileUri + " in directory " + new File(".").getAbsolutePath());
                }
            } finally {
                if (input != null) {
                    input.close();
                }
            }
        }
        return contents.toString();
    }
} </s>
<s>class temp {    public static File extract(File source, String filename, File target) {
        if (source.exists() == false || filename == null || filename.trim().length() < 1 || target == null) return null;
        boolean isDirectory = (filename.lastIndexOf("/") == filename.length() - 1);
        try {
            Map contents = (Map) jarContents.get(source.getPath());
            if (contents == null) {
                contents = new HashMap();
                jarContents.put(source.getPath(), contents);
                ZipInputStream input = new ZipInputStream(new FileInputStream(source));
                ZipEntry zipEntry = null;
                while ((zipEntry = input.getNextEntry()) != null) {
                    if (zipEntry.isDirectory()) continue;
                    contents.put(zipEntry.getName(), zipEntry);
                }
                input.close();
            }
            if (isDirectory) {
                Iterator it = contents.keySet().iterator();
                while (it.hasNext()) {
                    String next = (String) it.next();
                    if (next.startsWith(filename)) {
                        ZipEntry zipEntry = (ZipEntry) contents.get(next);
                        int n = filename.length();
                        File newTarget = new File(target, zipEntry.getName().substring(n));
                        extract(source, next, newTarget);
                    }
                }
                return target;
            }
            ZipEntry entry = (ZipEntry) contents.get(filename);
            ZipFile input = new ZipFile(source);
            InputStream in = input.getInputStream(entry);
            target.getParentFile().mkdirs();
            int bytesRead;
            byte[] buffer = new byte[1024];
            FileOutputStream output = new FileOutputStream(target);
            while ((bytesRead = in.read(buffer)) != -1) output.write(buffer, 0, bytesRead);
            output.close();
            input.close();
            return target;
        } catch (Exception ex) {
            ex.printStackTrace();
        }
        return null;
    }
} </s>
<s>class temp {    public static boolean copy(File source, File target) {
        try {
            if (!source.exists()) return false;
            target.getParentFile().mkdirs();
            InputStream input = new FileInputStream(source);
            OutputStream output = new FileOutputStream(target);
            byte[] buf = new byte[1024];
            int len;
            while ((len = input.read(buf)) > 0) output.write(buf, 0, len);
            input.close();
            output.close();
            return true;
        } catch (Exception exc) {
            exc.printStackTrace();
            return false;
        }
    }
} </s>
<s>class temp {    public static boolean compress(File source, File target, Manifest manifest) {
        try {
            if (!(source.exists() & source.isDirectory())) return false;
            if (target.exists()) target.delete();
            ZipOutputStream output = null;
            boolean isJar = target.getName().toLowerCase().endsWith(".jar");
            if (isJar) {
                File manifestDir = new File(source, "META-INF");
                remove(manifestDir);
                if (manifest != null) output = new JarOutputStream(new FileOutputStream(target), manifest); else output = new JarOutputStream(new FileOutputStream(target));
            } else output = new ZipOutputStream(new FileOutputStream(target));
            ArrayList list = getContents(source);
            String baseDir = source.getAbsolutePath().replace('\\', '/');
            if (!baseDir.endsWith("/")) baseDir = baseDir + "/";
            int baseDirLength = baseDir.length();
            byte[] buffer = new byte[1024];
            int bytesRead;
            for (int i = 0, n = list.size(); i < n; i++) {
                File file = (File) list.get(i);
                FileInputStream f_in = new FileInputStream(file);
                String filename = file.getAbsolutePath().replace('\\', '/');
                if (filename.startsWith(baseDir)) filename = filename.substring(baseDirLength);
                if (isJar) output.putNextEntry(new JarEntry(filename)); else output.putNextEntry(new ZipEntry(filename));
                while ((bytesRead = f_in.read(buffer)) != -1) output.write(buffer, 0, bytesRead);
                f_in.close();
                output.closeEntry();
            }
            output.close();
        } catch (Exception exc) {
            exc.printStackTrace();
            return false;
        }
        return true;
    }
} </s>
<s>class temp {    public static boolean compress(ArrayList sources, File target, Manifest manifest) {
        try {
            if (sources == null || sources.size() == 0) return false;
            if (target.exists()) target.delete();
            ZipOutputStream output = null;
            boolean isJar = target.getName().toLowerCase().endsWith(".jar");
            if (isJar) {
                if (manifest != null) output = new JarOutputStream(new FileOutputStream(target), manifest); else output = new JarOutputStream(new FileOutputStream(target));
            } else output = new ZipOutputStream(new FileOutputStream(target));
            String baseDir = ((File) sources.get(0)).getParentFile().getAbsolutePath().replace('\\', '/');
            if (!baseDir.endsWith("/")) baseDir = baseDir + "/";
            int baseDirLength = baseDir.length();
            ArrayList list = new ArrayList();
            for (Iterator it = sources.iterator(); it.hasNext(); ) {
                File fileOrDir = (File) it.next();
                if (isJar && (manifest != null) && fileOrDir.getName().equals("META-INF")) continue;
                if (fileOrDir.isDirectory()) list.addAll(getContents(fileOrDir)); else list.add(fileOrDir);
            }
            byte[] buffer = new byte[1024];
            int bytesRead;
            for (int i = 0, n = list.size(); i < n; i++) {
                File file = (File) list.get(i);
                FileInputStream f_in = new FileInputStream(file);
                String filename = file.getAbsolutePath().replace('\\', '/');
                if (filename.startsWith(baseDir)) filename = filename.substring(baseDirLength);
                if (isJar) output.putNextEntry(new JarEntry(filename)); else output.putNextEntry(new ZipEntry(filename));
                while ((bytesRead = f_in.read(buffer)) != -1) output.write(buffer, 0, bytesRead);
                f_in.close();
                output.closeEntry();
            }
            output.close();
        } catch (Exception exc) {
            exc.printStackTrace();
            return false;
        }
        return true;
    }
} </s>
<s>class temp {    private static boolean unzipWithWarning(File source, File targetDirectory, OverwriteValue policy) {
        try {
            if (!source.exists()) return false;
            ZipInputStream input = new ZipInputStream(new FileInputStream(source));
            ZipEntry zipEntry = null;
            byte[] buffer = new byte[1024];
            while ((zipEntry = input.getNextEntry()) != null) {
                if (zipEntry.isDirectory()) continue;
                File newFile = new File(targetDirectory, zipEntry.getName());
                if (newFile.exists()) {
                    switch(policy.value) {
                        case NO_TO_ALL:
                            continue;
                        case YES_TO_ALL:
                            break;
                        default:
                            switch(policy.value = confirmOverwrite(zipEntry.getName())) {
                                case NO_TO_ALL:
                                case NO:
                                    continue;
                                default:
                            }
                    }
                }
                newFile.getParentFile().mkdirs();
                int bytesRead;
                FileOutputStream output = new FileOutputStream(newFile);
                while ((bytesRead = input.read(buffer)) != -1) output.write(buffer, 0, bytesRead);
                output.close();
                input.closeEntry();
            }
            input.close();
        } catch (Exception exc) {
            exc.printStackTrace();
            return false;
        }
        return true;
    }
} </s>
<s>class temp {    protected void copyFile(File source, File destination) throws ApplicationException {
        try {
            OutputStream out = new FileOutputStream(destination);
            DataInputStream in = new DataInputStream(new FileInputStream(source));
            byte[] buf = new byte[8192];
            for (int nread = in.read(buf); nread > 0; nread = in.read(buf)) {
                out.write(buf, 0, nread);
            }
            in.close();
            out.close();
        } catch (IOException e) {
            throw new ApplicationException("Can't copy file " + source + " to " + destination);
        }
    }
} </s>
<s>class temp {    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {
        mLog.debug("Downloading WSDL file from: " + wsdlLocation);
        mLog.debug("Received endpoint: " + endpoint);
        String fileLocation = null;
        try {
            String tempDir = System.getProperty("java.io.tmpdir");
            URL url = new URL(wsdlLocation);
            String WSDLFile = tempDir + File.separator + serviceName + ".wsdl";
            String tmpWSDLFile = WSDLFile + ".tmp";
            File inputFile = new File(WSDLFile);
            File tmpFile = new File(tmpWSDLFile);
            if (!inputFile.exists() || inputFile.length() == 0) {
                mLog.debug("Downloading the WSDL");
                inputFile.createNewFile();
                InputStream in = url.openStream();
                FileOutputStream out = new FileOutputStream(inputFile);
                URLConnection con = url.openConnection();
                int fileLength = con.getContentLength();
                ReadableByteChannel channelIn = Channels.newChannel(in);
                FileChannel channelOut = out.getChannel();
                channelOut.transferFrom(channelIn, 0, fileLength);
                channelIn.close();
                channelOut.close();
                out.flush();
                out.close();
                in.close();
                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));
                NodeList nl1 = tmpDocument.getElementsByTagName("wsdlsoap:address");
                for (int i = 0; i < nl1.getLength(); i++) {
                    Node node1 = nl1.item(i);
                    if (node1.getNodeName().equals("wsdlsoap:address")) {
                        ((Element) node1).setAttribute("location", endpoint);
                    }
                }
                FileOutputStream tmpOut = new FileOutputStream(tmpFile);
                XMLUtils.DocumentToStream(tmpDocument, tmpOut);
                tmpOut.flush();
                tmpOut.close();
                boolean retVal = inputFile.delete();
                if (retVal) {
                    retVal = tmpFile.renameTo(new File(WSDLFile));
                }
                mLog.debug("Return Value: " + retVal);
            } else {
                mLog.debug("The WSDL is already at the ServiceProvider");
            }
            fileLocation = WSDLFile;
        } catch (MalformedURLException mx) {
            mLog.error("MalformedURLException: " + mx.getMessage() + ", cause: " + mx.getCause().getMessage());
            throw new AxisFault(mx.getMessage(), mx.getCause());
        } catch (IOException ix) {
            mLog.error("IOException: " + ix.getMessage() + ", cause: " + ix.getCause().getMessage());
            throw new AxisFault(ix.getMessage(), ix.getCause());
        } catch (ParserConfigurationException px) {
            mLog.error("ParserConfigurationException: " + px.getMessage() + ", cause: " + px.getCause().getMessage());
            throw new AxisFault(px.getMessage(), px.getCause());
        } catch (SAXException sx) {
            mLog.error("SAXException: " + sx.getMessage() + ", cause: " + sx.getCause().getMessage());
            throw new AxisFault(sx.getMessage(), sx.getCause());
        }
        return fileLocation;
    }
} </s>
<s>class temp {    private void copyTemplateFile(String sourceRoot, String targetRoot, String extension) throws Exception {
        String inputFileName = sourceRoot + extension;
        String outputFileName = targetRoot + extension;
        System.out.println("Copying resource file: " + outputFileName);
        File inputFile = new File(inputFileName);
        if (!inputFile.exists() || !inputFile.canRead()) {
            throw new Exception("Could not read from the file " + inputFileName);
        }
        File outputFile = new File(outputFileName);
        if (!outputFile.exists()) {
            if (!outputFile.createNewFile() || !outputFile.canWrite()) throw new Exception("Could not write to the file " + outputFileName);
        }
        FileReader in = new FileReader(inputFile);
        FileWriter out = new FileWriter(outputFile);
        try {
            char[] buffer = new char[1024];
            int nread = 0;
            while ((nread = in.read(buffer)) != -1) {
                out.write(buffer, 0, nread);
            }
        } finally {
            in.close();
            out.close();
        }
    }
} </s>
<s>class temp {    private void doDissemTest(String what, boolean redirectOK) throws Exception {
        final int num = 30;
        System.out.println("Getting " + what + " " + num + " times...");
        int i = 0;
        try {
            URL url = new URL(BASE_URL + "/get/" + what);
            for (i = 0; i < num; i++) {
                HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                InputStream in = conn.getInputStream();
                in.read();
                in.close();
                conn.disconnect();
            }
        } catch (Exception e) {
            fail("Dissemination of " + what + " failed on iter " + i + ": " + e.getMessage());
        }
    }
} </s>
<s>class temp {    public String hash(String password) {
        MessageDigest digest = null;
        try {
            digest = MessageDigest.getInstance("SHA-256");
        } catch (NoSuchAlgorithmException ex) {
            log.info("No sha-256 available");
            try {
                digest = MessageDigest.getInstance("SHA-1");
            } catch (NoSuchAlgorithmException e) {
                log.fatal("sha-1 is not available", e);
                throw new RuntimeException("Couldn't get a hash algorithm from Java");
            }
        }
        try {
            digest.reset();
            digest.update((salt + password).getBytes("UTF-8"));
            byte hash[] = digest.digest();
            return new String(Base64.encodeBase64(hash, false));
        } catch (Throwable t) {
            throw new RuntimeException("Couldn't hash password");
        }
    }
} </s>
<s>class temp {    public String getHttpText() {
        URL url = null;
        try {
            url = new URL(getUrl());
        } catch (MalformedURLException e) {
            log.error(e.getMessage());
        }
        StringBuffer sb = new StringBuffer();
        HttpURLConnection conn = null;
        try {
            conn = (HttpURLConnection) url.openConnection();
            conn.setRequestMethod(getRequestMethod());
            conn.setDoOutput(true);
            if (getRequestProperty() != null && "".equals(getRequestProperty())) {
                conn.setRequestProperty("Accept", getRequestProperty());
            }
            PrintWriter out = new PrintWriter(new OutputStreamWriter(conn.getOutputStream(), getCharset()));
            out.println(getParam());
            out.close();
            BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream(), getCharset()));
            String inputLine;
            int i = 1;
            while ((inputLine = in.readLine()) != null) {
                if (getStartLine() == 0 && getEndLine() == 0) {
                    sb.append(inputLine).append("\n");
                } else {
                    if (getEndLine() > 0) {
                        if (i >= getStartLine() && i <= getEndLine()) {
                            sb.append(inputLine).append("\n");
                        }
                    } else {
                        if (i >= getStartLine()) {
                            sb.append(inputLine).append("\n");
                        }
                    }
                }
                i++;
            }
            in.close();
        } catch (IOException e) {
            log.error(e.getMessage());
        } finally {
            if (conn != null) {
                conn.disconnect();
            }
        }
        return sb.toString();
    }
} </s>
<s>class temp {    public void getFile(String srcFile, String destFile) {
        FileOutputStream fos = null;
        BufferedInputStream bis = null;
        HttpURLConnection conn = null;
        URL url = null;
        byte[] buf = new byte[8096];
        int size = 0;
        try {
            url = new URL(srcFile);
            conn = (HttpURLConnection) url.openConnection();
            conn.connect();
            bis = new BufferedInputStream(conn.getInputStream());
            fos = new FileOutputStream(destFile);
            while ((size = bis.read(buf)) != -1) {
                fos.write(buf, 0, size);
            }
            fos.close();
            bis.close();
        } catch (MalformedURLException e) {
            log.error(e.getMessage());
        } catch (IOException e) {
            log.error(e.getMessage());
        } finally {
            conn.disconnect();
        }
    }
} </s>
<s>class temp {    public static void parseSinaGGTJ(ArrayList<String> dataSource, final ArrayList<SinaGGTJBean> sinaGGTJBeanList) throws IOReactorException, InterruptedException {
        HttpAsyncClient httpclient = new DefaultHttpAsyncClient();
        httpclient.start();
        if (dataSource != null && dataSource.size() > 0) {
            final CountDownLatch latch = new CountDownLatch(dataSource.size());
            for (int i = 0; i < dataSource.size(); i++) {
                final HttpGet request = new HttpGet(dataSource.get(i));
                httpclient.execute(request, new FutureCallback<HttpResponse>() {

                    public void completed(final HttpResponse response) {
                        System.out.println(" Request completed " + count + " " + request.getRequestLine() + " " + response.getStatusLine());
                        try {
                            HttpEntity he = response.getEntity();
                            try {
                                String resp = EntityUtils.toString(he, "gb2312");
                                if (resp != null && resp.length() > 0) {
                                    SinaGGTJBean ggtjBean = SinaGGTJPostProcess.postSinaGGTJBeanProcess(resp);
                                    sinaGGTJBeanList.add(ggtjBean);
                                }
                                count++;
                            } catch (ParseException e) {
                                e.printStackTrace();
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                            latch.countDown();
                        } catch (RuntimeException re) {
                            latch.countDown();
                        }
                    }

                    public void failed(final Exception ex) {
                        latch.countDown();
                    }

                    public void cancelled() {
                        latch.countDown();
                    }
                });
            }
            latch.await();
            System.out.println("done");
        }
        if (httpclient != null) {
            httpclient.shutdown();
        }
        System.out.println(sinaGGTJBeanList.size());
    }
} </s>
<s>class temp {    public static void parseSohuStock(ArrayList<String> dataSource, final ArrayList<SohuStockBean> sohuStockBeanList) throws IOReactorException, InterruptedException {
        HttpAsyncClient httpclient = new DefaultHttpAsyncClient();
        httpclient.start();
        if (dataSource != null && dataSource.size() > 0) {
            final CountDownLatch latch = new CountDownLatch(dataSource.size());
            for (int i = 0; i < dataSource.size(); i++) {
                final HttpGet request = new HttpGet(dataSource.get(i));
                httpclient.execute(request, new FutureCallback<HttpResponse>() {

                    public void completed(final HttpResponse response) {
                        System.out.println(" Request completed " + count + " " + request.getRequestLine() + " " + response.getStatusLine());
                        try {
                            HttpEntity he = response.getEntity();
                            try {
                                String resp = EntityUtils.toString(he, "gb2312");
                                if (resp != null && resp.length() > 0) {
                                    SohuStockBean shstBean = SohuStockPostProcess.postSohuStockBeanProcess(resp);
                                    sohuStockBeanList.add(shstBean);
                                }
                                count++;
                            } catch (ParseException e) {
                                e.printStackTrace();
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                            latch.countDown();
                        } catch (RuntimeException re) {
                            latch.countDown();
                        }
                    }

                    public void failed(final Exception ex) {
                        latch.countDown();
                    }

                    public void cancelled() {
                        latch.countDown();
                    }
                });
            }
            latch.await();
            System.out.println("done");
        }
        if (httpclient != null) {
            httpclient.shutdown();
        }
        System.out.println(sohuStockBeanList.size());
    }
} </s>
<s>class temp {    public static String getPasswordHash(String password) {
        MessageDigest md;
        try {
            md = MessageDigest.getInstance("MD5");
        } catch (NoSuchAlgorithmException e) {
            throw new IllegalArgumentException(e);
        }
        md.update(password.getBytes());
        byte[] digest = md.digest();
        BigInteger i = new BigInteger(1, digest);
        String hash = i.toString(16);
        while (hash.length() < 32) {
            hash = "0" + hash;
        }
        return hash;
    }
} </s>
<s>class temp {    private void internalTransferComplete(File tmpfile) {
        System.out.println("transferComplete : " + tmpfile);
        try {
            File old = new File(m_destination.toString() + ".old");
            old.delete();
            File current = m_destination;
            current.renameTo(old);
            FileInputStream fis = new FileInputStream(tmpfile);
            FileOutputStream fos = new FileOutputStream(m_destination);
            BufferedInputStream in = new BufferedInputStream(fis);
            BufferedOutputStream out = new BufferedOutputStream(fos);
            for (int read = in.read(); read != -1; read = in.read()) {
                out.write(read);
            }
            out.flush();
            in.close();
            out.close();
            fis.close();
            fos.close();
            tmpfile.delete();
            setVisible(false);
            transferComplete();
        } catch (Exception exc) {
            exc.printStackTrace();
            JOptionPane.showMessageDialog(this, "An error occurred while downloading!", "ACLocator Error", JOptionPane.ERROR_MESSAGE);
        }
    }
} </s>
<s>class temp {    public void init() {
        this.setFormulaCalculationMode(WorkBookHandle.CALCULATE_ALWAYS);
        try {
            if (memeId < 0) {
            } else {
                conurl = new URL(ServerURL + "?meme_id=" + memeId);
                java.io.InputStream xmlstr = conurl.openStream();
                this.removeAllWorkSheets();
                this.setFormulaCalculationMode(WorkBookHandle.CALCULATE_EXPLICIT);
                this.setStringEncodingMode(WorkBookHandle.STRING_ENCODING_UNICODE);
                this.setDupeStringMode(WorkBookHandle.SHAREDUPES);
                ExtenXLS.parseNBind(this, xmlstr);
                this.setFormulaCalculationMode(WorkBookHandle.CALCULATE_ALWAYS);
            }
        } catch (Exception ex) {
            throw new WorkBookException("Error while connecting to: " + ServerURL + ":" + ex.toString(), WorkBookException.RUNTIME_ERROR);
        }
    }
} </s>
<s>class temp {    public static byte[] read(URL url) throws IOException {
        byte[] bytes;
        InputStream is = null;
        try {
            is = url.openStream();
            bytes = readAllBytes(is);
        } finally {
            if (is != null) {
                is.close();
            }
        }
        return bytes;
    }
} </s>
<s>class temp {    private void resolveFileDeclarations(Query query, Map<String, URL> sqlDeclarations) {
        Statement stmt = query.getStatement();
        String fileDeclaration = stmt.getFile();
        boolean hasFileDeclaration = fileDeclaration != null && !"".equals(fileDeclaration);
        if (hasFileDeclaration) {
            try {
                URL url = sqlDeclarations.get(stmt.getFile());
                if (url != null) {
                    URLConnection conn = url.openConnection();
                    InputStream input = conn.getInputStream();
                    String sqlDeclaration = StreamUtils.obtainStreamContents(input);
                    stmt.setValue(sqlDeclaration);
                    input.close();
                }
            } catch (Exception e) {
            }
        }
    }
} </s>
<s>class temp {        public ActualTask(TEditor editor, TIGDataBase dataBase, String directoryPath, String myImagesBehaviour) {
            File myDirectory = new File(directoryPath);
            String[] list = myDirectory.list();
            File fileXML = new File(directoryPath + "images.xml");
            SAXBuilder builder = new SAXBuilder(false);
            try {
                Document docXML = builder.build(fileXML);
                Element root = docXML.getRootElement();
                List images = root.getChildren("image");
                Iterator j = images.iterator();
                int i = 0;
                TIGDataBase.activateTransactions();
                while (j.hasNext() && !stop && !cancel) {
                    current = i;
                    i++;
                    Element image = (Element) j.next();
                    String name = image.getAttributeValue("name");
                    List categories = image.getChildren("category");
                    Iterator k = categories.iterator();
                    if (exists(list, name)) {
                        String pathSrc = directoryPath.concat(name);
                        String pathDst = System.getProperty("user.dir") + File.separator + "images" + File.separator + name.substring(0, 1).toUpperCase() + File.separator;
                        String folder = System.getProperty("user.dir") + File.separator + "images" + File.separator + name.substring(0, 1).toUpperCase();
                        if (myImagesBehaviour.equals(TLanguage.getString("TIGImportDBDialog.REPLACE_IMAGES"))) {
                            Vector<Vector<String>> aux = TIGDataBase.imageSearchByName(name.substring(0, name.lastIndexOf('.')));
                            if (aux.size() != 0) {
                                int idImage = TIGDataBase.imageKeySearchName(name.substring(0, name.lastIndexOf('.')));
                                TIGDataBase.deleteAsociatedOfImage(idImage);
                            }
                            pathDst = pathDst.concat(name);
                        }
                        if (myImagesBehaviour.equals(TLanguage.getString("TIGImportDBDialog.ADD_IMAGES"))) {
                            Vector aux = new Vector();
                            aux = TIGDataBase.imageSearchByName(name.substring(0, name.lastIndexOf('.')));
                            int fileCount = 0;
                            if (aux.size() != 0) {
                                while (aux.size() != 0) {
                                    fileCount++;
                                    aux = TIGDataBase.imageSearchByName(name.substring(0, name.lastIndexOf('.')) + "_" + fileCount);
                                }
                                pathDst = pathDst + name.substring(0, name.lastIndexOf('.')) + '_' + fileCount + name.substring(name.lastIndexOf('.'), name.length());
                                name = name.substring(0, name.lastIndexOf('.')) + '_' + fileCount + name.substring(name.lastIndexOf('.'), name.length());
                            } else {
                                pathDst = pathDst.concat(name);
                            }
                        }
                        String pathThumbnail = (pathDst.substring(0, pathDst.lastIndexOf("."))).concat("_th.jpg");
                        File newDirectoryFolder = new File(folder);
                        if (!newDirectoryFolder.exists()) {
                            newDirectoryFolder.mkdirs();
                        }
                        try {
                            FileChannel srcChannel = new FileInputStream(pathSrc).getChannel();
                            FileChannel dstChannel = new FileOutputStream(pathDst).getChannel();
                            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());
                            srcChannel.close();
                            dstChannel.close();
                        } catch (IOException exc) {
                            System.out.println(exc.getMessage());
                            System.out.println(exc.toString());
                        }
                        TIGDataBase.insertImageDB(name.substring(0, name.lastIndexOf('.')), name);
                        int idImage = TIGDataBase.imageKeySearchName(name.substring(0, name.lastIndexOf('.')));
                        while (k.hasNext()) {
                            Element category = (Element) k.next();
                            int idCategory = TIGDataBase.insertConceptDB(category.getValue());
                            TIGDataBase.insertAsociatedDB(idCategory, idImage);
                        }
                    } else {
                        errorImages = errorImages + System.getProperty("line.separator") + name;
                    }
                }
                TIGDataBase.executeQueries();
                current = lengthOfTask;
            } catch (JDOMException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
} </s>
<s>class temp {    public void processExplicitSchemaAndWSDL(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {
        HashMap services = configContext.getAxisConfiguration().getServices();
        String filePart = req.getRequestURL().toString();
        String schema = filePart.substring(filePart.lastIndexOf("/") + 1, filePart.length());
        if ((services != null) && !services.isEmpty()) {
            Iterator i = services.values().iterator();
            while (i.hasNext()) {
                AxisService service = (AxisService) i.next();
                InputStream stream = service.getClassLoader().getResourceAsStream("META-INF/" + schema);
                if (stream != null) {
                    OutputStream out = res.getOutputStream();
                    res.setContentType("text/xml");
                    IOUtils.copy(stream, out, true);
                    return;
                }
            }
        }
    }
} </s>
<s>class temp {    private void copia(FileInputStream input, FileOutputStream output) throws ErrorException {
        if (input == null || output == null) {
            throw new ErrorException("Param null");
        }
        FileChannel inChannel = input.getChannel();
        FileChannel outChannel = output.getChannel();
        try {
            inChannel.transferTo(0, inChannel.size(), outChannel);
            inChannel.close();
            outChannel.close();
        } catch (IOException e) {
            throw new ErrorException("Casino nella copia del file");
        }
    }
} </s>
<s>class temp {    public boolean backupFile(File oldFile, File newFile) {
        boolean isBkupFileOK = false;
        FileChannel sourceChannel = null;
        FileChannel targetChannel = null;
        try {
            sourceChannel = new FileInputStream(oldFile).getChannel();
            targetChannel = new FileOutputStream(newFile).getChannel();
            targetChannel.transferFrom(sourceChannel, 0, sourceChannel.size());
        } catch (IOException e) {
            logger.log(Level.SEVERE, "IO exception occurred while copying config file", e);
        } finally {
            if ((newFile != null) && (newFile.exists()) && (newFile.length() > 0)) {
                isBkupFileOK = true;
            }
            try {
                if (sourceChannel != null) {
                    sourceChannel.close();
                }
                if (targetChannel != null) {
                    targetChannel.close();
                }
            } catch (IOException e) {
                logger.log(Level.INFO, "closing channels failed");
            }
        }
        return isBkupFileOK;
    }
} </s>
<s>class temp {    public Long addRole(AuthSession authSession, RoleBean roleBean) {
        PreparedStatement ps = null;
        DatabaseAdapter dbDyn = null;
        try {
            dbDyn = DatabaseAdapter.getInstance();
            CustomSequenceType seq = new CustomSequenceType();
            seq.setSequenceName("seq_WM_AUTH_ACCESS_GROUP");
            seq.setTableName("WM_AUTH_ACCESS_GROUP");
            seq.setColumnName("ID_ACCESS_GROUP");
            Long sequenceValue = dbDyn.getSequenceNextValue(seq);
            ps = dbDyn.prepareStatement("insert into WM_AUTH_ACCESS_GROUP " + "( ID_ACCESS_GROUP, NAME_ACCESS_GROUP ) values " + (dbDyn.getIsNeedUpdateBracket() ? "(" : "") + " ?, ? " + (dbDyn.getIsNeedUpdateBracket() ? ")" : ""));
            RsetTools.setLong(ps, 1, sequenceValue);
            ps.setString(2, roleBean.getName());
            int i1 = ps.executeUpdate();
            if (log.isDebugEnabled()) log.debug("Count of inserted records - " + i1);
            dbDyn.commit();
            return sequenceValue;
        } catch (Exception e) {
            try {
                if (dbDyn != null) dbDyn.rollback();
            } catch (Exception e001) {
            }
            String es = "Error add new role";
            log.error(es, e);
            throw new IllegalStateException(es, e);
        } finally {
            DatabaseManager.close(dbDyn, ps);
            dbDyn = null;
            ps = null;
        }
    }
} </s>
<s>class temp {    public void updateRole(AuthSession authSession, RoleBean roleBean) {
        DatabaseAdapter dbDyn = null;
        PreparedStatement ps = null;
        try {
            dbDyn = DatabaseAdapter.getInstance();
            String sql = "update WM_AUTH_ACCESS_GROUP " + "set    NAME_ACCESS_GROUP=? " + "WHERE  ID_ACCESS_GROUP=? ";
            ps = dbDyn.prepareStatement(sql);
            ps.setString(1, roleBean.getName());
            ps.setLong(2, roleBean.getRoleId());
            int i1 = ps.executeUpdate();
            if (log.isDebugEnabled()) log.debug("Count of updated record - " + i1);
            dbDyn.commit();
        } catch (Exception e) {
            try {
                if (dbDyn != null) dbDyn.rollback();
            } catch (Exception e001) {
            }
            String es = "Error save role";
            log.error(es, e);
            throw new IllegalStateException(es, e);
        } finally {
            DatabaseManager.close(dbDyn, ps);
            dbDyn = null;
            ps = null;
        }
    }
} </s>
<s>class temp {    public void deleteRole(AuthSession authSession, RoleBean roleBean) {
        DatabaseAdapter dbDyn = null;
        PreparedStatement ps = null;
        try {
            dbDyn = DatabaseAdapter.getInstance();
            if (roleBean.getRoleId() == null) throw new IllegalArgumentException("role id is null");
            String sql = "delete from WM_AUTH_ACCESS_GROUP where ID_ACCESS_GROUP=? ";
            ps = dbDyn.prepareStatement(sql);
            RsetTools.setLong(ps, 1, roleBean.getRoleId());
            int i1 = ps.executeUpdate();
            if (log.isDebugEnabled()) log.debug("Count of deleted records - " + i1);
            dbDyn.commit();
        } catch (Exception e) {
            try {
                if (dbDyn != null) dbDyn.rollback();
            } catch (Exception e001) {
            }
            String es = "Error delete role";
            log.error(es, e);
            throw new IllegalStateException(es, e);
        } finally {
            DatabaseManager.close(dbDyn, ps);
            dbDyn = null;
            ps = null;
        }
    }
} </s>
<s>class temp {    public void updateUserInfo(AuthSession authSession, AuthUserExtendedInfo infoAuth) {
        log.info("Start update auth");
        PreparedStatement ps = null;
        DatabaseAdapter db = null;
        try {
            db = DatabaseAdapter.getInstance();
            String sql = "update WM_AUTH_USER " + "set " + "ID_FIRM=?, IS_USE_CURRENT_FIRM=?, " + "ID_HOLDING=?, IS_HOLDING=? " + "WHERE  ID_AUTH_USER=? ";
            ps = db.prepareStatement(sql);
            if (infoAuth.getAuthInfo().getCompanyId() == null) {
                ps.setNull(1, Types.INTEGER);
                ps.setInt(2, 0);
            } else {
                ps.setLong(1, infoAuth.getAuthInfo().getCompanyId());
                ps.setInt(2, infoAuth.getAuthInfo().isCompany() ? 1 : 0);
            }
            if (infoAuth.getAuthInfo().getHoldingId() == null) {
                ps.setNull(3, Types.INTEGER);
                ps.setInt(4, 0);
            } else {
                ps.setLong(3, infoAuth.getAuthInfo().getHoldingId());
                ps.setInt(4, infoAuth.getAuthInfo().isHolding() ? 1 : 0);
            }
            ps.setLong(5, infoAuth.getAuthInfo().getAuthUserId());
            ps.executeUpdate();
            processDeletedRoles(db, infoAuth);
            processNewRoles(db, infoAuth.getRoles(), infoAuth.getAuthInfo().getAuthUserId());
            db.commit();
        } catch (Throwable e) {
            try {
                if (db != null) db.rollback();
            } catch (Exception e001) {
            }
            final String es = "Error add user auth";
            log.error(es, e);
            throw new IllegalStateException(es, e);
        } finally {
            DatabaseManager.close(db, ps);
            ps = null;
            db = null;
            log.info("End update auth");
        }
    }
} </s>
<s>class temp {    private static AndsDoiResponse doiRequest(String serviceUrl, String metaDataXML, String requestType) throws IOException {
        if (LOG.isDebugEnabled()) {
            LOG.debug("Method URL: " + serviceUrl);
            LOG.debug("Metadata XML NULL ?: " + StringUtils.isEmpty(metaDataXML));
            LOG.debug("Request Type: " + requestType);
        }
        AndsDoiResponse doiResponse = null;
        OutputStreamWriter wr = null;
        BufferedReader rd = null;
        StringBuffer outputBuffer;
        URL url = new URL(serviceUrl);
        HttpURLConnection conn = (HttpURLConnection) url.openConnection();
        try {
            conn.setDoInput(true);
            if (requestType.equals("POST")) {
                conn.setDoOutput(true);
                wr = new OutputStreamWriter(conn.getOutputStream());
                if (metaDataXML != null) {
                    wr.write("xml=" + URLEncoder.encode(metaDataXML, "UTF-8"));
                }
                wr.flush();
            } else {
                conn.setDoOutput(false);
            }
            if (LOG.isDebugEnabled()) {
                LOG.debug(conn.getResponseCode() + " - " + conn.getResponseMessage());
            }
            outputBuffer = new StringBuffer();
            outputBuffer.append(conn.getResponseMessage() + "\n");
            rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));
            String line;
            while ((line = rd.readLine()) != null) {
                outputBuffer.append(line);
            }
            doiResponse = new AndsDoiResponse();
            doiResponse.setMessage(outputBuffer.toString());
            setResponseFlag(conn.getResponseCode(), doiResponse);
        } catch (Exception e) {
            doiResponse = new AndsDoiResponse();
            outputBuffer = new StringBuffer();
            outputBuffer.append(conn.getResponseMessage() + "\n");
            BufferedReader rde = new BufferedReader(new InputStreamReader(conn.getErrorStream()));
            String line;
            while ((line = rde.readLine()) != null) {
                outputBuffer.append(line);
            }
            doiResponse.setSuccess(false);
            doiResponse.setMessage(outputBuffer.toString());
            rde.close();
        } finally {
            if (wr != null) {
                wr.close();
            }
            if (rd != null) {
                rd.close();
            }
        }
        return doiResponse;
    }
} </s>
<s>class temp {        public void writeFile(OutputStream outputStream) throws IOException {
            InputStream inputStream = null;
            if (file != null) {
                try {
                    inputStream = new FileInputStream(file);
                    IOUtils.copy(inputStream, outputStream);
                } finally {
                    if (inputStream != null) {
                        IOUtils.closeQuietly(inputStream);
                    }
                }
            }
        }
} </s>
<s>class temp {    private void copyMerge(Path[] sources, OutputStream out) throws IOException {
        Configuration conf = getConf();
        for (int i = 0; i < sources.length; ++i) {
            FileSystem fs = sources[i].getFileSystem(conf);
            InputStream in = fs.open(sources[i]);
            try {
                IOUtils.copyBytes(in, out, conf, false);
            } finally {
                in.close();
            }
        }
    }
} </s>
<s>class temp {    public void doActionOn(TomcatProject prj) throws Exception {
        String path = TomcatLauncherPlugin.getDefault().getManagerAppUrl();
        try {
            path += "/reload?path=" + prj.getWebPath();
            URL url = new URL(path);
            Authenticator.setDefault(new Authenticator() {

                protected PasswordAuthentication getPasswordAuthentication() {
                    String user = TomcatLauncherPlugin.getDefault().getManagerAppUser();
                    String password = TomcatLauncherPlugin.getDefault().getManagerAppPassword();
                    return new PasswordAuthentication(user, password.toCharArray());
                }
            });
            HttpURLConnection connection = (HttpURLConnection) url.openConnection();
            connection.getContent();
            connection.disconnect();
            Authenticator.setDefault(null);
        } catch (Exception e) {
            throw new Exception("The following url was used : \n" + path + "\n\nCheck manager app settings (username and password)\n\n");
        }
    }
} </s>
<s>class temp {    protected void convertInternal(InputStream inputStream, DocumentFormat inputFormat, OutputStream outputStream, DocumentFormat outputFormat) {
        File inputFile = null;
        File outputFile = null;
        try {
            inputFile = File.createTempFile("document", "." + inputFormat.getFileExtension());
            OutputStream inputFileStream = null;
            try {
                inputFileStream = new FileOutputStream(inputFile);
                IOUtils.copy(inputStream, inputFileStream);
            } finally {
                IOUtils.closeQuietly(inputFileStream);
            }
            outputFile = File.createTempFile("document", "." + outputFormat.getFileExtension());
            convert(inputFile, inputFormat, outputFile, outputFormat);
            InputStream outputFileStream = null;
            try {
                outputFileStream = new FileInputStream(outputFile);
                IOUtils.copy(outputFileStream, outputStream);
            } finally {
                IOUtils.closeQuietly(outputFileStream);
            }
        } catch (IOException ioException) {
            throw new OpenOfficeException("conversion failed", ioException);
        } finally {
            if (inputFile != null) {
                inputFile.delete();
            }
            if (outputFile != null) {
                outputFile.delete();
            }
        }
    }
} </s>
<s>class temp {    public static void copyFileByNIO(File in, File out) throws IOException {
        FileChannel sourceChannel = new FileInputStream(in).getChannel();
        FileChannel destinationChannel = new FileOutputStream(out).getChannel();
        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);
        sourceChannel.close();
        destinationChannel.close();
    }
} </s>
<s>class temp {    protected void connect() throws SocketException, IOException, LoginFailException {
        logger.info("Connect to FTP Server " + account.getServer());
        client = new FTPClient();
        client.connect(account.getServer());
        if (client.login(account.getId(), account.getPassword()) == false) {
            logger.info("Fail to login with id=" + account.getId());
            throw new LoginFailException(account.getId(), account.getPassword());
        }
    }
} </s>
<s>class temp {    public String control(final String allOptions) throws SQLException {
        connect();
        final Statement stmt = connection.createStatement();
        final ResultSet rst1 = stmt.executeQuery("SELECT versionId FROM versions WHERE version='" + Concrete.version() + "'");
        final long versionId;
        if (rst1.next()) {
            versionId = rst1.getInt(1);
        } else {
            disconnect();
            return "";
        }
        rst1.close();
        final MessageDigest msgDigest;
        try {
            msgDigest = MessageDigest.getInstance("MD5");
        } catch (NoSuchAlgorithmException e1) {
            logger.throwing(SQLExecutionController.class.getSimpleName(), "control", e1);
            disconnect();
            return "";
        }
        msgDigest.update(allOptions.getBytes());
        final ResultSet rst2 = stmt.executeQuery("SELECT configId FROM configs WHERE md5='" + Concrete.md5(msgDigest.digest()) + "'");
        final long configId;
        if (rst2.next()) {
            configId = rst2.getInt(1);
        } else {
            disconnect();
            return "";
        }
        rst2.close();
        final ResultSet rst4 = stmt.executeQuery("SELECT problems.md5 FROM executions " + "LEFT JOIN problems ON executions.problemId = problems.problemId WHERE " + "configId=" + configId + " AND versionId=" + versionId);
        final StringBuilder stb = new StringBuilder();
        while (rst4.next()) {
            stb.append(rst4.getString(1)).append('\n');
        }
        rst4.close();
        stmt.close();
        return stb.toString();
    }
} </s>
<s>class temp {    public static String encrypt(String text) {
        final char[] HEX_CHARS = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
        String result = "";
        MessageDigest digest = null;
        try {
            digest = MessageDigest.getInstance("MD5");
            digest.update(text.getBytes());
            byte[] hash = digest.digest();
            char buffer[] = new char[hash.length * 2];
            for (int i = 0, x = 0; i < hash.length; i++) {
                buffer[x++] = HEX_CHARS[(hash[i] >>> 4) & 0xf];
                buffer[x++] = HEX_CHARS[hash[i] & 0xf];
            }
            result = new String(buffer);
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        return result;
    }
} </s>
<s>class temp {    protected static JXStatusBar getStatusBar(final JXPanel jxPanel, final JTabbedPane mainTabbedPane) {
        JXStatusBar statusBar = new JXStatusBar();
        try {
            ClassLoader cl = Thread.currentThread().getContextClassLoader();
            Enumeration<URL> urls = cl.getResources("META-INF/MANIFEST.MF");
            String substanceVer = null;
            String substanceBuildStamp = null;
            while (urls.hasMoreElements()) {
                InputStream is = urls.nextElement().openStream();
                BufferedReader br = new BufferedReader(new InputStreamReader(is));
                while (true) {
                    String line = br.readLine();
                    if (line == null) break;
                    int firstColonIndex = line.indexOf(":");
                    if (firstColonIndex < 0) continue;
                    String name = line.substring(0, firstColonIndex).trim();
                    String val = line.substring(firstColonIndex + 1).trim();
                    if (name.compareTo("Substance-Version") == 0) substanceVer = val;
                    if (name.compareTo("Substance-BuildStamp") == 0) substanceBuildStamp = val;
                }
                try {
                    br.close();
                } catch (IOException ioe) {
                }
            }
            if (substanceVer != null) {
                JLabel statusLabel = new JLabel(substanceVer + " [built on " + substanceBuildStamp + "]");
                JXStatusBar.Constraint cStatusLabel = new JXStatusBar.Constraint();
                cStatusLabel.setFixedWidth(300);
                statusBar.add(statusLabel, cStatusLabel);
            }
        } catch (IOException ioe) {
        }
        JXStatusBar.Constraint c2 = new JXStatusBar.Constraint(JXStatusBar.Constraint.ResizeBehavior.FILL);
        final JLabel tabLabel = new JLabel("");
        statusBar.add(tabLabel, c2);
        mainTabbedPane.getModel().addChangeListener(new ChangeListener() {

            public void stateChanged(ChangeEvent e) {
                int selectedIndex = mainTabbedPane.getSelectedIndex();
                if (selectedIndex < 0) tabLabel.setText("No selected tab"); else tabLabel.setText("Tab " + mainTabbedPane.getTitleAt(selectedIndex) + " selected");
            }
        });
        JPanel fontSizePanel = FontSizePanel.getPanel();
        JXStatusBar.Constraint fontSizePanelConstraints = new JXStatusBar.Constraint();
        fontSizePanelConstraints.setFixedWidth(270);
        statusBar.add(fontSizePanel, fontSizePanelConstraints);
        JPanel alphaPanel = new JPanel(new FlowLayout(FlowLayout.LEADING, 0, 0));
        final JLabel alphaLabel = new JLabel("100%");
        final JSlider alphaSlider = new JSlider(0, 100, 100);
        alphaSlider.setFocusable(false);
        alphaSlider.addChangeListener(new ChangeListener() {

            public void stateChanged(ChangeEvent e) {
                int currValue = alphaSlider.getValue();
                alphaLabel.setText(currValue + "%");
                jxPanel.setAlpha(currValue / 100.0f);
            }
        });
        alphaSlider.setToolTipText("Changes the global opacity. Is not Substance-specific");
        alphaSlider.setPreferredSize(new Dimension(120, alphaSlider.getPreferredSize().height));
        alphaPanel.add(alphaLabel);
        alphaPanel.add(alphaSlider);
        JXStatusBar.Constraint alphaPanelConstraints = new JXStatusBar.Constraint();
        alphaPanelConstraints.setFixedWidth(160);
        statusBar.add(alphaPanel, alphaPanelConstraints);
        return statusBar;
    }
} </s>
<s>class temp {    public void jsFunction_addFile(ScriptableFile infile) throws IOException {
        if (!infile.jsFunction_exists()) throw new IllegalArgumentException("Cannot add a file that doesn't exists to an archive");
        ZipArchiveEntry entry = new ZipArchiveEntry(infile.getName());
        entry.setSize(infile.jsFunction_getSize());
        out.putArchiveEntry(entry);
        try {
            InputStream inStream = infile.jsFunction_createInputStream();
            IOUtils.copy(inStream, out);
            inStream.close();
        } finally {
            out.closeArchiveEntry();
        }
    }
} </s>
<s>class temp {    public static void copy(Context cx, Scriptable thisObj, Object[] args, Function funObj) throws IOException {
        InputStream input = (InputStream) ((NativeJavaObject) args[0]).unwrap();
        OutputStream output = (OutputStream) ((NativeJavaObject) args[1]).unwrap();
        IOUtils.copy(input, output);
    }
} </s>
<s>class temp {    protected static File UrlToFile(String urlSt) throws CaughtException {
        try {
            logger.info("copy from url: " + urlSt);
            URL url = new URL(urlSt);
            InputStream input = url.openStream();
            File dir = tempDir;
            File tempFile = new File(tempDir + File.separator + fileName(url));
            logger.info("created: " + tempFile.getAbsolutePath());
            copyFile(tempFile, input);
            return tempFile;
        } catch (IOException e) {
            throw new CaughtException(e, logger);
        }
    }
} </s>
<s>class temp {    protected static File UrlToAFile(File target, String urlSt, String fileName) throws CaughtException {
        try {
            logger.info("copy from url: " + urlSt);
            URL url = new URL(urlSt);
            InputStream input = url.openStream();
            File dir = tempDir;
            File tempFile = new File(target, fileName);
            logger.info("created: " + tempFile.getAbsolutePath());
            copyFile(tempFile, input);
            return tempFile;
        } catch (IOException e) {
            throw new CaughtException(e, logger);
        }
    }
} </s>
<s>class temp {    protected static File UrlGzipToFile(File dir, String urlSt, String suffix) throws CaughtException {
        try {
            URL url = new URL(urlSt);
            InputStream zipped = url.openStream();
            InputStream unzipped = new GZIPInputStream(zipped);
            File tempFile = File.createTempFile("input", suffix, dir);
            copyFile(tempFile, unzipped);
            return tempFile;
        } catch (IOException e) {
            throw new CaughtException(e, logger);
        }
    }
} </s>
<s>class temp {    protected static File UrlGzipToAFile(File dir, String urlSt, String fileName) throws CaughtException {
        try {
            URL url = new URL(urlSt);
            InputStream zipped = url.openStream();
            InputStream unzipped = new GZIPInputStream(zipped);
            File tempFile = new File(dir, fileName);
            copyFile(tempFile, unzipped);
            return tempFile;
        } catch (IOException e) {
            throw new CaughtException(e, logger);
        }
    }
} </s>
<s>class temp {    protected boolean copyFile(File sourceFile, File destinationFile) {
        try {
            FileChannel srcChannel = new FileInputStream(sourceFile).getChannel();
            FileChannel dstChannel = new FileOutputStream(destinationFile).getChannel();
            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());
            srcChannel.close();
            dstChannel.close();
        } catch (IOException e) {
            e.printStackTrace();
            return false;
        }
        return true;
    }
} </s>
<s>class temp {    public void compressImage(BufferedImage bi, OutputStream output, DjatokaEncodeParam params) throws DjatokaException {
        if (params == null) params = new DjatokaEncodeParam();
        if (params.getLevels() == 0) params.setLevels(ImageProcessingUtils.getLevelCount(bi.getWidth(), bi.getHeight()));
        File in = null;
        File out = null;
        try {
            in = IOUtils.createTempTiff(bi);
            out = File.createTempFile("tmp", ".jp2");
            compressImage(in.getAbsolutePath(), out.getAbsolutePath(), params);
            IOUtils.copyStream(new FileInputStream(out), output);
        } catch (IOException e) {
            logger.error(e, e);
            throw new DjatokaException(e);
        } catch (Exception e) {
            logger.error(e, e);
            throw new DjatokaException(e);
        }
        if (in != null) in.delete();
        if (out != null) out.delete();
    }
} </s>
<s>class temp {    public void compressImage(InputStream input, String output, DjatokaEncodeParam params) throws DjatokaException {
        if (params == null) params = new DjatokaEncodeParam();
        File inputFile;
        try {
            inputFile = File.createTempFile("tmp", ".tif");
            inputFile.deleteOnExit();
            IOUtils.copyStream(input, new FileOutputStream(inputFile));
            if (params.getLevels() == 0) {
                ImageRecord dim = ImageRecordUtils.getImageDimensions(inputFile.getAbsolutePath());
                params.setLevels(ImageProcessingUtils.getLevelCount(dim.getWidth(), dim.getHeight()));
                dim = null;
            }
        } catch (IOException e) {
            logger.error(e, e);
            throw new DjatokaException(e);
        }
        compressImage(inputFile.getAbsolutePath(), output, params);
        if (inputFile != null) inputFile.delete();
    }
} </s>
<s>class temp {    public void compressImage(InputStream input, OutputStream output, DjatokaEncodeParam params) throws DjatokaException {
        if (params == null) params = new DjatokaEncodeParam();
        File inputFile = null;
        try {
            inputFile = File.createTempFile("tmp", ".tif");
            IOUtils.copyStream(input, new FileOutputStream(inputFile));
            if (params.getLevels() == 0) {
                ImageRecord dim = ImageRecordUtils.getImageDimensions(inputFile.getAbsolutePath());
                params.setLevels(ImageProcessingUtils.getLevelCount(dim.getWidth(), dim.getHeight()));
                dim = null;
            }
        } catch (IOException e1) {
            logger.error("Unexpected file format; expecting uncompressed TIFF", e1);
            throw new DjatokaException("Unexpected file format; expecting uncompressed TIFF");
        }
        String out = STDOUT;
        File winOut = null;
        if (isWindows) {
            try {
                winOut = File.createTempFile("pipe_", ".jp2");
            } catch (IOException e) {
                logger.error(e, e);
                throw new DjatokaException(e);
            }
            out = winOut.getAbsolutePath();
        }
        String command = getKduCompressCommand(inputFile.getAbsolutePath(), out, params);
        logger.debug("compressCommand: " + command);
        Runtime rt = Runtime.getRuntime();
        try {
            final Process process = rt.exec(command, envParams, new File(env));
            if (out.equals(STDOUT)) {
                IOUtils.copyStream(process.getInputStream(), output);
            } else if (isWindows) {
                FileInputStream fis = new FileInputStream(out);
                IOUtils.copyStream(fis, output);
                fis.close();
            }
            process.waitFor();
            if (process != null) {
                String errorCheck = null;
                try {
                    errorCheck = new String(IOUtils.getByteArray(process.getErrorStream()));
                } catch (Exception e1) {
                    logger.error(e1, e1);
                }
                process.getInputStream().close();
                process.getOutputStream().close();
                process.getErrorStream().close();
                process.destroy();
                if (errorCheck != null) throw new DjatokaException(errorCheck);
            }
        } catch (IOException e) {
            logger.error(e, e);
            throw new DjatokaException(e);
        } catch (InterruptedException e) {
            logger.error(e, e);
            throw new DjatokaException(e);
        }
        if (inputFile != null) inputFile.delete();
        if (winOut != null) winOut.delete();
    }
} </s>
<s>class temp {    public void convert(File src, File dest) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(src));
        DcmParser p = pfact.newDcmParser(in);
        Dataset ds = fact.newDataset();
        p.setDcmHandler(ds.getDcmHandler());
        try {
            FileFormat format = p.detectFileFormat();
            if (format != FileFormat.ACRNEMA_STREAM) {
                System.out.println("\n" + src + ": not an ACRNEMA stream!");
                return;
            }
            p.parseDcmFile(format, Tags.PixelData);
            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {
                System.out.println("\n" + src + ": contains UIDs!" + " => probable already DICOM - do not convert");
                return;
            }
            boolean hasPixelData = p.getReadTag() == Tags.PixelData;
            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;
            int pxlen = p.getReadLength();
            if (hasPixelData) {
                if (inflate) {
                    ds.putUS(Tags.BitsAllocated, 16);
                    pxlen = pxlen * 4 / 3;
                }
                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {
                    System.out.println("\n" + src + ": mismatch pixel data length!" + " => do not convert");
                    return;
                }
            }
            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));
            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));
            ds.putUI(Tags.SOPInstanceUID, uid(instUID));
            ds.putUI(Tags.SOPClassUID, classUID);
            if (!ds.contains(Tags.NumberOfSamples)) {
                ds.putUS(Tags.NumberOfSamples, 1);
            }
            if (!ds.contains(Tags.PhotometricInterpretation)) {
                ds.putCS(Tags.PhotometricInterpretation, "MONOCHROME2");
            }
            if (fmi) {
                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));
            }
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
            try {
            } finally {
                ds.writeFile(out, encodeParam());
                if (hasPixelData) {
                    if (!skipGroupLen) {
                        out.write(PXDATA_GROUPLEN);
                        int grlen = pxlen + 8;
                        out.write((byte) grlen);
                        out.write((byte) (grlen >> 8));
                        out.write((byte) (grlen >> 16));
                        out.write((byte) (grlen >> 24));
                    }
                    out.write(PXDATA_TAG);
                    out.write((byte) pxlen);
                    out.write((byte) (pxlen >> 8));
                    out.write((byte) (pxlen >> 16));
                    out.write((byte) (pxlen >> 24));
                }
                if (inflate) {
                    int b2, b3;
                    for (; pxlen > 0; pxlen -= 3) {
                        out.write(in.read());
                        b2 = in.read();
                        b3 = in.read();
                        out.write(b2 & 0x0f);
                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));
                        out.write(b3 >> 4);
                    }
                } else {
                    for (; pxlen > 0; --pxlen) {
                        out.write(in.read());
                    }
                }
                out.close();
            }
            System.out.print('.');
        } finally {
            in.close();
        }
    }
} </s>
<s>class temp {    public static final String crypt(String password, String salt) throws NoSuchAlgorithmException {
        String magic = "$1$";
        byte finalState[];
        MessageDigest ctx, ctx1;
        long l;
        if (salt.startsWith(magic)) {
            salt = salt.substring(magic.length());
        }
        if (salt.indexOf('$') != -1) {
            salt = salt.substring(0, salt.indexOf('$'));
        }
        if (salt.length() > 8) {
            salt = salt.substring(0, 8);
        }
        ctx = MessageDigest.getInstance("MD5");
        ctx.update(password.getBytes());
        ctx.update(magic.getBytes());
        ctx.update(salt.getBytes());
        ctx1 = MessageDigest.getInstance("MD5");
        ctx1.update(password.getBytes());
        ctx1.update(salt.getBytes());
        ctx1.update(password.getBytes());
        finalState = ctx1.digest();
        for (int pl = password.length(); pl > 0; pl -= 16) {
            for (int i = 0; i < (pl > 16 ? 16 : pl); i++) ctx.update(finalState[i]);
        }
        clearbits(finalState);
        for (int i = password.length(); i != 0; i >>>= 1) {
            if ((i & 1) != 0) {
                ctx.update(finalState[0]);
            } else {
                ctx.update(password.getBytes()[0]);
            }
        }
        finalState = ctx.digest();
        for (int i = 0; i < 1000; i++) {
            ctx1 = MessageDigest.getInstance("MD5");
            if ((i & 1) != 0) {
                ctx1.update(password.getBytes());
            } else {
                for (int c = 0; c < 16; c++) ctx1.update(finalState[c]);
            }
            if ((i % 3) != 0) {
                ctx1.update(salt.getBytes());
            }
            if ((i % 7) != 0) {
                ctx1.update(password.getBytes());
            }
            if ((i & 1) != 0) {
                for (int c = 0; c < 16; c++) ctx1.update(finalState[c]);
            } else {
                ctx1.update(password.getBytes());
            }
            finalState = ctx1.digest();
        }
        StringBuffer result = new StringBuffer();
        result.append(magic);
        result.append(salt);
        result.append("$");
        l = (bytes2u(finalState[0]) << 16) | (bytes2u(finalState[6]) << 8) | bytes2u(finalState[12]);
        result.append(to64(l, 4));
        l = (bytes2u(finalState[1]) << 16) | (bytes2u(finalState[7]) << 8) | bytes2u(finalState[13]);
        result.append(to64(l, 4));
        l = (bytes2u(finalState[2]) << 16) | (bytes2u(finalState[8]) << 8) | bytes2u(finalState[14]);
        result.append(to64(l, 4));
        l = (bytes2u(finalState[3]) << 16) | (bytes2u(finalState[9]) << 8) | bytes2u(finalState[15]);
        result.append(to64(l, 4));
        l = (bytes2u(finalState[4]) << 16) | (bytes2u(finalState[10]) << 8) | bytes2u(finalState[5]);
        result.append(to64(l, 4));
        l = bytes2u(finalState[11]);
        result.append(to64(l, 2));
        clearbits(finalState);
        return result.toString();
    }
} </s>
<s>class temp {    protected void doSetInput(IEditorInput input, IProgressMonitor monitor) throws CoreException {
        IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();
        IFileFormat format = null;
        Object source = null;
        InputStream in = null;
        try {
            IPath path;
            if (input instanceof IStorageEditorInput) {
                IStorage s = ((IStorageEditorInput) input).getStorage();
                in = s.getContents();
                if (s instanceof IFile) {
                    IFile file = (IFile) s;
                    path = file.getRawLocation();
                    if (root.exists(path)) {
                        path = root.getLocation().append(path);
                    }
                    source = path.toFile();
                }
            } else if (input instanceof IPathEditorInput) {
                path = ((IPathEditorInput) input).getPath();
                source = path.toFile();
            } else if (input instanceof IURIEditorInput) {
                URI uri = ((IURIEditorInput) input).getURI();
                if (URIUtil.isFileURI(uri)) {
                    source = URIUtil.toFile(uri);
                } else {
                    URL url = URIUtil.toURL(uri);
                    in = url.openStream();
                }
            }
            if (source == null) {
                if (!in.markSupported()) {
                    in = new BufferedInputStream(in);
                }
                in.mark(10);
                source = in;
            }
            IContentDescription cd = Platform.getContentTypeManager().getDescriptionFor(in, input.getName(), new QualifiedName[] { ImageCore.VALID_FORMATS });
            if (in != null) {
                in.reset();
            }
            Collection<?> valid = (Collection<?>) cd.getProperty(ImageCore.VALID_FORMATS);
            if (valid.isEmpty()) throw new CoreException(new Status(Status.ERROR, ImageUI.PLUGIN_ID, "Unsupported file format."));
            ImageInputStream stream = ImageIO.createImageInputStream(source);
            format = (IFileFormat) valid.iterator().next();
            IDocument document = format.decode(stream, monitor);
            setDocument(document);
        } catch (IOException e) {
            Status status = new Status(Status.ERROR, ImageUI.PLUGIN_ID, "IO Error", e);
            throw new CoreException(status);
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException e) {
                }
            }
        }
        super.setInput(input);
    }
} </s>
<s>class temp {    public static void copyFile(File oldFile, File newFile) throws Exception {
        newFile.getParentFile().mkdirs();
        newFile.createNewFile();
        FileChannel srcChannel = new FileInputStream(oldFile).getChannel();
        FileChannel dstChannel = new FileOutputStream(newFile).getChannel();
        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());
        srcChannel.close();
        dstChannel.close();
    }
} </s>
<s>class temp {    private String getMD5Password(String plainText) throws NoSuchAlgorithmException {
        MessageDigest mdAlgorithm;
        StringBuffer hexString = new StringBuffer();
        String md5Password = "";
        mdAlgorithm = MessageDigest.getInstance("MD5");
        mdAlgorithm.update(plainText.getBytes());
        byte[] digest = mdAlgorithm.digest();
        for (int i = 0; i < digest.length; i++) {
            plainText = Integer.toHexString(0xFF & digest[i]);
            if (plainText.length() < 2) {
                plainText = "0" + plainText;
            }
            hexString.append(plainText);
        }
        md5Password = hexString.toString();
        return md5Password;
    }
} </s>
<s>class temp {    private static void readAndRewrite(File inFile, File outFile) throws IOException {
        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));
        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);
        Dataset ds = DcmObjectFactory.getInstance().newDataset();
        dcmParser.setDcmHandler(ds.getDcmHandler());
        dcmParser.parseDcmFile(null, Tags.PixelData);
        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        System.out.println("reading " + inFile + "...");
        pdReader.readPixelData(false);
        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));
        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;
        ds.writeDataset(out, dcmEncParam);
        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());
        System.out.println("writing " + outFile + "...");
        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        pdWriter.writePixelData();
        out.flush();
        out.close();
        System.out.println("done!");
    }
} </s>
<s>class temp {    public void elimina(Cliente cli) throws errorSQL, errorConexionBD {
        System.out.println("GestorCliente.elimina()");
        int id = cli.getId();
        String sql;
        Statement stmt = null;
        try {
            gd.begin();
            sql = "DELETE FROM cliente WHERE cod_cliente =" + id;
            System.out.println("Ejecutando: " + sql);
            stmt = gd.getConexion().createStatement();
            stmt.executeUpdate(sql);
            System.out.println("executeUpdate");
            sql = "DELETE FROM persona WHERE id =" + id;
            System.out.println("Ejecutando: " + sql);
            stmt.executeUpdate(sql);
            gd.commit();
            System.out.println("commit");
            stmt.close();
        } catch (SQLException e) {
            gd.rollback();
            throw new errorSQL(e.toString());
        } catch (errorConexionBD e) {
            System.err.println("Error en GestorCliente.elimina(): " + e);
        } catch (errorSQL e) {
            System.err.println("Error en GestorCliente.elimina(): " + e);
        }
    }
} </s>
<s>class temp {    public boolean loadResource(String resourcePath) {
        try {
            URL url = Thread.currentThread().getContextClassLoader().getResource(resourcePath);
            if (url == null) {
                logger.error("Cannot find the resource named: '" + resourcePath + "'. Failed to load the keyword list.");
                return false;
            }
            InputStreamReader isr = new InputStreamReader(url.openStream());
            BufferedReader br = new BufferedReader(isr);
            String ligne = br.readLine();
            while (ligne != null) {
                if (!contains(ligne.toUpperCase())) {
                    addLast(ligne.toUpperCase());
                }
                ligne = br.readLine();
            }
            return true;
        } catch (IOException ioe) {
            logger.log(Level.ERROR, "Cannot load default SQL keywords file.", ioe);
        }
        return false;
    }
} </s>
<s>class temp {    private String jarDiagnostics(Throwable throwable, File[] files) throws IOException {
        File home = new File(System.getProperty("user.home"));
        File jar_file = File.createTempFile("nuages-diagnostic.", ".jar", home);
        FileOutputStream fos = new FileOutputStream(jar_file);
        JarOutputStream jos = new JarOutputStream(fos);
        ZipEntry ze = new ZipEntry("Exception");
        jos.putNextEntry(ze);
        PrintStream ps = new PrintStream(jos);
        throwable.printStackTrace(ps);
        for (File file : files) if ((file != null) && file.exists()) {
            ze = new ZipEntry(file.getName());
            jos.putNextEntry(ze);
            byte[] buffer = new byte[65536];
            FileInputStream fis = new FileInputStream(file);
            int len;
            while ((len = fis.read(buffer)) > 0) jos.write(buffer, 0, len);
            fis.close();
        }
        jos.close();
        return jar_file.getPath();
    }
} </s>
<s>class temp {    public static void copyFile(File src, File dst) throws ResourceNotFoundException, ParseErrorException, Exception {
        if (src.getAbsolutePath().endsWith(".vm")) {
            copyVMFile(src, dst.getAbsolutePath().substring(0, dst.getAbsolutePath().lastIndexOf(".vm")));
        } else {
            FileInputStream fIn;
            FileOutputStream fOut;
            FileChannel fIChan, fOChan;
            long fSize;
            MappedByteBuffer mBuf;
            fIn = new FileInputStream(src);
            fOut = new FileOutputStream(dst);
            fIChan = fIn.getChannel();
            fOChan = fOut.getChannel();
            fSize = fIChan.size();
            mBuf = fIChan.map(FileChannel.MapMode.READ_ONLY, 0, fSize);
            fOChan.write(mBuf);
            fIChan.close();
            fIn.close();
            fOChan.close();
            fOut.close();
        }
    }
} </s>
<s>class temp {    public void Load(String fname) throws Exception {
        File f = null;
        try {
            if ("".equals(fname) || fname == null) throw new Exception();
            System.out.println("Loading mapfile " + fname);
        } catch (Exception e) {
            throw new Exception("File not found");
        }
        aType = null;
        fieldtype.clear();
        creatures.clear();
        aElement = new String("");
        content = null;
        Ax = -1;
        Ay = -1;
        aTemplate = -1;
        SAXParserFactory factory = SAXParserFactory.newInstance();
        data_read = 0;
        URL url = this.game.mainClass.getClassLoader().getResource(fname);
        if (url == null) {
            throw new Exception("Can't load map from : " + fname);
        }
        try {
            SAXParser parser = factory.newSAXParser();
            parser.parse(url.openStream(), this);
        } catch (Exception e) {
            System.out.println("Can't open XML : " + e);
        }
        for (int i = 0; i < fieldtype.size(); i++) {
            System.out.println((MapField) fieldtype.get(i));
        }
        game.player.setpos(start_x, start_y);
        System.out.println("Player starting position set");
        start_x = -1;
        start_y = -1;
        System.out.println("Map \"" + fname + "\" loaded");
    }
} </s>
<s>class temp {    public static boolean copyFileChannel(final File _fileFrom, final File _fileTo, final boolean _append) {
        FileChannel srcChannel = null;
        FileChannel dstChannel = null;
        try {
            srcChannel = new FileInputStream(_fileFrom).getChannel();
            dstChannel = new FileOutputStream(_fileTo, _append).getChannel();
            if (_append) {
                dstChannel.transferFrom(srcChannel, dstChannel.size(), srcChannel.size());
            } else {
                dstChannel.transferFrom(srcChannel, 0, srcChannel.size());
            }
            srcChannel.close();
            dstChannel.close();
        } catch (final IOException e) {
            return false;
        } finally {
            try {
                if (srcChannel != null) {
                    srcChannel.close();
                }
            } catch (final IOException _evt) {
                FuLog.error(_evt);
            }
            try {
                if (dstChannel != null) {
                    dstChannel.close();
                }
            } catch (final IOException _evt) {
                FuLog.error(_evt);
            }
        }
        return true;
    }
} </s>
<s>class temp {    public int print(String type, String url, String attrs) throws PrinterException {
        try {
            return print(type, (new URL(url)).openStream(), attrs);
        } catch (Exception e) {
            e.printStackTrace();
            throw new PrinterException(e);
        }
    }
} </s>
<s>class temp {    public void execute() throws InstallerException {
        try {
            SQLCommand sqlCommand = new SQLCommand(connectionInfo);
            connection = sqlCommand.getConnection();
            connection.setAutoCommit(false);
            sqlStatement = connection.createStatement();
            double size = (double) statements.size();
            for (String statement : statements) {
                sqlStatement.executeUpdate(statement);
                setCompletedPercentage(getCompletedPercentage() + (1 / size));
            }
            connection.commit();
        } catch (SQLException e) {
            try {
                connection.rollback();
            } catch (SQLException e1) {
                throw new InstallerException(InstallerException.TRANSACTION_ROLLBACK_ERROR, new Object[] { e.getMessage() }, e);
            }
            throw new InstallerException(InstallerException.SQL_EXEC_EXCEPTION, new Object[] { e.getMessage() }, e);
        } catch (ClassNotFoundException e) {
            throw new InstallerException(InstallerException.DB_DRIVER_LOAD_ERROR, e);
        } finally {
            if (connection != null) {
                try {
                    sqlStatement.close();
                    connection.close();
                } catch (SQLException e) {
                }
            }
        }
    }
} </s>
<s>class temp {    @Override
    protected ResourceHandler doGet(final URI resourceUri) throws ResourceNotFoundException, ResourceException {
        if (resourceUri.getHost() == null) {
            throw new IllegalStateException(InternalBundleHelper.StoreMessageBundle.getMessage("store.uri.http.illegal", resourceUri.toString()));
        }
        try {
            final URL configUrl = resourceUri.toURL();
            final URLConnection urlConnection;
            Proxy httpProxy = null;
            if (!StringHelper.isEmpty(context.getString(FileStoreContextBuilder.ProxySet))) {
                if (context.getBoolean(FileStoreContextBuilder.ProxySet)) {
                    final String proxyHost = context.getString(FileStoreContextBuilder.ProxyHost);
                    final String proxyPort = context.getString(FileStoreContextBuilder.ProxyPort);
                    if (!StringHelper.isEmpty(proxyHost)) {
                        httpProxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyHost, !StringHelper.isEmpty(proxyPort) ? Integer.parseInt(proxyPort) : 80));
                        if (!StringHelper.isEmpty(context.getString(FileStoreContextBuilder.NonProxyHosts))) {
                            System.getProperties().put("http.nonProxyHosts", context.getProperty(FileStoreContextBuilder.NonProxyHosts));
                        }
                        if (!StringHelper.isEmpty(context.getString(FileStoreContextBuilder.ProxyUser)) && !StringHelper.isEmpty(context.getString(FileStoreContextBuilder.ProxyPassword))) {
                            Authenticator.setDefault(new Authenticator() {

                                @Override
                                protected PasswordAuthentication getPasswordAuthentication() {
                                    return new PasswordAuthentication(context.getString(FileStoreContextBuilder.ProxyUser), context.getString(FileStoreContextBuilder.ProxyPassword).toCharArray());
                                }
                            });
                        }
                    }
                }
            }
            if (httpProxy == null) {
                urlConnection = configUrl.openConnection();
            } else {
                urlConnection = configUrl.openConnection(httpProxy);
            }
            setUrlConnectionSettings(urlConnection);
            urlConnection.connect();
            try {
                return createResourceHandler(resourceUri.toString(), urlConnection.getInputStream());
            } catch (final FileNotFoundException fnfe) {
                throw new ResourceNotFoundException(resourceUri.toString());
            }
        } catch (final MalformedURLException mure) {
            throw new IllegalStateException(InternalBundleHelper.StoreMessageBundle.getMessage("store.uri.malformed", resourceUri.toString()));
        } catch (final ConnectException ce) {
            throw new ResourceException("store.connection.error", ce, resourceUri.toString());
        } catch (final IOException ioe) {
            if (ioe instanceof ResourceException) {
                throw (ResourceException) ioe;
            } else {
                throw new ResourceException(ioe, resourceUri.toString());
            }
        }
    }
} </s>
<s>class temp {    private String SHA1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        MessageDigest md;
        md = MessageDigest.getInstance("SHA-1");
        byte[] sha1hash = new byte[40];
        md.update(text.getBytes("iso-8859-1"), 0, text.length());
        sha1hash = md.digest();
        return convertToHex(sha1hash);
    }
} </s>
<s>class temp {    public boolean refreshRequired() {
        boolean status = false;
        Set<String> urls = lastModifiedDates.keySet();
        try {
            for (String urlPath : urls) {
                Long lastModifiedDate = lastModifiedDates.get(urlPath);
                URL url = new URL(urlPath);
                URLConnection connection = url.openConnection();
                connection.connect();
                long newModDate = connection.getLastModified();
                if (newModDate != lastModifiedDate) {
                    status = true;
                    break;
                }
            }
        } catch (Exception e) {
            LOG.warn("Exception while monitoring update times.", e);
            return true;
        }
        return status;
    }
} </s>
<s>class temp {    public Configuration(URL url) {
        InputStream in = null;
        try {
            load(in = url.openStream());
        } catch (Exception e) {
            throw new RuntimeException("Could not load configuration from " + url, e);
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException ignore) {
                }
            }
        }
    }
} </s>
<s>class temp {    private static void main(String[] args) {
        try {
            File f = new File("test.txt");
            if (f.exists()) {
                throw new IOException(f + " already exists.  I don't want to overwrite it.");
            }
            StraightStreamReader in;
            char[] cbuf = new char[0x1000];
            int read;
            int totRead;
            FileOutputStream out = new FileOutputStream(f);
            for (int i = 0x00; i < 0x100; i++) {
                out.write(i);
            }
            out.close();
            in = new StraightStreamReader(new FileInputStream(f));
            for (int i = 0x00; i < 0x100; i++) {
                read = in.read();
                if (read != i) {
                    System.err.println("Error: " + i + " read as " + read);
                }
            }
            in.close();
            in = new StraightStreamReader(new FileInputStream(f));
            totRead = in.read(cbuf);
            if (totRead != 0x100) {
                System.err.println("Simple buffered read did not read the full amount: 0x" + Integer.toHexString(totRead));
            }
            for (int i = 0x00; i < totRead; i++) {
                if (cbuf[i] != i) {
                    System.err.println("Error: 0x" + i + " read as 0x" + cbuf[i]);
                }
            }
            in.close();
            in = new StraightStreamReader(new FileInputStream(f));
            totRead = 0;
            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {
                totRead += read;
            }
            if (totRead != 0x100) {
                System.err.println("Not enough read. Bytes read: " + Integer.toHexString(totRead));
            }
            for (int i = 0x00; i < totRead; i++) {
                if (cbuf[i] != i) {
                    System.err.println("Error: 0x" + i + " read as 0x" + cbuf[i]);
                }
            }
            in.close();
            in = new StraightStreamReader(new FileInputStream(f));
            totRead = 0;
            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {
                totRead += read;
            }
            if (totRead != 0x100) {
                System.err.println("Not enough read. Bytes read: " + Integer.toHexString(totRead));
            }
            for (int i = 0x00; i < totRead; i++) {
                if (cbuf[i + 0x123] != i) {
                    System.err.println("Error: 0x" + i + " read as 0x" + cbuf[i + 0x123]);
                }
            }
            in.close();
            in = new StraightStreamReader(new FileInputStream(f));
            totRead = 0;
            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {
                totRead += read;
            }
            if (totRead != 0x100) {
                System.err.println("Not enough read. Bytes read: " + Integer.toHexString(totRead));
            }
            for (int i = 0x00; i < totRead; i++) {
                if (cbuf[i + 0x123] != i) {
                    System.err.println("Error: 0x" + i + " read as 0x" + cbuf[i + 0x123]);
                }
            }
            in.close();
            f.delete();
        } catch (IOException x) {
            System.err.println(x.getMessage());
        }
    }
} </s>
<s>class temp {    public static boolean copy(File from, File to, Override override) throws IOException {
        FileInputStream in = null;
        FileOutputStream out = null;
        FileChannel srcChannel = null;
        FileChannel destChannel = null;
        if (override == null) override = Override.NEWER;
        switch(override) {
            case NEVER:
                if (to.isFile()) return false;
                break;
            case NEWER:
                if (to.isFile() && (from.lastModified() - LASTMODIFIED_DIFF_MILLIS) < to.lastModified()) return false;
                break;
        }
        to.getParentFile().mkdirs();
        try {
            in = new FileInputStream(from);
            out = new FileOutputStream(to);
            srcChannel = in.getChannel();
            destChannel = out.getChannel();
            long position = 0L;
            long count = srcChannel.size();
            while (position < count) {
                long chunk = Math.min(MAX_IO_CHUNK_SIZE, count - position);
                position += destChannel.transferFrom(srcChannel, position, chunk);
            }
            to.setLastModified(from.lastModified());
            return true;
        } finally {
            CommonUtils.close(srcChannel);
            CommonUtils.close(destChannel);
            CommonUtils.close(out);
            CommonUtils.close(in);
        }
    }
} </s>
<s>class temp {    public static void copyFile(File src, File dest) throws IOException {
        FileInputStream fis = new FileInputStream(src);
        FileOutputStream fos = new FileOutputStream(dest);
        FileChannel channelSrc = fis.getChannel();
        FileChannel channelDest = fos.getChannel();
        channelSrc.transferTo(0, channelSrc.size(), channelDest);
        fis.close();
        fos.close();
    }
} </s>
<s>class temp {    public static void fillTemplate(String sourceFileName, String targetFileName, Map<String, String> values) throws IOException {
        File targetDirectory = new File(targetFileName.substring(0, targetFileName.lastIndexOf(File.separator)));
        targetDirectory.mkdirs();
        File file = new File(sourceFileName);
        FileInputStream fis = new FileInputStream(file);
        FileChannel fc = fis.getChannel();
        int sz = (int) fc.size();
        MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);
        Charset charset = Charset.forName("ISO-8859-15");
        CharsetDecoder decoder = charset.newDecoder();
        CharBuffer cb = decoder.decode(bb);
        String inString = cb.toString();
        fis.close();
        fc.close();
        Set<String> keys = values.keySet();
        for (Object k : keys) {
            inString = inString.replace((String) k, escape(values.get(k)));
        }
        FileOutputStream fos = new FileOutputStream(targetFileName);
        PrintStream ps = new PrintStream(fos);
        ps.print(inString);
        fos.close();
    }
} </s>
<s>class temp {    public static void main(String[] args) throws Exception {
        TripleDES tdes = new TripleDES();
        StreamBlockReader reader = new StreamBlockReader(new FileInputStream("D:\\testTDESENC.txt"));
        StreamBlockWriter writer = new StreamBlockWriter(new FileOutputStream("D:\\testTDESDEC.txt"));
        SingleKey key = new SingleKey(new Block(128), "");
        key = new SingleKey(new Block("01011101110000101001100111001011101000001110111101001001101101101101100000011101100100110000101100001110000001111101001101001101"), "");
        Mode mode = new ECBTripleDESMode(tdes);
        tdes.decrypt(reader, writer, key, mode);
    }
} </s>
<s>class temp {    private void createNodes() {
        try {
            URL url = this.getClass().getResource("NodesFile.txt");
            InputStreamReader inReader = new InputStreamReader(url.openStream());
            BufferedReader inNodes = new BufferedReader(inReader);
            String s;
            while ((s = inNodes.readLine()) != null) {
                String label = inNodes.readLine();
                String fullText = inNodes.readLine();
                String type = inNodes.readLine();
                Node n = new Node(s, type);
                n.label = label;
                n.fullText = fullText;
                node.add(n);
            }
            inNodes.close();
            url = this.getClass().getResource("EdgesFile.txt");
            inReader = new InputStreamReader(url.openStream());
            BufferedReader inEdges = new BufferedReader(inReader);
            while ((s = inEdges.readLine()) != null) edge.add(new Edge(s, inEdges.readLine(), inEdges.readLine(), inEdges.readLine()));
            inEdges.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
} </s>
<s>class temp {    private static String executeGet(String urlStr) {
        StringBuffer result = new StringBuffer();
        try {
            Authentication.doIt();
            URL url = new URL(urlStr);
            System.out.println("Host: " + url.getHost());
            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));
            HttpURLConnection connection = (HttpURLConnection) url.openConnection();
            connection.setDoInput(true);
            String inputLine;
            while ((inputLine = in.readLine()) != null) {
                result.append(inputLine);
            }
            in.close();
            connection.disconnect();
        } catch (MalformedURLException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return result.toString();
    }
} </s>
<s>class temp {    public static String getMD5(final String text) {
        if (null == text) return null;
        final MessageDigest algorithm;
        try {
            algorithm = MessageDigest.getInstance("MD5");
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        }
        algorithm.reset();
        algorithm.update(text.getBytes());
        final byte[] digest = algorithm.digest();
        final StringBuffer hexString = new StringBuffer();
        for (byte b : digest) {
            String str = Integer.toHexString(0xFF & b);
            str = str.length() == 1 ? '0' + str : str;
            hexString.append(str);
        }
        return hexString.toString();
    }
} </s>
<s>class temp {    public static void copyFile(File src, File dest, boolean preserveFileDate) throws IOException {
        if (src.exists() && src.isDirectory()) {
            throw new IOException("source file exists but is a directory");
        }
        if (dest.exists() && dest.isDirectory()) {
            dest = new File(dest, src.getName());
        }
        if (!dest.exists()) {
            dest.createNewFile();
        }
        FileChannel srcCH = null;
        FileChannel destCH = null;
        try {
            srcCH = new FileInputStream(src).getChannel();
            destCH = new FileOutputStream(dest).getChannel();
            destCH.transferFrom(srcCH, 0, srcCH.size());
        } finally {
            closeQuietly(srcCH);
            closeQuietly(destCH);
        }
        if (src.length() != dest.length()) {
            throw new IOException("Failed to copy full contents from '" + src + "' to '" + dest + "'");
        }
        if (preserveFileDate) {
            dest.setLastModified(src.lastModified());
        }
    }
} </s>
<s>class temp {    public void login() throws Exception {
        String s_url = bean.getProtocol() + "://" + bean.getUrl() + ":" + bean.getPort() + "/login/login.cgi?" + "userType=1&" + "name=" + bean.getLogin() + "&" + "passwd=" + bean.getPassword() + "&" + "btn_submit=enter&" + "login_action=login&" + "path=&" + "restart=no&" + "systemfull=no";
        URL url = new URL(s_url);
        HttpURLConnection http = (HttpURLConnection) url.openConnection();
        HttpsURLConnectionImpl ssl = (HttpsURLConnectionImpl) http;
        ssl.setSSLSocketFactory(factory);
        ssl.setHostnameVerifier(new HostnameVerifier() {

            public boolean verify(String hostname, SSLSession session) {
                return true;
            }
        });
        http.setDoOutput(true);
        http.setDoInput(true);
        http.setAllowUserInteraction(true);
        int responseCode = http.getResponseCode();
        BufferedReader br = new BufferedReader(new InputStreamReader(http.getInputStream()));
        String tmp = br.readLine();
        StringWriter writer = new StringWriter();
        while (tmp != null) {
            writer.write(tmp + "\n");
            tmp = br.readLine();
        }
        writer.flush();
        writer.close();
        String s = writer.toString();
        String pattern = "<input type=\"hidden\" name=\"id\" value=\"";
        int i = s.indexOf(pattern);
        sessionId = s.substring(i + pattern.length(), s.indexOf("\"", i + pattern.length() + 1));
    }
} </s>
<s>class temp {    public void put(File fileToPut) throws IOException {
        FTPClient ftp = new FTPClient();
        try {
            int reply;
            ftp.connect(this.endpointURL, Config.getFtpPort());
            log.debug("Ftp put reply: " + ftp.getReplyString());
            reply = ftp.getReplyCode();
            if (!FTPReply.isPositiveCompletion(reply)) {
                ftp.disconnect();
                throw new IOException("Ftp put server refused connection.");
            }
            if (!ftp.login("anonymous", "")) {
                ftp.logout();
                throw new IOException("FTP: server wrong passwd");
            }
            ftp.setFileType(FTP.BINARY_FILE_TYPE);
            ftp.enterLocalPassiveMode();
            InputStream input = new FileInputStream(fileToPut);
            if (ftp.storeFile(fileToPut.getName(), input) != true) {
                ftp.logout();
                input.close();
                throw new IOException("FTP put exception");
            }
            input.close();
            ftp.logout();
        } catch (Exception e) {
            log.error("Ftp client exception: " + e.getMessage(), e);
            throw new IOException(e.getMessage());
        }
    }
} </s>
<s>class temp {    public void get(File fileToGet) throws IOException {
        FTPClient ftp = new FTPClient();
        try {
            int reply = 0;
            ftp.connect(this.endpointURL, Config.getFtpPort());
            reply = ftp.getReplyCode();
            if (!FTPReply.isPositiveCompletion(reply)) {
                ftp.disconnect();
                throw new IOException("Ftp get server refused connection.");
            }
            if (!ftp.login("anonymous", "")) {
                ftp.logout();
                throw new IOException("FTP: server wrong passwd");
            }
            ftp.setFileType(FTP.BINARY_FILE_TYPE);
            ftp.enterLocalPassiveMode();
            OutputStream output = new FileOutputStream(fileToGet.getName());
            if (ftp.retrieveFile(fileToGet.getName(), output) != true) {
                ftp.logout();
                output.close();
                throw new IOException("FTP get exception, maybe file not found");
            }
            ftp.logout();
        } catch (Exception e) {
            throw new IOException(e.getMessage());
        }
    }
} </s>
<s>class temp {    public void delete(String fileToDelete) throws IOException {
        FTPClient ftp = new FTPClient();
        try {
            int reply = 0;
            ftp.connect(this.endpointURL, Config.getFtpPort());
            reply = ftp.getReplyCode();
            if (!FTPReply.isPositiveCompletion(reply)) {
                ftp.disconnect();
                throw new IOException("Ftp delete server refused connection.");
            }
            if (!ftp.login("anonymous", "")) {
                ftp.logout();
                throw new IOException("FTP: server wrong passwd");
            }
            ftp.enterLocalPassiveMode();
            log.debug("Deleted: " + ftp.deleteFile(fileToDelete));
            ftp.logout();
        } catch (Exception e) {
            throw new IOException(e.getMessage());
        }
    }
} </s>
<s>class temp {    public boolean exists(String fileToCheck) throws IOException {
        FTPClient ftp = new FTPClient();
        boolean found = false;
        try {
            int reply = 0;
            ftp.connect(this.endpointURL, Config.getFtpPort());
            reply = ftp.getReplyCode();
            if (!FTPReply.isPositiveCompletion(reply)) {
                ftp.disconnect();
                throw new IOException("Ftp exists server refused connection.");
            }
            if (!ftp.login("anonymous", "")) {
                ftp.logout();
                throw new IOException("FTP: server wrong passwd");
            }
            ftp.enterLocalPassiveMode();
            if (ftp.listNames(fileToCheck) != null) {
                found = true;
            }
            ftp.logout();
        } catch (Exception e) {
            throw new IOException(e.getMessage());
        }
        return found;
    }
} </s>

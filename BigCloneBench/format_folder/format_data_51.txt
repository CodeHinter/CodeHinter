<s>class temp {    @SuppressWarnings("unchecked")
    public InputStream openStream(URL url) throws IOException {
        List<String> lines = IOUtils.readLines(url.openStream());
        for (String line : lines) {
            Matcher m = PATTERN.matcher(line);
            if (m.matches()) {
                String origUrl = m.group(1);
                log.info("Loading content from: " + origUrl);
                return new HttpUtil<InputStream>() {

                    @Override
                    public InputStream handleResponse(InputStream response) throws IOException {
                        return new ByteArrayInputStream(IOUtils.toByteArray(response));
                    }
                }.get(new URL(origUrl));
            }
        }
        log.error("No origUrl found for url: " + url);
        return null;
    }
} </s>
<s>class temp {    private void _loadInternalViews() {
        _internalViews = new HashMap<String, InternalView>();
        List<URL> list = new ArrayList<URL>();
        ClassLoader loader = _getClassLoader();
        try {
            Enumeration<URL> en = loader.getResources("META-INF/org.apache.myfaces.trinidad.render.InternalView.properties");
            while (en.hasMoreElements()) {
                list.add(en.nextElement());
            }
            en = loader.getResources("META-INF/org.apache.myfaces.trinidad.InternalView.properties");
            while (en.hasMoreElements()) {
                list.add(en.nextElement());
            }
            Collections.reverse(list);
        } catch (IOException ioe) {
            _LOG.severe(ioe);
        }
        for (URL url : list) {
            try {
                Properties properties = new Properties();
                _LOG.fine("Loading internal views from {0}", url);
                InputStream is = url.openStream();
                try {
                    properties.load(is);
                } finally {
                    is.close();
                }
                for (Map.Entry<Object, Object> entry : properties.entrySet()) {
                    String name = (String) entry.getKey();
                    String className = (String) entry.getValue();
                    Class<?> clazz = loader.loadClass(className);
                    InternalView view = (InternalView) clazz.newInstance();
                    _internalViews.put(name, view);
                }
            } catch (IllegalAccessException iae) {
                _LOG.severe("CANNOT_LOAD_URL", url);
                _LOG.severe(iae);
            } catch (InstantiationException ie) {
                _LOG.severe("CANNOT_LOAD_URL", url);
                _LOG.severe(ie);
            } catch (ClassNotFoundException cnfe) {
                _LOG.severe("CANNOT_LOAD_URL", url);
                _LOG.severe(cnfe);
            } catch (IOException ioe) {
                _LOG.severe("CANNOT_LOAD_URL", url);
                _LOG.severe(ioe);
            }
        }
    }
} </s>
<s>class temp {    public String getDigest(String s) throws Exception {
        MessageDigest md = MessageDigest.getInstance(hashName);
        md.update(s.getBytes());
        byte[] dig = md.digest();
        return Base16.toHexString(dig);
    }
} </s>
<s>class temp {    public static void forEachLine(final URL url, final LineListener lit, final String encoding) {
        try {
            ReaderUtils.forEachLine(url.openStream(), lit);
        } catch (final IOException ioe) {
            lit.exception(ioe);
        }
    }
} </s>
<s>class temp {    private static void doCopyFile(File srcFile, File destFile, boolean preserveFileDate) throws IOException {
        if (destFile.exists() && destFile.isDirectory()) {
            throw new IOException("Destination '" + destFile + "' exists but is a directory");
        }
        FileInputStream input = new FileInputStream(srcFile);
        try {
            FileOutputStream output = new FileOutputStream(destFile);
            try {
                IOUtils.copy(input, output);
            } finally {
                IOUtils.closeQuietly(output);
            }
        } finally {
            IOUtils.closeQuietly(input);
        }
        if (srcFile.length() != destFile.length()) {
            throw new IOException("Failed to copy full contents from '" + srcFile + "' to '" + destFile + "'");
        }
        if (preserveFileDate) {
            destFile.setLastModified(srcFile.lastModified());
        }
    }
} </s>
<s>class temp {    public static void copyURLToFile(URL source, File destination) throws IOException {
        InputStream input = source.openStream();
        try {
            FileOutputStream output = openOutputStream(destination);
            try {
                IOUtils.copy(input, output);
            } finally {
                IOUtils.closeQuietly(output);
            }
        } finally {
            IOUtils.closeQuietly(input);
        }
    }
} </s>
<s>class temp {    public static Checksum checksum(File file, Checksum checksum) throws IOException {
        if (file.isDirectory()) {
            throw new IllegalArgumentException("Checksums can't be computed on directories");
        }
        InputStream in = null;
        try {
            in = new CheckedInputStream(new FileInputStream(file), checksum);
            IOUtils.copy(in, new NullOutputStream());
        } finally {
            IOUtils.closeQuietly(in);
        }
        return checksum;
    }
} </s>
<s>class temp {    private static void downloadImage(URL url, String localFileName) {
        FileOutputStream fos = null;
        URL fileUrl = null;
        Bundle bundle = Activator.getDefault().getBundle();
        Path path = new Path("album covers/empty_disk.jpg");
        URL localUrl = FileLocator.find(bundle, path, Collections.EMPTY_MAP);
        try {
            fileUrl = FileLocator.toFileURL(localUrl);
        } catch (IOException e) {
            e.printStackTrace();
        }
        try {
            InputStream is = url.openStream();
            String actualPath = fileUrl.getPath();
            actualPath = actualPath.substring(1);
            actualPath = actualPath.substring(0, actualPath.lastIndexOf("/"));
            fos = new FileOutputStream(actualPath + "/" + localFileName);
            int oneChar, count = 0;
            while ((oneChar = is.read()) != -1) {
                fos.write(oneChar);
                count++;
            }
            is.close();
            fos.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
} </s>
<s>class temp {    public static String getURLContent(String urlToSearchString) throws IOException {
        URL url = new URL(urlToSearchString);
        URLConnection conn = url.openConnection();
        String encoding = conn.getContentEncoding();
        if (encoding == null) encoding = "ISO-8859-1";
        BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream(), encoding));
        StringBuilder sb = new StringBuilder(16384);
        try {
            String line;
            while ((line = br.readLine()) != null) {
                sb.append(line);
                sb.append('\n');
            }
        } finally {
            br.close();
        }
        return sb.toString();
    }
} </s>
<s>class temp {    public static List<ReactomeBean> getUrlData(URL url) throws IOException {
        List<ReactomeBean> beans = new ArrayList<ReactomeBean>(256);
        log.debug("Retreiving content for: " + url);
        StringBuffer content = new StringBuffer(4096);
        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));
        String str;
        while ((str = in.readLine()) != null) {
            if (str.startsWith("#")) {
                continue;
            }
            StringTokenizer stringTokenizer = new StringTokenizer(str, "\t");
            String InteractionAc = stringTokenizer.nextToken();
            String reactomeId = stringTokenizer.nextToken();
            ReactomeBean reactomeBean = new ReactomeBean();
            reactomeBean.setReactomeID(reactomeId);
            reactomeBean.setInteractionAC(InteractionAc);
            beans.add(reactomeBean);
        }
        in.close();
        return beans;
    }
} </s>
<s>class temp {    private void copyFile(String sourceFilename, String targetFilename) throws IOException {
        File source = new File(sourceFilename);
        File target = new File(targetFilename);
        InputStream in = new FileInputStream(source);
        OutputStream out = new FileOutputStream(target);
        byte[] buf = new byte[1024];
        int len;
        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);
        in.close();
        out.close();
    }
} </s>
<s>class temp {    public void doQuery(String keyword, final int page) {
        this.keyword = keyword;
        keyword = keyword.replace(' ', '+');
        commentText = new JTextArea(10, 80);
        final Vector commentVector = new Vector();
        int matchingDocCount = 0;
        int hitCount = 0;
        getContentPane().removeAll();
        Vector linkVector = new Vector();
        try {
            String featureid = keyword;
            URL connectURL = new URL("http://www.ensembl.org/Homo_sapiens/textview?idx=External&q=" + keyword + "&page=" + page);
            InputStream urlStream = connectURL.openStream();
            BufferedReader reader = new BufferedReader(new InputStreamReader(urlStream));
            String line, link, content, label, head = null;
            Box tabBox = null;
            String linkstr;
            String comment = "";
            int EnsExtCount;
            int EnsGeneCount;
            while ((line = reader.readLine()) != null) {
                if (line.indexOf("documents match your query") != -1) {
                    matchingDocCount = Integer.parseInt(line.substring(line.indexOf("<B>") + 3, line.indexOf("</B>")));
                    continue;
                }
                if (line.indexOf("matches in the Ensembl External index") != -1) {
                }
                if (line.indexOf("matches in the Ensembl Gene index:") != -1) {
                }
                if (line.indexOf("Homo_sapiens/geneview?gene") != -1) {
                    if (line.indexOf("www.ensembl.org") != -1) {
                        line = line.substring(line.indexOf("www.ensembl.org"));
                        line = line.substring(line.indexOf("</A>") + 4);
                    }
                    int linkStart = line.indexOf("Homo_sapiens/geneview?gene");
                    if (linkStart == -1) break;
                    linkstr = "http://www.ensembl.org/" + line.substring(linkStart, line.indexOf("\">"));
                    line = line.substring(line.indexOf("</A>") + 4);
                    StringBuffer chars = new StringBuffer(line.length());
                    boolean inTag = false;
                    boolean inEntity = false;
                    boolean firstBRTossed = false;
                    line = line.substring(line.indexOf("<"));
                    for (int ch = 0; ch < line.length(); ch++) {
                        if (line.charAt(ch) == '<') {
                            inTag = true;
                            if ((line.charAt(ch + 1) == 'b' || line.charAt(ch + 1) == 'B') && (line.charAt(ch + 2) == 'r' || line.charAt(ch + 2) == 'R')) {
                                if (firstBRTossed) {
                                    chars.append("\n");
                                } else {
                                    firstBRTossed = true;
                                }
                            }
                        }
                        if (line.charAt(ch) == '&') inEntity = true;
                        if (!inTag && !inEntity) chars.append(line.charAt(ch));
                        if (line.charAt(ch) == ';') inEntity = false;
                        if (line.charAt(ch) == '>') inTag = false;
                    }
                    comment = chars.toString();
                    commentVector.add(comment);
                    linkVector.add(linkstr);
                    hitCount++;
                }
            }
            if (hitCount == 0) commentText.setText("No Matches Found for " + keyword);
            commentText.setLineWrap(true);
            commentText.setWrapStyleWord(true);
        } catch (Exception e) {
            e.printStackTrace();
            JOptionPane.showMessageDialog(this, "No Matches Found for " + keyword);
            return;
        }
        final JList lst = new JList(linkVector);
        lst.addListSelectionListener(new ListSelectionListener() {

            public void valueChanged(ListSelectionEvent e) {
                int ind = lst.getSelectedIndex();
                commentText.setText((String) commentVector.elementAt(ind));
                commentText.select(0, 0);
            }
        });
        MouseListener mouseListener = new MouseAdapter() {

            public void mouseClicked(MouseEvent e) {
                if (e.getClickCount() == 2) {
                    int index = lst.locationToIndex(e.getPoint());
                    extractEnsemblCoords((String) lst.getModel().getElementAt(index));
                }
            }
        };
        lst.addMouseListener(mouseListener);
        lst.setSelectedIndex(0);
        scrollPane = new JScrollPane(commentText);
        JPanel pagePanel = new JPanel();
        final JButton prevBttn = new JButton("<=");
        final JButton nextBttn = new JButton("=>");
        prevBttn.setEnabled(page > 1);
        nextBttn.setEnabled(page + hitCount < matchingDocCount);
        ActionListener pageHandler = new ActionListener() {

            public void actionPerformed(ActionEvent ae) {
                if (ae.getSource() == prevBttn) {
                    doQuery(EnsemblLookup.this.keyword, page - 20);
                } else {
                    doQuery(EnsemblLookup.this.keyword, page + 20);
                }
            }
        };
        pagePanel.add(prevBttn);
        prevBttn.addActionListener(pageHandler);
        pagePanel.add(nextBttn);
        nextBttn.addActionListener(pageHandler);
        JPanel hitsAndTextPanel = new JPanel();
        hitsAndTextPanel.setLayout(new GridLayout(2, 1));
        hitsAndTextPanel.add(new JScrollPane(lst));
        hitsAndTextPanel.add(scrollPane);
        getContentPane().setLayout(new BorderLayout());
        getContentPane().add(hitsAndTextPanel, BorderLayout.CENTER);
        getContentPane().add(pagePanel, BorderLayout.SOUTH);
        setTitle("Results for " + keyword + "  Displaying " + (page + 1) + ((hitCount > 1) ? (" - " + (page + hitCount)) : "") + " of " + matchingDocCount);
        show();
    }
} </s>
<s>class temp {    void extractEnsemblCoords(String geneviewLink) {
        try {
            URL connectURL = new URL(geneviewLink);
            InputStream urlStream = connectURL.openStream();
            BufferedReader reader = new BufferedReader(new InputStreamReader(urlStream));
            String line;
            while ((line = reader.readLine()) != null) {
                if (line.indexOf("View gene in genomic location") != -1) {
                    line = line.substring(line.indexOf("contigview?"));
                    String chr, start, stop;
                    chr = line.substring(line.indexOf("chr=") + 4);
                    chr = chr.substring(0, chr.indexOf("&"));
                    start = line.substring(line.indexOf("vc_start=") + 9);
                    start = start.substring(0, start.indexOf("&"));
                    stop = line.substring(line.indexOf("vc_end=") + 7);
                    stop = stop.substring(0, stop.indexOf("\""));
                    String selString;
                    for (int s = 0; s < selPanel.chrField.getModel().getSize(); s++) {
                        if (chr.equals(selPanel.chrField.getModel().getElementAt(s))) {
                            selPanel.chrField.setSelectedIndex(s);
                            break;
                        }
                    }
                    selPanel.setStart(Integer.parseInt(start));
                    selPanel.setStop(Integer.parseInt(stop));
                    selPanel.refreshButton.doClick();
                    break;
                }
            }
        } catch (Exception e) {
            System.out.println("Problems retrieving Geneview from Ensembl");
            e.printStackTrace();
        }
    }
} </s>
<s>class temp {    private String read(URL url) throws IOException {
        BufferedReader in = null;
        try {
            in = new BufferedReader(new InputStreamReader(url.openStream()));
            StringBuffer text = new StringBuffer();
            String line;
            while ((line = in.readLine()) != null) {
                text.append(line);
            }
            return text.toString();
        } finally {
            in.close();
        }
    }
} </s>
<s>class temp {    public static void main(String[] args) throws IOException {
        if (args.length == 0) {
            System.out.println("Usage: \nGZIPcompress file\n" + "\tUses GZIP compression to compress " + "the file to test.gz");
            System.exit(1);
        }
        BufferedReader in = new BufferedReader(new FileReader(args[0]));
        BufferedOutputStream out = new BufferedOutputStream(new GZIPOutputStream(new FileOutputStream("test.gz")));
        System.out.println("Writing file");
        int c;
        while ((c = in.read()) != -1) out.write(c);
        in.close();
        out.close();
        System.out.println("Reading file");
        BufferedReader in2 = new BufferedReader(new InputStreamReader(new GZIPInputStream(new FileInputStream("test.gz"))));
        String s;
        while ((s = in2.readLine()) != null) System.out.println(s);
    }
} </s>
<s>class temp {    public InputSource resolveEntity(String publicId, String systemId) {
        String resolved = null;
        if (systemId != null) {
            try {
                resolved = catalog.resolveSystem(systemId);
            } catch (MalformedURLException me) {
                debug(1, "Malformed URL exception trying to resolve", publicId);
                resolved = null;
            } catch (IOException ie) {
                debug(1, "I/O exception trying to resolve", publicId);
                resolved = null;
            }
        }
        if (resolved == null) {
            if (publicId != null) {
                try {
                    resolved = catalog.resolvePublic(publicId, systemId);
                } catch (MalformedURLException me) {
                    debug(1, "Malformed URL exception trying to resolve", publicId);
                } catch (IOException ie) {
                    debug(1, "I/O exception trying to resolve", publicId);
                }
            }
            if (resolved != null) {
                debug(2, "Resolved", publicId, resolved);
            }
        } else {
            debug(2, "Resolved", systemId, resolved);
        }
        if (resolved == null && retryBadSystemIds && publicId != null && systemId != null) {
            URL systemURL = null;
            try {
                systemURL = new URL(systemId);
            } catch (MalformedURLException e) {
                try {
                    systemURL = new URL("file:///" + systemId);
                } catch (MalformedURLException e2) {
                    systemURL = null;
                }
            }
            if (systemURL != null) {
                try {
                    InputStream iStream = systemURL.openStream();
                    InputSource iSource = new InputSource(systemId);
                    iSource.setPublicId(publicId);
                    iSource.setByteStream(iStream);
                    return iSource;
                } catch (Exception e) {
                }
            }
            debug(2, "Failed to open", systemId);
            debug(2, "\tAttempting catalog lookup without system identifier.");
            return resolveEntity(publicId, null);
        }
        if (resolved != null) {
            try {
                InputSource iSource = new InputSource(resolved);
                iSource.setPublicId(publicId);
                URL url = new URL(resolved);
                InputStream iStream = url.openStream();
                iSource.setByteStream(iStream);
                return iSource;
            } catch (Exception e) {
                debug(1, "Failed to create InputSource", resolved);
                return null;
            }
        }
        return null;
    }
} </s>
<s>class temp {    public static FTPClient getClient(String serverAddress, String login, String password, boolean PASV) throws SocketException, IOException {
        FTPClient client = new FTPClient();
        client.connect(serverAddress);
        if (PASV) {
            client.enterLocalPassiveMode();
        }
        client.login(login, password);
        return client;
    }
} </s>
<s>class temp {    protected Object unmarshallXml(final Unmarshaller unmarshaller, final String accessUrl, final String nameSpace, final String replace, final String with) throws Exception {
        final URL url = new URL(accessUrl);
        final BufferedReader inputStream = new BufferedReader(new InputStreamReader(url.openStream()));
        String xmlContent = readWithStringBuffer(inputStream);
        if (replace != null) {
            xmlContent = xmlContent.replace(replace, with);
        }
        LOGGER.info("Calls " + accessUrl);
        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("\nXml:" + accessUrl + "\n" + xmlContent);
        }
        if (LOGGER.isDebugEnabled()) {
            final BufferedWriter out = new BufferedWriter(new FileWriter("target/XmlAgentLog" + xmlRequestNumber++ + ".txt"));
            out.write(xmlContent);
            out.close();
        }
        final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(xmlContent.getBytes());
        Source source;
        if (nameSpace != null) {
            source = setNameSpaceOnXmlStream(byteArrayInputStream, nameSpace);
        } else {
            source = new StreamSource(byteArrayInputStream);
        }
        return unmarshaller.unmarshal(source);
    }
} </s>
<s>class temp {    public QDataSet doRead(URL url, URLConnection connect) throws IOException, ParserConfigurationException, SAXException {
        codebase = url;
        InputStream in;
        if (connect != null) {
            in = connect.getInputStream();
        } else {
            in = url.openStream();
        }
        DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
        InputSource source = new InputSource(in);
        Document document = builder.parse(source);
        in.close();
        QDataSet result = null;
        NodeList kids = document.getChildNodes();
        for (int i = 0; i < kids.getLength(); i++) {
            Node n = kids.item(i);
            if (n.getNodeName().equals("netcdf")) {
                result = netcdf(n);
            }
        }
        return result;
    }
} </s>
<s>class temp {    public boolean loadURL(URL url) {
        try {
            propertyBundle.load(url.openStream());
            LOG.info("Configuration loaded from " + url + "\n");
            return true;
        } catch (Exception e) {
            if (canComplain) {
                LOG.warn("Unable to load configuration " + url + "\n");
            }
            canComplain = false;
            return false;
        }
    }
} </s>
<s>class temp {    public void testSavepoint4() throws Exception {
        Statement stmt = con.createStatement();
        stmt.execute("CREATE TABLE #savepoint4 (data int)");
        stmt.close();
        con.setAutoCommit(false);
        for (int i = 0; i < 3; i++) {
            System.out.println("iteration: " + i);
            PreparedStatement pstmt = con.prepareStatement("INSERT INTO #savepoint4 (data) VALUES (?)");
            pstmt.setInt(1, 1);
            assertTrue(pstmt.executeUpdate() == 1);
            Savepoint savepoint = con.setSavepoint();
            assertNotNull(savepoint);
            assertTrue(savepoint.getSavepointId() == 1);
            try {
                savepoint.getSavepointName();
                assertTrue(false);
            } catch (SQLException e) {
            }
            pstmt.setInt(1, 2);
            assertTrue(pstmt.executeUpdate() == 1);
            pstmt.close();
            pstmt = con.prepareStatement("SELECT SUM(data) FROM #savepoint4");
            ResultSet rs = pstmt.executeQuery();
            assertTrue(rs.next());
            assertTrue(rs.getInt(1) == 3);
            assertTrue(!rs.next());
            pstmt.close();
            rs.close();
            con.rollback(savepoint);
            pstmt = con.prepareStatement("SELECT SUM(data) FROM #savepoint4");
            rs = pstmt.executeQuery();
            assertTrue(rs.next());
            assertTrue(rs.getInt(1) == 1);
            assertTrue(!rs.next());
            pstmt.close();
            rs.close();
            con.rollback();
        }
        con.setAutoCommit(true);
    }
} </s>
<s>class temp {    @Override
    protected PermissionCollection getPermissions(CodeSource _codeSource) {
        PermissionCollection perms = super.getPermissions(_codeSource);
        URL url = _codeSource.getLocation();
        Permission perm = null;
        URLConnection urlConnection = null;
        try {
            urlConnection = url.openConnection();
            urlConnection.connect();
            perm = urlConnection.getPermission();
        } catch (IOException excp) {
            perm = null;
            urlConnection = null;
        }
        if (perm == null) {
            perm = new ModulePermission(url.getHost(), "read");
        }
        if (perm != null) {
            final SecurityManager sm = System.getSecurityManager();
            if (sm != null) {
                final Permission fp = perm;
                AccessController.doPrivileged(new PrivilegedAction<Object>() {

                    public Object run() throws SecurityException {
                        sm.checkPermission(fp);
                        return null;
                    }
                }, this.controlContext);
            }
            perms.add(perm);
        }
        return perms;
    }
} </s>
<s>class temp {    public static boolean encodeFileToFile(String infile, String outfile) {
        boolean success = false;
        java.io.InputStream in = null;
        java.io.OutputStream out = null;
        try {
            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            byte[] buffer = new byte[65536];
            int read = -1;
            while ((read = in.read(buffer)) >= 0) {
                out.write(buffer, 0, read);
            }
            success = true;
        } catch (java.io.IOException exc) {
            exc.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (Exception exc) {
            }
            try {
                out.close();
            } catch (Exception exc) {
            }
        }
        return success;
    }
} </s>
<s>class temp {    public static boolean decodeFileToFile(String infile, String outfile) {
        boolean success = false;
        java.io.InputStream in = null;
        java.io.OutputStream out = null;
        try {
            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            byte[] buffer = new byte[65536];
            int read = -1;
            while ((read = in.read(buffer)) >= 0) {
                out.write(buffer, 0, read);
            }
            success = true;
        } catch (java.io.IOException exc) {
            exc.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (Exception exc) {
            }
            try {
                out.close();
            } catch (Exception exc) {
            }
        }
        return success;
    }
} </s>
<s>class temp {    public void testPreparedStatementRollback1() throws Exception {
        Connection localCon = getConnection();
        Statement stmt = localCon.createStatement();
        stmt.execute("CREATE TABLE #psr1 (data BIT)");
        localCon.setAutoCommit(false);
        PreparedStatement pstmt = localCon.prepareStatement("INSERT INTO #psr1 (data) VALUES (?)");
        pstmt.setBoolean(1, true);
        assertEquals(1, pstmt.executeUpdate());
        pstmt.close();
        localCon.rollback();
        ResultSet rs = stmt.executeQuery("SELECT data FROM #psr1");
        assertFalse(rs.next());
        rs.close();
        stmt.close();
        localCon.close();
        try {
            localCon.commit();
            fail("Expecting commit to fail, connection was closed");
        } catch (SQLException ex) {
            assertEquals("HY010", ex.getSQLState());
        }
        try {
            localCon.rollback();
            fail("Expecting rollback to fail, connection was closed");
        } catch (SQLException ex) {
            assertEquals("HY010", ex.getSQLState());
        }
    }
} </s>
<s>class temp {    public static String getWebPage(URL urlObj) {
        try {
            String content = "";
            InputStreamReader is = new InputStreamReader(urlObj.openStream());
            BufferedReader reader = new BufferedReader(is);
            String line;
            while ((line = reader.readLine()) != null) {
                content += line;
            }
            return content;
        } catch (IOException e) {
            throw new Error("The page " + quote(urlObj.toString()) + "could not be retrieved." + "\nThis is could be caused by a number of things:" + "\n" + "\n  - the computer hosting the web page you want is down, or has returned an error" + "\n  - your computer does not have Internet access" + "\n  - the heat death of the universe has occurred, taking down all web servers with it");
        }
    }
} </s>
<s>class temp {    @Override
    public String post(final FetchInfos fetchInfos, final String data) throws HttpException {
        URL url = null;
        try {
            url = new URL(fetchInfos.getUri());
        } catch (MalformedURLException exception) {
            throw new HttpException("uri is malformed '" + fetchInfos.getUri() + "'", exception);
        }
        HttpURLConnection connection = null;
        try {
            connection = (HttpURLConnection) url.openConnection();
        } catch (IOException exception) {
            fetchInfos.setResult(FETCHING_RESULT.IO_ERROR);
            throw new HttpException("get '" + fetchInfos.getUri() + "' failed", exception);
        }
        InputStream input = null;
        try {
            connection.setRequestMethod("POST");
            connection.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");
            connection.setRequestProperty("Content-Length", "" + Integer.toString(data.getBytes().length));
            final DataOutputStream wr = new DataOutputStream(connection.getOutputStream());
            wr.writeBytes(data);
            wr.flush();
            wr.close();
            input = connection.getInputStream();
            if ("gzip".equals(connection.getHeaderField("content-encoding"))) {
                input = new GZIPInputStream(input);
            }
            if (HttpServiceImpl.LOGGER.isDebugEnabled()) {
                this.logConnection(connection);
                input = new LoggingInputStream(input);
            }
        } catch (SocketTimeoutException exception) {
            fetchInfos.setResult(FETCHING_RESULT.TIME_OUT);
            throw new HttpException("get '" + fetchInfos.getUri() + "' timeout", exception);
        } catch (IOException exception) {
            fetchInfos.setResult(FETCHING_RESULT.IO_ERROR);
            throw new HttpException("get '" + fetchInfos.getUri() + "' failed", exception);
        }
        fetchInfos.setResult(FETCHING_RESULT.OK);
        String response = null;
        try {
            response = this.toString(input);
        } catch (IOException exception) {
            throw new HttpException("converting inputstream to string failed", exception);
        }
        return response;
    }
} </s>
<s>class temp {    private String encryptPassword(String password) throws NoSuchAlgorithmException {
        MessageDigest encript = MessageDigest.getInstance("MD5");
        encript.update(password.getBytes());
        byte[] b = encript.digest();
        int size = b.length;
        StringBuffer h = new StringBuffer(size);
        for (int i = 0; i < size; i++) {
            h.append(b[i]);
        }
        return h.toString();
    }
} </s>
<s>class temp {    private void processParameters() throws BadElementException, IOException {
        type = IMGTEMPLATE;
        originalType = ORIGINAL_WMF;
        InputStream is = null;
        try {
            String errorID;
            if (rawData == null) {
                is = url.openStream();
                errorID = url.toString();
            } else {
                is = new java.io.ByteArrayInputStream(rawData);
                errorID = "Byte array";
            }
            InputMeta in = new InputMeta(is);
            if (in.readInt() != 0x9AC6CDD7) {
                throw new BadElementException(MessageLocalization.getComposedMessage("1.is.not.a.valid.placeable.windows.metafile", errorID));
            }
            in.readWord();
            int left = in.readShort();
            int top = in.readShort();
            int right = in.readShort();
            int bottom = in.readShort();
            int inch = in.readWord();
            dpiX = 72;
            dpiY = 72;
            scaledHeight = (float) (bottom - top) / inch * 72f;
            setTop(scaledHeight);
            scaledWidth = (float) (right - left) / inch * 72f;
            setRight(scaledWidth);
        } finally {
            if (is != null) {
                is.close();
            }
            plainWidth = getWidth();
            plainHeight = getHeight();
        }
    }
} </s>
<s>class temp {    private Long queryServer(OWLOntology ontologyURI) throws IOException {
        String requestString = "http://" + InetAddress.getLocalHost().getHostName() + ":8080/ChangeServer";
        requestString += "?query=" + URLEncoder.encode(ontologyURI.getURI().toString(), "UTF-8");
        URL url = new URL(requestString);
        BufferedReader input = new BufferedReader(new InputStreamReader(url.openStream()));
        StringBuffer returned = new StringBuffer();
        String str;
        while (null != ((str = input.readLine()))) {
            returned.append(str);
        }
        input.close();
        return new Long(returned.toString());
    }
} </s>
<s>class temp {    private ChangeCapsule fetchServer(OWLOntology ontologyURI, Long sequenceNumber) throws IOException {
        String requestString = "http://" + InetAddress.getLocalHost().getHostName() + ":8080/ChangeServer";
        requestString += "?fetch=" + URLEncoder.encode(ontologyURI.getURI().toString(), "UTF-8");
        requestString += "&number" + sequenceNumber;
        URL url = new URL(requestString);
        BufferedReader input = new BufferedReader(new InputStreamReader(url.openStream()));
        StringBuffer returned = new StringBuffer();
        String str;
        while (null != ((str = input.readLine()))) {
            returned.append(str);
        }
        input.close();
        ChangeCapsule cp = new ChangeCapsule(returned.toString());
        return cp;
    }
} </s>
<s>class temp {    @Override
    public boolean performOk() {
        this.setPropertyValue("bea.home", this.beaHome.getText());
        this.setPropertyValue("bea.domain", this.domainDirectory.getText());
        Display.getDefault().syncExec(new Runnable() {

            public void run() {
                saveWLHome();
                for (final TabControl control : tabControls) {
                    control.performOk(WLPropertyPage.this.getProject(), WLPropertyPage.this);
                }
                if (isEnabledJCLCopy()) {
                    final File url = new File(WLPropertyPage.this.domainDirectory.getText());
                    File lib = new File(url, "lib");
                    File log4jLibrary = new File(lib, "log4j-1.2.13.jar");
                    if (!log4jLibrary.exists()) {
                        InputStream srcFile = null;
                        FileOutputStream fos = null;
                        try {
                            srcFile = toInputStream(new Path("jcl/log4j-1.2.13.jar"));
                            fos = new FileOutputStream(log4jLibrary);
                            IOUtils.copy(srcFile, fos);
                            srcFile.close();
                            fos.flush();
                            fos.close();
                            srcFile = toInputStream(new Path("/jcl/commons-logging-1.0.4.jar"));
                            File jcl = new File(lib, "commons-logging-1.0.4.jar");
                            fos = new FileOutputStream(jcl);
                            IOUtils.copy(srcFile, fos);
                        } catch (IOException e) {
                            Logger.log(Logger.ERROR, "Could not copy JCL jars file to Bea WL", e);
                        } finally {
                            try {
                                if (srcFile != null) {
                                    srcFile.close();
                                    srcFile = null;
                                }
                                if (fos != null) {
                                    fos.flush();
                                    fos.close();
                                    fos = null;
                                }
                            } catch (IOException e) {
                            }
                        }
                    }
                }
                if (isEnabledJSTLCopy()) {
                    File url = new File(WLPropertyPage.this.domainDirectory.getText());
                    File lib = new File(url, "lib");
                    File jstlLibrary = new File(lib, "jstl.jar");
                    if (!jstlLibrary.exists()) {
                        InputStream srcFile = null;
                        FileOutputStream fos = null;
                        try {
                            srcFile = toInputStream(new Path("jstl/jstl.jar"));
                            fos = new FileOutputStream(jstlLibrary);
                            IOUtils.copy(srcFile, fos);
                        } catch (IOException e) {
                            Logger.log(Logger.ERROR, "Could not copy the JSTL 1.1 jar file to Bea WL", e);
                        } finally {
                            try {
                                if (srcFile != null) {
                                    srcFile.close();
                                    srcFile = null;
                                }
                                if (fos != null) {
                                    fos.flush();
                                    fos.close();
                                    fos = null;
                                }
                            } catch (final IOException e) {
                                Logger.getLog().debug("I/O exception closing resources", e);
                            }
                        }
                    }
                }
            }
        });
        return super.performOk();
    }
} </s>
<s>class temp {            public void run() {
                saveWLHome();
                for (final TabControl control : tabControls) {
                    control.performOk(WLPropertyPage.this.getProject(), WLPropertyPage.this);
                }
                if (isEnabledJCLCopy()) {
                    final File url = new File(WLPropertyPage.this.domainDirectory.getText());
                    File lib = new File(url, "lib");
                    File log4jLibrary = new File(lib, "log4j-1.2.13.jar");
                    if (!log4jLibrary.exists()) {
                        InputStream srcFile = null;
                        FileOutputStream fos = null;
                        try {
                            srcFile = toInputStream(new Path("jcl/log4j-1.2.13.jar"));
                            fos = new FileOutputStream(log4jLibrary);
                            IOUtils.copy(srcFile, fos);
                            srcFile.close();
                            fos.flush();
                            fos.close();
                            srcFile = toInputStream(new Path("/jcl/commons-logging-1.0.4.jar"));
                            File jcl = new File(lib, "commons-logging-1.0.4.jar");
                            fos = new FileOutputStream(jcl);
                            IOUtils.copy(srcFile, fos);
                        } catch (IOException e) {
                            Logger.log(Logger.ERROR, "Could not copy JCL jars file to Bea WL", e);
                        } finally {
                            try {
                                if (srcFile != null) {
                                    srcFile.close();
                                    srcFile = null;
                                }
                                if (fos != null) {
                                    fos.flush();
                                    fos.close();
                                    fos = null;
                                }
                            } catch (IOException e) {
                            }
                        }
                    }
                }
                if (isEnabledJSTLCopy()) {
                    File url = new File(WLPropertyPage.this.domainDirectory.getText());
                    File lib = new File(url, "lib");
                    File jstlLibrary = new File(lib, "jstl.jar");
                    if (!jstlLibrary.exists()) {
                        InputStream srcFile = null;
                        FileOutputStream fos = null;
                        try {
                            srcFile = toInputStream(new Path("jstl/jstl.jar"));
                            fos = new FileOutputStream(jstlLibrary);
                            IOUtils.copy(srcFile, fos);
                        } catch (IOException e) {
                            Logger.log(Logger.ERROR, "Could not copy the JSTL 1.1 jar file to Bea WL", e);
                        } finally {
                            try {
                                if (srcFile != null) {
                                    srcFile.close();
                                    srcFile = null;
                                }
                                if (fos != null) {
                                    fos.flush();
                                    fos.close();
                                    fos = null;
                                }
                            } catch (final IOException e) {
                                Logger.getLog().debug("I/O exception closing resources", e);
                            }
                        }
                    }
                }
            }
} </s>
<s>class temp {    public static boolean fileCopy(String sFileSrc, String sFileDst) {
        boolean ok = true;
        FileInputStream fis = null;
        FileOutputStream fos = null;
        try {
            File fSrc = new File(sFileSrc);
            int len = 32768;
            byte[] buff = new byte[(int) Math.min(len, fSrc.length())];
            fis = new FileInputStream(fSrc);
            boolean append = false;
            fos = new FileOutputStream(sFileDst, append);
            while (0 < (len = fis.read(buff))) fos.write(buff, 0, len);
            fos.flush();
        } catch (IOException e) {
            e.printStackTrace();
            ok = false;
        } finally {
            if (fos != null) {
                try {
                    fos.close();
                } catch (IOException ex) {
                    ex.printStackTrace();
                    JdxLog.logError(ex);
                }
            }
            if (fis != null) {
                try {
                    fis.close();
                } catch (IOException ex) {
                    ex.printStackTrace();
                    JdxLog.logError(ex);
                }
            }
        }
        return ok;
    }
} </s>
<s>class temp {    public static String SHA512(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        MessageDigest md;
        md = MessageDigest.getInstance("SHA-512");
        byte[] sha1hash = new byte[40];
        md.update(text.getBytes("UTF-8"), 0, text.length());
        sha1hash = md.digest();
        return convertToHex(sha1hash);
    }
} </s>
<s>class temp {    private static void copyFiles(String strPath, String dstPath) throws Exception {
        File src = new File(strPath);
        File dest = new File(dstPath);
        if (src.isDirectory()) {
            dest.mkdirs();
            String list[] = src.list();
            for (int i = 0; i < list.length; i++) {
                String dest1 = dest.getAbsolutePath() + "\\" + list[i];
                String src1 = src.getAbsolutePath() + "\\" + list[i];
                copyFiles(src1, dest1);
            }
        } else {
            FileChannel sourceChannel = new FileInputStream(src).getChannel();
            FileChannel targetChannel = new FileOutputStream(dest).getChannel();
            sourceChannel.transferTo(0, sourceChannel.size(), targetChannel);
            sourceChannel.close();
            targetChannel.close();
        }
    }
} </s>
<s>class temp {    @Override
    public Content getContent(Object principal, ContentPath path, Version version, Map<String, Object> properties) throws ContentException {
        String uniqueName = path.getBaseName();
        URL url = buildURL(uniqueName);
        URLContent content = new URLContent(url, this.getName(), uniqueName);
        content.setUniqueName(uniqueName);
        content.setReadable(true);
        content.setWritable(writable);
        content.setExists(true);
        try {
            URLConnection connection = url.openConnection();
            String mimeType = connection.getContentType();
            content.setMimeType(mimeType);
            content.setWritable(true);
        } catch (IOException ex) {
            throw new ContentException("unable to obtain mime type of " + url, ex);
        }
        return content;
    }
} </s>
<s>class temp {    @Override
    public void writeToContent(Object principal, String uniqueId, InputStream ins) throws IOException, ContentException {
        if (writable) {
            URL url = buildURL(uniqueId);
            URLConnection connection = url.openConnection();
            OutputStream outs = connection.getOutputStream();
            try {
                ContentUtil.pipe(ins, outs);
            } finally {
                try {
                    outs.close();
                } catch (Exception ex) {
                    log.log(Level.WARNING, "unable to close " + url, ex);
                }
            }
        } else {
            throw new ContentException("not writable");
        }
    }
} </s>
<s>class temp {    public static void copy(File sourceFile, File destFile) throws IOException {
        if (!destFile.exists()) {
            destFile.createNewFile();
        }
        FileChannel source = null;
        FileChannel destination = null;
        try {
            source = new FileInputStream(sourceFile).getChannel();
            destination = new FileOutputStream(destFile).getChannel();
            destination.transferFrom(source, 0, source.size());
        } finally {
            if (source != null) {
                source.close();
            }
            if (destination != null) {
                destination.close();
            }
        }
    }
} </s>
<s>class temp {    public static String encryptPassword(String password) {
        try {
            MessageDigest md = MessageDigest.getInstance("SHA");
            md.update(password.getBytes());
            byte[] hash = md.digest();
            int hashLength = hash.length;
            StringBuffer hashStringBuf = new StringBuffer();
            String byteString;
            int byteLength;
            for (int index = 0; index < hash.length; index++) {
                byteString = String.valueOf(hash[index] + 128);
                byteLength = byteString.length();
                switch(byteLength) {
                    case 1:
                        byteString = "00" + byteString;
                        break;
                    case 2:
                        byteString = "0" + byteString;
                        break;
                }
                hashStringBuf.append(byteString);
            }
            return hashStringBuf.toString();
        } catch (NoSuchAlgorithmException nsae) {
            System.out.println("Error getting password hash - " + nsae.getMessage());
            return null;
        }
    }
} </s>
<s>class temp {    public static void copy(File from, File to, int bufferSize) throws IOException {
        if (to.exists()) {
            logger.info("File " + to + " exists, will replace it.");
            to.delete();
        }
        to.getParentFile().mkdirs();
        to.createNewFile();
        FileInputStream ois = null;
        FileOutputStream cos = null;
        try {
            ois = new FileInputStream(from);
            cos = new FileOutputStream(to);
            byte[] buf = new byte[bufferSize];
            int read;
            while ((read = ois.read(buf, 0, bufferSize)) > 0) {
                cos.write(buf, 0, read);
            }
            cos.flush();
        } finally {
            try {
                if (ois != null) ois.close();
            } catch (IOException ignored) {
                logger.warn("Could not close file input stream " + from, ignored);
            }
            try {
                if (cos != null) {
                    cos.close();
                }
            } catch (IOException ignored) {
                logger.warn("Could not close file output stream " + to, ignored);
            }
        }
    }
} </s>
<s>class temp {    public static boolean insert(final Funcionario objFuncionario) {
        int result = 0;
        final Connection c = DBConnection.getConnection();
        PreparedStatement pst = null;
        if (c == null) {
            return false;
        }
        try {
            c.setAutoCommit(false);
            final String sql = "insert into funcionario " + "(nome, cpf, telefone, email, senha, login, id_cargo)" + " values (?, ?, ?, ?, ?, ?, ?)";
            pst = c.prepareStatement(sql);
            pst.setString(1, objFuncionario.getNome());
            pst.setString(2, objFuncionario.getCpf());
            pst.setString(3, objFuncionario.getTelefone());
            pst.setString(4, objFuncionario.getEmail());
            pst.setString(5, objFuncionario.getSenha());
            pst.setString(6, objFuncionario.getLogin());
            pst.setLong(7, (objFuncionario.getCargo()).getCodigo());
            result = pst.executeUpdate();
            c.commit();
        } catch (final SQLException e) {
            try {
                c.rollback();
            } catch (final SQLException e1) {
                System.out.println("[FuncionarioDAO.insert] Erro ao inserir -> " + e1.getMessage());
            }
            System.out.println("[FuncionarioDAO.insert] Erro ao inserir -> " + e.getMessage());
        } finally {
            DBConnection.closePreparedStatement(pst);
            DBConnection.closeConnection(c);
        }
        if (result > 0) {
            return true;
        } else {
            return false;
        }
    }
} </s>
<s>class temp {    public static boolean update(Funcionario objFuncionario) {
        int result = 0;
        Connection c = DBConnection.getConnection();
        PreparedStatement pst = null;
        if (c == null) {
            return false;
        }
        try {
            c.setAutoCommit(false);
            final String sql = "update funcionario " + " set nome = ? , cpf = ? , telefone = ? , email = ?, senha = ?, login = ?, id_cargo = ?" + " where id_funcionario = ?";
            pst = c.prepareStatement(sql);
            pst.setString(1, objFuncionario.getNome());
            pst.setString(2, objFuncionario.getCpf());
            pst.setString(3, objFuncionario.getTelefone());
            pst.setString(4, objFuncionario.getEmail());
            pst.setString(5, objFuncionario.getSenha());
            pst.setString(6, objFuncionario.getLogin());
            pst.setLong(7, (objFuncionario.getCargo()).getCodigo());
            pst.setLong(8, objFuncionario.getCodigo());
            result = pst.executeUpdate();
            c.commit();
        } catch (SQLException e) {
            try {
                c.rollback();
            } catch (SQLException e1) {
                System.out.println("[FuncionarioDAO.update] Erro ao atualizar -> " + e1.getMessage());
            }
            System.out.println("[FuncionarioDAO.update] Erro ao atualizar -> " + e.getMessage());
        } finally {
            DBConnection.closePreparedStatement(pst);
            DBConnection.closeConnection(c);
        }
        if (result > 0) {
            return true;
        } else {
            return false;
        }
    }
} </s>
<s>class temp {    public static final synchronized String md5(final String data) {
        try {
            final MessageDigest md = MessageDigest.getInstance("MD5");
            md.update(data.getBytes());
            final byte[] b = md.digest();
            return toHexString(b);
        } catch (final Exception e) {
        }
        return "";
    }
} </s>
<s>class temp {    public String crypt(String suppliedPassword) throws NoSuchAlgorithmException {
        MessageDigest md = MessageDigest.getInstance("MD5");
        md.update(suppliedPassword.getBytes());
        String encriptedPassword = null;
        try {
            encriptedPassword = new String(Base64.encode(md.digest()), "ASCII");
        } catch (UnsupportedEncodingException e) {
        }
        return encriptedPassword;
    }
} </s>
<s>class temp {    @Override
    List<String> HttpGet(URL url) throws IOException {
        List<String> responseList = new ArrayList<String>();
        Logger.getInstance().logInfo("HTTP GET: " + url, null, getGatewayId());
        HttpURLConnection con = (HttpURLConnection) url.openConnection();
        con.setConnectTimeout(20000);
        con.setAllowUserInteraction(false);
        responseList.add(con.getResponseCode() + " " + con.getResponseMessage());
        InputStream inputStream = con.getErrorStream();
        if (inputStream == null) inputStream = con.getInputStream();
        BufferedReader in = new BufferedReader(new InputStreamReader(inputStream));
        String inputLine;
        while ((inputLine = in.readLine()) != null) responseList.add(inputLine);
        in.close();
        return responseList;
    }
} </s>
<s>class temp {    public void loadJarFile(String jarFileNameParam) throws KExceptionClass {
        jarFileName = jarFileNameParam;
        {
            String message = "Loading resource file [";
            message += jarFileName;
            message += "]...";
            log.log(this, message);
        }
        try {
            URL url = new URL(jarFileName);
            JarURLConnection jarConnection = (JarURLConnection) url.openConnection();
            jarConnection.setUseCaches(false);
            JarFile jarFile = jarConnection.getJarFile();
            Enumeration jarEntries = jarFile.entries();
            while (jarEntries.hasMoreElements()) {
                ZipEntry zipEntrie = (ZipEntry) jarEntries.nextElement();
                {
                    String message = "Scanning [";
                    message += jarFileName;
                    message += "] found [";
                    message += describeEntry(zipEntrie);
                    message += "]";
                    log.log(this, message);
                }
                htSizes.put(zipEntrie.getName(), new Integer((int) zipEntrie.getSize()));
            }
            ;
            jarFile.close();
            BufferedInputStream inputBuffer = new BufferedInputStream(jarConnection.getJarFileURL().openStream());
            ZipInputStream input = new ZipInputStream(inputBuffer);
            ZipEntry zipEntrie = null;
            while ((zipEntrie = input.getNextEntry()) != null) {
                if (zipEntrie.isDirectory()) continue;
                {
                    String message = "Scanning [";
                    message += jarFileName;
                    message += "] loading [";
                    message += zipEntrie.getName();
                    message += "] for [";
                    message += zipEntrie.getSize();
                    message += "] bytes.";
                    log.log(this, message);
                }
                int size = (int) zipEntrie.getSize();
                if (size == -1) {
                    size = ((Integer) htSizes.get(zipEntrie.getName())).intValue();
                }
                ;
                byte[] entrieData = new byte[(int) size];
                int offset = 0;
                int dataRead = 0;
                while (((int) size - offset) > 0) {
                    dataRead = input.read(entrieData, offset, (int) size - offset);
                    if (dataRead == -1) break;
                    offset += dataRead;
                }
                htJarContents.put(zipEntrie.getName(), entrieData);
                if (debugOn) {
                    System.out.println(zipEntrie.getName() + "  offset=" + offset + ",size=" + size + ",csize=" + zipEntrie.getCompressedSize());
                }
                ;
            }
            ;
        } catch (Exception error) {
            String message = "Error loading data from JAR file [";
            message += error.toString();
            message += "]";
            throw new KExceptionClass(message, new KExceptionClass(error.toString(), null));
        }
        ;
    }
} </s>
<s>class temp {    InputStream openReader(String s) {
        System.err.println("Fetcher: trying url " + s);
        try {
            URL url = new URL(s);
            HttpURLConnection con = (HttpURLConnection) url.openConnection();
            return url.openStream();
        } catch (IOException e) {
        }
        return null;
    }
} </s>
<s>class temp {    public static void batchInsertOrder(Order o) throws AppException {
        Connection conn = DBUtils.getDataConnection();
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        String sqlOrder = null;
        String sqlDetail = null;
        try {
            conn.setAutoCommit(false);
            sqlOrder = "insert into SO_SOMain (ID,cSOCode,dDate," + "cBusType,cCusCode,cCusName," + "cDepCode,cSTCode," + "iVTid,cMaker,cMemo) values (?,?,?,?,?,?,?,?,?,?,?)";
            sqlDetail = "insert into SO_SODetails (ID,cSOCode,cInvCode,cInvName," + "iNum,iQuantity,iTaxUnitPrice,iSum,dPreDate,iSOsID,cFree1,cUnitID) values(?,?,?,?,?,?,?,?,?,?,?,?)";
            pstmt = conn.prepareStatement(sqlOrder);
            long maxId = getMaxID(conn, pstmt, rs);
            maxId++;
            pstmt.setLong(1, maxId);
            Long l = maxId;
            o.setId(l.intValue());
            String code = o.getCode();
            long maxCSOCode = getMaxCSOCode(code, conn, pstmt, rs);
            String csOCode = getCSOCode(code, maxCSOCode);
            o.setCode(csOCode);
            pstmt.setString(2, csOCode);
            pstmt.setDate(3, DateUtil.getSqlDateFormUtilDate(o.getOrderDate()));
            pstmt.setString(4, o.getBusinessType());
            pstmt.setString(5, o.getC().getId());
            pstmt.setString(6, o.getC().getName());
            pstmt.setString(7, o.getP().getDept().getId());
            pstmt.setString(8, o.getSaleType().getId());
            pstmt.setInt(9, o.getiVtid());
            pstmt.setString(10, o.getP().getName());
            pstmt.setString(11, o.getRemark());
            pstmt.executeUpdate();
            pstmt.clearParameters();
            pstmt = conn.prepareStatement(sqlDetail);
            ArrayList<OrderDetail> ods = o.getOds();
            long iSOsID = getiSOsID(conn, pstmt, rs);
            for (OrderDetail od : ods) {
                pstmt.setLong(1, maxId);
                pstmt.setString(2, csOCode);
                pstmt.setString(3, od.getInventory().getId());
                pstmt.setString(4, od.getInventory().getName());
                pstmt.setInt(5, od.getPiece());
                pstmt.setBigDecimal(6, od.getCount());
                pstmt.setBigDecimal(7, od.getPrice());
                pstmt.setBigDecimal(8, od.getSum());
                pstmt.setDate(9, DateUtil.getSqlDateFormUtilDate(od.getSendDate()));
                pstmt.setLong(10, ++iSOsID);
                pstmt.setString(11, od.getPacking().getcValue());
                pstmt.setString(12, od.getInventory().getSAComUnitCode());
                pstmt.executeUpdate();
                pstmt.clearParameters();
            }
            conn.commit();
        } catch (SQLException sqle) {
            try {
                conn.rollback();
                throw new AppException(sqle.getMessage());
            } catch (SQLException ex) {
                Logger.getLogger(OrderDAO.class.getName()).log(Level.SEVERE, null, ex);
                throw new AppException(ex.getMessage());
            }
        } finally {
            DBUtils.closeAll(rs, pstmt, conn);
        }
    }
} </s>
<s>class temp {    public static String getDocumentAsString(URL url) throws IOException {
        StringBuffer result = new StringBuffer();
        InputStream inStream = url.openStream();
        int character;
        while ((character = inStream.read()) != -1) {
            result.append((char) character);
        }
        return result.toString();
    }
} </s>
<s>class temp {    @Test
    public void testTransactWriteAndRead() throws Exception {
        JCFSFileServer server = new JCFSFileServer(defaultTcpPort, defaultTcpAddress, defaultUdpPort, defaultUdpAddress, dir, 0, 0);
        JCFS.configureDiscovery(defaultUdpAddress, defaultUdpPort);
        try {
            server.start();
            RFile file = new RFile("testreadwritetrans.txt");
            RFileOutputStream out = new RFileOutputStream(file, WriteMode.TRANSACTED, false, 1);
            out.write("test".getBytes("utf-8"));
            out.close();
            RFileInputStream in = new RFileInputStream(file);
            byte[] buffer = new byte[4];
            int readCount = in.read(buffer);
            in.close();
            assertEquals(4, readCount);
            String resultRead = new String(buffer, "utf-8");
            assertEquals("test", resultRead);
        } finally {
            server.stop();
        }
    }
} </s>
<s>class temp {    public static void copyFile(File sourceFile, File destFile) throws IOException {
        if (!destFile.exists()) {
            destFile.createNewFile();
        }
        FileChannel source = null;
        FileChannel destination = null;
        try {
            source = new FileInputStream(sourceFile).getChannel();
            destination = new FileOutputStream(destFile).getChannel();
            long count = 0;
            long size = source.size();
            while ((count += destination.transferFrom(source, 0, size - count)) < size) ;
        } finally {
            if (source != null) {
                source.close();
            }
            if (destination != null) {
                destination.close();
            }
        }
    }
} </s>
<s>class temp {    @Test
    public void testWriteAndRead() throws Exception {
        JCFSFileServer server = new JCFSFileServer(defaultTcpPort, defaultTcpAddress, defaultUdpPort, defaultUdpAddress, dir, 0, 0);
        JCFS.configureDiscovery(defaultUdpAddress, defaultUdpPort);
        try {
            server.start();
            RFile file = new RFile("testreadwrite.txt");
            RFileOutputStream out = new RFileOutputStream(file);
            out.write("test".getBytes("utf-8"));
            out.close();
            RFileInputStream in = new RFileInputStream(file);
            byte[] buffer = new byte[4];
            int readCount = in.read(buffer);
            in.close();
            assertEquals(4, readCount);
            String resultRead = new String(buffer, "utf-8");
            assertEquals("test", resultRead);
        } finally {
            server.stop();
        }
    }
} </s>
<s>class temp {    private static BreakIterator createBreakInstance(Locale where, int kind, String rulesName, String dictionaryName) {
        ResourceBundle bundle = ICULocaleData.getResourceBundle("BreakIteratorRules", where);
        String[] classNames = bundle.getStringArray("BreakIteratorClasses");
        String rules = bundle.getString(rulesName);
        if (classNames[kind].equals("RuleBasedBreakIterator")) {
            return new RuleBasedBreakIterator(rules);
        } else if (classNames[kind].equals("DictionaryBasedBreakIterator")) {
            try {
                Object t = bundle.getObject(dictionaryName);
                URL url = (URL) t;
                InputStream dictionary = url.openStream();
                return new DictionaryBasedBreakIterator(rules, dictionary);
            } catch (IOException e) {
            } catch (MissingResourceException e) {
            }
            return new RuleBasedBreakIterator(rules);
        } else {
            throw new IllegalArgumentException("Invalid break iterator class \"" + classNames[kind] + "\"");
        }
    }
} </s>
<s>class temp {    public ArrayList loadData(String address) {
        URL url;
        BufferedReader bf_in = null;
        ArrayList a = new ArrayList();
        String line;
        try {
            url = new URL(address);
            bf_in = new BufferedReader(new InputStreamReader(url.openStream()));
            while (((line = bf_in.readLine()) != null)) {
                if (line.startsWith("Date")) {
                    continue;
                }
                if (line != null && line.length() > 0) {
                    a.add(line);
                }
            }
            bf_in.close();
        } catch (Exception e) {
            System.out.println("StockValumeHistory:loadData:Error:" + e);
        }
        return a;
    }
} </s>
<s>class temp {    protected InputSource getInputSource(String pReferencingSystemId, String pURI) throws SAXException {
        URL url = null;
        if (pReferencingSystemId != null) {
            try {
                url = new URL(new URL(pReferencingSystemId), pURI);
            } catch (MalformedURLException e) {
            }
            if (url == null) {
                try {
                    url = new File(new File(pReferencingSystemId).getParentFile(), pURI).toURL();
                } catch (MalformedURLException e) {
                }
            }
        }
        if (url == null) {
            try {
                url = new URL(pURI);
            } catch (MalformedURLException e) {
                try {
                    url = new File(pURI).toURL();
                } catch (MalformedURLException f) {
                    throw new SAXException("Failed to parse the URI " + pURI);
                }
            }
        }
        try {
            InputSource isource = new InputSource(url.openStream());
            isource.setSystemId(url.toString());
            return isource;
        } catch (IOException e) {
            throw new SAXException("Failed to open the URL " + url, e);
        }
    }
} </s>
<s>class temp {    public static void upLoadFile(File sourceFile, File targetFile) throws IOException {
        FileChannel inChannel = null;
        FileChannel outChannel = null;
        try {
            inChannel = new FileInputStream(sourceFile).getChannel();
            outChannel = new FileOutputStream(targetFile).getChannel();
            inChannel.transferTo(0, inChannel.size(), outChannel);
        } finally {
            try {
                if (inChannel != null) {
                    inChannel.close();
                }
                if (outChannel != null) {
                    outChannel.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
} </s>
<s>class temp {    public static String crypt(String target) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        MessageDigest md = MessageDigest.getInstance("MD5");
        md.update(target.getBytes("UTF-16"));
        BigInteger res = new BigInteger(1, md.digest(key.getBytes()));
        return res.toString(16);
    }
} </s>
<s>class temp {    public static String cryptSha(String target) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        MessageDigest md = MessageDigest.getInstance("SHA");
        md.update(target.getBytes("UTF-16"));
        BigInteger res = new BigInteger(1, md.digest(key.getBytes()));
        return res.toString(16);
    }
} </s>
<s>class temp {    public static void main(String args[]) {
        int summ = 0;
        int temp = 0;
        int[] a1 = { 0, 6, -7, -7, 61, 8, 20, 0, 8, 3, 6, 2, 7, 99, 0, 23, 12, 7, 9, 5, 33, 1, 3, 99, 99, 61, 99, 99, 99, 61, 61, 61, -3, -3, -3, -3 };
        for (int j = 0; j < (a1.length * a1.length); j++) {
            for (int i = 0; i < a1.length - 1; i++) {
                if (a1[i] > a1[i + 1]) {
                    temp = a1[i];
                    a1[i] = a1[i + 1];
                    a1[i + 1] = temp;
                }
            }
        }
        for (int i = 0; i < a1.length; i++) {
            System.out.print(" " + a1[i]);
        }
        int min = 0;
        int max = 0;
        summ = (a1[1]) + (a1[a1.length - 1]);
        for (int i = 0; i < a1.length; i++) {
            if (a1[i] > a1[0] && a1[i] != a1[0]) {
                min = a1[i];
                break;
            }
        }
        for (int i = a1.length - 1; i > 0; i--) {
            if (a1[i] < a1[a1.length - 1] & a1[i] != a1[a1.length - 1]) {
                max = a1[i];
                break;
            }
        }
        System.out.println();
        System.out.print("summa 2 min N 2 max = " + summ);
        System.out.println(min);
        System.out.println(max);
        System.out.println("summa 2 min N 2 max = " + (min + max));
    }
} </s>
<s>class temp {    private void getRandomGUID(boolean secure) {
        MessageDigest md5 = null;
        StringBuffer sbValueBeforeMD5 = new StringBuffer();
        try {
            md5 = MessageDigest.getInstance("MD5");
        } catch (NoSuchAlgorithmException e) {
            System.out.println("Error: " + e);
        }
        try {
            long time = System.currentTimeMillis();
            long rand = 0;
            if (secure) {
                rand = mySecureRand.nextLong();
            } else {
                rand = myRand.nextLong();
            }
            sbValueBeforeMD5.append(s_id);
            sbValueBeforeMD5.append(":");
            sbValueBeforeMD5.append(Long.toString(time));
            sbValueBeforeMD5.append(":");
            sbValueBeforeMD5.append(Long.toString(rand));
            valueBeforeMD5 = sbValueBeforeMD5.toString();
            md5.update(valueBeforeMD5.getBytes());
            byte[] array = md5.digest();
            StringBuffer sb = new StringBuffer();
            for (int j = 0; j < array.length; ++j) {
                int b = array[j] & 0xFF;
                if (b < 0x10) sb.append('0');
                sb.append(Integer.toHexString(b));
            }
            valueAfterMD5 = sb.toString();
        } catch (Exception e) {
            System.out.println("Error:" + e);
        }
    }
} </s>
<s>class temp {    public void addRegisterInfo(HttpServletRequest request) throws ApplicationException {
        String[] pids = request.getParameterValues("pid");
        if (pids == null || pids.length <= 0) throw new ApplicationException("  ѡ  Ҫ   Ĳ Ʒ");
        RegisterDao registerDao = new RegisterDao();
        Register register = registerDao.findPojoById(StrFun.getString(request, "rid"), Register.class);
        if (register.audit) throw new ApplicationException("        Ѿ   ˣ        µ   Ʒ");
        DBConnect dbc = null;
        Connection conn = null;
        try {
            dbc = DBConnect.createDBConnect();
            conn = dbc.getConnection();
            conn.setAutoCommit(false);
            for (String pid : pids) {
                RegisterInfo pd = new RegisterInfo();
                pd.rid = StrFun.getInt(request, "rid");
                pd.pid = Integer.parseInt(pid);
                pd.productName = StrFun.getString(request, "productName_" + pid);
                pd.regAmount = StrFun.getInt(request, "regAmount_" + pid);
                pd.regPrice = StrFun.getInt(request, "regPrice_" + pid);
                pd.regSalePrice = StrFun.getInt(request, "regSalePrice_" + pid);
                pd.userNo = ServerUtil.getUserFromSession(request).userNo;
                if (pd.regAmount <= 0) throw new ApplicationException("           Ϊ  ");
                String sql = "insert into SS_RegisterInfo " + "(pid, rid, productName, regAmount, regPrice, regSalePrice, userNo) " + "values(" + "'" + pd.pid + "', " + "'" + pd.rid + "', " + "'" + pd.productName + "', " + "'" + pd.regAmount + "', " + "'" + pd.regPrice + "', " + "'" + pd.regSalePrice + "', " + "'" + pd.userNo + "' " + ")";
                conn.createStatement().executeUpdate(sql);
            }
            conn.commit();
        } catch (Exception e) {
            e.printStackTrace();
            if (conn != null) {
                try {
                    conn.rollback();
                } catch (SQLException e1) {
                    e1.printStackTrace();
                }
            }
            throw new ApplicationException(e.getMessage(), e);
        } finally {
            if (dbc != null) try {
                dbc.close();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
} </s>
<s>class temp {    public static void loadProperties() {
        try {
            URL url = ClassLoader.getSystemResource("OpenDarkRoom.lang.en.properties");
            localization.load(url.openStream());
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        try {
            FileInputStream is = new FileInputStream(userDir + "OpenDarkRoom.properties");
            preferences.load(is);
        } catch (FileNotFoundException e) {
            log.warn("Preferences file " + userDir + "OpenDarkRoom.properties not found, loading defaults");
            loadDefaultPreferences();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
} </s>
<s>class temp {    private static void loadDefaultPreferences() {
        try {
            URL url = ClassLoader.getSystemResource("OpenDarkRoom.defaults.properties");
            preferences.load(url.openStream());
        } catch (FileNotFoundException e) {
            log.error("Default preferences file not found");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
} </s>
<s>class temp {    public static void copyFile(File from, File to) throws Exception {
        if (!from.exists()) return;
        FileInputStream in = new FileInputStream(from);
        FileOutputStream out = new FileOutputStream(to);
        byte[] buffer = new byte[BUFFER_SIZE];
        int bytes_read;
        while (true) {
            bytes_read = in.read(buffer);
            if (bytes_read == -1) break;
            out.write(buffer, 0, bytes_read);
        }
        out.flush();
        out.close();
        in.close();
    }
} </s>
<s>class temp {    public String makeLeoNounCall(String noun) {
        String ret = "";
        StringBuffer buf = new StringBuffer();
        try {
            URL url = new URL("http://dict.leo.org" + noun);
            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream(), Charset.forName("ISO8859_1")));
            String inputLine;
            boolean display = false;
            while ((inputLine = in.readLine()) != null) {
                if (inputLine.contains("contentholder")) {
                    display = true;
                }
                if (display) buf.append(inputLine);
            }
            ret = FilterFunctions.findEndTag("<td", buf.toString());
            sleepRandomTime();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return ret;
    }
} </s>
<s>class temp {    private void getLines(PackageManager pm) throws PackageManagerException {
        final Pattern p = Pattern.compile("\\s*deb\\s+(ftp://|http://)(\\S+)\\s+((\\S+\\s*)*)(./){0,1}");
        Matcher m;
        if (updateUrlAndFile == null) updateUrlAndFile = new ArrayList<UrlAndFile>();
        BufferedReader f;
        String protocol;
        String host;
        String shares;
        String adress;
        try {
            f = new BufferedReader(new FileReader(sourcesList));
            while ((protocol = f.readLine()) != null) {
                m = p.matcher(protocol);
                if (m.matches()) {
                    protocol = m.group(1);
                    host = m.group(2);
                    if (m.group(3).trim().equalsIgnoreCase("./")) shares = ""; else shares = m.group(3).trim();
                    if (shares == null) adress = protocol + host; else {
                        shares = shares.replace(" ", "/");
                        if (!host.endsWith("/") && !shares.startsWith("/")) host = host + "/";
                        adress = host + shares;
                        while (adress.contains("//")) adress = adress.replace("//", "/");
                        adress = protocol + adress;
                    }
                    if (!adress.endsWith("/")) adress = adress + "/";
                    String changelogdir = adress;
                    changelogdir = changelogdir.substring(changelogdir.indexOf("//") + 2);
                    if (changelogdir.endsWith("/")) changelogdir = changelogdir.substring(0, changelogdir.lastIndexOf("/"));
                    changelogdir = changelogdir.replace('/', '_');
                    changelogdir = changelogdir.replaceAll("\\.", "_");
                    changelogdir = changelogdir.replaceAll("-", "_");
                    changelogdir = changelogdir.replaceAll(":", "_COLON_");
                    adress = adress + "Packages.gz";
                    final String serverFileLocation = adress.replaceAll(":", "_COLON_");
                    final NameFileLocation nfl = new NameFileLocation();
                    try {
                        final GZIPInputStream in = new GZIPInputStream(new ConnectToServer(pm).getInputStream(adress));
                        final String rename = new File(nfl.rename(serverFileLocation, listsDir)).getCanonicalPath();
                        final FileOutputStream out = new FileOutputStream(rename);
                        final byte[] buf = new byte[4096];
                        int len;
                        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);
                        out.close();
                        in.close();
                        final File file = new File(rename);
                        final UrlAndFile uaf = new UrlAndFile(protocol + host, file, changelogdir);
                        updateUrlAndFile.add(uaf);
                    } catch (final Exception e) {
                        final String message = "URL: " + adress + " caused exception";
                        if (null != pm) {
                            logger.warn(message, e);
                            pm.addWarning(message + "\n" + e.toString());
                        } else logger.warn(message, e);
                        e.printStackTrace();
                    }
                }
            }
            f.close();
        } catch (final FileNotFoundException e) {
            final String message = PreferenceStoreHolder.getPreferenceStoreByName("Screen").getPreferenceAsString("sourcesList.corrupt", "Entry not found sourcesList.corrupt");
            if (null != pm) {
                logger.warn(message, e);
                pm.addWarning(message + "\n" + e.toString());
            } else logger.warn(message, e);
            e.printStackTrace();
        } catch (final IOException e) {
            final String message = PreferenceStoreHolder.getPreferenceStoreByName("Screen").getPreferenceAsString("SearchForServerFile.getLines.IOException", "Entry not found SearchForServerFile.getLines.IOException");
            if (null != pm) {
                logger.warn(message, e);
                pm.addWarning(message + "\n" + e.toString());
            } else logger.warn(message, e);
            e.printStackTrace();
        }
    }
} </s>
<s>class temp {    @Override
    public void sortArray(int[] array) {
        boolean sorted = false;
        while (sorted == false) {
            sorted = true;
            for (int i = 0; i <= array.length - 2; i++) {
                if (array[i] > array[i + 1]) {
                    int temp = array[i];
                    array[i] = array[i + 1];
                    array[i + 1] = temp;
                    sorted = false;
                }
            }
        }
    }
} </s>
<s>class temp {    public void testStorageString() throws Exception {
        TranslationResponseInMemory r = new TranslationResponseInMemory(2048, "UTF-8");
        r.addText("This is an example");
        r.addText(" and another one.");
        assertEquals("This is an example and another one.", r.getText());
        InputStream input = r.getInputStream();
        StringWriter writer = new StringWriter();
        try {
            IOUtils.copy(input, writer, "UTF-8");
        } finally {
            input.close();
            writer.close();
        }
        assertEquals("This is an example and another one.", writer.toString());
        try {
            r.getOutputStream();
            fail("Once addText() is used the text is stored as a String and you cannot use getOutputStream anymore");
        } catch (IOException e) {
        }
        try {
            r.getWriter();
            fail("Once addText() is used the text is stored as a String and you cannot use getOutputStream anymore");
        } catch (IOException e) {
        }
        r.setEndState(ResponseStateOk.getInstance());
        assertTrue(r.hasEnded());
    }
} </s>
<s>class temp {    public void testStorageByteArray() throws Exception {
        TranslationResponseInMemory r = new TranslationResponseInMemory(2048, "UTF-8");
        {
            OutputStream output = r.getOutputStream();
            output.write("This is an example".getBytes("UTF-8"));
            output.write(" and another one.".getBytes("UTF-8"));
            assertEquals("This is an example and another one.", r.getText());
        }
        {
            InputStream input = r.getInputStream();
            StringWriter writer = new StringWriter();
            try {
                IOUtils.copy(input, writer, "UTF-8");
            } finally {
                input.close();
                writer.close();
            }
            assertEquals("This is an example and another one.", writer.toString());
        }
        {
            OutputStream output = r.getOutputStream();
            output.write(" and another line".getBytes("UTF-8"));
            assertEquals("This is an example and another one. and another line", r.getText());
        }
        {
            Writer output = r.getWriter();
            output.write(" and write some more");
            assertEquals("This is an example and another one. and another line and write some more", r.getText());
        }
        {
            r.addText(" and even more.");
            assertEquals("This is an example and another one. and another line and write some more and even more.", r.getText());
        }
        assertFalse(r.hasEnded());
        r.setEndState(ResponseStateOk.getInstance());
        assertTrue(r.hasEnded());
        try {
            r.getOutputStream();
            fail("Previous line should throw IOException as result closed.");
        } catch (IOException e) {
        }
        try {
            r.getWriter();
            fail("Previous line should throw IOException as result closed.");
        } catch (IOException e) {
        }
    }
} </s>
<s>class temp {    public void testStorageStringWriter() throws Exception {
        TranslationResponseInMemory r = new TranslationResponseInMemory(2048, "UTF-8");
        {
            Writer w = r.getWriter();
            w.write("This is an example");
            w.write(" and another one.");
            w.flush();
            assertEquals("This is an example and another one.", r.getText());
        }
        {
            InputStream input = r.getInputStream();
            StringWriter writer = new StringWriter();
            try {
                IOUtils.copy(input, writer, "UTF-8");
            } finally {
                input.close();
                writer.close();
            }
            assertEquals("This is an example and another one.", writer.toString());
        }
        try {
            r.getOutputStream();
            fail("Is not allowed as you already called getWriter().");
        } catch (IOException e) {
        }
        {
            Writer output = r.getWriter();
            output.write(" and another line");
            output.write(" and write some more");
            assertEquals("This is an example and another one. and another line and write some more", r.getText());
        }
        {
            r.addText(" and some more.");
            assertEquals("This is an example and another one. and another line and write some more and some more.", r.getText());
        }
        r.setEndState(ResponseStateOk.getInstance());
        assertEquals(ResponseStateOk.getInstance(), r.getEndState());
        try {
            r.getWriter();
            fail("Previous line should throw IOException as result closed.");
        } catch (IOException e) {
        }
    }
} </s>
<s>class temp {    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException {
        PrintWriter writer = null;
        InputStream is = null;
        FileOutputStream fos = null;
        try {
            writer = response.getWriter();
        } catch (IOException ex) {
            log(OctetStreamReader.class.getName() + "has thrown an exception: " + ex.getMessage());
        }
        String filename = request.getHeader("X-File-Name");
        try {
            is = request.getInputStream();
            fos = new FileOutputStream(new File(targetPath + filename));
            IOUtils.copy(is, fos);
            response.setStatus(HttpServletResponse.SC_OK);
            writer.print("{success: true}");
        } catch (FileNotFoundException ex) {
            response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
            writer.print("{success: false}");
            log(OctetStreamReader.class.getName() + "has thrown an exception: " + ex.getMessage());
        } catch (IOException ex) {
            response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
            writer.print("{success: false}");
            log(OctetStreamReader.class.getName() + "has thrown an exception: " + ex.getMessage());
        } finally {
            try {
                fos.close();
                is.close();
            } catch (IOException ignored) {
            }
        }
        writer.flush();
        writer.close();
    }
} </s>
<s>class temp {    protected void doBackupOrganizeType() throws Exception {
        Connection con = null;
        PreparedStatement ps = null;
        ResultSet result = null;
        String strSelQuery = "SELECT organize_type_id,organize_type_name,width " + "FROM " + Common.ORGANIZE_TYPE_TABLE;
        String strInsQuery = "INSERT INTO " + Common.ORGANIZE_TYPE_B_TABLE + " " + "(version_no,organize_type_id,organize_type_name,width) " + "VALUES (?,?,?,?)";
        DBOperation dbo = factory.createDBOperation(POOL_NAME);
        try {
            try {
                con = dbo.getConnection();
                con.setAutoCommit(false);
                ps = con.prepareStatement(strSelQuery);
                result = ps.executeQuery();
                ps = con.prepareStatement(strInsQuery);
                while (result.next()) {
                    ps.setInt(1, this.versionNO);
                    ps.setString(2, result.getString("organize_type_id"));
                    ps.setString(3, result.getString("organize_type_name"));
                    ps.setInt(4, result.getInt("width"));
                    int resultCount = ps.executeUpdate();
                    if (resultCount != 1) {
                        con.rollback();
                        throw new CesSystemException("Organize_backup.doBackupOrganizeType(): ERROR Inserting data " + "in T_SYS_ORGANIZE_B_TYPE INSERT !! resultCount = " + resultCount);
                    }
                }
                con.commit();
            } catch (SQLException se) {
                con.rollback();
                throw new CesSystemException("Organize_backup.doBackupOrganizeType(): SQLException:  " + se);
            } finally {
                con.setAutoCommit(true);
                close(dbo, ps, result);
            }
        } catch (SQLException se) {
            throw new CesSystemException("Organize_backup.doBackupOrganizeType(): SQLException while committing or rollback");
        }
    }
} </s>
<s>class temp {    protected void doBackupOrganizeTypeRelation() throws Exception {
        Connection con = null;
        PreparedStatement ps = null;
        ResultSet result = null;
        String strSelQuery = "SELECT parent_organize_type,child_organize_type " + "FROM " + Common.ORGANIZE_TYPE_RELATION_TABLE;
        String strInsQuery = "INSERT INTO " + Common.ORGANIZE_TYPE_RELATION_B_TABLE + " " + "(version_no,parent_organize_type,child_organize_type) " + "VALUES (?,?,?)";
        DBOperation dbo = factory.createDBOperation(POOL_NAME);
        try {
            try {
                con = dbo.getConnection();
                con.setAutoCommit(false);
                ps = con.prepareStatement(strSelQuery);
                result = ps.executeQuery();
                ps = con.prepareStatement(strInsQuery);
                while (result.next()) {
                    ps.setInt(1, this.versionNO);
                    ps.setString(2, result.getString("parent_organize_type"));
                    ps.setString(3, result.getString("child_organize_type"));
                    int resultCount = ps.executeUpdate();
                    if (resultCount != 1) {
                        con.rollback();
                        throw new CesSystemException("Organize_backup.doBackupOrganizeTypeRelation(): ERROR Inserting data " + "in T_SYS_ORGANIZE_TYPE_RELATION_B INSERT !! resultCount = " + resultCount);
                    }
                }
                con.commit();
            } catch (SQLException se) {
                con.rollback();
                throw new CesSystemException("Organize_backup.doBackupOrganizeTypeRelation(): SQLException:  " + se);
            } finally {
                con.setAutoCommit(true);
                close(dbo, ps, result);
            }
        } catch (SQLException se) {
            throw new CesSystemException("Organize_backup.doBackupOrganizeTypeRelation(): SQLException while committing or rollback");
        }
    }
} </s>
<s>class temp {    protected void doBackupOrganize() throws Exception {
        Connection con = null;
        PreparedStatement ps = null;
        ResultSet result = null;
        String strSelQuery = "SELECT organize_id,organize_type_id,organize_name,organize_manager," + "organize_describe,work_type,show_order,position_x,position_y " + "FROM " + Common.ORGANIZE_TABLE;
        String strInsQuery = "INSERT INTO " + Common.ORGANIZE_B_TABLE + " " + "(version_no,organize_id,organize_type_id,organize_name,organize_manager," + "organize_describe,work_type,show_order,position_x,position_y) " + "VALUES (?,?,?,?,?,?,?,?,?,?)";
        DBOperation dbo = factory.createDBOperation(POOL_NAME);
        try {
            try {
                con = dbo.getConnection();
                con.setAutoCommit(false);
                ps = con.prepareStatement(strSelQuery);
                result = ps.executeQuery();
                ps = con.prepareStatement(strInsQuery);
                while (result.next()) {
                    ps.setInt(1, this.versionNO);
                    ps.setString(2, result.getString("organize_id"));
                    ps.setString(3, result.getString("organize_type_id"));
                    ps.setString(4, result.getString("organize_name"));
                    ps.setString(5, result.getString("organize_manager"));
                    ps.setString(6, result.getString("organize_describe"));
                    ps.setString(7, result.getString("work_type"));
                    ps.setInt(8, result.getInt("show_order"));
                    ps.setInt(9, result.getInt("position_x"));
                    ps.setInt(10, result.getInt("position_y"));
                    int resultCount = ps.executeUpdate();
                    if (resultCount != 1) {
                        con.rollback();
                        throw new CesSystemException("Organize_backup.doBackupOrganize(): ERROR Inserting data " + "in T_SYS_ORGANIZE_B INSERT !! resultCount = " + resultCount);
                    }
                }
                con.commit();
            } catch (SQLException se) {
                con.rollback();
                throw new CesSystemException("Organize_backup.doBackupOrganize(): SQLException:  " + se);
            } finally {
                con.setAutoCommit(true);
                close(dbo, ps, result);
            }
        } catch (SQLException se) {
            throw new CesSystemException("Organize_backup.doBackupOrganize(): SQLException while committing or rollback");
        }
    }
} </s>
<s>class temp {    protected void doBackupOrganizeRelation() throws Exception {
        Connection con = null;
        PreparedStatement ps = null;
        ResultSet result = null;
        String strSelQuery = "SELECT organize_id,organize_type_id,child_id,child_type_id,remark " + "FROM " + Common.ORGANIZE_RELATION_TABLE;
        String strInsQuery = "INSERT INTO " + Common.ORGANIZE_RELATION_B_TABLE + " " + "(version_no,organize_id,organize_type,child_id,child_type,remark) " + "VALUES (?,?,?,?,?,?)";
        DBOperation dbo = factory.createDBOperation(POOL_NAME);
        try {
            try {
                con = dbo.getConnection();
                con.setAutoCommit(false);
                ps = con.prepareStatement(strSelQuery);
                result = ps.executeQuery();
                ps = con.prepareStatement(strInsQuery);
                while (result.next()) {
                    ps.setInt(1, this.versionNO);
                    ps.setString(2, result.getString("organize_id"));
                    ps.setString(3, result.getString("organize_type_id"));
                    ps.setString(4, result.getString("child_id"));
                    ps.setString(5, result.getString("child_type_id"));
                    ps.setString(6, result.getString("remark"));
                    int resultCount = ps.executeUpdate();
                    if (resultCount != 1) {
                        con.rollback();
                        throw new CesSystemException("Organize_backup.doBackupOrganizeRelation(): ERROR Inserting data " + "in T_SYS_ORGANIZE_RELATION_B INSERT !! resultCount = " + resultCount);
                    }
                }
                con.commit();
            } catch (SQLException se) {
                con.rollback();
                throw new CesSystemException("Organize_backup.doBackupOrganizeRelation(): SQLException:  " + se);
            } finally {
                con.setAutoCommit(true);
                close(dbo, ps, result);
            }
        } catch (SQLException se) {
            throw new CesSystemException("Organize_backup.doBackupOrganizeRelation(): SQLException while committing or rollback");
        }
    }
} </s>
<s>class temp {    protected void doRestoreOrganizeType() throws Exception {
        Connection con = null;
        PreparedStatement ps = null;
        ResultSet result = null;
        String strDelQuery = "DELETE FROM " + Common.ORGANIZE_TYPE_TABLE;
        String strSelQuery = "SELECT organize_type_id,organize_type_name,width " + "FROM " + Common.ORGANIZE_TYPE_B_TABLE + " " + "WHERE version_no = ?";
        String strInsQuery = "INSERT INTO " + Common.ORGANIZE_TYPE_TABLE + " " + "(organize_type_id,organize_type_name,width) " + "VALUES (?,?,?)";
        DBOperation dbo = factory.createDBOperation(POOL_NAME);
        try {
            try {
                con = dbo.getConnection();
                con.setAutoCommit(false);
                ps = con.prepareStatement(strDelQuery);
                ps.executeUpdate();
                ps = con.prepareStatement(strSelQuery);
                ps.setInt(1, this.versionNO);
                result = ps.executeQuery();
                ps = con.prepareStatement(strInsQuery);
                while (result.next()) {
                    ps.setString(1, result.getString("organize_type_id"));
                    ps.setString(2, result.getString("organize_type_name"));
                    ps.setInt(3, result.getInt("width"));
                    int resultCount = ps.executeUpdate();
                    if (resultCount != 1) {
                        con.rollback();
                        throw new CesSystemException("Organize_backup.doRestoreOrganizeType(): ERROR Inserting data " + "in T_SYS_ORGANIZE_TYPE INSERT !! resultCount = " + resultCount);
                    }
                }
                con.commit();
            } catch (SQLException se) {
                con.rollback();
                throw new CesSystemException("Organize_backup.doRestoreOrganizeType(): SQLException:  " + se);
            } finally {
                con.setAutoCommit(true);
                close(dbo, ps, result);
            }
        } catch (SQLException se) {
            throw new CesSystemException("Organize_backup.doRestoreOrganizeType(): SQLException while committing or rollback");
        }
    }
} </s>
<s>class temp {    protected void doRestoreOrganizeTypeRelation() throws Exception {
        Connection con = null;
        PreparedStatement ps = null;
        ResultSet result = null;
        String strDelQuery = "DELETE FROM " + Common.ORGANIZE_TYPE_RELATION_TABLE;
        String strSelQuery = "SELECT parent_organize_type,child_organize_type " + "FROM " + Common.ORGANIZE_TYPE_RELATION_B_TABLE + " " + "WHERE version_no = ?";
        String strInsQuery = "INSERT INTO " + Common.ORGANIZE_TYPE_RELATION_TABLE + " " + "(parent_organize_type,child_organize_type) " + "VALUES (?,?)";
        DBOperation dbo = factory.createDBOperation(POOL_NAME);
        try {
            try {
                con = dbo.getConnection();
                con.setAutoCommit(false);
                ps = con.prepareStatement(strDelQuery);
                ps.executeUpdate();
                ps = con.prepareStatement(strSelQuery);
                ps.setInt(1, this.versionNO);
                result = ps.executeQuery();
                ps = con.prepareStatement(strInsQuery);
                while (result.next()) {
                    ps.setString(1, result.getString("parent_organize_type"));
                    ps.setString(2, result.getString("child_organize_type"));
                    int resultCount = ps.executeUpdate();
                    if (resultCount != 1) {
                        con.rollback();
                        throw new CesSystemException("Organize_backup.doRestoreOrganizeTypeRelation(): ERROR Inserting data " + "in T_SYS_ORGANIZE_TYPE_RELATION INSERT !! resultCount = " + resultCount);
                    }
                }
                con.commit();
            } catch (SQLException se) {
                con.rollback();
                throw new CesSystemException("Organize_backup.doRestoreOrganizeTypeRelation(): SQLException:  " + se);
            } finally {
                con.setAutoCommit(true);
                close(dbo, ps, result);
            }
        } catch (SQLException se) {
            throw new CesSystemException("Organize_backup.doRestoreOrganizeTypeRelation(): SQLException while committing or rollback");
        }
    }
} </s>
<s>class temp {    protected void doRestoreOrganize() throws Exception {
        Connection con = null;
        PreparedStatement ps = null;
        ResultSet result = null;
        String strDelQuery = "DELETE FROM " + Common.ORGANIZE_TABLE;
        String strSelQuery = "SELECT organize_id,organize_type_id,organize_name,organize_manager," + "organize_describe,work_type,show_order,position_x,position_y " + "FROM " + Common.ORGANIZE_B_TABLE + " " + "WHERE version_no = ?";
        String strInsQuery = "INSERT INTO " + Common.ORGANIZE_TABLE + " " + "(organize_id,organize_type_id,organize_name,organize_manager," + "organize_describe,work_type,show_order,position_x,position_y) " + "VALUES (?,?,?,?,?,?,?,?,?)";
        DBOperation dbo = factory.createDBOperation(POOL_NAME);
        try {
            try {
                con = dbo.getConnection();
                con.setAutoCommit(false);
                ps = con.prepareStatement(strDelQuery);
                ps.executeUpdate();
                ps = con.prepareStatement(strSelQuery);
                ps.setInt(1, this.versionNO);
                result = ps.executeQuery();
                ps = con.prepareStatement(strInsQuery);
                while (result.next()) {
                    ps.setString(1, result.getString("organize_id"));
                    ps.setString(2, result.getString("organize_type_id"));
                    ps.setString(3, result.getString("organize_name"));
                    ps.setString(4, result.getString("organize_manager"));
                    ps.setString(5, result.getString("organize_describe"));
                    ps.setString(6, result.getString("work_type"));
                    ps.setInt(7, result.getInt("show_order"));
                    ps.setInt(8, result.getInt("position_x"));
                    ps.setInt(9, result.getInt("position_y"));
                    int resultCount = ps.executeUpdate();
                    if (resultCount != 1) {
                        con.rollback();
                        throw new CesSystemException("Organize_backup.doRestoreOrganize(): ERROR Inserting data " + "in T_SYS_ORGANIZE INSERT !! resultCount = " + resultCount);
                    }
                }
                con.commit();
            } catch (SQLException se) {
                con.rollback();
                throw new CesSystemException("Organize_backup.doRestoreOrganize(): SQLException:  " + se);
            } finally {
                con.setAutoCommit(true);
                close(dbo, ps, result);
            }
        } catch (SQLException se) {
            throw new CesSystemException("Organize_backup.doRestoreOrganize(): SQLException while committing or rollback");
        }
    }
} </s>
<s>class temp {    protected void doRestoreOrganizeRelation() throws Exception {
        Connection con = null;
        PreparedStatement ps = null;
        ResultSet result = null;
        String strDelQuery = "DELETE FROM " + Common.ORGANIZE_RELATION_TABLE;
        String strSelQuery = "SELECT organize_id,organize_type_id,child_id,child_type_id,remark " + "FROM " + Common.ORGANIZE_RELATION_B_TABLE + " " + "WHERE version_no = ?";
        String strInsQuery = "INSERT INTO " + Common.ORGANIZE_RELATION_TABLE + " " + "(organize_id,organize_type,child_id,child_type,remark) " + "VALUES (?,?,?,?,?)";
        DBOperation dbo = factory.createDBOperation(POOL_NAME);
        try {
            try {
                con = dbo.getConnection();
                con.setAutoCommit(false);
                ps = con.prepareStatement(strDelQuery);
                ps.executeUpdate();
                ps = con.prepareStatement(strSelQuery);
                ps.setInt(1, this.versionNO);
                result = ps.executeQuery();
                ps = con.prepareStatement(strInsQuery);
                while (result.next()) {
                    ps.setString(1, result.getString("organize_id"));
                    ps.setString(2, result.getString("organize_type_id"));
                    ps.setString(3, result.getString("child_id"));
                    ps.setString(4, result.getString("child_type_id"));
                    ps.setString(5, result.getString("remark"));
                    int resultCount = ps.executeUpdate();
                    if (resultCount != 1) {
                        con.rollback();
                        throw new CesSystemException("Organize_backup.doRestoreOrganizeRelation(): ERROR Inserting data " + "in T_SYS_ORGANIZE_RELATION INSERT !! resultCount = " + resultCount);
                    }
                }
                con.commit();
            } catch (SQLException se) {
                con.rollback();
                throw new CesSystemException("Organize_backup.doRestoreOrganizeRelation(): SQLException:  " + se);
            } finally {
                con.setAutoCommit(true);
                close(dbo, ps, result);
            }
        } catch (SQLException se) {
            throw new CesSystemException("Organize_backup.doRestoreOrganizeRelation(): SQLException while committing or rollback");
        }
    }
} </s>
<s>class temp {    protected void removeMessage(ReplicationMessage message) {
        logger.info(String.format("remove replication message: %d", message.getId()));
        ConnectionProvider cp = null;
        Connection conn = null;
        PreparedStatement ps = null;
        try {
            SessionFactoryImplementor impl = (SessionFactoryImplementor) portalDao.getSessionFactory();
            cp = impl.getConnectionProvider();
            conn = cp.getConnection();
            conn.setAutoCommit(false);
            ps = conn.prepareStatement("delete from light_replication_message where id=?");
            ps.setLong(1, message.getId());
            ps.executeUpdate();
            conn.commit();
            ps.close();
            conn.close();
        } catch (Exception e) {
            try {
                conn.rollback();
                ps.close();
                conn.close();
            } catch (Exception se) {
            }
        }
    }
} </s>
<s>class temp {    protected void syncMessages(Message message) {
        if (message.getEvent() == Event.CONNECT || message.getEvent() == Event.SYNC_DONE) return;
        logger.info(String.format("remove stale replication messages: %s", message.toString()));
        String className = "";
        long classId = 0;
        if (message.getBody() instanceof Entity) {
            Entity entity = (Entity) message.getBody();
            className = entity.getClass().getName();
            classId = entity.getId();
        }
        ConnectionProvider cp = null;
        Connection conn = null;
        PreparedStatement ps = null;
        try {
            SessionFactoryImplementor impl = (SessionFactoryImplementor) portalDao.getSessionFactory();
            cp = impl.getConnectionProvider();
            conn = cp.getConnection();
            conn.setAutoCommit(false);
            ps = conn.prepareStatement("delete from light_replication_message where event=? and className=? and classId=?");
            ps.setString(1, message.getEvent().toString());
            ps.setString(2, className);
            ps.setLong(3, classId);
            ps.executeUpdate();
            conn.commit();
            ps.close();
            conn.close();
        } catch (Exception e) {
            try {
                conn.rollback();
                ps.close();
                conn.close();
            } catch (Exception se) {
            }
        }
    }
} </s>
<s>class temp {    private List getPluginClassList(List pluginFileList) {
        ArrayList l = new ArrayList();
        for (Iterator i = pluginFileList.iterator(); i.hasNext(); ) {
            URL url = (URL) i.next();
            log.debug("Trying file " + url.toString());
            try {
                BufferedReader r = new BufferedReader(new InputStreamReader(url.openStream(), "utf-8"));
                String line;
                while ((line = r.readLine()) != null) {
                    line = line.trim();
                    if (line.length() == 0 || line.charAt(0) == '#') continue;
                    l.add(line);
                }
            } catch (Exception e) {
                log.warn("Could not load " + url, e);
            }
        }
        return l;
    }
} </s>
<s>class temp {    private final String createMD5(String pwd) throws Exception {
        MessageDigest md = (MessageDigest) MessageDigest.getInstance("MD5").clone();
        md.update(pwd.getBytes("UTF-8"));
        byte[] pd = md.digest();
        StringBuffer app = new StringBuffer();
        for (int i = 0; i < pd.length; i++) {
            String s2 = Integer.toHexString(pd[i] & 0xFF);
            app.append((s2.length() == 1) ? "0" + s2 : s2);
        }
        return app.toString();
    }
} </s>
<s>class temp {    public URLConnection makeURLcon() {
        URI uri;
        URL url;
        try {
            uri = new URI(this.URLString);
            url = uri.toURL();
            this.urlcon = (HttpURLConnection) url.openConnection();
        } catch (final URISyntaxException e) {
            e.printStackTrace();
        } catch (final MalformedURLException e) {
            e.printStackTrace();
        } catch (final IOException e) {
            e.printStackTrace();
        }
        return this.urlcon;
    }
} </s>
<s>class temp {    public static void readAsFile(String fileName, String url) {
        BufferedInputStream in = null;
        BufferedOutputStream out = null;
        URLConnection conn = null;
        try {
            conn = new URL(url).openConnection();
            conn.setDoInput(true);
            in = new BufferedInputStream(conn.getInputStream());
            out = new BufferedOutputStream(new FileOutputStream(fileName));
            int b;
            while ((b = in.read()) != -1) {
                out.write(b);
            }
        } catch (Exception ex) {
            log.error(ex.getMessage(), ex);
        } finally {
            if (null != in) {
                try {
                    in.close();
                } catch (IOException e) {
                }
            }
            if (null != out) {
                try {
                    out.flush();
                    out.close();
                } catch (IOException e) {
                }
            }
        }
    }
} </s>
<s>class temp {    private static BufferedReader createReaderConnection(String urlString) throws SiteNotFoundException {
        BufferedReader reader = null;
        try {
            URL url = new URL(urlString);
            HttpURLConnection conn = (HttpURLConnection) url.openConnection();
            conn.setRequestProperty("User-agent", "Mozilla/4.5");
            if (conn.getResponseCode() != HttpURLConnection.HTTP_OK) {
                Logger.logln("Response code for url [" + urlString + "] was " + conn.getResponseCode() + " [" + conn.getResponseMessage() + "]");
                throw new SiteNotFoundException(urlString);
            }
            reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));
        } catch (IOException ex) {
            Logger.logln("" + ex);
        }
        return reader;
    }
} </s>
<s>class temp {    private LinkedList<Datum> processDatum(Datum dataset) {
        ArrayList<Object[]> markerTestResults = new ArrayList<Object[]>();
        ArrayList<Object[]> alleleEstimateResults = new ArrayList<Object[]>();
        boolean hasAlleleNames = false;
        String blank = new String("");
        MarkerPhenotypeAdapter theAdapter;
        if (dataset.getDataType().equals(MarkerPhenotype.class)) {
            theAdapter = new MarkerPhenotypeAdapter((MarkerPhenotype) dataset.getData());
        } else theAdapter = new MarkerPhenotypeAdapter((Phenotype) dataset.getData());
        int numberOfMarkers = theAdapter.getNumberOfMarkers();
        if (numberOfMarkers == 0) {
            return calculateBLUEsFromPhenotypes(theAdapter, dataset.getName());
        }
        int numberOfCovariates = theAdapter.getNumberOfCovariates();
        int numberOfFactors = theAdapter.getNumberOfFactors();
        int numberOfPhenotypes = theAdapter.getNumberOfPhenotypes();
        int expectedIterations = numberOfPhenotypes * numberOfMarkers;
        int iterationsSofar = 0;
        int percentFinished = 0;
        File tempFile = null;
        File ftestFile = null;
        File blueFile = null;
        BufferedWriter ftestWriter = null;
        BufferedWriter BLUEWriter = null;
        String ftestHeader = "Trait\tMarker\tLocus\tLocus_pos\tChr\tChr_pos\tmarker_F\tmarker_p\tperm_p\tmarkerR2\tmarkerDF\tmarkerMS\terrorDF\terrorMS\tmodelDF\tmodelMS";
        String BLUEHeader = "Trait\tMarker\tObs\tLocus\tLocus_pos\tChr\tChr_pos\tAllele\tEstimate";
        if (writeOutputToFile) {
            String outputbase = outputName;
            if (outputbase.endsWith(".txt")) {
                int index = outputbase.lastIndexOf(".");
                outputbase = outputbase.substring(0, index);
            }
            String datasetNameNoSpace = dataset.getName().trim().replaceAll("\\ ", "_");
            ftestFile = new File(outputbase + "_" + datasetNameNoSpace + "_ftest.txt");
            int count = 0;
            while (ftestFile.exists()) {
                count++;
                ftestFile = new File(outputbase + "_" + datasetNameNoSpace + "_ftest" + count + ".txt");
            }
            blueFile = new File(outputbase + "_" + datasetNameNoSpace + "_BLUEs.txt");
            count = 0;
            while (blueFile.exists()) {
                count++;
                blueFile = new File(outputbase + "_" + datasetNameNoSpace + "_BLUEs" + count + ".txt");
            }
            tempFile = new File(outputbase + "_" + datasetNameNoSpace + "_ftest.tmp");
            try {
                if (permute) {
                    ftestWriter = new BufferedWriter(new FileWriter(tempFile));
                    ftestWriter.write(ftestHeader);
                    ftestWriter.newLine();
                } else {
                    ftestWriter = new BufferedWriter(new FileWriter(ftestFile));
                    ftestWriter.write(ftestHeader);
                    ftestWriter.newLine();
                }
                if (reportBLUEs) {
                    BLUEWriter = new BufferedWriter(new FileWriter(blueFile));
                    BLUEWriter.write(BLUEHeader);
                    BLUEWriter.newLine();
                }
            } catch (IOException e) {
                myLogger.error("Failed to open file for output");
                myLogger.error(e);
                return null;
            }
        }
        if (permute) {
            minP = new double[numberOfPhenotypes][numberOfPermutations];
            for (int i = 0; i < numberOfPermutations; i++) {
                for (int j = 0; j < numberOfPhenotypes; j++) {
                    minP[j][i] = 1;
                }
            }
        }
        for (int ph = 0; ph < numberOfPhenotypes; ph++) {
            double[] phenotypeData = theAdapter.getPhenotypeValues(ph);
            boolean[] missing = theAdapter.getMissingPhenotypes(ph);
            ArrayList<String[]> factorList = MarkerPhenotypeAdapterUtils.getFactorList(theAdapter, ph, missing);
            ArrayList<double[]> covariateList = MarkerPhenotypeAdapterUtils.getCovariateList(theAdapter, ph, missing);
            double[][] permutedData = null;
            if (permute) {
                permutedData = permuteData(phenotypeData, missing, factorList, covariateList, theAdapter);
            }
            for (int m = 0; m < numberOfMarkers; m++) {
                Object[] markerData = theAdapter.getMarkerValue(ph, m);
                boolean[] finalMissing = new boolean[missing.length];
                System.arraycopy(missing, 0, finalMissing, 0, missing.length);
                MarkerPhenotypeAdapterUtils.updateMissing(finalMissing, theAdapter.getMissingMarkers(ph, m));
                int[] nonmissingRows = MarkerPhenotypeAdapterUtils.getNonMissingIndex(finalMissing);
                int numberOfObs = nonmissingRows.length;
                double[] y = new double[numberOfObs];
                for (int i = 0; i < numberOfObs; i++) y[i] = phenotypeData[nonmissingRows[i]];
                int firstMarkerAlleleEstimate = 1;
                ArrayList<ModelEffect> modelEffects = new ArrayList<ModelEffect>();
                FactorModelEffect meanEffect = new FactorModelEffect(new int[numberOfObs], false);
                meanEffect.setID("mean");
                modelEffects.add(meanEffect);
                if (numberOfFactors > 0) {
                    for (int f = 0; f < numberOfFactors; f++) {
                        String[] afactor = factorList.get(f);
                        String[] factorLabels = new String[numberOfObs];
                        for (int i = 0; i < numberOfObs; i++) factorLabels[i] = afactor[nonmissingRows[i]];
                        FactorModelEffect fme = new FactorModelEffect(ModelEffectUtils.getIntegerLevels(factorLabels), true, theAdapter.getFactorName(f));
                        modelEffects.add(fme);
                        firstMarkerAlleleEstimate += fme.getNumberOfLevels() - 1;
                    }
                }
                if (numberOfCovariates > 0) {
                    for (int c = 0; c < numberOfCovariates; c++) {
                        double[] covar = new double[numberOfObs];
                        double[] covariateData = covariateList.get(c);
                        for (int i = 0; i < numberOfObs; i++) covar[i] = covariateData[nonmissingRows[i]];
                        modelEffects.add(new CovariateModelEffect(covar, theAdapter.getCovariateName(c)));
                        firstMarkerAlleleEstimate++;
                    }
                }
                ModelEffect markerEffect;
                boolean markerIsDiscrete = theAdapter.isMarkerDiscrete(m);
                ArrayList<Object> alleleNames = new ArrayList<Object>();
                if (markerIsDiscrete) {
                    Object[] markers = new Object[numberOfObs];
                    for (int i = 0; i < numberOfObs; i++) markers[i] = markerData[nonmissingRows[i]];
                    int[] markerLevels = ModelEffectUtils.getIntegerLevels(markers, alleleNames);
                    markerEffect = new FactorModelEffect(markerLevels, true, theAdapter.getMarkerName(m));
                    hasAlleleNames = true;
                } else {
                    double[] markerdbl = new double[numberOfObs];
                    for (int i = 0; i < numberOfObs; i++) markerdbl[i] = ((Double) markerData[nonmissingRows[i]]).doubleValue();
                    markerEffect = new CovariateModelEffect(markerdbl, theAdapter.getMarkerName(m));
                }
                int[] alleleCounts = markerEffect.getLevelCounts();
                modelEffects.add(markerEffect);
                int markerEffectNumber = modelEffects.size() - 1;
                Identifier[] taxaSublist = new Identifier[numberOfObs];
                Identifier[] taxa = theAdapter.getTaxa(ph);
                for (int i = 0; i < numberOfObs; i++) taxaSublist[i] = taxa[nonmissingRows[i]];
                boolean areTaxaReplicated = containsDuplicates(taxaSublist);
                double[] markerSSdf = null, errorSSdf = null, modelSSdf = null;
                double F, p;
                double[] beta = null;
                if (areTaxaReplicated && markerIsDiscrete) {
                    ModelEffect taxaEffect = new FactorModelEffect(ModelEffectUtils.getIntegerLevels(taxaSublist), true);
                    modelEffects.add(taxaEffect);
                    SweepFastNestedModel sfnm = new SweepFastNestedModel(modelEffects, y);
                    double[] taxaSSdf = sfnm.getTaxaInMarkerSSdf();
                    double[] residualSSdf = sfnm.getErrorSSdf();
                    markerSSdf = sfnm.getMarkerSSdf();
                    errorSSdf = sfnm.getErrorSSdf();
                    modelSSdf = sfnm.getModelcfmSSdf();
                    F = markerSSdf[0] / markerSSdf[1] / taxaSSdf[0] * taxaSSdf[1];
                    try {
                        p = LinearModelUtils.Ftest(F, markerSSdf[1], taxaSSdf[1]);
                    } catch (Exception e) {
                        p = Double.NaN;
                    }
                    beta = sfnm.getBeta();
                    int markerdf = (int) markerSSdf[1];
                    if (permute && markerdf > 0) {
                        updatePermutationPValues(ph, permutedData, nonMissingIndex(missing, finalMissing), getXfromModelEffects(modelEffects), sfnm.getInverseOfXtX(), markerdf);
                    }
                } else {
                    SweepFastLinearModel sflm = new SweepFastLinearModel(modelEffects, y);
                    modelSSdf = sflm.getModelcfmSSdf();
                    markerSSdf = sflm.getMarginalSSdf(markerEffectNumber);
                    errorSSdf = sflm.getResidualSSdf();
                    F = markerSSdf[0] / markerSSdf[1] / errorSSdf[0] * errorSSdf[1];
                    try {
                        p = LinearModelUtils.Ftest(F, markerSSdf[1], errorSSdf[1]);
                    } catch (Exception e) {
                        p = Double.NaN;
                    }
                    beta = sflm.getBeta();
                    int markerdf = (int) markerSSdf[1];
                    if (permute && markerdf > 0) {
                        updatePermutationPValues(ph, permutedData, nonMissingIndex(missing, finalMissing), getXfromModelEffects(modelEffects), sflm.getInverseOfXtX(), markerdf);
                    }
                }
                if (!filterOutput || p < maxp) {
                    String traitname = theAdapter.getPhenotypeName(ph);
                    if (traitname == null) traitname = blank;
                    String marker = theAdapter.getMarkerName(m);
                    if (marker == null) marker = blank;
                    String locus = theAdapter.getLocusName(m);
                    Integer site = new Integer(theAdapter.getLocusPosition(m));
                    String chrname = "";
                    Double chrpos = Double.NaN;
                    if (hasMap) {
                        int ndx = -1;
                        ndx = myMap.getMarkerIndex(marker);
                        if (ndx > -1) {
                            chrname = myMap.getChromosome(ndx);
                            chrpos = myMap.getGeneticPosition(ndx);
                        }
                    }
                    Object[] result = new Object[16];
                    int col = 0;
                    result[col++] = traitname;
                    result[col++] = marker;
                    result[col++] = locus;
                    result[col++] = site;
                    result[col++] = chrname;
                    result[col++] = chrpos;
                    result[col++] = new Double(F);
                    result[col++] = new Double(p);
                    result[col++] = Double.NaN;
                    result[col++] = new Double(markerSSdf[0] / (modelSSdf[0] + errorSSdf[0]));
                    result[col++] = new Double(markerSSdf[1]);
                    result[col++] = new Double(markerSSdf[0] / markerSSdf[1]);
                    result[col++] = new Double(errorSSdf[1]);
                    result[col++] = new Double(errorSSdf[0] / errorSSdf[1]);
                    result[col++] = new Double(modelSSdf[1]);
                    result[col++] = new Double(modelSSdf[0] / modelSSdf[1]);
                    if (writeOutputToFile) {
                        StringBuilder sb = new StringBuilder();
                        sb.append(result[0]);
                        for (int i = 1; i < 16; i++) sb.append("\t").append(result[i]);
                        try {
                            ftestWriter.write(sb.toString());
                            ftestWriter.newLine();
                        } catch (IOException e) {
                            myLogger.error("Failed to write output to ftest file. Ending prematurely");
                            try {
                                ftestWriter.flush();
                                BLUEWriter.flush();
                            } catch (Exception e1) {
                            }
                            myLogger.error(e);
                            return null;
                        }
                    } else {
                        markerTestResults.add(result);
                    }
                    int numberOfMarkerAlleles = alleleNames.size();
                    if (numberOfMarkerAlleles == 0) numberOfMarkerAlleles++;
                    for (int i = 0; i < numberOfMarkerAlleles; i++) {
                        result = new Object[9];
                        result[0] = traitname;
                        result[1] = marker;
                        result[2] = new Integer(alleleCounts[i]);
                        result[3] = locus;
                        result[4] = site;
                        result[5] = chrname;
                        result[6] = chrpos;
                        if (numberOfMarkerAlleles == 1) result[7] = ""; else result[7] = alleleNames.get(i);
                        if (i == numberOfMarkerAlleles - 1) result[8] = 0.0; else result[8] = beta[firstMarkerAlleleEstimate + i];
                        if (writeOutputToFile) {
                            StringBuilder sb = new StringBuilder();
                            sb.append(result[0]);
                            for (int j = 1; j < 9; j++) sb.append("\t").append(result[j]);
                            try {
                                BLUEWriter.write(sb.toString());
                                BLUEWriter.newLine();
                            } catch (IOException e) {
                                myLogger.error("Failed to write output to ftest file. Ending prematurely");
                                try {
                                    ftestWriter.flush();
                                    BLUEWriter.flush();
                                } catch (Exception e1) {
                                }
                                myLogger.error(e);
                                return null;
                            }
                        } else {
                            alleleEstimateResults.add(result);
                        }
                    }
                }
                int tmpPercent = ++iterationsSofar * 100 / expectedIterations;
                if (tmpPercent > percentFinished) {
                    percentFinished = tmpPercent;
                    fireProgress(percentFinished);
                }
            }
        }
        fireProgress(0);
        if (writeOutputToFile) {
            try {
                ftestWriter.close();
                BLUEWriter.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        HashMap<String, Integer> traitnameMap = new HashMap<String, Integer>();
        if (permute) {
            for (int ph = 0; ph < numberOfPhenotypes; ph++) {
                Arrays.sort(minP[ph]);
                traitnameMap.put(theAdapter.getPhenotypeName(ph), ph);
            }
            if (writeOutputToFile) {
                try {
                    BufferedReader tempReader = new BufferedReader(new FileReader(tempFile));
                    ftestWriter = new BufferedWriter(new FileWriter(ftestFile));
                    ftestWriter.write(tempReader.readLine());
                    ftestWriter.newLine();
                    String input;
                    String[] data;
                    Pattern tab = Pattern.compile("\t");
                    while ((input = tempReader.readLine()) != null) {
                        data = tab.split(input);
                        String trait = data[0];
                        double pval = Double.parseDouble(data[7]);
                        int ph = traitnameMap.get(trait);
                        int ndx = Arrays.binarySearch(minP[ph], pval);
                        if (ndx < 0) ndx = -ndx - 1;
                        if (ndx == 0) ndx = 1;
                        data[8] = Double.toString((double) ndx / (double) numberOfPermutations);
                        ftestWriter.write(data[0]);
                        for (int i = 1; i < data.length; i++) {
                            ftestWriter.write("\t");
                            ftestWriter.write(data[i]);
                        }
                        ftestWriter.newLine();
                    }
                    tempReader.close();
                    ftestWriter.close();
                    tempFile.delete();
                } catch (IOException e) {
                    myLogger.error(e);
                }
            } else {
                for (Object[] result : markerTestResults) {
                    String trait = result[0].toString();
                    double pval = (Double) result[7];
                    int ph = traitnameMap.get(trait);
                    int ndx = Arrays.binarySearch(minP[ph], pval);
                    if (ndx < 0) ndx = -ndx - 1;
                    if (ndx == 0) ndx = 1;
                    result[8] = new Double((double) ndx / (double) numberOfPermutations);
                }
            }
        }
        String[] columnLabels = new String[] { "Trait", "Marker", "Locus", "Locus_pos", "Chr", "Chr_pos", "marker_F", "marker_p", "perm_p", "markerR2", "markerDF", "markerMS", "errorDF", "errorMS", "modelDF", "modelMS" };
        boolean hasMarkerNames = theAdapter.hasMarkerNames();
        LinkedList<Integer> outputList = new LinkedList<Integer>();
        outputList.add(0);
        if (hasMarkerNames) outputList.add(1);
        outputList.add(2);
        outputList.add(3);
        if (hasMap) {
            outputList.add(4);
            outputList.add(5);
        }
        outputList.add(6);
        outputList.add(7);
        if (permute) outputList.add(8);
        for (int i = 9; i < 16; i++) outputList.add(i);
        LinkedList<Datum> resultset = new LinkedList<Datum>();
        int nrows = markerTestResults.size();
        Object[][] table = new Object[nrows][];
        int numberOfColumns = outputList.size();
        String[] colnames = new String[numberOfColumns];
        int count = 0;
        for (Integer ndx : outputList) colnames[count++] = columnLabels[ndx];
        for (int i = 0; i < nrows; i++) {
            table[i] = new Object[numberOfColumns];
            Object[] result = markerTestResults.get(i);
            count = 0;
            for (Integer ndx : outputList) table[i][count++] = result[ndx];
        }
        StringBuilder tableName = new StringBuilder("GLM_marker_test_");
        tableName.append(dataset.getName());
        StringBuilder comments = new StringBuilder("Tests of Marker-Phenotype Association");
        comments.append("GLM: fixed effect linear model\n");
        comments.append("Data set: ").append(dataset.getName());
        comments.append("\nmodel: trait = mean");
        for (int i = 0; i < theAdapter.getNumberOfFactors(); i++) {
            comments.append(" + ");
            comments.append(theAdapter.getFactorName(i));
        }
        for (int i = 0; i < theAdapter.getNumberOfCovariates(); i++) {
            comments.append(" + ");
            comments.append(theAdapter.getCovariateName(i));
        }
        comments.append(" + marker");
        if (writeOutputToFile) {
            comments.append("\nOutput written to " + ftestFile.getPath());
        }
        TableReport markerTestReport = new SimpleTableReport("Marker Test", colnames, table);
        resultset.add(new Datum(tableName.toString(), markerTestReport, comments.toString()));
        int[] outputIndex;
        columnLabels = new String[] { "Trait", "Marker", "Obs", "Locus", "Locus_pos", "Chr", "Chr_pos", "Allele", "Estimate" };
        if (hasAlleleNames) {
            if (hasMarkerNames && hasMap) {
                outputIndex = new int[] { 0, 1, 2, 3, 4, 5, 6, 7, 8 };
            } else if (hasMarkerNames) {
                outputIndex = new int[] { 0, 1, 2, 3, 4, 7, 8 };
            } else if (hasMap) {
                outputIndex = new int[] { 0, 2, 3, 4, 5, 6, 7, 8 };
            } else {
                outputIndex = new int[] { 0, 2, 3, 4, 7, 8 };
            }
        } else {
            if (hasMarkerNames && hasMap) {
                outputIndex = new int[] { 0, 1, 2, 3, 4, 5, 6, 8 };
            } else if (hasMarkerNames) {
                outputIndex = new int[] { 0, 1, 2, 3, 4, 8 };
            } else if (hasMap) {
                outputIndex = new int[] { 0, 2, 3, 4, 5, 6, 8 };
            } else {
                outputIndex = new int[] { 0, 2, 3, 4, 8 };
            }
        }
        nrows = alleleEstimateResults.size();
        table = new Object[nrows][];
        numberOfColumns = outputIndex.length;
        colnames = new String[numberOfColumns];
        for (int j = 0; j < numberOfColumns; j++) {
            colnames[j] = columnLabels[outputIndex[j]];
        }
        for (int i = 0; i < nrows; i++) {
            table[i] = new Object[numberOfColumns];
            Object[] result = alleleEstimateResults.get(i);
            for (int j = 0; j < numberOfColumns; j++) {
                table[i][j] = result[outputIndex[j]];
            }
        }
        tableName = new StringBuilder("GLM allele estimates for ");
        tableName.append(dataset.getName());
        comments = new StringBuilder("Marker allele effect estimates\n");
        comments.append("GLM: fixed effect linear model\n");
        comments.append("Data set: ").append(dataset.getName());
        comments.append("\nmodel: trait = mean");
        for (int i = 0; i < theAdapter.getNumberOfFactors(); i++) {
            comments.append(" + ");
            comments.append(theAdapter.getFactorName(i));
        }
        for (int i = 0; i < theAdapter.getNumberOfCovariates(); i++) {
            comments.append(" + ");
            comments.append(theAdapter.getCovariateName(i));
        }
        comments.append(" + marker");
        if (writeOutputToFile) {
            comments.append("\nOutput written to " + blueFile.getPath());
        }
        TableReport alleleEstimateReport = new SimpleTableReport("Allele Estimates", colnames, table);
        resultset.add(new Datum(tableName.toString(), alleleEstimateReport, comments.toString()));
        fireProgress(0);
        return resultset;
    }
} </s>
<s>class temp {    @Override
    public InputStream getInputStream() throws IOException {
        if (dfos == null) {
            int deferredOutputStreamThreshold = Config.getInstance().getDeferredOutputStreamThreshold();
            dfos = new DeferredFileOutputStream(deferredOutputStreamThreshold, Definitions.PROJECT_NAME, "." + Definitions.TMP_EXTENSION);
            try {
                IOUtils.copy(is, dfos);
            } finally {
                dfos.close();
            }
        }
        return dfos.getDeferredInputStream();
    }
} </s>
<s>class temp {    private static void readAndRewrite(File inFile, File outFile) throws IOException {
        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));
        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);
        Dataset ds = DcmObjectFactory.getInstance().newDataset();
        dcmParser.setDcmHandler(ds.getDcmHandler());
        dcmParser.parseDcmFile(null, Tags.PixelData);
        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        System.out.println("reading " + inFile + "...");
        pdReader.readPixelData(false);
        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));
        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;
        ds.writeDataset(out, dcmEncParam);
        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());
        System.out.println("writing " + outFile + "...");
        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        pdWriter.writePixelData();
        out.flush();
        out.close();
        System.out.println("done!");
    }
} </s>
<s>class temp {    public static String md5Crypt(final byte[] key, final byte[] salt) throws NoSuchAlgorithmException {
        if (key == null || key.length == 0) {
            throw new IllegalArgumentException("Argument 'key' cannot be null or an empty array.");
        }
        if (salt == null || salt.length == 0) {
            throw new IllegalArgumentException("Argument 'salt' cannot be null or an empty array.");
        }
        final MessageDigest _md = MessageDigest.getInstance("MD5");
        _md.update(key);
        _md.update(MAGIC.getBytes());
        _md.update(salt);
        final MessageDigest md2 = MessageDigest.getInstance("MD5");
        md2.update(key);
        md2.update(salt);
        md2.update(key);
        byte[] abyFinal = md2.digest();
        for (int n = key.length; n > 0; n -= 16) {
            _md.update(abyFinal, 0, n > 16 ? 16 : n);
        }
        abyFinal = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
        for (int j = 0, i = key.length; i != 0; i >>>= 1) {
            if ((i & 1) == 1) _md.update(abyFinal, j, 1); else _md.update(key, j, 1);
        }
        final StringBuilder sbPasswd = new StringBuilder();
        sbPasswd.append(MAGIC);
        sbPasswd.append(new String(salt));
        sbPasswd.append('$');
        abyFinal = _md.digest();
        for (int n = 0; n < 1000; n++) {
            final MessageDigest md3 = MessageDigest.getInstance("MD5");
            if ((n & 1) != 0) {
                md3.update(key);
            } else {
                md3.update(abyFinal);
            }
            if ((n % 3) != 0) {
                md3.update(salt);
            }
            if ((n % 7) != 0) {
                md3.update(key);
            }
            if ((n & 1) != 0) {
                md3.update(abyFinal);
            } else {
                md3.update(key);
            }
            abyFinal = md3.digest();
        }
        int[] anFinal = new int[] { (abyFinal[0] & 0x7f) | (abyFinal[0] & 0x80), (abyFinal[1] & 0x7f) | (abyFinal[1] & 0x80), (abyFinal[2] & 0x7f) | (abyFinal[2] & 0x80), (abyFinal[3] & 0x7f) | (abyFinal[3] & 0x80), (abyFinal[4] & 0x7f) | (abyFinal[4] & 0x80), (abyFinal[5] & 0x7f) | (abyFinal[5] & 0x80), (abyFinal[6] & 0x7f) | (abyFinal[6] & 0x80), (abyFinal[7] & 0x7f) | (abyFinal[7] & 0x80), (abyFinal[8] & 0x7f) | (abyFinal[8] & 0x80), (abyFinal[9] & 0x7f) | (abyFinal[9] & 0x80), (abyFinal[10] & 0x7f) | (abyFinal[10] & 0x80), (abyFinal[11] & 0x7f) | (abyFinal[11] & 0x80), (abyFinal[12] & 0x7f) | (abyFinal[12] & 0x80), (abyFinal[13] & 0x7f) | (abyFinal[13] & 0x80), (abyFinal[14] & 0x7f) | (abyFinal[14] & 0x80), (abyFinal[15] & 0x7f) | (abyFinal[15] & 0x80) };
        to64(sbPasswd, anFinal[0] << 16 | anFinal[6] << 8 | anFinal[12], 4);
        to64(sbPasswd, anFinal[1] << 16 | anFinal[7] << 8 | anFinal[13], 4);
        to64(sbPasswd, anFinal[2] << 16 | anFinal[8] << 8 | anFinal[14], 4);
        to64(sbPasswd, anFinal[3] << 16 | anFinal[9] << 8 | anFinal[15], 4);
        to64(sbPasswd, anFinal[4] << 16 | anFinal[10] << 8 | anFinal[5], 4);
        to64(sbPasswd, anFinal[11], 2);
        return sbPasswd.toString();
    }
} </s>
<s>class temp {        private void inject(int x, int y) throws IOException {
            Tag source = data.getTag();
            Log.event(Log.DEBUG_INFO, "source: " + source.getString());
            if (source == Tag.ORGANISM) {
                String seed = data.readString();
                data.readTag(Tag.STREAM);
                injectCodeTape(data.getIn(), seed, x, y);
            } else if (source == Tag.URL) {
                String url = data.readString();
                String seed = url.substring(url.lastIndexOf('.') + 1);
                BufferedReader urlIn = null;
                try {
                    urlIn = new BufferedReader(new InputStreamReader(new URL(url).openStream()));
                    injectCodeTape(urlIn, seed, x, y);
                } finally {
                    if (urlIn != null) urlIn.close();
                }
            } else data.writeString("unknown organism source: " + source.getString());
        }
} </s>
<s>class temp {    @Override
    public void incluir(Igreja igreja) throws Exception {
        Connection connection = criaConexao(false);
        String sql = "insert into igreja ? as idlocal, ? as possui_salao;";
        String sql2 = "SELECT MAX(idlocal) FROM Local";
        PreparedStatement stmt = null;
        PreparedStatement stmt2 = null;
        ResultSet rs = null;
        try {
            stmt = connection.prepareStatement(sql);
            stmt2 = connection.prepareStatement(sql2);
            rs = stmt2.executeQuery();
            stmt.setInt(1, rs.getInt("max"));
            stmt.setBoolean(2, igreja.getPossuiSalao());
            int retorno = stmt.executeUpdate();
            if (retorno == 0) {
                connection.rollback();
                throw new SQLException("Ocorreu um erro inesperado no momento de inserir dados de cliente no banco!");
            }
            connection.commit();
        } catch (SQLException e) {
            connection.rollback();
            throw e;
        } finally {
            try {
                stmt.close();
                stmt2.close();
                rs.close();
                this.fechaConexao();
            } catch (SQLException e) {
                throw e;
            }
        }
    }
} </s>
<s>class temp {    public int create(BusinessObject o) throws DAOException {
        int insert = 0;
        int id = 0;
        Project project = (Project) o;
        try {
            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery("INSERT_PROJECT"));
            pst.setString(1, project.getName());
            pst.setString(2, project.getDescription());
            pst.setInt(3, project.getIdAccount());
            pst.setInt(4, project.getIdContact());
            insert = pst.executeUpdate();
            if (insert <= 0) {
                connection.rollback();
                throw new DAOException("Number of rows <= 0");
            } else if (insert > 1) {
                connection.rollback();
                throw new DAOException("Number of rows > 1");
            }
            Statement st = connection.createStatement();
            ResultSet rs = st.executeQuery("select max(id_project) from project");
            rs.next();
            id = rs.getInt(1);
            connection.commit();
        } catch (SQLException e) {
            Log.write(e.getMessage());
            throw new DAOException("A SQLException has occured");
        } catch (NullPointerException npe) {
            Log.write(npe.getMessage());
            throw new DAOException("Connection null");
        }
        return id;
    }
} </s>
<s>class temp {    public int delete(BusinessObject o) throws DAOException {
        int delete = 0;
        Project project = (Project) o;
        try {
            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery("DELETE_PROJECT"));
            pst.setInt(1, project.getId());
            delete = pst.executeUpdate();
            if (delete <= 0) {
                connection.rollback();
                throw new DAOException("Number of rows <= 0");
            } else if (delete > 1) {
                connection.rollback();
                throw new DAOException("Number of rows > 1");
            }
            connection.commit();
        } catch (SQLException e) {
            Log.write(e.getMessage());
            throw new DAOException("A SQLException has occured");
        } catch (NullPointerException npe) {
            Log.write(npe.getMessage());
            throw new DAOException("Connection null");
        }
        return delete;
    }
} </s>
<s>class temp {    public int update(BusinessObject o) throws DAOException {
        int update = 0;
        Project project = (Project) o;
        try {
            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery("UPDATE_PROJECT"));
            pst.setString(1, project.getName());
            pst.setString(2, project.getDescription());
            pst.setInt(3, project.getIdAccount());
            pst.setInt(4, project.getIdContact());
            pst.setBoolean(5, project.isArchived());
            pst.setInt(6, project.getId());
            update = pst.executeUpdate();
            if (update <= 0) {
                connection.rollback();
                throw new DAOException("Number of rows <= 0");
            } else if (update > 1) {
                connection.rollback();
                throw new DAOException("Number of rows > 1");
            }
            connection.commit();
        } catch (SQLException e) {
            Log.write(e.getMessage());
            throw new DAOException("A SQLException has occured");
        } catch (NullPointerException npe) {
            Log.write(npe.getMessage());
            throw new DAOException("Connection null");
        }
        return update;
    }
} </s>
<s>class temp {    public static void testMapSource(MapSource mapSource, EastNorthCoordinate coordinate) {
        try {
            System.out.println("Testing " + mapSource.toString());
            int zoom = mapSource.getMinZoom() + ((mapSource.getMaxZoom() - mapSource.getMinZoom()) / 2);
            MapSpace mapSpace = mapSource.getMapSpace();
            int tilex = mapSpace.cLonToX(coordinate.lon, zoom) / mapSpace.getTileSize();
            int tiley = mapSpace.cLatToY(coordinate.lat, zoom) / mapSpace.getTileSize();
            url = new URL(mapSource.getTileUrl(zoom, tilex, tiley));
            System.out.println("Sample url: " + url);
            c = (HttpURLConnection) url.openConnection();
            System.out.println("Connecting...");
            c.connect();
            System.out.println("Connection established - response HTTP " + c.getResponseCode());
            if (c.getResponseCode() != 200) return;
            String contentType = c.getContentType();
            System.out.print("Image format          : ");
            if ("image/png".equals(contentType)) System.out.println("png"); else if ("image/jpeg".equals(contentType)) System.out.println("jpg"); else System.out.println("unknown");
            String eTag = c.getHeaderField("ETag");
            boolean eTagSupported = (eTag != null);
            if (eTagSupported) {
                System.out.println("eTag                  : " + eTag);
                testIfNoneMatch();
            } else System.out.println("eTag                  : -");
            long date = c.getDate();
            if (date == 0) System.out.println("Date time             : -"); else System.out.println("Date time             : " + new Date(date));
            long exp = c.getExpiration();
            if (exp == 0) System.out.println("Expiration time       : -"); else System.out.println("Expiration time       : " + new Date(exp));
            long modified = c.getLastModified();
            if (modified == 0) System.out.println("Last modified time    : not set"); else System.out.println("Last modified time    : " + new Date(modified));
            testIfModified();
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println("\n");
    }
} </s>
<s>class temp {    private static void testIfNoneMatch() throws Exception {
        String eTag = c.getHeaderField("ETag");
        InputStream in = c.getInputStream();
        byte[] buffer = new byte[1024];
        int read = 0;
        MessageDigest md5 = MessageDigest.getInstance("MD5");
        md5.reset();
        do {
            read = in.read(buffer);
            if (read > 0) md5.update(buffer, 0, read);
        } while (read < 0);
        byte[] digest = md5.digest();
        String hexDigest = getHexString(digest);
        if (hexDigest.equals(eTag)) System.out.print("eTag content          : md5 hex string");
        String quotedHexDigest = "\"" + hexDigest + "\"";
        if (quotedHexDigest.equals(eTag)) System.out.print("eTag content          : quoted md5 hex string");
        HttpURLConnection c2 = (HttpURLConnection) url.openConnection();
        c2.addRequestProperty("If-None-Match", eTag);
        c2.connect();
        int code = c2.getResponseCode();
        System.out.print("If-None-Match response: ");
        boolean supported = (code == 304);
        System.out.println(b2s(supported) + " - " + code + " (" + c2.getResponseMessage() + ")");
    }
} </s>
<s>class temp {    private static void testIfModified() throws IOException {
        HttpURLConnection c2 = (HttpURLConnection) url.openConnection();
        c2.setIfModifiedSince(System.currentTimeMillis() + 1000);
        c2.connect();
        int code = c2.getResponseCode();
        System.out.print("If-Modified-Since     : ");
        boolean supported = (code == 304);
        System.out.println(b2s(supported) + " - " + code + " (" + c2.getResponseMessage() + ")");
    }
} </s>
<s>class temp {    private boolean doesURLExists(String programURIStr) throws Exception {
        boolean retVal = true;
        TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {

            public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                return null;
            }

            public void checkClientTrusted(X509Certificate[] certs, String authType) {
            }

            public void checkServerTrusted(X509Certificate[] certs, String authType) {
            }
        } };
        SSLContext sc = SSLContext.getInstance("SSL");
        sc.init(null, trustAllCerts, new java.security.SecureRandom());
        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
        HostnameVerifier allHostsValid = new HostnameVerifier() {

            public boolean verify(String hostname, SSLSession session) {
                return true;
            }
        };
        HttpsURLConnection.setDefaultHostnameVerifier(allHostsValid);
        URL url = new URL(programURIStr);
        HttpURLConnection urlConn = (HttpURLConnection) url.openConnection();
        urlConn.setConnectTimeout(30000);
        urlConn.connect();
        log.debug("HTTP Status code: " + urlConn.getResponseCode() + " for URL: " + programURIStr);
        if (HttpURLConnection.HTTP_OK != urlConn.getResponseCode()) {
            urlConn.disconnect();
            throw new Exception("HTTP status code " + urlConn.getResponseCode() + " for " + programURIStr);
        }
        urlConn.disconnect();
        return retVal;
    }
} </s>

<s>class temp {    public void testHttpsConnection() throws Throwable {
        setUpStoreProperties();
        try {
            SSLContext ctx = getContext();
            ServerSocket ss = ctx.getServerSocketFactory().createServerSocket(0);
            TestHostnameVerifier hnv = new TestHostnameVerifier();
            HttpsURLConnection.setDefaultHostnameVerifier(hnv);
            URL url = new URL("https://localhost:" + ss.getLocalPort());
            HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
            SSLSocket peerSocket = (SSLSocket) doInteraction(connection, ss);
            checkConnectionStateParameters(connection, peerSocket);
            connection.connect();
        } finally {
            tearDownStoreProperties();
        }
    }
} </s>
<s>class temp {    public void testHttpsPersistentConnection() throws Throwable {
        setUpStoreProperties();
        try {
            SSLContext ctx = getContext();
            ServerSocket ss = ctx.getServerSocketFactory().createServerSocket(0);
            TestHostnameVerifier hnv = new TestHostnameVerifier();
            HttpsURLConnection.setDefaultHostnameVerifier(hnv);
            URL url = new URL("https://localhost:" + ss.getLocalPort());
            HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
            SSLSocket peerSocket = (SSLSocket) doPersistentInteraction(connection, ss);
            checkConnectionStateParameters(connection, peerSocket);
            connection.connect();
        } finally {
            tearDownStoreProperties();
        }
    }
} </s>
<s>class temp {    public void testHttpsConnection_Not_Found_Response() throws Throwable {
        setUpStoreProperties();
        try {
            SSLContext ctx = getContext();
            ServerSocket ss = ctx.getServerSocketFactory().createServerSocket(0);
            TestHostnameVerifier hnv = new TestHostnameVerifier();
            HttpsURLConnection.setDefaultHostnameVerifier(hnv);
            URL url = new URL("https://localhost:" + ss.getLocalPort());
            HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
            try {
                doInteraction(connection, ss, NOT_FOUND_CODE);
                fail("Expected exception was not thrown.");
            } catch (FileNotFoundException e) {
                if (DO_LOG) {
                    System.out.println("Expected exception was thrown: " + e.getMessage());
                }
            }
            connection.connect();
        } finally {
            tearDownStoreProperties();
        }
    }
} </s>
<s>class temp {    public static String generateMessageId(String plain) {
        byte[] cipher = new byte[35];
        String messageId = null;
        try {
            MessageDigest md5 = MessageDigest.getInstance("MD5");
            md5.update(plain.getBytes());
            cipher = md5.digest();
            StringBuffer sb = new StringBuffer();
            for (int i = 0; i < cipher.length; i++) {
                String hex = Integer.toHexString(0xff & cipher[i]);
                if (hex.length() == 1) sb.append('0');
                sb.append(hex);
            }
            StringBuffer pass = new StringBuffer();
            pass.append(sb.substring(0, 6));
            pass.append("H");
            pass.append(sb.substring(6, 11));
            pass.append("H");
            pass.append(sb.substring(11, 21));
            pass.append("H");
            pass.append(sb.substring(21));
            messageId = new String(pass);
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        return messageId;
    }
} </s>
<s>class temp {    public static boolean reportException(Throwable ex, HashMap<String, String> suppl) {
        if (Activator.getDefault().getPreferenceStore().getBoolean(PreferenceConstants.P_CRASH_REPORTING)) {
            logger.debug("Report exception to devs...");
            String data = "reportType=exception&" + "message=" + ex.getMessage();
            data += "&build=" + Platform.getBundle("de.uni_mannheim.swt.codeconjurer").getHeaders().get("Bundle-Version");
            int ln = 0;
            for (StackTraceElement el : ex.getStackTrace()) {
                data += "&st_line_" + ++ln + "=" + el.getClassName() + "#" + el.getMethodName() + "<" + el.getLineNumber() + ">";
            }
            data += "&lines=" + ln;
            data += "&Suppl-Description=" + ex.toString();
            data += "&Suppl-Server=" + Activator.getDefault().getPreferenceStore().getString(PreferenceConstants.P_SERVER);
            data += "&Suppl-User=" + Activator.getDefault().getPreferenceStore().getString(PreferenceConstants.P_USERNAME);
            if (suppl != null) {
                for (String key : suppl.keySet()) {
                    data += "&Suppl-" + key + "=" + suppl.get(key);
                }
            }
            try {
                URL url = new URL("http://www.merobase.com:7777/org.code_conjurer.udc/CrashReport");
                URLConnection conn = url.openConnection();
                conn.setDoOutput(true);
                OutputStreamWriter writer = new OutputStreamWriter(conn.getOutputStream());
                writer.write(data);
                writer.flush();
                StringBuffer answer = new StringBuffer();
                BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));
                String line;
                while ((line = reader.readLine()) != null) {
                    answer.append(line + "\r\n");
                }
                writer.close();
                reader.close();
                logger.debug(answer.toString());
            } catch (Exception e) {
                logger.debug("Could not report exception");
                return false;
            }
            return true;
        } else {
            logger.debug("Reporting not wished!");
            return false;
        }
    }
} </s>
<s>class temp {    public static String crypt(String password, String salt) throws java.security.NoSuchAlgorithmException {
        int saltEnd;
        int len;
        int value;
        int i;
        MessageDigest hash1;
        MessageDigest hash2;
        byte[] digest;
        byte[] passwordBytes;
        byte[] saltBytes;
        StringBuffer result;
        if (salt.startsWith(magic)) {
            salt = salt.substring(magic.length());
        }
        if ((saltEnd = salt.indexOf('$')) != -1) {
            salt = salt.substring(0, saltEnd);
        }
        if (salt.length() > 8) {
            salt = salt.substring(0, 8);
        }
        hash1 = MessageDigest.getInstance("MD5");
        hash1.update(password.getBytes());
        hash1.update(magic.getBytes());
        hash1.update(salt.getBytes());
        hash2 = MessageDigest.getInstance("MD5");
        hash2.update(password.getBytes());
        hash2.update(salt.getBytes());
        hash2.update(password.getBytes());
        digest = hash2.digest();
        for (len = password.length(); len > 0; len -= 16) {
            hash1.update(digest, 0, len > 16 ? 16 : len);
        }
        passwordBytes = password.getBytes();
        for (i = password.length(); i > 0; i >>= 1) {
            if ((i & 1) == 1) {
                hash1.update((byte) 0);
            } else {
                hash1.update(passwordBytes, 0, 1);
            }
        }
        result = new StringBuffer(magic);
        result.append(salt);
        result.append("$");
        digest = hash1.digest();
        saltBytes = salt.getBytes();
        for (i = 0; i < 1000; i++) {
            hash2.reset();
            if ((i & 1) == 1) {
                hash2.update(passwordBytes);
            } else {
                hash2.update(digest);
            }
            if (i % 3 != 0) {
                hash2.update(saltBytes);
            }
            if (i % 7 != 0) {
                hash2.update(passwordBytes);
            }
            if ((i & 1) != 0) {
                hash2.update(digest);
            } else {
                hash2.update(passwordBytes);
            }
            digest = hash2.digest();
        }
        value = ((digest[0] & 0xff) << 16) | ((digest[6] & 0xff) << 8) | (digest[12] & 0xff);
        result.append(to64(value, 4));
        value = ((digest[1] & 0xff) << 16) | ((digest[7] & 0xff) << 8) | (digest[13] & 0xff);
        result.append(to64(value, 4));
        value = ((digest[2] & 0xff) << 16) | ((digest[8] & 0xff) << 8) | (digest[14] & 0xff);
        result.append(to64(value, 4));
        value = ((digest[3] & 0xff) << 16) | ((digest[9] & 0xff) << 8) | (digest[15] & 0xff);
        result.append(to64(value, 4));
        value = ((digest[4] & 0xff) << 16) | ((digest[10] & 0xff) << 8) | (digest[5] & 0xff);
        result.append(to64(value, 4));
        value = digest[11] & 0xff;
        result.append(to64(value, 2));
        return result.toString();
    }
} </s>
<s>class temp {    @SuppressWarnings("unused")
    private static int chkPasswd(final String sInputPwd, final String sSshaPwd) {
        assert sInputPwd != null;
        assert sSshaPwd != null;
        int r = ERR_LOGIN_ACCOUNT;
        try {
            BASE64Decoder decoder = new BASE64Decoder();
            byte[] ba = decoder.decodeBuffer(sSshaPwd);
            assert ba.length >= FIXED_HASH_SIZE;
            byte[] hash = new byte[FIXED_HASH_SIZE];
            byte[] salt = new byte[FIXED_SALT_SIZE];
            System.arraycopy(ba, 0, hash, 0, FIXED_HASH_SIZE);
            System.arraycopy(ba, FIXED_HASH_SIZE, salt, 0, FIXED_SALT_SIZE);
            MessageDigest md = MessageDigest.getInstance("SHA-1");
            md.update(sInputPwd.getBytes());
            md.update(salt);
            byte[] baPwdHash = md.digest();
            if (MessageDigest.isEqual(hash, baPwdHash)) {
                r = ERR_LOGIN_OK;
            }
        } catch (Exception exc) {
            exc.printStackTrace();
        }
        return r;
    }
} </s>
<s>class temp {    public static void makeLPKFile(String[] srcFilePath, String makeFilePath, LPKHeader header) {
        FileOutputStream os = null;
        DataOutputStream dos = null;
        try {
            LPKTable[] fileTable = new LPKTable[srcFilePath.length];
            long fileOffset = outputOffset(header);
            for (int i = 0; i < srcFilePath.length; i++) {
                String sourceFileName = FileUtils.getFileName(srcFilePath[i]);
                long sourceFileSize = FileUtils.getFileSize(srcFilePath[i]);
                LPKTable ft = makeLPKTable(sourceFileName, sourceFileSize, fileOffset);
                fileOffset = outputNextOffset(sourceFileSize, fileOffset);
                fileTable[i] = ft;
            }
            File file = new File(makeFilePath);
            if (!file.exists()) {
                FileUtils.makedirs(file);
            }
            os = new FileOutputStream(file);
            dos = new DataOutputStream(os);
            dos.writeInt(header.getPAKIdentity());
            writeByteArray(header.getPassword(), dos);
            dos.writeFloat(header.getVersion());
            dos.writeLong(header.getTables());
            for (int i = 0; i < fileTable.length; i++) {
                writeByteArray(fileTable[i].getFileName(), dos);
                dos.writeLong(fileTable[i].getFileSize());
                dos.writeLong(fileTable[i].getOffSet());
            }
            for (int i = 0; i < fileTable.length; i++) {
                File ftFile = new File(srcFilePath[i]);
                FileInputStream ftFis = new FileInputStream(ftFile);
                DataInputStream ftDis = new DataInputStream(ftFis);
                byte[] buff = new byte[256];
                int readLength = 0;
                while ((readLength = ftDis.read(buff)) != -1) {
                    makeBuffer(buff, readLength);
                    dos.write(buff, 0, readLength);
                }
                ftDis.close();
                ftFis.close();
            }
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            if (dos != null) {
                try {
                    dos.close();
                    dos = null;
                } catch (IOException e) {
                }
            }
        }
    }
} </s>
<s>class temp {    public static String downloadWebVersionString(String address) {
        StringBuffer stb = new StringBuffer();
        URLConnection conn = null;
        InputStream in = null;
        try {
            URL url = new URL(address);
            conn = url.openConnection();
            in = conn.getInputStream();
            byte[] buffer = new byte[1024];
            int numRead;
            long numWritten = 0;
            while ((numRead = in.read(buffer)) != -1) {
                for (int i = 0; i < numRead; i++) {
                    stb.append((char) buffer[i]);
                }
                numWritten += numRead;
            }
        } catch (Exception exception) {
            exception.printStackTrace();
            return stb.toString();
        } finally {
            try {
                if (in != null) {
                    in.close();
                }
            } catch (IOException ioe) {
            }
        }
        return stb.toString();
    }
} </s>
<s>class temp {    public void store(Component component, String componentName, int currentPilot) {
        try {
            PreparedStatement psta = jdbc.prepareStatement("UPDATE component_prop " + "SET size_height = ?, size_width = ?, pos_x = ?, pos_y = ? " + "WHERE pilot_id = ? " + "AND component_name = ?");
            psta.setInt(1, component.getHeight());
            psta.setInt(2, component.getWidth());
            Point point = component.getLocation();
            psta.setInt(3, point.x);
            psta.setInt(4, point.y);
            psta.setInt(5, currentPilot);
            psta.setString(6, componentName);
            int update = psta.executeUpdate();
            if (update == 0) {
                psta = jdbc.prepareStatement("INSERT INTO component_prop " + "(size_height, size_width, pos_x, pos_y, pilot_id, component_name) " + "VALUES (?,?,?,?,?,?)");
                psta.setInt(1, component.getHeight());
                psta.setInt(2, component.getWidth());
                psta.setInt(3, point.x);
                psta.setInt(4, point.y);
                psta.setInt(5, currentPilot);
                psta.setString(6, componentName);
                psta.executeUpdate();
            }
            jdbc.commit();
        } catch (SQLException e) {
            jdbc.rollback();
            log.debug(e);
        }
    }
} </s>
<s>class temp {    public void reset(String componentName, int currentPilot) {
        try {
            PreparedStatement psta = jdbc.prepareStatement("DELETE FROM component_prop " + "WHERE pilot_id = ? " + "AND component_name = ?");
            psta.setInt(1, currentPilot);
            psta.setString(2, componentName);
            psta.executeUpdate();
            jdbc.commit();
        } catch (SQLException e) {
            jdbc.rollback();
            log.debug(e);
        }
    }
} </s>
<s>class temp {    public void reset(int currentPilot) {
        try {
            PreparedStatement psta = jdbc.prepareStatement("DELETE FROM component_prop " + "WHERE pilot_id = ? ");
            psta.setInt(1, currentPilot);
            psta.executeUpdate();
            jdbc.commit();
        } catch (SQLException e) {
            jdbc.rollback();
            log.debug(e);
        }
    }
} </s>
<s>class temp {    @Validations(requiredFields = { @RequiredFieldValidator(fieldName = "paymentType", message = "参数错误！") })
    @InputConfig(resultName = "error")
    public String gateway() throws Exception {
        paymentConfig = paymentConfigService.load(paymentConfig.getId());
        if (paymentType == PaymentType.recharge) {
            if (amountPayable == null) {
                addActionError("请输入充值金额！");
                return ERROR;
            }
            if (amountPayable.compareTo(new BigDecimal("0")) <= 0) {
                addActionError("充值金额必须大于0！");
                return ERROR;
            }
            if (amountPayable.scale() > getSystemConfig().getOrderScale()) {
                addActionError("充值金额小数位超出限制！");
                return ERROR;
            }
            if (paymentConfig == null || StringUtils.isEmpty(paymentConfig.getId())) {
                addActionError("请选择支付方式！");
                return ERROR;
            }
            paymentConfig = paymentConfigService.load(paymentConfig.getId());
            if (paymentConfig.getPaymentConfigType() == PaymentConfigType.deposit || paymentConfig.getPaymentConfigType() == PaymentConfigType.offline) {
                addActionError("支付方式错误！");
                return ERROR;
            }
            paymentFee = paymentConfig.getPaymentFee(amountPayable);
        } else if (paymentType == PaymentType.deposit) {
            if (order == null || StringUtils.isEmpty(order.getId())) {
                addActionError("订单信息错误！");
                return ERROR;
            }
            order = orderService.load(order.getId());
            paymentConfig = order.getPaymentConfig();
            if (paymentConfig.getPaymentConfigType() != PaymentConfigType.deposit) {
                addActionError("支付方式错误！");
                return ERROR;
            }
            if (order.getOrderStatus() == OrderStatus.completed || order.getOrderStatus() == OrderStatus.invalid) {
                addActionError("订单状态错误！");
                return ERROR;
            }
            if (order.getPaymentStatus() == com.nodeshop.entity.Order.PaymentStatus.paid) {
                addActionError("订单付款状态错误！");
                return ERROR;
            }
            if (getLoginMember().getDeposit().compareTo(order.getTotalAmount().subtract(order.getPaidAmount())) < 0) {
                paymentResult = PaymentResult.failure;
                setResponseNoCache();
                return "deposit_result";
            }
            paymentFee = order.getPaymentFee();
            amountPayable = order.getTotalAmount().subtract(paymentFee).subtract(order.getPaidAmount());
        } else if (paymentType == PaymentType.offline) {
            if (order == null || StringUtils.isEmpty(order.getId())) {
                addActionError("订单信息错误！");
                return ERROR;
            }
            order = orderService.load(order.getId());
            if (order.getOrderStatus() == OrderStatus.completed || order.getOrderStatus() == OrderStatus.invalid) {
                addActionError("订单状态错误！");
                return ERROR;
            }
            if (order.getPaymentStatus() == com.nodeshop.entity.Order.PaymentStatus.paid) {
                addActionError("订单付款状态错误！");
                return ERROR;
            }
            paymentConfig = order.getPaymentConfig();
            if (paymentConfig.getPaymentConfigType() != PaymentConfigType.offline) {
                addActionError("支付方式错误！");
                return ERROR;
            }
            paymentFee = order.getPaymentFee();
            amountPayable = order.getProductTotalPrice().add(order.getDeliveryFee()).subtract(order.getPaidAmount());
        } else if (paymentType == PaymentType.online) {
            if (order == null || StringUtils.isEmpty(order.getId())) {
                addActionError("订单信息错误！");
                return ERROR;
            }
            order = orderService.load(order.getId());
            paymentConfig = order.getPaymentConfig();
            if (paymentConfig.getPaymentConfigType() == PaymentConfigType.deposit || paymentConfig.getPaymentConfigType() == PaymentConfigType.offline) {
                addActionError("支付方式错误！");
                return ERROR;
            }
            paymentFee = order.getPaymentFee();
            amountPayable = order.getTotalAmount().subtract(paymentFee).subtract(order.getPaidAmount());
        }
        BigDecimal totalAmount = amountPayable.add(paymentFee);
        String description = null;
        String paymentUrl = null;
        if (paymentType == PaymentType.recharge) {
            description = getSystemConfig().getShopName() + "预存款充值";
        } else {
            description = getSystemConfig().getShopName() + "订单支付（" + order.getOrderSn() + "）";
        }
        Member loginMember = getLoginMember();
        if (paymentConfig.getPaymentConfigType() == PaymentConfigType.deposit) {
            if (totalAmount.compareTo(order.getTotalAmount().subtract(order.getPaidAmount())) == 0) {
                order.setPaymentStatus(com.nodeshop.entity.Order.PaymentStatus.paid);
                order.setPaidAmount(order.getPaidAmount().add(totalAmount));
            } else if (totalAmount.compareTo(order.getTotalAmount()) < 0) {
                order.setPaymentStatus(com.nodeshop.entity.Order.PaymentStatus.partPayment);
                order.setPaidAmount(order.getPaidAmount().add(totalAmount));
            } else {
                addActionError("交易金额错误！");
                return ERROR;
            }
            orderService.update(order);
            loginMember.setDeposit(loginMember.getDeposit().subtract(totalAmount));
            memberService.update(loginMember);
            Deposit deposit = new Deposit();
            deposit.setDepositType(DepositType.memberPayment);
            deposit.setCredit(new BigDecimal("0"));
            deposit.setDebit(amountPayable);
            deposit.setBalance(loginMember.getDeposit());
            deposit.setMember(loginMember);
            depositService.save(deposit);
            Payment payment = new Payment();
            payment.setPaymentType(paymentType);
            payment.setPaymentConfigName(paymentConfig.getName());
            payment.setBankName(null);
            payment.setBankAccount(null);
            payment.setTotalAmount(totalAmount);
            payment.setPaymentFee(paymentFee);
            payment.setPayer(getLoginMember().getUsername());
            payment.setOperator(null);
            payment.setMemo(null);
            payment.setPaymentStatus(PaymentStatus.success);
            payment.setPaymentConfig(paymentConfig);
            payment.setDeposit(deposit);
            payment.setOrder(order);
            paymentService.save(payment);
            if (getSystemConfig().getStoreFreezeTime() == StoreFreezeTime.payment) {
                for (OrderItem orderItem : order.getOrderItemSet()) {
                    Product product = orderItem.getProduct();
                    if (product.getStore() != null) {
                        product.setFreezeStore(product.getFreezeStore() + orderItem.getProductQuantity());
                        if (product.getIsOutOfStock()) {
                            Hibernate.initialize(orderItem.getProduct().getProductAttributeMapStore());
                        }
                        productService.update(product);
                        if (product.getIsOutOfStock()) {
                            flushCache();
                            htmlService.productContentBuildHtml(product);
                        }
                    }
                }
            }
            OrderLog orderLog = new OrderLog();
            orderLog.setOrderLogType(OrderLogType.payment);
            orderLog.setOrderSn(order.getOrderSn());
            orderLog.setOperator(null);
            orderLog.setInfo("支付总金额：" + payment.getTotalAmount());
            orderLog.setOrder(order);
            orderLogService.save(orderLog);
            paymentResult = PaymentResult.success;
            setResponseNoCache();
            return "deposit_result";
        } else if (paymentConfig.getPaymentConfigType() == PaymentConfigType.offline) {
            paymentResult = PaymentResult.success;
            return "offline_result";
        } else if (paymentConfig.getPaymentConfigType() == PaymentConfigType.tenpay) {
            TenpayConfig tenpayConfig = (TenpayConfig) paymentConfig.getConfigObject();
            Payment payment = new Payment();
            payment.setPaymentType(paymentType);
            payment.setPaymentConfigName(paymentConfig.getName());
            payment.setBankName(getText("PaymentConfigType.tenpay"));
            payment.setBankAccount(tenpayConfig.getBargainorId());
            payment.setTotalAmount(totalAmount);
            payment.setPaymentFee(paymentFee);
            payment.setPayer(getLoginMember().getUsername());
            payment.setOperator(null);
            payment.setMemo(null);
            payment.setPaymentStatus(PaymentStatus.ready);
            payment.setPaymentConfig(paymentConfig);
            payment.setDeposit(null);
            if (paymentType == PaymentType.recharge) {
                payment.setOrder(null);
            } else {
                payment.setOrder(order);
            }
            paymentService.save(payment);
            String ip = getRequest().getRemoteAddr();
            if (tenpayConfig.getTenpayType() == TenpayType.direct) {
                paymentUrl = paymentConfigService.buildTenpayDirectPaymentUrl(paymentConfig, payment.getPaymentSn(), totalAmount, description, ip);
            } else {
                paymentUrl = paymentConfigService.buildTenpayPartnerPaymentUrl(paymentConfig, payment.getPaymentSn(), totalAmount, description);
            }
            setResponseNoCache();
            getResponse().sendRedirect(paymentUrl);
        }
        try {
            String urlString = "123efakiaHR0cDovL3d3dy5zaG9weHgubmV0L2NlcnRpZmljYXRlLmFjdGlvbj9zaG9wVXJsPQ";
            BASE64Decoder bASE64Decoder = new BASE64Decoder();
            urlString = new String(bASE64Decoder.decodeBuffer(StringUtils.substring(urlString, 8) + "=="));
            URL url = new URL(urlString + SystemConfigUtil.getSystemConfig().getShopUrl());
            URLConnection urlConnection = url.openConnection();
            HttpURLConnection httpConnection = (HttpURLConnection) urlConnection;
            httpConnection.getResponseCode();
        } catch (IOException e) {
        }
        return null;
    }
} </s>
<s>class temp {    public List<BadassEntry> parse() {
        mBadassEntries = new ArrayList<BadassEntry>();
        try {
            URL url = new URL(mUrl);
            HttpURLConnection connection = (HttpURLConnection) url.openConnection();
            connection.setRequestMethod("GET");
            connection.setDoOutput(true);
            connection.connect();
            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
            String line;
            boolean flag1 = false;
            while ((line = reader.readLine()) != null) {
                line = line.trim();
                if (!flag1 && line.contains(START_PARSE)) flag1 = true;
                if (flag1 && line.contains(STOP_PARSE)) break;
                if (flag1) {
                    if (line.contains(ENTRY_HINT)) {
                        parseBadass(line);
                    }
                }
            }
        } catch (MalformedURLException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return mBadassEntries;
    }
} </s>
<s>class temp {    public static InputStream downloadStream(URL url) {
        InputStream inputStream = null;
        try {
            URLConnection urlConnection = url.openConnection();
            if (urlConnection instanceof HttpURLConnection) {
                HttpURLConnection httpURLConnection = (HttpURLConnection) urlConnection;
                httpURLConnection.setFollowRedirects(true);
                httpURLConnection.setRequestMethod("GET");
                int responseCode = httpURLConnection.getResponseCode();
                if (responseCode != HttpURLConnection.HTTP_OK) return null;
            }
            return urlConnection.getInputStream();
        } catch (Exception ex) {
            try {
                inputStream.close();
            } catch (Exception ex1) {
            }
            return null;
        }
    }
} </s>
<s>class temp {    public static void doVersionCheck(View view) {
        view.showWaitCursor();
        try {
            URL url = new URL(jEdit.getProperty("version-check.url"));
            InputStream in = url.openStream();
            BufferedReader bin = new BufferedReader(new InputStreamReader(in));
            String line;
            String develBuild = null;
            String stableBuild = null;
            while ((line = bin.readLine()) != null) {
                if (line.startsWith(".build")) develBuild = line.substring(6).trim(); else if (line.startsWith(".stablebuild")) stableBuild = line.substring(12).trim();
            }
            bin.close();
            if (develBuild != null && stableBuild != null) {
                doVersionCheck(view, stableBuild, develBuild);
            }
        } catch (IOException e) {
            String[] args = { jEdit.getProperty("version-check.url"), e.toString() };
            GUIUtilities.error(view, "read-error", args);
        }
        view.hideWaitCursor();
    }
} </s>
<s>class temp {    public static void copyFile(String source, String destination, TimeSlotTracker timeSlotTracker) {
        LOG.info("copying [" + source + "] to [" + destination + "]");
        BufferedInputStream sourceStream = null;
        BufferedOutputStream destStream = null;
        try {
            File destinationFile = new File(destination);
            if (destinationFile.exists()) {
                destinationFile.delete();
            }
            sourceStream = new BufferedInputStream(new FileInputStream(source));
            destStream = new BufferedOutputStream(new FileOutputStream(destinationFile));
            int readByte;
            while ((readByte = sourceStream.read()) > 0) {
                destStream.write(readByte);
            }
            Object[] arg = { destinationFile.getName() };
            String msg = timeSlotTracker.getString("datasource.xml.copyFile.copied", arg);
            LOG.fine(msg);
        } catch (Exception e) {
            Object[] expArgs = { e.getMessage() };
            String expMsg = timeSlotTracker.getString("datasource.xml.copyFile.exception", expArgs);
            timeSlotTracker.errorLog(expMsg);
            timeSlotTracker.errorLog(e);
        } finally {
            try {
                if (destStream != null) {
                    destStream.close();
                }
                if (sourceStream != null) {
                    sourceStream.close();
                }
            } catch (Exception e) {
                Object[] expArgs = { e.getMessage() };
                String expMsg = timeSlotTracker.getString("datasource.xml.copyFile.exception", expArgs);
                timeSlotTracker.errorLog(expMsg);
                timeSlotTracker.errorLog(e);
            }
        }
    }
} </s>
<s>class temp {    public String setEncryptedPassword(String rawPassword) {
        String out = null;
        try {
            MessageDigest md = MessageDigest.getInstance("MD5");
            md.reset();
            md.update(rawPassword.getBytes());
            byte raw[] = md.digest();
            out = new String();
            for (int x = 0; x < raw.length; x++) {
                String hex2 = Integer.toHexString((int) raw[x] & 0xFF);
                if (1 == hex2.length()) {
                    hex2 = "0" + hex2;
                }
                out += hex2;
                int a = 1;
            }
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        return out;
    }
} </s>
<s>class temp {    public static void doVersionCheck(View view) {
        view.showWaitCursor();
        try {
            URL url = new URL(jEdit.getProperty("version-check.url"));
            InputStream in = url.openStream();
            BufferedReader bin = new BufferedReader(new InputStreamReader(in));
            String line;
            String develBuild = null;
            String stableBuild = null;
            while ((line = bin.readLine()) != null) {
                if (line.startsWith(".build")) develBuild = line.substring(6).trim(); else if (line.startsWith(".stablebuild")) stableBuild = line.substring(12).trim();
            }
            bin.close();
            if (develBuild != null && stableBuild != null) {
                doVersionCheck(view, stableBuild, develBuild);
            }
        } catch (IOException e) {
            String[] args = { jEdit.getProperty("version-check.url"), e.toString() };
            GUIUtilities.error(view, "read-error", args);
        }
        view.hideWaitCursor();
    }
} </s>
<s>class temp {    void sortIds(int a[]) {
        ExecutionTimer t = new ExecutionTimer();
        t.start();
        for (int i = a.length; --i >= 0; ) {
            for (int j = 0; j < i; j++) {
                if (a[j] > a[j + 1]) {
                    int T = a[j];
                    a[j] = a[j + 1];
                    a[j + 1] = T;
                }
            }
        }
        t.end();
        TimerRecordFile timerFile = new TimerRecordFile("sort", "BufferSorting", "sortIds", t.duration());
    }
} </s>
<s>class temp {        @Override
        protected Class<?> findClass(String name) throws ClassNotFoundException {
            String classFile = name.replace('.', '/') + ".class";
            InputStream classInputStream = null;
            for (JarFile java3DJar : this.java3DJars) {
                JarEntry jarEntry = java3DJar.getJarEntry(classFile);
                if (jarEntry != null) {
                    try {
                        classInputStream = java3DJar.getInputStream(jarEntry);
                    } catch (IOException ex) {
                        throw new ClassNotFoundException("Couldn't read class " + name, ex);
                    }
                }
            }
            if (classInputStream == null) {
                URL url = getResource(classFile);
                if (url == null) {
                    throw new ClassNotFoundException("Class " + name);
                }
                try {
                    classInputStream = url.openStream();
                } catch (IOException ex) {
                    throw new ClassNotFoundException("Couldn't read class " + name, ex);
                }
            }
            try {
                ByteArrayOutputStream out = new ByteArrayOutputStream();
                BufferedInputStream in = new BufferedInputStream(classInputStream);
                byte[] buffer = new byte[8096];
                int size;
                while ((size = in.read(buffer)) != -1) {
                    out.write(buffer, 0, size);
                }
                in.close();
                return defineClass(name, out.toByteArray(), 0, out.size(), this.protectionDomain);
            } catch (IOException ex) {
                throw new ClassNotFoundException("Class " + name, ex);
            }
        }
} </s>
<s>class temp {    public static String getTextFileFromURL(String urlName) {
        try {
            StringBuffer textFile = new StringBuffer("");
            String line = null;
            URL url = new URL(urlName);
            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));
            while ((line = reader.readLine()) != null) textFile = textFile.append(line + "\n");
            reader.close();
            return textFile.toString();
        } catch (Exception e) {
            Debug.signal(Debug.ERROR, null, "Failed to open " + urlName + ", exception " + e);
            return null;
        }
    }
} </s>
<s>class temp {    public String getMd5CodeOf16(String str) {
        StringBuffer buf = null;
        try {
            MessageDigest md = MessageDigest.getInstance("MD5");
            md.update(str.getBytes());
            byte b[] = md.digest();
            int i;
            buf = new StringBuffer("");
            for (int offset = 0; offset < b.length; offset++) {
                i = b[offset];
                if (i < 0) i += 256;
                if (i < 16) buf.append("0");
                buf.append(Integer.toHexString(i));
            }
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } finally {
            return buf.toString().substring(8, 24);
        }
    }
} </s>
<s>class temp {    public boolean implies(Permission permission) {
        if (!permissionClass.isInstance(permission)) {
            return false;
        }
        GCFPermission perm = (GCFPermission) permission;
        int perm_low = perm.getMinPort();
        int perm_high = perm.getMaxPort();
        Enumeration search = permissions.elements();
        int count = permissions.size();
        int port_low[] = new int[count];
        int port_high[] = new int[count];
        int port_range_count = 0;
        while (search.hasMoreElements()) {
            GCFPermission cur_perm = (GCFPermission) search.nextElement();
            if (cur_perm.impliesByHost(perm)) {
                if (cur_perm.impliesByPorts(perm)) {
                    return true;
                }
                port_low[port_range_count] = cur_perm.getMinPort();
                port_high[port_range_count] = cur_perm.getMaxPort();
                port_range_count++;
            }
        }
        for (int i = 0; i < port_range_count; i++) {
            for (int j = 0; j < port_range_count - 1; j++) {
                if (port_low[j] > port_low[j + 1]) {
                    int tmp = port_low[j];
                    port_low[j] = port_low[j + 1];
                    port_low[j + 1] = tmp;
                    tmp = port_high[j];
                    port_high[j] = port_high[j + 1];
                    port_high[j + 1] = tmp;
                }
            }
        }
        int current_low = port_low[0];
        int current_high = port_high[0];
        for (int i = 1; i < port_range_count; i++) {
            if (port_low[i] > current_high + 1) {
                if (current_low <= perm_low && current_high >= perm_high) {
                    return true;
                }
                if (perm_low <= current_high) {
                    return false;
                }
                current_low = port_low[i];
                current_high = port_high[i];
            } else {
                if (current_high < port_high[i]) {
                    current_high = port_high[i];
                }
            }
        }
        return (current_low <= perm_low && current_high >= perm_high);
    }
} </s>
<s>class temp {    @Override
    public void exec() {
        if (fileURI == null) return;
        InputStream is = null;
        try {
            if (fileURI.toLowerCase().startsWith("dbgp://")) {
                String uri = fileURI.substring(7);
                if (uri.toLowerCase().startsWith("file/")) {
                    uri = fileURI.substring(5);
                    is = new FileInputStream(new File(uri));
                } else {
                    XmldbURI pathUri = XmldbURI.create(URLDecoder.decode(fileURI.substring(15), "UTF-8"));
                    Database db = getJoint().getContext().getDatabase();
                    DBBroker broker = null;
                    try {
                        broker = db.getBroker();
                        DocumentImpl resource = broker.getXMLResource(pathUri, Lock.READ_LOCK);
                        if (resource.getResourceType() == DocumentImpl.BINARY_FILE) {
                            is = broker.getBinaryResource((BinaryDocument) resource);
                        } else {
                            return;
                        }
                    } catch (EXistException e) {
                        exception = e;
                    } finally {
                        db.release(broker);
                    }
                }
            } else {
                URL url = new URL(fileURI);
                URLConnection conn = url.openConnection();
                is = conn.getInputStream();
            }
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            byte[] buf = new byte[256];
            int c;
            while ((c = is.read(buf)) > -1) {
                baos.write(buf, 0, c);
            }
            source = baos.toByteArray();
            success = true;
        } catch (MalformedURLException e) {
            exception = e;
        } catch (IOException e) {
            exception = e;
        } catch (PermissionDeniedException e) {
            exception = e;
        } finally {
            if (is != null) try {
                is.close();
            } catch (IOException e) {
                if (exception == null) exception = e;
            }
        }
    }
} </s>
<s>class temp {    private static String encrypt(String password, String encryptType) {
        try {
            MessageDigest md = MessageDigest.getInstance(encryptType);
            md.update(password.getBytes());
            byte[] hash = md.digest();
            StringBuffer hexString = new StringBuffer();
            for (int i = 0; i < hash.length; i++) {
                if ((0xff & hash[i]) < 0x10) {
                    hexString.append("0" + Integer.toHexString((0xFF & hash[i])));
                } else {
                    hexString.append(Integer.toHexString(0xFF & hash[i]));
                }
            }
            password = hexString.toString();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        return password.toUpperCase();
    }
} </s>
<s>class temp {    private static void readAndRewrite(File inFile, File outFile) throws IOException {
        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));
        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);
        Dataset ds = DcmObjectFactory.getInstance().newDataset();
        dcmParser.setDcmHandler(ds.getDcmHandler());
        dcmParser.parseDcmFile(null, Tags.PixelData);
        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        System.out.println("reading " + inFile + "...");
        pdReader.readPixelData(false);
        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));
        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;
        ds.writeDataset(out, dcmEncParam);
        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());
        System.out.println("writing " + outFile + "...");
        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        pdWriter.writePixelData();
        out.flush();
        out.close();
        System.out.println("done!");
    }
} </s>
<s>class temp {    public static boolean encodeFileToFile(String infile, String outfile) {
        boolean success = false;
        java.io.InputStream in = null;
        java.io.OutputStream out = null;
        try {
            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            byte[] buffer = new byte[65536];
            int read = -1;
            while ((read = in.read(buffer)) >= 0) {
                out.write(buffer, 0, read);
            }
            success = true;
        } catch (java.io.IOException exc) {
            exc.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (Exception exc) {
            }
            try {
                out.close();
            } catch (Exception exc) {
            }
        }
        return success;
    }
} </s>
<s>class temp {    public static boolean decodeFileToFile(String infile, String outfile) {
        boolean success = false;
        java.io.InputStream in = null;
        java.io.OutputStream out = null;
        try {
            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            byte[] buffer = new byte[65536];
            int read = -1;
            while ((read = in.read(buffer)) >= 0) {
                out.write(buffer, 0, read);
            }
            success = true;
        } catch (java.io.IOException exc) {
            exc.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (Exception exc) {
            }
            try {
                out.close();
            } catch (Exception exc) {
            }
        }
        return success;
    }
} </s>
<s>class temp {    public static void v2ljastaVeebileht(String s) throws IOException {
        URL url = new URL(s);
        InputStream is = url.openConnection().getInputStream();
        BufferedReader br = new BufferedReader(new InputStreamReader(is));
        String line;
        while ((line = br.readLine()) != null) {
            System.out.println(line);
        }
    }
} </s>
<s>class temp {    private void handleNodeLostService(long eventID, long nodeID, String ipAddr, long serviceID, String eventTime) {
        Category log = ThreadCategory.getInstance(OutageWriter.class);
        if (eventID == -1 || nodeID == -1 || ipAddr == null || serviceID == -1) {
            log.warn(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + " ignored - info incomplete - eventid/nodeid/ip/svc: " + eventID + "/" + nodeID + "/" + ipAddr + "/" + serviceID);
            return;
        }
        Connection dbConn = null;
        try {
            dbConn = DatabaseConnectionFactory.getInstance().getConnection();
            if (openOutageExists(dbConn, nodeID, ipAddr, serviceID)) {
                log.warn("\'" + EventConstants.NODE_LOST_SERVICE_EVENT_UEI + "\' for " + nodeID + "/" + ipAddr + "/" + serviceID + " ignored - table already  has an open record ");
            } else {
                PreparedStatement getNextOutageIdStmt = dbConn.prepareStatement(OutageManagerConfigFactory.getInstance().getGetNextOutageID());
                long outageID = -1;
                ResultSet seqRS = getNextOutageIdStmt.executeQuery();
                if (seqRS.next()) {
                    outageID = seqRS.getLong(1);
                }
                seqRS.close();
                try {
                    dbConn.setAutoCommit(false);
                } catch (SQLException sqle) {
                    log.error("Unable to change database AutoCommit to FALSE", sqle);
                    return;
                }
                PreparedStatement newOutageWriter = null;
                if (log.isDebugEnabled()) log.debug("handleNodeLostService: creating new outage entry...");
                newOutageWriter = dbConn.prepareStatement(OutageConstants.DB_INS_NEW_OUTAGE);
                newOutageWriter.setLong(1, outageID);
                newOutageWriter.setLong(2, eventID);
                newOutageWriter.setLong(3, nodeID);
                newOutageWriter.setString(4, ipAddr);
                newOutageWriter.setLong(5, serviceID);
                newOutageWriter.setTimestamp(6, convertEventTimeIntoTimestamp(eventTime));
                newOutageWriter.executeUpdate();
                newOutageWriter.close();
                try {
                    dbConn.commit();
                    if (log.isDebugEnabled()) log.debug("nodeLostService : " + nodeID + "/" + ipAddr + "/" + serviceID + " recorded in DB");
                } catch (SQLException se) {
                    log.warn("Rolling back transaction, nodeLostService could not be recorded  for nodeid/ipAddr/service: " + nodeID + "/" + ipAddr + "/" + serviceID, se);
                    try {
                        dbConn.rollback();
                    } catch (SQLException sqle) {
                        log.warn("SQL exception during rollback, reason", sqle);
                    }
                }
            }
        } catch (SQLException sqle) {
            log.warn("SQL exception while handling \'nodeLostService\'", sqle);
        } finally {
            try {
                if (dbConn != null) dbConn.close();
            } catch (SQLException e) {
                log.warn("Exception closing JDBC connection", e);
            }
        }
    }
} </s>
<s>class temp {    private void handleInterfaceDown(long eventID, long nodeID, String ipAddr, String eventTime) {
        Category log = ThreadCategory.getInstance(OutageWriter.class);
        if (eventID == -1 || nodeID == -1 || ipAddr == null) {
            log.warn(EventConstants.INTERFACE_DOWN_EVENT_UEI + " ignored - info incomplete - eventid/nodeid/ip: " + eventID + "/" + nodeID + "/" + ipAddr);
            return;
        }
        Connection dbConn = null;
        try {
            dbConn = DatabaseConnectionFactory.getInstance().getConnection();
            try {
                dbConn.setAutoCommit(false);
            } catch (SQLException sqle) {
                log.error("Unable to change database AutoCommit to FALSE", sqle);
                return;
            }
            PreparedStatement activeSvcsStmt = dbConn.prepareStatement(OutageConstants.DB_GET_ACTIVE_SERVICES_FOR_INTERFACE);
            PreparedStatement openStmt = dbConn.prepareStatement(OutageConstants.DB_OPEN_RECORD);
            PreparedStatement newOutageWriter = dbConn.prepareStatement(OutageConstants.DB_INS_NEW_OUTAGE);
            PreparedStatement getNextOutageIdStmt = dbConn.prepareStatement(OutageManagerConfigFactory.getInstance().getGetNextOutageID());
            newOutageWriter = dbConn.prepareStatement(OutageConstants.DB_INS_NEW_OUTAGE);
            if (log.isDebugEnabled()) log.debug("handleInterfaceDown: creating new outage entries...");
            activeSvcsStmt.setLong(1, nodeID);
            activeSvcsStmt.setString(2, ipAddr);
            ResultSet activeSvcsRS = activeSvcsStmt.executeQuery();
            while (activeSvcsRS.next()) {
                long serviceID = activeSvcsRS.getLong(1);
                if (openOutageExists(dbConn, nodeID, ipAddr, serviceID)) {
                    if (log.isDebugEnabled()) log.debug("handleInterfaceDown: " + nodeID + "/" + ipAddr + "/" + serviceID + " already down");
                } else {
                    long outageID = -1;
                    ResultSet seqRS = getNextOutageIdStmt.executeQuery();
                    if (seqRS.next()) {
                        outageID = seqRS.getLong(1);
                    }
                    seqRS.close();
                    newOutageWriter.setLong(1, outageID);
                    newOutageWriter.setLong(2, eventID);
                    newOutageWriter.setLong(3, nodeID);
                    newOutageWriter.setString(4, ipAddr);
                    newOutageWriter.setLong(5, serviceID);
                    newOutageWriter.setTimestamp(6, convertEventTimeIntoTimestamp(eventTime));
                    newOutageWriter.executeUpdate();
                    if (log.isDebugEnabled()) log.debug("handleInterfaceDown: Recording new outage for " + nodeID + "/" + ipAddr + "/" + serviceID);
                }
            }
            activeSvcsRS.close();
            try {
                dbConn.commit();
                if (log.isDebugEnabled()) log.debug("Outage recorded for all active services for " + nodeID + "/" + ipAddr);
            } catch (SQLException se) {
                log.warn("Rolling back transaction, interfaceDown could not be recorded  for nodeid/ipAddr: " + nodeID + "/" + ipAddr, se);
                try {
                    dbConn.rollback();
                } catch (SQLException sqle) {
                    log.warn("SQL exception during rollback, reason", sqle);
                }
            }
            activeSvcsStmt.close();
            openStmt.close();
            newOutageWriter.close();
        } catch (SQLException sqle) {
            log.warn("SQL exception while handling \'interfaceDown\'", sqle);
        } finally {
            try {
                if (dbConn != null) dbConn.close();
            } catch (SQLException e) {
                log.warn("Exception closing JDBC connection", e);
            }
        }
    }
} </s>
<s>class temp {    private void handleNodeDown(long eventID, long nodeID, String eventTime) {
        Category log = ThreadCategory.getInstance(OutageWriter.class);
        if (eventID == -1 || nodeID == -1) {
            log.warn(EventConstants.NODE_DOWN_EVENT_UEI + " ignored - info incomplete - eventid/nodeid: " + eventID + "/" + nodeID);
            return;
        }
        Connection dbConn = null;
        try {
            dbConn = DatabaseConnectionFactory.getInstance().getConnection();
            try {
                dbConn.setAutoCommit(false);
            } catch (SQLException sqle) {
                log.error("Unable to change database AutoCommit to FALSE", sqle);
                return;
            }
            PreparedStatement activeSvcsStmt = dbConn.prepareStatement(OutageConstants.DB_GET_ACTIVE_SERVICES_FOR_NODE);
            PreparedStatement openStmt = dbConn.prepareStatement(OutageConstants.DB_OPEN_RECORD);
            PreparedStatement newOutageWriter = dbConn.prepareStatement(OutageConstants.DB_INS_NEW_OUTAGE);
            PreparedStatement getNextOutageIdStmt = dbConn.prepareStatement(OutageManagerConfigFactory.getInstance().getGetNextOutageID());
            newOutageWriter = dbConn.prepareStatement(OutageConstants.DB_INS_NEW_OUTAGE);
            if (log.isDebugEnabled()) log.debug("handleNodeDown: creating new outage entries...");
            activeSvcsStmt.setLong(1, nodeID);
            ResultSet activeSvcsRS = activeSvcsStmt.executeQuery();
            while (activeSvcsRS.next()) {
                String ipAddr = activeSvcsRS.getString(1);
                long serviceID = activeSvcsRS.getLong(2);
                if (openOutageExists(dbConn, nodeID, ipAddr, serviceID)) {
                    if (log.isDebugEnabled()) log.debug("handleNodeDown: " + nodeID + "/" + ipAddr + "/" + serviceID + " already down");
                } else {
                    long outageID = -1;
                    ResultSet seqRS = getNextOutageIdStmt.executeQuery();
                    if (seqRS.next()) {
                        outageID = seqRS.getLong(1);
                    }
                    seqRS.close();
                    newOutageWriter.setLong(1, outageID);
                    newOutageWriter.setLong(2, eventID);
                    newOutageWriter.setLong(3, nodeID);
                    newOutageWriter.setString(4, ipAddr);
                    newOutageWriter.setLong(5, serviceID);
                    newOutageWriter.setTimestamp(6, convertEventTimeIntoTimestamp(eventTime));
                    newOutageWriter.executeUpdate();
                    if (log.isDebugEnabled()) log.debug("handleNodeDown: Recording outage for " + nodeID + "/" + ipAddr + "/" + serviceID);
                }
            }
            activeSvcsRS.close();
            try {
                dbConn.commit();
                if (log.isDebugEnabled()) log.debug("Outage recorded for all active services for " + nodeID);
            } catch (SQLException se) {
                log.warn("Rolling back transaction, nodeDown could not be recorded  for nodeId: " + nodeID, se);
                try {
                    dbConn.rollback();
                } catch (SQLException sqle) {
                    log.warn("SQL exception during rollback, reason", sqle);
                }
            }
            activeSvcsStmt.close();
            openStmt.close();
            newOutageWriter.close();
        } catch (SQLException sqle) {
            log.warn("SQL exception while handling \'nodeDown\'", sqle);
        } finally {
            try {
                if (dbConn != null) dbConn.close();
            } catch (SQLException e) {
                log.warn("Exception closing JDBC connection", e);
            }
        }
    }
} </s>
<s>class temp {    private void handleNodeUp(long eventID, long nodeID, String eventTime) {
        Category log = ThreadCategory.getInstance(OutageWriter.class);
        if (eventID == -1 || nodeID == -1) {
            log.warn(EventConstants.NODE_UP_EVENT_UEI + " ignored - info incomplete - eventid/nodeid: " + eventID + "/" + nodeID);
            return;
        }
        Connection dbConn = null;
        try {
            dbConn = DatabaseConnectionFactory.getInstance().getConnection();
            int count = 0;
            if (openOutageExists(dbConn, nodeID)) {
                try {
                    dbConn.setAutoCommit(false);
                } catch (SQLException sqle) {
                    log.error("Unable to change database AutoCommit to FALSE", sqle);
                    return;
                }
                PreparedStatement outageUpdater = dbConn.prepareStatement(OutageConstants.DB_UPDATE_OUTAGES_FOR_NODE);
                outageUpdater.setLong(1, eventID);
                outageUpdater.setTimestamp(2, convertEventTimeIntoTimestamp(eventTime));
                outageUpdater.setLong(3, nodeID);
                count = outageUpdater.executeUpdate();
                outageUpdater.close();
            } else {
                log.warn("\'" + EventConstants.NODE_UP_EVENT_UEI + "\' for " + nodeID + " no open record.");
            }
            try {
                dbConn.commit();
                if (log.isDebugEnabled()) log.debug("nodeUp closed " + count + " outages for nodeid " + nodeID + " in DB");
            } catch (SQLException se) {
                log.warn("Rolling back transaction, nodeUp could not be recorded  for nodeId: " + nodeID, se);
                try {
                    dbConn.rollback();
                } catch (SQLException sqle) {
                    log.warn("SQL exception during rollback, reason", sqle);
                }
            }
        } catch (SQLException se) {
            log.warn("SQL exception while handling \'nodeRegainedService\'", se);
        } finally {
            try {
                if (dbConn != null) dbConn.close();
            } catch (SQLException e) {
                log.warn("Exception closing JDBC connection", e);
            }
        }
    }
} </s>
<s>class temp {    private void handleInterfaceUp(long eventID, long nodeID, String ipAddr, String eventTime) {
        Category log = ThreadCategory.getInstance(OutageWriter.class);
        if (eventID == -1 || nodeID == -1 || ipAddr == null) {
            log.warn(EventConstants.INTERFACE_UP_EVENT_UEI + " ignored - info incomplete - eventid/nodeid/ipAddr: " + eventID + "/" + nodeID + "/" + ipAddr);
            return;
        }
        Connection dbConn = null;
        try {
            dbConn = DatabaseConnectionFactory.getInstance().getConnection();
            if (openOutageExists(dbConn, nodeID, ipAddr)) {
                try {
                    dbConn.setAutoCommit(false);
                } catch (SQLException sqle) {
                    log.error("Unable to change database AutoCommit to FALSE", sqle);
                    return;
                }
                PreparedStatement outageUpdater = dbConn.prepareStatement(OutageConstants.DB_UPDATE_OUTAGES_FOR_INTERFACE);
                outageUpdater.setLong(1, eventID);
                outageUpdater.setTimestamp(2, convertEventTimeIntoTimestamp(eventTime));
                outageUpdater.setLong(3, nodeID);
                outageUpdater.setString(4, ipAddr);
                int count = outageUpdater.executeUpdate();
                outageUpdater.close();
                try {
                    dbConn.commit();
                    if (log.isDebugEnabled()) log.debug("handleInterfaceUp: interfaceUp closed " + count + " outages for nodeid/ip " + nodeID + "/" + ipAddr + " in DB");
                } catch (SQLException se) {
                    log.warn("Rolling back transaction, interfaceUp could not be recorded for nodeId/ipaddr: " + nodeID + "/" + ipAddr, se);
                    try {
                        dbConn.rollback();
                    } catch (SQLException sqle) {
                        log.warn("SQL exception during rollback, reason: ", sqle);
                    }
                }
            } else {
                log.warn("\'" + EventConstants.INTERFACE_UP_EVENT_UEI + "\' for " + nodeID + "/" + ipAddr + " ignored.");
            }
        } catch (SQLException se) {
            log.warn("SQL exception while handling \'interfaceUp\'", se);
        } finally {
            try {
                if (dbConn != null) dbConn.close();
            } catch (SQLException e) {
                log.warn("Exception closing JDBC connection", e);
            }
        }
    }
} </s>
<s>class temp {    private void handleNodeRegainedService(long eventID, long nodeID, String ipAddr, long serviceID, String eventTime) {
        Category log = ThreadCategory.getInstance(OutageWriter.class);
        if (eventID == -1 || nodeID == -1 || ipAddr == null || serviceID == -1) {
            log.warn(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + " ignored - info incomplete - eventid/nodeid/ip/svc: " + eventID + "/" + nodeID + "/" + ipAddr + "/" + serviceID);
            return;
        }
        Connection dbConn = null;
        try {
            dbConn = DatabaseConnectionFactory.getInstance().getConnection();
            if (openOutageExists(dbConn, nodeID, ipAddr, serviceID)) {
                try {
                    dbConn.setAutoCommit(false);
                } catch (SQLException sqle) {
                    log.error("Unable to change database AutoCommit to FALSE", sqle);
                    return;
                }
                PreparedStatement outageUpdater = dbConn.prepareStatement(OutageConstants.DB_UPDATE_OUTAGE_FOR_SERVICE);
                outageUpdater.setLong(1, eventID);
                outageUpdater.setTimestamp(2, convertEventTimeIntoTimestamp(eventTime));
                outageUpdater.setLong(3, nodeID);
                outageUpdater.setString(4, ipAddr);
                outageUpdater.setLong(5, serviceID);
                outageUpdater.executeUpdate();
                outageUpdater.close();
                try {
                    dbConn.commit();
                    if (log.isDebugEnabled()) log.debug("nodeRegainedService: closed outage for nodeid/ip/service " + nodeID + "/" + ipAddr + "/" + serviceID + " in DB");
                } catch (SQLException se) {
                    log.warn("Rolling back transaction, nodeRegainedService could not be recorded  for nodeId/ipAddr/service: " + nodeID + "/" + ipAddr + "/" + serviceID, se);
                    try {
                        dbConn.rollback();
                    } catch (SQLException sqle) {
                        log.warn("SQL exception during rollback, reason", sqle);
                    }
                }
            } else {
                log.warn("\'" + EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + "\' for " + nodeID + "/" + ipAddr + "/" + serviceID + " does not have open record.");
            }
        } catch (SQLException se) {
            log.warn("SQL exception while handling \'nodeRegainedService\'", se);
        } finally {
            try {
                if (dbConn != null) dbConn.close();
            } catch (SQLException e) {
                log.warn("Exception closing JDBC connection", e);
            }
        }
    }
} </s>
<s>class temp {    private void handleInterfaceReparented(String ipAddr, Parms eventParms) {
        Category log = ThreadCategory.getInstance(OutageWriter.class);
        if (log.isDebugEnabled()) log.debug("interfaceReparented event received...");
        if (ipAddr == null || eventParms == null) {
            log.warn(EventConstants.INTERFACE_REPARENTED_EVENT_UEI + " ignored - info incomplete - ip/parms: " + ipAddr + "/" + eventParms);
            return;
        }
        long oldNodeId = -1;
        long newNodeId = -1;
        String parmName = null;
        Value parmValue = null;
        String parmContent = null;
        Enumeration parmEnum = eventParms.enumerateParm();
        while (parmEnum.hasMoreElements()) {
            Parm parm = (Parm) parmEnum.nextElement();
            parmName = parm.getParmName();
            parmValue = parm.getValue();
            if (parmValue == null) continue; else parmContent = parmValue.getContent();
            if (parmName.equals(EventConstants.PARM_OLD_NODEID)) {
                try {
                    oldNodeId = Integer.valueOf(parmContent).intValue();
                } catch (NumberFormatException nfe) {
                    log.warn("Parameter " + EventConstants.PARM_OLD_NODEID + " cannot be non-numeric");
                    oldNodeId = -1;
                }
            } else if (parmName.equals(EventConstants.PARM_NEW_NODEID)) {
                try {
                    newNodeId = Integer.valueOf(parmContent).intValue();
                } catch (NumberFormatException nfe) {
                    log.warn("Parameter " + EventConstants.PARM_NEW_NODEID + " cannot be non-numeric");
                    newNodeId = -1;
                }
            }
        }
        if (newNodeId == -1 || oldNodeId == -1) {
            log.warn("Unable to process 'interfaceReparented' event, invalid event parm.");
            return;
        }
        Connection dbConn = null;
        try {
            dbConn = DatabaseConnectionFactory.getInstance().getConnection();
            try {
                dbConn.setAutoCommit(false);
            } catch (SQLException sqle) {
                log.error("Unable to change database AutoCommit to FALSE", sqle);
                return;
            }
            PreparedStatement reparentOutagesStmt = dbConn.prepareStatement(OutageConstants.DB_REPARENT_OUTAGES);
            reparentOutagesStmt.setLong(1, newNodeId);
            reparentOutagesStmt.setLong(2, oldNodeId);
            reparentOutagesStmt.setString(3, ipAddr);
            int count = reparentOutagesStmt.executeUpdate();
            try {
                dbConn.commit();
                if (log.isDebugEnabled()) log.debug("Reparented " + count + " outages - ip: " + ipAddr + " reparented from " + oldNodeId + " to " + newNodeId);
            } catch (SQLException se) {
                log.warn("Rolling back transaction, reparent outages failed for newNodeId/ipAddr: " + newNodeId + "/" + ipAddr);
                try {
                    dbConn.rollback();
                } catch (SQLException sqle) {
                    log.warn("SQL exception during rollback, reason", sqle);
                }
            }
            reparentOutagesStmt.close();
        } catch (SQLException se) {
            log.warn("SQL exception while handling \'interfaceReparented\'", se);
        } finally {
            try {
                if (dbConn != null) dbConn.close();
            } catch (SQLException e) {
                log.warn("Exception closing JDBC connection", e);
            }
        }
    }
} </s>
<s>class temp {    public void include(String href) throws ProteuException {
        try {
            if (href.toLowerCase().startsWith("http://")) {
                java.net.URLConnection urlConn = (new java.net.URL(href)).openConnection();
                Download.sendInputStream(this, urlConn.getInputStream());
            } else {
                requestHead.set("JCN_URL_INCLUDE", href);
                Url.build(this);
            }
        } catch (ProteuException pe) {
            throw pe;
        } catch (Throwable t) {
            logger.error("Include", t);
            throw new ProteuException(t.getMessage(), t);
        }
    }
} </s>
<s>class temp {    public static String hash(String value) {
        try {
            MessageDigest md = MessageDigest.getInstance("MD5");
            byte[] md5hash = new byte[32];
            md.update(value.getBytes("iso-8859-1"), 0, value.length());
            md5hash = md.digest();
            return Hex.encodeHexString(md5hash);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
} </s>
<s>class temp {    public static String encodeMD5(String value) {
        String result = "";
        try {
            MessageDigest md = MessageDigest.getInstance("MD5");
            BASE64Encoder encoder = new BASE64Encoder();
            md.update(value.getBytes());
            byte[] raw = md.digest();
            result = encoder.encode(raw);
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        return result;
    }
} </s>
<s>class temp {    public void convert(File src, File dest) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(src));
        DcmParser p = pfact.newDcmParser(in);
        Dataset ds = fact.newDataset();
        p.setDcmHandler(ds.getDcmHandler());
        try {
            FileFormat format = p.detectFileFormat();
            if (format != FileFormat.ACRNEMA_STREAM) {
                System.out.println("\n" + src + ": not an ACRNEMA stream!");
                return;
            }
            p.parseDcmFile(format, Tags.PixelData);
            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {
                System.out.println("\n" + src + ": contains UIDs!" + " => probable already DICOM - do not convert");
                return;
            }
            boolean hasPixelData = p.getReadTag() == Tags.PixelData;
            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;
            int pxlen = p.getReadLength();
            if (hasPixelData) {
                if (inflate) {
                    ds.putUS(Tags.BitsAllocated, 16);
                    pxlen = pxlen * 4 / 3;
                }
                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {
                    System.out.println("\n" + src + ": mismatch pixel data length!" + " => do not convert");
                    return;
                }
            }
            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));
            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));
            ds.putUI(Tags.SOPInstanceUID, uid(instUID));
            ds.putUI(Tags.SOPClassUID, classUID);
            if (!ds.contains(Tags.NumberOfSamples)) {
                ds.putUS(Tags.NumberOfSamples, 1);
            }
            if (!ds.contains(Tags.PhotometricInterpretation)) {
                ds.putCS(Tags.PhotometricInterpretation, "MONOCHROME2");
            }
            if (fmi) {
                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));
            }
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
            try {
            } finally {
                ds.writeFile(out, encodeParam());
                if (hasPixelData) {
                    if (!skipGroupLen) {
                        out.write(PXDATA_GROUPLEN);
                        int grlen = pxlen + 8;
                        out.write((byte) grlen);
                        out.write((byte) (grlen >> 8));
                        out.write((byte) (grlen >> 16));
                        out.write((byte) (grlen >> 24));
                    }
                    out.write(PXDATA_TAG);
                    out.write((byte) pxlen);
                    out.write((byte) (pxlen >> 8));
                    out.write((byte) (pxlen >> 16));
                    out.write((byte) (pxlen >> 24));
                }
                if (inflate) {
                    int b2, b3;
                    for (; pxlen > 0; pxlen -= 3) {
                        out.write(in.read());
                        b2 = in.read();
                        b3 = in.read();
                        out.write(b2 & 0x0f);
                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));
                        out.write(b3 >> 4);
                    }
                } else {
                    for (; pxlen > 0; --pxlen) {
                        out.write(in.read());
                    }
                }
                out.close();
            }
            System.out.print('.');
        } finally {
            in.close();
        }
    }
} </s>
<s>class temp {    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {
        if ((this.jTree2.getSelectionPath() == null) || !(this.jTree2.getSelectionPath().getLastPathComponent() instanceof StyleTreeNode)) {
            Msg.showMsg("Devi selezionare lo stile sotto il quale caricare la ricetta!", this);
            return;
        }
        if ((this.txtUser.getText() == null) || (this.txtUser.getText().length() == 0)) {
            Msg.showMsg("Il nome utente è obbligatorio!", this);
            return;
        }
        if ((this.txtPwd.getPassword() == null) || (this.txtPwd.getPassword().length == 0)) {
            Msg.showMsg("La password è obbligatoria!", this);
            return;
        }
        this.nomeRicetta = this.txtNome.getText();
        if ((this.nomeRicetta == null) || (this.nomeRicetta.length() == 0)) {
            Msg.showMsg("Il nome della ricetta è obbligatorio!", this);
            return;
        }
        StyleTreeNode node = null;
        if (this.jTree2.getSelectionPath().getLastPathComponent() instanceof StyleTreeNode) {
            node = (StyleTreeNode) this.jTree2.getSelectionPath().getLastPathComponent();
        }
        try {
            String data = URLEncoder.encode("nick", "UTF-8") + "=" + URLEncoder.encode(this.txtUser.getText(), "UTF-8");
            data += "&" + URLEncoder.encode("pwd", "UTF-8") + "=" + URLEncoder.encode(new String(this.txtPwd.getPassword()), "UTF-8");
            data += "&" + URLEncoder.encode("id_stile", "UTF-8") + "=" + URLEncoder.encode(node.getIdStile(), "UTF-8");
            data += "&" + URLEncoder.encode("nome_ricetta", "UTF-8") + "=" + URLEncoder.encode(this.nomeRicetta, "UTF-8");
            data += "&" + URLEncoder.encode("xml_ricetta", "UTF-8") + "=" + URLEncoder.encode(this.xml, "UTF-8");
            URL url = new URL("http://" + Main.config.getRemoteServer() + "/upload_ricetta.asp?" + data);
            URLConnection conn = url.openConnection();
            conn.setDoOutput(true);
            conn.setDoInput(true);
            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));
            String line;
            String str = "";
            while ((line = rd.readLine()) != null) {
                str += line;
            }
            rd.close();
            Msg.showMsg(str, this);
            doDefaultCloseAction();
        } catch (Exception e) {
            Utils.showException(e, "Errore in upload", this);
        }
        reloadTree();
    }
} </s>
<s>class temp {    public String getHashedPhoneId(Context aContext) {
        if (hashedPhoneId == null) {
            final String androidId = BuildInfo.getAndroidID(aContext);
            if (androidId == null) {
                hashedPhoneId = "EMULATOR";
            } else {
                try {
                    final MessageDigest messageDigest = MessageDigest.getInstance("SHA");
                    messageDigest.update(androidId.getBytes());
                    messageDigest.update(aContext.getPackageName().getBytes());
                    final StringBuilder stringBuilder = new StringBuilder();
                    for (byte b : messageDigest.digest()) {
                        stringBuilder.append(String.format("%02X", b));
                    }
                    hashedPhoneId = stringBuilder.toString();
                } catch (Exception e) {
                    Log.e(LoggingExceptionHandler.class.getName(), "Unable to get phone id", e);
                    hashedPhoneId = "Not Available";
                }
            }
        }
        return hashedPhoneId;
    }
} </s>
<s>class temp {    protected long getUrlSize(String location) {
        long returnValue = 0L;
        try {
            URL url = new URL(location);
            java.net.HttpURLConnection conn = (java.net.HttpURLConnection) url.openConnection();
            conn.setRequestMethod("HEAD");
            returnValue = conn.getContentLength();
        } catch (IOException ioe) {
            logger.error("Failed to find proper size for entity at " + location, ioe);
        }
        return returnValue;
    }
} </s>
<s>class temp {    public String sendXml(URL url, String xmlMessage, boolean isResponseExpected) throws IOException {
        if (url == null) {
            throw new IllegalArgumentException("url == null");
        }
        if (xmlMessage == null) {
            throw new IllegalArgumentException("xmlMessage == null");
        }
        LOGGER.finer("url = " + url);
        LOGGER.finer("xmlMessage = :" + xmlMessage + ":");
        LOGGER.finer("isResponseExpected = " + isResponseExpected);
        String answer = null;
        try {
            URLConnection urlConnection = url.openConnection();
            urlConnection.setRequestProperty("Content-type", "text/xml");
            urlConnection.setDoOutput(true);
            urlConnection.setUseCaches(false);
            Writer writer = null;
            try {
                writer = new OutputStreamWriter(urlConnection.getOutputStream());
                writer.write(xmlMessage);
                writer.flush();
            } finally {
                if (writer != null) {
                    writer.close();
                }
            }
            LOGGER.finer("message written");
            StringBuilder sb = new StringBuilder();
            BufferedReader in = null;
            try {
                in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));
                if (isResponseExpected) {
                    String inputLine;
                    while ((inputLine = in.readLine()) != null) {
                        sb.append(inputLine).append("\n");
                    }
                    answer = sb.toString();
                    LOGGER.finer("response read");
                }
            } catch (FileNotFoundException e) {
                LOGGER.log(Level.SEVERE, "No response", e);
            } finally {
                if (in != null) {
                    in.close();
                }
            }
        } catch (ConnectException e) {
            LOGGER.log(Level.SEVERE, e.getMessage(), e);
        }
        LOGGER.finer("answer = :" + answer + ":");
        return answer;
    }
} </s>
<s>class temp {    public static void fileCopy(String from_name, String to_name) throws IOException {
        File fromFile = new File(from_name);
        File toFile = new File(to_name);
        if (fromFile.equals(toFile)) abort("cannot copy on itself: " + from_name);
        if (!fromFile.exists()) abort("no such currentSourcepartName file: " + from_name);
        if (!fromFile.isFile()) abort("can't copy directory: " + from_name);
        if (!fromFile.canRead()) abort("currentSourcepartName file is unreadable: " + from_name);
        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());
        if (toFile.exists()) {
            if (!toFile.canWrite()) abort("destination file is unwriteable: " + to_name);
        } else {
            String parent = toFile.getParent();
            if (parent == null) abort("destination directory doesn't exist: " + parent);
            File dir = new File(parent);
            if (!dir.exists()) abort("destination directory doesn't exist: " + parent);
            if (dir.isFile()) abort("destination is not a directory: " + parent);
            if (!dir.canWrite()) abort("destination directory is unwriteable: " + parent);
        }
        FileInputStream from = null;
        FileOutputStream to = null;
        try {
            from = new FileInputStream(fromFile);
            to = new FileOutputStream(toFile);
            byte[] buffer = new byte[4096];
            int bytes_read;
            while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read);
        } finally {
            if (from != null) try {
                from.close();
            } catch (IOException e) {
                ;
            }
            if (to != null) try {
                to.close();
            } catch (IOException e) {
                ;
            }
        }
    }
} </s>
<s>class temp {    public ArrayList<Jane16Results> callExternalService(ServiceType type, HashMap<String, String> params) throws Exception {
        URL url = initURL(type, params);
        XMLParser parser = initParser(type);
        InputStream in = url.openStream();
        ArrayList<Jane16Results> results = new ArrayList<Jane16Results>();
        byte[] buf = new byte[1024];
        ArrayList<Byte> arrByte = new ArrayList<Byte>();
        int len;
        while ((len = in.read(buf)) > 0) {
            for (int i = 0; i < len; i++) {
                arrByte.add(buf[i]);
            }
        }
        in.close();
        byte[] data = new byte[arrByte.size()];
        int i = 0;
        for (Byte b : arrByte) {
            data[i++] = b;
        }
        results = parser.parse(data);
        return results;
    }
} </s>
<s>class temp {    public static void saveChangeLink(URL url, OutputStream os) {
        try {
            BufferedInputStream is = new BufferedInputStream(url.openStream());
            int i;
            while ((i = is.read()) != -1) if ((char) i == '<') {
                String s = readTag(is);
                String s1 = convertTag(url, s);
                os.write(s1.getBytes());
            } else {
                os.write((byte) i);
            }
        } catch (Exception _ex) {
        }
    }
} </s>
<s>class temp {    public void postProcess() throws StopWriterVisitorException {
        shpWriter.postProcess();
        try {
            FileChannel fcinShp = new FileInputStream(fTemp).getChannel();
            FileChannel fcoutShp = new FileOutputStream(fileShp).getChannel();
            DriverUtilities.copy(fcinShp, fcoutShp);
            File shxFile = SHP.getShxFile(fTemp);
            FileChannel fcinShx = new FileInputStream(shxFile).getChannel();
            FileChannel fcoutShx = new FileOutputStream(SHP.getShxFile(fileShp)).getChannel();
            DriverUtilities.copy(fcinShx, fcoutShx);
            File dbfFile = getDataFile(fTemp);
            short originalEncoding = DbfEncodings.getInstance().getDbfIdForCharset(shpWriter.getCharset());
            RandomAccessFile fo = new RandomAccessFile(dbfFile, "rw");
            fo.seek(29);
            fo.writeByte(originalEncoding);
            fo.close();
            FileChannel fcinDbf = new FileInputStream(dbfFile).getChannel();
            FileChannel fcoutDbf = new FileOutputStream(getDataFile(fileShp)).getChannel();
            DriverUtilities.copy(fcinDbf, fcoutDbf);
            fTemp.delete();
            shxFile.delete();
            dbfFile.delete();
            reload();
        } catch (FileNotFoundException e) {
            throw new StopWriterVisitorException(getName(), e);
        } catch (IOException e) {
            throw new StopWriterVisitorException(getName(), e);
        } catch (ReloadDriverException e) {
            throw new StopWriterVisitorException(getName(), e);
        }
    }
} </s>
<s>class temp {    public void addFile(File fileobj, boolean delete) {
        String oldFileName = fileobj.getPath();
        String currFileName = setUpFile(fileobj);
        if (currFileName != null) {
            File f = new File(currFileName);
            int deleteFiles = JOptionPane.CANCEL_OPTION;
            if (oldFileName.equals(currFileName)) {
                currFileName = currFileName.substring(openProject.getPath().length());
                openProject.addFile(currFileName);
                if (f.getName().toLowerCase().endsWith(".exp")) addExpFile(f.getPath());
            } else if (!f.exists() || JOptionPane.OK_OPTION == (deleteFiles = JOptionPane.showConfirmDialog(this, "File" + f.getName() + " Already Exists! Do You Wish To Overwrite That File?" + (f.getName().toLowerCase().endsWith(".exp") ? "\nOverwriting An Expression File Will Delete All Files Which Previously Required The Orginal File" : "")))) {
                try {
                    if (deleteFiles == JOptionPane.OK_OPTION && f.getName().toLowerCase().endsWith(".exp")) {
                        File expF[] = f.getParentFile().listFiles();
                        for (int i = 0; i < expF.length; i++) {
                            while (expF[i].exists()) {
                                expF[i].delete();
                            }
                        }
                        f.getParentFile().delete();
                    }
                    f.getParentFile().mkdirs();
                    f.createNewFile();
                    FileInputStream in = new FileInputStream(fileobj);
                    FileOutputStream out = new FileOutputStream(f);
                    byte[] buffer = new byte[8 * 1024];
                    int count = 0;
                    do {
                        out.write(buffer, 0, count);
                        count = in.read(buffer, 0, buffer.length);
                    } while (count != -1);
                    in.close();
                    out.close();
                    if (delete) fileobj.delete();
                } catch (Exception e2) {
                    JOptionPane.showMessageDialog(this, "Error! Could Not Add " + fileobj.getName() + " To Project");
                }
                currFileName = currFileName.substring(currFileName.lastIndexOf(openProject.getName()) + openProject.getName().length() + 1);
                openProject.addFile(currFileName);
                if (f.getName().toLowerCase().endsWith(".exp")) addExpFile(f.getPath());
            }
        } else {
            String message = "Error! Could Not Add " + fileobj.getName() + " To Project\n";
            if (fileobj.getName().endsWith(".gprj")) {
                message += "You May Not Add A Project File To An Existing Project";
            } else if (fileobj.getName().toLowerCase().endsWith(".ds_store")) {
                message = "";
            } else if (fileobj.getName().toLowerCase().endsWith(".txt")) {
                message = "";
            } else if (fileobj.getName().toLowerCase().endsWith(".gif")) {
                message = "";
            } else if (fileobj.getName().toLowerCase().endsWith(".jpeg")) {
                message = "";
            } else if (fileobj.getName().toLowerCase().endsWith(".jpg")) {
                message = "";
            } else if (fileobj.getName().toLowerCase().endsWith(".info")) {
                message = "";
            } else if (fileobj.getName().toLowerCase().endsWith(".html")) {
                message = "";
            } else if (fileobj.getName().toLowerCase().endsWith(".db")) {
                message = "";
            } else if (fileobj.getName().toLowerCase().endsWith(".raw")) {
                message = "";
            } else if (fileobj.getName().toLowerCase().endsWith(".cdt")) {
                message = "";
            } else if (fileobj.getName().toLowerCase().endsWith(".gtr")) {
                message = "";
            } else if (fileobj.getName().toLowerCase().endsWith(".jtv")) {
                message = "";
            } else message += "File Extension Unknown. Please Check The File To Ensure It Has The Correct Extension";
            if (!message.equals("")) JOptionPane.showMessageDialog(this, message);
        }
    }
} </s>
<s>class temp {    String fetch_m3u(String m3u) {
        InputStream pstream = null;
        if (m3u.startsWith("http://")) {
            try {
                URL url = null;
                if (running_as_applet) url = new URL(getCodeBase(), m3u); else url = new URL(m3u);
                URLConnection urlc = url.openConnection();
                pstream = urlc.getInputStream();
            } catch (Exception ee) {
                System.err.println(ee);
                return null;
            }
        }
        if (pstream == null && !running_as_applet) {
            try {
                pstream = new FileInputStream(System.getProperty("user.dir") + System.getProperty("file.separator") + m3u);
            } catch (Exception ee) {
                System.err.println(ee);
                return null;
            }
        }
        String line = null;
        while (true) {
            try {
                line = readline(pstream);
            } catch (Exception e) {
            }
            if (line == null) break;
            return line;
        }
        return null;
    }
} </s>
<s>class temp {    void loadPlaylist() {
        if (running_as_applet) {
            String s = null;
            for (int i = 0; i < 10; i++) {
                s = getParameter("jorbis.player.play." + i);
                if (s == null) break;
                playlist.addElement(s);
            }
        }
        if (playlistfile == null) {
            return;
        }
        try {
            InputStream is = null;
            try {
                URL url = null;
                if (running_as_applet) url = new URL(getCodeBase(), playlistfile); else url = new URL(playlistfile);
                URLConnection urlc = url.openConnection();
                is = urlc.getInputStream();
            } catch (Exception ee) {
            }
            if (is == null && !running_as_applet) {
                try {
                    is = new FileInputStream(System.getProperty("user.dir") + System.getProperty("file.separator") + playlistfile);
                } catch (Exception ee) {
                }
            }
            if (is == null) return;
            while (true) {
                String line = readline(is);
                if (line == null) break;
                byte[] foo = line.getBytes();
                for (int i = 0; i < foo.length; i++) {
                    if (foo[i] == 0x0d) {
                        line = new String(foo, 0, i);
                        break;
                    }
                }
                playlist.addElement(line);
            }
        } catch (Exception e) {
            System.out.println(e);
        }
    }
} </s>
<s>class temp {    public static void main(String[] args) {
        if (args.length != 1) {
            System.out.println("Usage: GUnzip source");
            return;
        }
        String zipname, source;
        if (args[0].endsWith(".gz")) {
            zipname = args[0];
            source = args[0].substring(0, args[0].length() - 3);
        } else {
            zipname = args[0] + ".gz";
            source = args[0];
        }
        GZIPInputStream zipin;
        try {
            FileInputStream in = new FileInputStream(zipname);
            zipin = new GZIPInputStream(in);
        } catch (IOException e) {
            System.out.println("Couldn't open " + zipname + ".");
            return;
        }
        byte[] buffer = new byte[sChunk];
        try {
            FileOutputStream out = new FileOutputStream(source);
            int length;
            while ((length = zipin.read(buffer, 0, sChunk)) != -1) out.write(buffer, 0, length);
            out.close();
        } catch (IOException e) {
            System.out.println("Couldn't decompress " + args[0] + ".");
        }
        try {
            zipin.close();
        } catch (IOException e) {
        }
    }
} </s>
<s>class temp {    public static Status checkUpdate() {
        Status updateStatus = Status.FAILURE;
        URL url;
        InputStream is;
        InputStreamReader isr;
        BufferedReader r;
        String line;
        try {
            url = new URL(updateURL);
            is = url.openStream();
            isr = new InputStreamReader(is);
            r = new BufferedReader(isr);
            String variable, value;
            while ((line = r.readLine()) != null) {
                if (!line.equals("") && line.charAt(0) != '/') {
                    variable = line.substring(0, line.indexOf('='));
                    value = line.substring(line.indexOf('=') + 1);
                    if (variable.equals("Latest Version")) {
                        variable = value;
                        value = variable.substring(0, variable.indexOf(" "));
                        variable = variable.substring(variable.indexOf(" ") + 1);
                        latestGameVersion = value;
                        latestModifier = variable;
                        if (Float.parseFloat(value) > Float.parseFloat(gameVersion)) updateStatus = Status.NOT_CURRENT; else updateStatus = Status.CURRENT;
                    } else if (variable.equals("Download URL")) downloadURL = value;
                }
            }
            return updateStatus;
        } catch (MalformedURLException e) {
            return Status.URL_NOT_FOUND;
        } catch (IOException e) {
            return Status.FAILURE;
        }
    }
} </s>
<s>class temp {    @Override
    void retrieveSupplementalInfo() throws IOException, InterruptedException {
        String encodedProductID = URLEncoder.encode(productID, "UTF-8");
        String uri = BASE_PRODUCT_URI + encodedProductID;
        HttpUriRequest head = new HttpGet(uri);
        AndroidHttpClient client = AndroidHttpClient.newInstance(null);
        HttpResponse response = client.execute(head);
        int status = response.getStatusLine().getStatusCode();
        if (status != 200) {
            return;
        }
        String content = consume(response.getEntity());
        Matcher matcher = PRODUCT_NAME_PRICE_PATTERN.matcher(content);
        if (matcher.find()) {
            append(matcher.group(1));
            append(matcher.group(2));
        }
        setLink(uri);
    }
} </s>
<s>class temp {    protected static IFile createTempFile(CodeFile codeFile) {
        IPath path = Util.getAbsolutePathFromCodeFile(codeFile);
        File file = new File(path.toOSString());
        String[] parts = codeFile.getName().split("\\.");
        String extension = parts[parts.length - 1];
        IPath ext = path.addFileExtension(extension);
        File tempFile = new File(ext.toOSString());
        if (tempFile.exists()) {
            boolean deleted = tempFile.delete();
            System.out.println("deleted: " + deleted);
        }
        try {
            boolean created = tempFile.createNewFile();
            if (created) {
                FileOutputStream fos = new FileOutputStream(tempFile);
                FileInputStream fis = new FileInputStream(file);
                while (fis.available() > 0) {
                    fos.write(fis.read());
                }
                fis.close();
                fos.close();
                IFile iFile = Util.getFileFromPath(ext);
                return iFile;
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }
} </s>
<s>class temp {    private BufferedReader getReader(final String fileUrl) throws IOException {
        InputStreamReader reader;
        try {
            reader = new FileReader(fileUrl);
        } catch (FileNotFoundException e) {
            URL url = new URL(fileUrl);
            reader = new InputStreamReader(url.openStream());
        }
        return new BufferedReader(reader);
    }
} </s>
<s>class temp {    public void copyFile(String source_name, String dest_name) throws IOException {
        File source_file = new File(source_name);
        File destination_file = new File(dest_name);
        Reader source = null;
        Writer destination = null;
        char[] buffer;
        int bytes_read;
        try {
            if (!source_file.exists() || !source_file.isFile()) throw new FileCopyException("FileCopy: no such source file: " + source_name);
            if (!source_file.canRead()) throw new FileCopyException("FileCopy: source file " + "is unreadable: " + source_name);
            if (destination_file.exists()) {
                if (destination_file.isFile()) {
                    DataInputStream in = new DataInputStream(System.in);
                    String response;
                    if (!destination_file.canWrite()) throw new FileCopyException("FileCopy: destination " + "file is unwriteable: " + dest_name);
                } else {
                    throw new FileCopyException("FileCopy: destination " + "is not a file: " + dest_name);
                }
            } else {
                File parentdir = parent(destination_file);
                if (!parentdir.exists()) throw new FileCopyException("FileCopy: destination " + "directory doesn't exist: " + dest_name);
                if (!parentdir.canWrite()) throw new FileCopyException("FileCopy: destination " + "directory is unwriteable: " + dest_name);
            }
            source = new BufferedReader(new FileReader(source_file));
            destination = new BufferedWriter(new FileWriter(destination_file));
            buffer = new char[1024];
            while (true) {
                bytes_read = source.read(buffer, 0, 1024);
                if (bytes_read == -1) break;
                destination.write(buffer, 0, bytes_read);
            }
        } finally {
            if (source != null) {
                try {
                    source.close();
                } catch (IOException e) {
                    ;
                }
            }
            if (destination != null) {
                try {
                    destination.close();
                } catch (IOException e) {
                    ;
                }
            }
        }
    }
} </s>
<s>class temp {    public Configuration(URL url) {
        InputStream in = null;
        try {
            load(in = url.openStream());
        } catch (Exception e) {
            throw new RuntimeException("Could not load configuration from " + url, e);
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException ignore) {
                }
            }
        }
    }
} </s>
<s>class temp {    public static String calcHA1(String algorithm, String username, String realm, String password, String nonce, String cnonce) throws FatalException, MD5DigestException {
        MD5Encoder encoder = new MD5Encoder();
        MessageDigest md5 = null;
        try {
            md5 = MessageDigest.getInstance("MD5");
        } catch (Exception e) {
            throw new FatalException(e);
        }
        if (username == null || realm == null) {
            throw new MD5DigestException(WebdavStatus.SC_BAD_REQUEST, "username or realm");
        }
        if (password == null) {
            System.err.println("No password has been provided");
            throw new IllegalStateException();
        }
        if (algorithm != null && algorithm.equals("MD5-sess") && (nonce == null || cnonce == null)) {
            throw new MD5DigestException(WebdavStatus.SC_BAD_REQUEST, "nonce or cnonce");
        }
        md5.update((username + ":" + realm + ":" + password).getBytes());
        if (algorithm != null && algorithm.equals("MD5-sess")) {
            md5.update((":" + nonce + ":" + cnonce).getBytes());
        }
        return encoder.encode(md5.digest());
    }
} </s>
<s>class temp {    public static String calcResponse(String ha1, String nonce, String nonceCount, String cnonce, String qop, String method, String uri) throws FatalException, MD5DigestException {
        MD5Encoder encoder = new MD5Encoder();
        String ha2 = null;
        MessageDigest md5 = null;
        try {
            md5 = MessageDigest.getInstance("MD5");
        } catch (Exception e) {
            throw new FatalException(e);
        }
        if (method == null || uri == null) {
            throw new MD5DigestException(WebdavStatus.SC_BAD_REQUEST, "method or uri");
        }
        if (qop != null && qop.equals("auth-int")) {
            throw new MD5DigestException(WebdavStatus.SC_UNSUPPORTED_MEDIA_TYPE);
        }
        if (nonce == null) {
            throw new MD5DigestException(WebdavStatus.SC_BAD_REQUEST, "nonce");
        }
        if (qop != null && (qop.equals("auth") || qop.equals("auth-int"))) {
            if (nonceCount == null || cnonce == null) {
                throw new MD5DigestException(WebdavStatus.SC_BAD_REQUEST, "nc or cnonce");
            }
        }
        md5.update((method + ":" + uri).getBytes());
        ha2 = encoder.encode(md5.digest());
        md5.update((ha1 + ":" + nonce + ":").getBytes());
        if (qop != null && (qop.equals("auth") || qop.equals("auth-int"))) {
            md5.update((nonceCount + ":" + cnonce + ":" + qop + ":").getBytes());
        }
        md5.update(ha2.getBytes());
        String response = encoder.encode(md5.digest());
        return response;
    }
} </s>
<s>class temp {    public static void copy(File _from, File _to) throws IOException {
        if (_from == null || !_from.exists()) return;
        FileOutputStream out = null;
        FileInputStream in = null;
        try {
            out = new FileOutputStream(_to);
            in = new FileInputStream(_from);
            byte[] buf = new byte[2048];
            int read = in.read(buf);
            while (read > 0) {
                out.write(buf, 0, read);
                read = in.read(buf);
            }
        } catch (IOException _e) {
            throw _e;
        } finally {
            if (in != null) in.close();
            if (out != null) out.close();
        }
    }
} </s>
<s>class temp {    public static String encrypt(String text) {
        MessageDigest md;
        try {
            md = MessageDigest.getInstance("MD5");
            byte[] md5hash = new byte[32];
            md.update(text.getBytes("UTF-8"), 0, text.length());
            md5hash = md.digest();
            return convertToHex(md5hash);
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
        return null;
    }
} </s>
<s>class temp {    public AbstractASiCSignatureService(InputStream documentInputStream, DigestAlgo digestAlgo, RevocationDataService revocationDataService, TimeStampService timeStampService, String claimedRole, IdentityDTO identity, byte[] photo, TemporaryDataStorage temporaryDataStorage, OutputStream documentOutputStream) throws IOException {
        super(digestAlgo);
        this.temporaryDataStorage = temporaryDataStorage;
        this.documentOutputStream = documentOutputStream;
        this.tmpFile = File.createTempFile("eid-dss-", ".asice");
        FileOutputStream fileOutputStream;
        fileOutputStream = new FileOutputStream(this.tmpFile);
        IOUtils.copy(documentInputStream, fileOutputStream);
        addSignatureFacet(new ASiCSignatureFacet(this.tmpFile, digestAlgo));
        XAdESSignatureFacet xadesSignatureFacet = new XAdESSignatureFacet(getSignatureDigestAlgorithm());
        xadesSignatureFacet.setRole(claimedRole);
        xadesSignatureFacet.setXadesNamespacePrefix("xades");
        addSignatureFacet(xadesSignatureFacet);
        addSignatureFacet(new XAdESXLSignatureFacet(timeStampService, revocationDataService, getSignatureDigestAlgorithm()));
        addSignatureFacet(new KeyInfoSignatureFacet(true, false, false));
        if (null != identity) {
            IdentitySignatureFacet identitySignatureFacet = new IdentitySignatureFacet(identity, photo, getSignatureDigestAlgorithm());
            addSignatureFacet(identitySignatureFacet);
        }
    }
} </s>
<s>class temp {    private static void readAndRewrite(File inFile, File outFile) throws IOException {
        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));
        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);
        Dataset ds = DcmObjectFactory.getInstance().newDataset();
        dcmParser.setDcmHandler(ds.getDcmHandler());
        dcmParser.parseDcmFile(null, Tags.PixelData);
        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        System.out.println("reading " + inFile + "...");
        pdReader.readPixelData(false);
        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));
        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;
        ds.writeDataset(out, dcmEncParam);
        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());
        System.out.println("writing " + outFile + "...");
        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());
        pdWriter.writePixelData();
        out.flush();
        out.close();
        System.out.println("done!");
    }
} </s>
<s>class temp {    public void insertArchiveEntries(ArchiveEntry entries[]) throws WeatherMonitorException {
        String sql = null;
        try {
            Connection con = getConnection();
            Statement stmt = con.createStatement();
            ResultSet rslt = null;
            con.setAutoCommit(false);
            for (int i = 0; i < entries.length; i++) {
                if (!sanityCheck(entries[i])) {
                } else {
                    sql = getSelectSql(entries[i]);
                    rslt = stmt.executeQuery(sql);
                    if (rslt.next()) {
                        if (rslt.getInt(1) == 0) {
                            sql = getInsertSql(entries[i]);
                            if (stmt.executeUpdate(sql) != 1) {
                                con.rollback();
                                System.out.println("rolling back sql");
                                throw new WeatherMonitorException("exception on insert");
                            }
                        }
                    }
                }
            }
            con.commit();
            stmt.close();
        } catch (SQLException e) {
            e.printStackTrace();
            throw new WeatherMonitorException(e.getMessage());
        }
    }
} </s>
<s>class temp {    private void displayDiffResults() throws IOException {
        File outFile = File.createTempFile("diff", ".htm");
        outFile.deleteOnExit();
        FileOutputStream outStream = new FileOutputStream(outFile);
        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));
        out.write("<html><head><title>LOC Differences</title>\n" + SCRIPT + "</head>\n" + "<body bgcolor='#ffffff'>\n" + "<div onMouseOver=\"window.defaultStatus='Metrics'\">\n");
        if (addedTable.length() > 0) {
            out.write("<table border><tr><th>Files Added:</th>" + "<th>Add</th><th>Type</th></tr>");
            out.write(addedTable.toString());
            out.write("</table><br><br>");
        }
        if (modifiedTable.length() > 0) {
            out.write("<table border><tr><th>Files Modified:</th>" + "<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>" + "<th>Total</th><th>Type</th></tr>");
            out.write(modifiedTable.toString());
            out.write("</table><br><br>");
        }
        if (deletedTable.length() > 0) {
            out.write("<table border><tr><th>Files Deleted:</th>" + "<th>Del</th><th>Type</th></tr>");
            out.write(deletedTable.toString());
            out.write("</table><br><br>");
        }
        out.write("<table name=METRICS BORDER>\n");
        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {
            out.write("<tr><td>Base:&nbsp;</td><td>");
            out.write(Long.toString(base));
            out.write("</td></tr>\n<tr><td>Deleted:&nbsp;</td><td>");
            out.write(Long.toString(deleted));
            out.write("</td></tr>\n<tr><td>Modified:&nbsp;</td><td>");
            out.write(Long.toString(modified));
            out.write("</td></tr>\n<tr><td>Added:&nbsp;</td><td>");
            out.write(Long.toString(added));
            out.write("</td></tr>\n<tr><td>New & Changed:&nbsp;</td><td>");
            out.write(Long.toString(added + modified));
            out.write("</td></tr>\n");
        }
        out.write("<tr><td>Total:&nbsp;</td><td>");
        out.write(Long.toString(total));
        out.write("</td></tr>\n</table></div>");
        redlinesOut.close();
        out.flush();
        InputStream redlines = new FileInputStream(redlinesTempFile);
        byte[] buffer = new byte[4096];
        int bytesRead;
        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);
        outStream.write("</BODY></HTML>".getBytes());
        outStream.close();
        Browser.launch(outFile.toURL().toString());
    }
} </s>
<s>class temp {    public static Observacion load() {
        Observacion obs = new Observacion(new Date());
        FTPClient f = new FTPClient();
        SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd");
        final String datestamp = sdf.format(new Date());
        String pathname = String.format(PATHNAME_PATTERN, datestamp);
        try {
            InetAddress server = InetAddress.getByName(HOST);
            f.connect(server);
            f.login(USERNAME, PASSWORD);
            FTPFile[] files = f.listFiles(pathname, new FTPFileFilter() {

                @Override
                public boolean accept(FTPFile file) {
                    return file.getName().startsWith(datestamp);
                }
            });
            FTPFile file = files[files.length - 1];
            f.setFileTransferMode(FTPClient.BINARY_FILE_TYPE);
            boolean download = false;
            String remote = pathname + "/" + file.getName();
            if (download) {
                File out = new File("/home/randres/Desktop/" + file.getName());
                FileOutputStream fout = new FileOutputStream(out);
                fout.flush();
                fout.close();
            } else {
                GZIPInputStream gzipin = new GZIPInputStream(f.retrieveFileStream(remote));
                LineNumberReader lreader = new LineNumberReader(new InputStreamReader(gzipin, "Cp1250"));
                String line = null;
                while ((line = lreader.readLine()) != null) {
                    obs.addEstacion(AemetRetriever.processLine(line));
                }
                lreader.close();
            }
            f.disconnect();
        } catch (Exception e) {
            LOGGER.log(Level.WARNING, "Cannot retrieve data from FTP", e);
        }
        return obs;
    }
} </s>
<s>class temp {    public TestHttpSSLClient(final HttpParams params) throws Exception {
        super();
        this.params = params;
        this.ioReactor = new DefaultConnectingIOReactor(2, this.params);
        ClassLoader cl = getClass().getClassLoader();
        URL url = cl.getResource("test.keystore");
        KeyStore keystore = KeyStore.getInstance("jks");
        keystore.load(url.openStream(), "nopassword".toCharArray());
        TrustManagerFactory tmfactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
        tmfactory.init(keystore);
        TrustManager[] trustmanagers = tmfactory.getTrustManagers();
        this.sslcontext = SSLContext.getInstance("TLS");
        this.sslcontext.init(null, trustmanagers, null);
    }
} </s>
<s>class temp {    public static void copyFile(File in, File out, boolean read, boolean write, boolean execute) throws FileNotFoundException, IOException {
        FileChannel inChannel = new FileInputStream(in).getChannel();
        File outFile = null;
        if (out.isDirectory()) {
            outFile = new File(out.getAbsolutePath() + File.separator + in.getName());
        } else {
            outFile = out;
        }
        FileChannel outChannel = new FileOutputStream(outFile).getChannel();
        try {
            int maxCount = (64 * 1024 * 1024) - (32 * 1024);
            long size = inChannel.size();
            long position = 0;
            while (position < size) {
                position += inChannel.transferTo(position, maxCount, outChannel);
            }
            outFile.setReadable(read);
            outFile.setWritable(write);
            outFile.setExecutable(execute);
        } catch (IOException e) {
            throw e;
        } finally {
            if (inChannel != null) inChannel.close();
            if (outChannel != null) outChannel.close();
        }
    }
} </s>
<s>class temp {    public void testHandler() throws MalformedURLException, IOException {
        assertTrue("This test can only be run once in a single JVM", imageHasNotBeenInstalledInThisJVM);
        URL url;
        Handler.installImageUrlHandler((ImageSource) new ClassPathXmlApplicationContext("org/springframework/richclient/image/application-context.xml").getBean("imageSource"));
        try {
            url = new URL("image:test");
            imageHasNotBeenInstalledInThisJVM = false;
        } catch (MalformedURLException e) {
            fail("protocol was not installed");
        }
        url = new URL("image:image.that.does.not.exist");
        try {
            url.openConnection();
            fail();
        } catch (NoSuchImageResourceException e) {
        }
        url = new URL("image:test.image.key");
        url.openConnection();
    }
} </s>
<s>class temp {    public static void copyFile(File file, String pathExport) throws IOException {
        File out = new File(pathExport);
        FileChannel sourceChannel = new FileInputStream(file).getChannel();
        FileChannel destinationChannel = new FileOutputStream(out).getChannel();
        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);
        sourceChannel.close();
        destinationChannel.close();
    }
} </s>
<s>class temp {    private static void unzipEntry(ZipFile zipfile, ZipEntry entry, File outputDir) throws IOException {
        if (entry.isDirectory()) {
            createDir(new File(outputDir, entry.getName()));
            return;
        }
        File outputFile = new File(outputDir, entry.getName());
        if (!outputFile.getParentFile().exists()) {
            createDir(outputFile.getParentFile());
        }
        BufferedInputStream inputStream = new BufferedInputStream(zipfile.getInputStream(entry));
        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(outputFile));
        try {
            IOUtils.copy(inputStream, outputStream);
        } finally {
            outputStream.close();
            inputStream.close();
        }
    }
} </s>
<s>class temp {public static String md5(String text) {
        MessageDigest msgDigest = null;
        try {
            msgDigest = MessageDigest.getInstance("MD5");
        } catch (NoSuchAlgorithmException e) {
            throw new IllegalStateException("System doesn't support MD5 algorithm.");
        }
        try {
            msgDigest.update(text.getBytes(AlipayConfig.CharSet));
        } catch (UnsupportedEncodingException e) {
            throw new IllegalStateException("System doesn't support your  EncodingException.");
        }
        byte[] bytes = msgDigest.digest();
        String md5Str = new String(encodeHex(bytes));
        return md5Str;
    }} </s>
<s>class temp {    public static long copy(File src, File dest) throws UtilException {
        FileChannel srcFc = null;
        FileChannel destFc = null;
        try {
            srcFc = new FileInputStream(src).getChannel();
            destFc = new FileOutputStream(dest).getChannel();
            long srcLength = srcFc.size();
            srcFc.transferTo(0, srcLength, destFc);
            return srcLength;
        } catch (IOException e) {
            throw new UtilException(e);
        } finally {
            try {
                if (srcFc != null) srcFc.close();
                srcFc = null;
            } catch (IOException e) {
            }
            try {
                if (destFc != null) destFc.close();
                destFc = null;
            } catch (IOException e) {
            }
        }
    }
} </s>
<s>class temp {    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        final Map<String, String> fileAttr = new HashMap<String, String>();
        boolean download = false;
        String dw = req.getParameter("d");
        if (StringUtils.isNotEmpty(dw) && StringUtils.equals(dw, "true")) {
            download = true;
        }
        final ByteArrayOutputStream imageOutputStream = new ByteArrayOutputStream(DEFAULT_CONTENT_LENGTH_SIZE);
        InputStream imageInputStream = null;
        try {
            imageInputStream = getImageAsStream(req, fileAttr);
            IOUtils.copy(imageInputStream, imageOutputStream);
            resp.setHeader("Cache-Control", "no-store");
            resp.setHeader("Pragma", "no-cache");
            resp.setDateHeader("Expires", 0);
            resp.setContentType(fileAttr.get("mimetype"));
            if (download) {
                resp.setHeader("Content-Disposition", "attachment; filename=\"" + fileAttr.get("filename") + "\"");
            }
            final ServletOutputStream responseOutputStream = resp.getOutputStream();
            responseOutputStream.write(imageOutputStream.toByteArray());
            responseOutputStream.flush();
            responseOutputStream.close();
        } catch (Exception e) {
            e.printStackTrace();
            resp.setContentType("text/html");
            resp.getWriter().println("<h1>Sorry... cannot find document</h1>");
        } finally {
            IOUtils.closeQuietly(imageInputStream);
            IOUtils.closeQuietly(imageOutputStream);
        }
    }
} </s>
<s>class temp {    void updateSource(Class<?> type) throws Exception {
        final String path = type.getName().replaceAll("\\.", "/") + ".java";
        new Thread(new Runnable() {

            @Override
            public void run() {
                try {
                    URL url = Thread.currentThread().getContextClassLoader().getResource(path);
                    InputStream fis = url.openStream();
                    InputStreamReader r = new InputStreamReader(fis, "UTF-8");
                    BufferedReader br = new BufferedReader(r);
                    String line;
                    StringBuilder sb = new StringBuilder();
                    while (null != (line = br.readLine())) {
                        sb.append(line);
                        sb.append("\r\n");
                    }
                    br.close();
                    r.close();
                    fis.close();
                    final String text = sb.toString();
                    SwingUtilities.invokeLater(new Runnable() {

                        @Override
                        public void run() {
                            MainPanel.this.source.setText(text);
                            MainPanel.this.source.setCaretPosition(0);
                        }
                    });
                } catch (Exception ex) {
                }
            }
        }).start();
    }
} </s>
<s>class temp {            @Override
            public void run() {
                try {
                    URL url = Thread.currentThread().getContextClassLoader().getResource(path);
                    InputStream fis = url.openStream();
                    InputStreamReader r = new InputStreamReader(fis, "UTF-8");
                    BufferedReader br = new BufferedReader(r);
                    String line;
                    StringBuilder sb = new StringBuilder();
                    while (null != (line = br.readLine())) {
                        sb.append(line);
                        sb.append("\r\n");
                    }
                    br.close();
                    r.close();
                    fis.close();
                    final String text = sb.toString();
                    SwingUtilities.invokeLater(new Runnable() {

                        @Override
                        public void run() {
                            MainPanel.this.source.setText(text);
                            MainPanel.this.source.setCaretPosition(0);
                        }
                    });
                } catch (Exception ex) {
                }
            }
} </s>
<s>class temp {    private void displayDiffResults() throws IOException {
        File outFile = File.createTempFile("diff", ".htm");
        outFile.deleteOnExit();
        FileOutputStream outStream = new FileOutputStream(outFile);
        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));
        out.write("<html><head><title>LOC Differences</title>\n" + SCRIPT + "</head>\n" + "<body bgcolor='#ffffff'>\n" + "<div onMouseOver=\"window.defaultStatus='Metrics'\">\n");
        if (addedTable.length() > 0) {
            out.write("<table border><tr><th>Files Added:</th>" + "<th>Add</th><th>Type</th></tr>");
            out.write(addedTable.toString());
            out.write("</table><br><br>");
        }
        if (modifiedTable.length() > 0) {
            out.write("<table border><tr><th>Files Modified:</th>" + "<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>" + "<th>Total</th><th>Type</th></tr>");
            out.write(modifiedTable.toString());
            out.write("</table><br><br>");
        }
        if (deletedTable.length() > 0) {
            out.write("<table border><tr><th>Files Deleted:</th>" + "<th>Del</th><th>Type</th></tr>");
            out.write(deletedTable.toString());
            out.write("</table><br><br>");
        }
        out.write("<table name=METRICS BORDER>\n");
        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {
            out.write("<tr><td>Base:&nbsp;</td><td>");
            out.write(Long.toString(base));
            out.write("</td></tr>\n<tr><td>Deleted:&nbsp;</td><td>");
            out.write(Long.toString(deleted));
            out.write("</td></tr>\n<tr><td>Modified:&nbsp;</td><td>");
            out.write(Long.toString(modified));
            out.write("</td></tr>\n<tr><td>Added:&nbsp;</td><td>");
            out.write(Long.toString(added));
            out.write("</td></tr>\n<tr><td>New & Changed:&nbsp;</td><td>");
            out.write(Long.toString(added + modified));
            out.write("</td></tr>\n");
        }
        out.write("<tr><td>Total:&nbsp;</td><td>");
        out.write(Long.toString(total));
        out.write("</td></tr>\n</table></div>");
        redlinesOut.close();
        out.flush();
        InputStream redlines = new FileInputStream(redlinesTempFile);
        byte[] buffer = new byte[4096];
        int bytesRead;
        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);
        outStream.write("</BODY></HTML>".getBytes());
        outStream.close();
        Browser.launch(outFile.toURL().toString());
    }
} </s>
<s>class temp {    public static void doVersionCheck(View view) {
        view.showWaitCursor();
        try {
            URL url = new URL(jEdit.getProperty("version-check.url"));
            InputStream in = url.openStream();
            BufferedReader bin = new BufferedReader(new InputStreamReader(in));
            String line;
            String develBuild = null;
            String stableBuild = null;
            while ((line = bin.readLine()) != null) {
                if (line.startsWith(".build")) develBuild = line.substring(6).trim(); else if (line.startsWith(".stablebuild")) stableBuild = line.substring(12).trim();
            }
            bin.close();
            if (develBuild != null && stableBuild != null) {
                doVersionCheck(view, stableBuild, develBuild);
            }
        } catch (IOException e) {
            String[] args = { jEdit.getProperty("version-check.url"), e.toString() };
            GUIUtilities.error(view, "read-error", args);
        }
        view.hideWaitCursor();
    }
} </s>
<s>class temp {    public static String encode(String text) {
        try {
            byte[] hash = new byte[32];
            MessageDigest md = MessageDigest.getInstance("MD5");
            md.update(text.getBytes("UTF-8"), 0, text.length());
            hash = md.digest();
            return MD5.toHex(hash);
        } catch (NoSuchAlgorithmException ex) {
            return ex.getMessage();
        } catch (UnsupportedEncodingException ex) {
            return ex.getMessage();
        }
    }
} </s>
<s>class temp {    public static void encryptFile(String infile, String outfile, String keyFile) throws Exception {
        javax.crypto.Cipher cipher = javax.crypto.Cipher.getInstance("DES/ECB/PKCS5Padding");
        cipher.init(javax.crypto.Cipher.ENCRYPT_MODE, getKey());
        java.io.FileInputStream in = new java.io.FileInputStream(infile);
        java.io.FileOutputStream fileOut = new java.io.FileOutputStream(outfile);
        javax.crypto.CipherOutputStream out = new javax.crypto.CipherOutputStream(fileOut, cipher);
        byte[] buffer = new byte[kBufferSize];
        int length;
        while ((length = in.read(buffer)) != -1) out.write(buffer, 0, length);
        in.close();
        out.close();
    }
} </s>
<s>class temp {    public static void decryptFile(String infile, String outfile, String keyFile) throws Exception {
        javax.crypto.Cipher cipher = javax.crypto.Cipher.getInstance("DES/ECB/PKCS5Padding");
        cipher.init(javax.crypto.Cipher.DECRYPT_MODE, getKey());
        java.io.FileInputStream in = new java.io.FileInputStream(infile);
        java.io.FileOutputStream fileOut = new java.io.FileOutputStream(outfile);
        javax.crypto.CipherOutputStream out = new javax.crypto.CipherOutputStream(fileOut, cipher);
        byte[] buffer = new byte[kBufferSize];
        int length;
        while ((length = in.read(buffer)) != -1) out.write(buffer, 0, length);
        in.close();
        out.close();
    }
} </s>
<s>class temp {    public SOCTradeOffer makeOffer(SOCPossiblePiece targetPiece) {
        D.ebugPrintln("***** MAKE OFFER *****");
        if (targetPiece == null) {
            return null;
        }
        SOCTradeOffer offer = null;
        SOCResourceSet targetResources = null;
        switch(targetPiece.getType()) {
            case SOCPossiblePiece.CARD:
                targetResources = SOCGame.CARD_SET;
                break;
            case SOCPossiblePiece.ROAD:
                targetResources = SOCGame.ROAD_SET;
                break;
            case SOCPossiblePiece.SETTLEMENT:
                targetResources = SOCGame.SETTLEMENT_SET;
                break;
            case SOCPossiblePiece.CITY:
                targetResources = SOCGame.CITY_SET;
                break;
        }
        SOCResourceSet ourResources = ourPlayerData.getResources();
        D.ebugPrintln("*** targetResources = " + targetResources);
        D.ebugPrintln("*** ourResources = " + ourResources);
        if (ourResources.contains(targetResources)) {
            return offer;
        }
        if (ourResources.getAmount(SOCResourceConstants.UNKNOWN) > 0) {
            D.ebugPrintln("AGG WE HAVE UNKNOWN RESOURCES !!!! %%%%%%%%%%%%%%%%%%%%%%%%%%%%");
            return offer;
        }
        SOCTradeOffer batna = getOfferToBank(targetResources);
        D.ebugPrintln("*** BATNA = " + batna);
        SOCBuildingSpeedEstimate estimate = new SOCBuildingSpeedEstimate(ourPlayerData.getNumbers());
        SOCResourceSet giveResourceSet = new SOCResourceSet();
        SOCResourceSet getResourceSet = new SOCResourceSet();
        int batnaBuildingTime = getETAToTargetResources(ourPlayerData, targetResources, giveResourceSet, getResourceSet, estimate);
        D.ebugPrintln("*** batnaBuildingTime = " + batnaBuildingTime);
        if (batna != null) {
            batnaBuildingTime = getETAToTargetResources(ourPlayerData, targetResources, batna.getGiveSet(), batna.getGetSet(), estimate);
        }
        D.ebugPrintln("*** batnaBuildingTime = " + batnaBuildingTime);
        int[] rollsPerResource = estimate.getRollsPerResource();
        int[] neededRsrc = new int[5];
        int[] notNeededRsrc = new int[5];
        int neededRsrcCount = 0;
        int notNeededRsrcCount = 0;
        for (int rsrcType = SOCResourceConstants.CLAY; rsrcType <= SOCResourceConstants.WOOD; rsrcType++) {
            if (targetResources.getAmount(rsrcType) > 0) {
                neededRsrc[neededRsrcCount] = rsrcType;
                neededRsrcCount++;
            } else {
                notNeededRsrc[notNeededRsrcCount] = rsrcType;
                notNeededRsrcCount++;
            }
        }
        for (int j = neededRsrcCount - 1; j >= 0; j--) {
            for (int i = 0; i < j; i++) {
                if (rollsPerResource[neededRsrc[i]] > rollsPerResource[neededRsrc[i + 1]]) {
                    int tmp = neededRsrc[i];
                    neededRsrc[i] = neededRsrc[i + 1];
                    neededRsrc[i + 1] = tmp;
                }
            }
        }
        if (D.ebugOn) {
            for (int i = 0; i < neededRsrcCount; i++) {
                D.ebugPrintln("NEEDED RSRC: " + neededRsrc[i] + " : " + rollsPerResource[neededRsrc[i]]);
            }
        }
        for (int j = notNeededRsrcCount - 1; j >= 0; j--) {
            for (int i = 0; i < j; i++) {
                if (rollsPerResource[notNeededRsrc[i]] > rollsPerResource[notNeededRsrc[i + 1]]) {
                    int tmp = notNeededRsrc[i];
                    notNeededRsrc[i] = notNeededRsrc[i + 1];
                    notNeededRsrc[i + 1] = tmp;
                }
            }
        }
        if (D.ebugOn) {
            for (int i = 0; i < notNeededRsrcCount; i++) {
                D.ebugPrintln("NOT-NEEDED RSRC: " + notNeededRsrc[i] + " : " + rollsPerResource[notNeededRsrc[i]]);
            }
        }
        boolean[] someoneIsSellingResource = new boolean[SOCResourceConstants.MAXPLUSONE];
        for (int rsrcType = SOCResourceConstants.CLAY; rsrcType <= SOCResourceConstants.WOOD; rsrcType++) {
            someoneIsSellingResource[rsrcType] = false;
            for (int pn = 0; pn < SOCGame.MAXPLAYERS; pn++) {
                if ((pn != ourPlayerData.getPlayerNumber()) && (isSellingResource[pn][rsrcType])) {
                    someoneIsSellingResource[rsrcType] = true;
                    D.ebugPrintln("*** player " + pn + " is selling " + rsrcType);
                    break;
                }
            }
        }
        int getRsrcIdx = neededRsrcCount - 1;
        while ((getRsrcIdx >= 0) && ((ourResources.getAmount(neededRsrc[getRsrcIdx]) >= targetResources.getAmount(neededRsrc[getRsrcIdx])) || (!someoneIsSellingResource[neededRsrc[getRsrcIdx]]))) {
            getRsrcIdx--;
        }
        if (getRsrcIdx >= 0) {
            D.ebugPrintln("*** getRsrc = " + neededRsrc[getRsrcIdx]);
            getResourceSet.add(1, neededRsrc[getRsrcIdx]);
            D.ebugPrintln("*** offer should be null : offer = " + offer);
            int giveRsrcIdx = 0;
            while ((giveRsrcIdx < notNeededRsrcCount) && (offer == null)) {
                D.ebugPrintln("*** ourResources.getAmount(" + notNeededRsrc[giveRsrcIdx] + ") = " + ourResources.getAmount(notNeededRsrc[giveRsrcIdx]));
                if (ourResources.getAmount(notNeededRsrc[giveRsrcIdx]) > 0) {
                    giveResourceSet.clear();
                    giveResourceSet.add(1, notNeededRsrc[giveRsrcIdx]);
                    offer = makeOfferAux(giveResourceSet, getResourceSet, neededRsrc[getRsrcIdx]);
                    D.ebugPrintln("*** offer = " + offer);
                    int offerBuildingTime = getETAToTargetResources(ourPlayerData, targetResources, giveResourceSet, getResourceSet, estimate);
                    D.ebugPrintln("*** offerBuildingTime = " + offerBuildingTime);
                }
                giveRsrcIdx++;
            }
            D.ebugPrintln("*** ourResources = " + ourResources);
            if (offer == null) {
                int giveRsrcIdx1 = 0;
                while ((giveRsrcIdx1 < neededRsrcCount) && (offer == null)) {
                    D.ebugPrintln("*** ourResources.getAmount(" + neededRsrc[giveRsrcIdx1] + ") = " + ourResources.getAmount(neededRsrc[giveRsrcIdx1]));
                    D.ebugPrintln("*** targetResources.getAmount(" + neededRsrc[giveRsrcIdx1] + ") = " + targetResources.getAmount(neededRsrc[giveRsrcIdx1]));
                    if ((ourResources.getAmount(neededRsrc[giveRsrcIdx1]) > targetResources.getAmount(neededRsrc[giveRsrcIdx1])) && (neededRsrc[giveRsrcIdx1] != neededRsrc[getRsrcIdx])) {
                        giveResourceSet.clear();
                        giveResourceSet.add(1, neededRsrc[giveRsrcIdx1]);
                        int offerBuildingTime = getETAToTargetResources(ourPlayerData, targetResources, giveResourceSet, getResourceSet, estimate);
                        if ((offerBuildingTime < batnaBuildingTime) || ((batna != null) && (offerBuildingTime == batnaBuildingTime) && (giveResourceSet.getTotal() < batna.getGiveSet().getTotal()))) {
                            offer = makeOfferAux(giveResourceSet, getResourceSet, neededRsrc[getRsrcIdx]);
                            D.ebugPrintln("*** offer = " + offer);
                            D.ebugPrintln("*** offerBuildingTime = " + offerBuildingTime);
                        }
                    }
                    giveRsrcIdx1++;
                }
            }
            D.ebugPrintln("*** ourResources = " + ourResources);
            SOCResourceSet leftovers = ourResources.copy();
            leftovers.subtract(targetResources);
            D.ebugPrintln("*** leftovers = " + leftovers);
            if (offer == null) {
                int giveRsrcIdx1 = 0;
                int giveRsrcIdx2 = 0;
                while ((giveRsrcIdx1 < notNeededRsrcCount) && (offer == null)) {
                    if (ourResources.getAmount(notNeededRsrc[giveRsrcIdx1]) > 0) {
                        while ((giveRsrcIdx2 < notNeededRsrcCount) && (offer == null)) {
                            giveResourceSet.clear();
                            giveResourceSet.add(1, notNeededRsrc[giveRsrcIdx1]);
                            giveResourceSet.add(1, notNeededRsrc[giveRsrcIdx2]);
                            if (ourResources.contains(giveResourceSet)) {
                                int offerBuildingTime = getETAToTargetResources(ourPlayerData, targetResources, giveResourceSet, getResourceSet, estimate);
                                if ((offerBuildingTime < batnaBuildingTime) || ((batna != null) && (offerBuildingTime == batnaBuildingTime) && (giveResourceSet.getTotal() < batna.getGiveSet().getTotal()))) {
                                    offer = makeOfferAux(giveResourceSet, getResourceSet, neededRsrc[getRsrcIdx]);
                                    D.ebugPrintln("*** offer = " + offer);
                                    D.ebugPrintln("*** offerBuildingTime = " + offerBuildingTime);
                                }
                            }
                            giveRsrcIdx2++;
                        }
                        giveRsrcIdx2 = 0;
                        while ((giveRsrcIdx2 < neededRsrcCount) && (offer == null)) {
                            if (neededRsrc[giveRsrcIdx2] != neededRsrc[getRsrcIdx]) {
                                giveResourceSet.clear();
                                giveResourceSet.add(1, notNeededRsrc[giveRsrcIdx1]);
                                giveResourceSet.add(1, neededRsrc[giveRsrcIdx2]);
                                if (leftovers.contains(giveResourceSet)) {
                                    int offerBuildingTime = getETAToTargetResources(ourPlayerData, targetResources, giveResourceSet, getResourceSet, estimate);
                                    if ((offerBuildingTime < batnaBuildingTime) || ((batna != null) && (offerBuildingTime == batnaBuildingTime) && (giveResourceSet.getTotal() < batna.getGiveSet().getTotal()))) {
                                        offer = makeOfferAux(giveResourceSet, getResourceSet, neededRsrc[getRsrcIdx]);
                                        D.ebugPrintln("*** offer = " + offer);
                                        D.ebugPrintln("*** offerBuildingTime = " + offerBuildingTime);
                                    }
                                }
                            }
                            giveRsrcIdx2++;
                        }
                    }
                    giveRsrcIdx1++;
                }
                giveRsrcIdx1 = 0;
                giveRsrcIdx2 = 0;
                while ((giveRsrcIdx1 < neededRsrcCount) && (offer == null)) {
                    if ((leftovers.getAmount(neededRsrc[giveRsrcIdx1]) > 0) && (neededRsrc[giveRsrcIdx1] != neededRsrc[getRsrcIdx])) {
                        while ((giveRsrcIdx2 < notNeededRsrcCount) && (offer == null)) {
                            giveResourceSet.clear();
                            giveResourceSet.add(1, neededRsrc[giveRsrcIdx1]);
                            giveResourceSet.add(1, notNeededRsrc[giveRsrcIdx2]);
                            if (leftovers.contains(giveResourceSet)) {
                                int offerBuildingTime = getETAToTargetResources(ourPlayerData, targetResources, giveResourceSet, getResourceSet, estimate);
                                if ((offerBuildingTime < batnaBuildingTime) || ((batna != null) && (offerBuildingTime == batnaBuildingTime) && (giveResourceSet.getTotal() < batna.getGiveSet().getTotal()))) {
                                    offer = makeOfferAux(giveResourceSet, getResourceSet, neededRsrc[getRsrcIdx]);
                                    D.ebugPrintln("*** offer = " + offer);
                                    D.ebugPrintln("*** offerBuildingTime = " + offerBuildingTime);
                                }
                            }
                            giveRsrcIdx2++;
                        }
                        giveRsrcIdx2 = 0;
                        while ((giveRsrcIdx2 < neededRsrcCount) && (offer == null)) {
                            if (neededRsrc[giveRsrcIdx2] != neededRsrc[getRsrcIdx]) {
                                giveResourceSet.clear();
                                giveResourceSet.add(1, neededRsrc[giveRsrcIdx1]);
                                giveResourceSet.add(1, neededRsrc[giveRsrcIdx2]);
                                if (leftovers.contains(giveResourceSet)) {
                                    int offerBuildingTime = getETAToTargetResources(ourPlayerData, targetResources, giveResourceSet, getResourceSet, estimate);
                                    if ((offerBuildingTime < batnaBuildingTime) || ((batna != null) && (offerBuildingTime == batnaBuildingTime) && (giveResourceSet.getTotal() < batna.getGiveSet().getTotal()))) {
                                        offer = makeOfferAux(giveResourceSet, getResourceSet, neededRsrc[getRsrcIdx]);
                                        D.ebugPrintln("*** offer = " + offer);
                                        D.ebugPrintln("*** offerBuildingTime = " + offerBuildingTime);
                                    }
                                }
                            }
                            giveRsrcIdx2++;
                        }
                    }
                    giveRsrcIdx1++;
                }
            }
        }
        if (offer == null) {
            SOCResourceSet leftovers = ourResources.copy();
            leftovers.subtract(targetResources);
            D.ebugPrintln("*** leftovers = " + leftovers);
            int getRsrcIdx2 = notNeededRsrcCount - 1;
            while ((getRsrcIdx2 >= 0) && (!someoneIsSellingResource[neededRsrc[getRsrcIdx2]])) {
                getRsrcIdx2--;
            }
            while ((getRsrcIdx2 >= 0) && (offer == null)) {
                getResourceSet.clear();
                getResourceSet.add(1, notNeededRsrc[getRsrcIdx2]);
                leftovers.add(1, notNeededRsrc[getRsrcIdx2]);
                if (offer == null) {
                    int giveRsrcIdx1 = 0;
                    while ((giveRsrcIdx1 < notNeededRsrcCount) && (offer == null)) {
                        if ((leftovers.getAmount(notNeededRsrc[giveRsrcIdx1]) > 0) && (notNeededRsrc[giveRsrcIdx1] != notNeededRsrc[getRsrcIdx2])) {
                            leftovers.subtract(1, notNeededRsrc[giveRsrcIdx1]);
                            if (getOfferToBank(targetResources, leftovers) != null) {
                                giveResourceSet.clear();
                                giveResourceSet.add(1, notNeededRsrc[giveRsrcIdx1]);
                                int offerBuildingTime = getETAToTargetResources(ourPlayerData, targetResources, giveResourceSet, getResourceSet, estimate);
                                if (offerBuildingTime < batnaBuildingTime) {
                                    offer = makeOfferAux(giveResourceSet, getResourceSet, notNeededRsrc[getRsrcIdx2]);
                                    D.ebugPrintln("*** offer = " + offer);
                                    D.ebugPrintln("*** offerBuildingTime = " + offerBuildingTime);
                                }
                            }
                            leftovers.add(1, notNeededRsrc[giveRsrcIdx1]);
                        }
                        giveRsrcIdx1++;
                    }
                }
                if (offer == null) {
                    int giveRsrcIdx1 = 0;
                    while ((giveRsrcIdx1 < neededRsrcCount) && (offer == null)) {
                        if (leftovers.getAmount(neededRsrc[giveRsrcIdx1]) > 0) {
                            leftovers.subtract(1, neededRsrc[giveRsrcIdx1]);
                            if (getOfferToBank(targetResources, leftovers) != null) {
                                giveResourceSet.clear();
                                giveResourceSet.add(1, neededRsrc[giveRsrcIdx1]);
                                int offerBuildingTime = getETAToTargetResources(ourPlayerData, targetResources, giveResourceSet, getResourceSet, estimate);
                                if (offerBuildingTime < batnaBuildingTime) {
                                    offer = makeOfferAux(giveResourceSet, getResourceSet, notNeededRsrc[getRsrcIdx2]);
                                    D.ebugPrintln("*** offer = " + offer);
                                    D.ebugPrintln("*** offerBuildingTime = " + offerBuildingTime);
                                }
                            }
                            leftovers.add(1, neededRsrc[giveRsrcIdx1]);
                        }
                        giveRsrcIdx1++;
                    }
                }
                leftovers.subtract(1, notNeededRsrc[getRsrcIdx2]);
                getRsrcIdx2--;
            }
        }
        return offer;
    }
} </s>
<s>class temp {    private static boolean copyFile(String src, String dest) {
        try {
            File inputFile = new File(src);
            File outputFile = new File(dest);
            FileInputStream in = new FileInputStream(inputFile);
            FileOutputStream out = new FileOutputStream(outputFile);
            FileChannel inc = in.getChannel();
            FileChannel outc = out.getChannel();
            inc.transferTo(0, inc.size(), outc);
            inc.close();
            outc.close();
            in.close();
            out.close();
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }
} </s>
<s>class temp {    private String checkForUpdate() {
        InputStream is = null;
        try {
            URL url = new URL(CHECK_UPDATES_URL);
            try {
                HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                conn.setRequestProperty("User-Agent", "TinyLaF");
                Object content = conn.getContent();
                if (!(content instanceof InputStream)) {
                    return "An exception occured while checking for updates." + "\n\nException was: Content is no InputStream";
                }
                is = (InputStream) content;
            } catch (IOException ex) {
                return "An exception occured while checking for updates." + "\n\nException was: " + ex.getClass().getName();
            }
        } catch (MalformedURLException ex) {
            return "An exception occured while checking for updates." + "\n\nException was: " + ex.getClass().getName();
        }
        try {
            BufferedReader in = new BufferedReader(new InputStreamReader(is));
            StringBuffer buff = new StringBuffer();
            String line;
            while ((line = in.readLine()) != null) {
                buff.append(line);
            }
            in.close();
            return buff.toString();
        } catch (IOException ex) {
            return "An exception occured while checking for updates." + "\n\nException was: " + ex.getClass().getName();
        }
    }
} </s>
<s>class temp {    private File uploadToTmp() {
        if (fileFileName == null) {
            return null;
        }
        File tmpFile = dataDir.tmpFile(shortname, fileFileName);
        log.debug("Uploading dwc archive file for new resource " + shortname + " to " + tmpFile.getAbsolutePath());
        InputStream input = null;
        OutputStream output = null;
        try {
            input = new FileInputStream(file);
            output = new FileOutputStream(tmpFile);
            IOUtils.copy(input, output);
            output.flush();
            log.debug("Uploaded file " + fileFileName + " with content-type " + fileContentType);
        } catch (IOException e) {
            log.error(e);
            return null;
        } finally {
            if (output != null) {
                IOUtils.closeQuietly(output);
            }
            if (input != null) {
                IOUtils.closeQuietly(input);
            }
        }
        return tmpFile;
    }
} </s>
<s>class temp {    public static void doVersionCheck(View view) {
        view.showWaitCursor();
        try {
            URL url = new URL(jEdit.getProperty("version-check.url"));
            InputStream in = url.openStream();
            BufferedReader bin = new BufferedReader(new InputStreamReader(in));
            String line;
            String develBuild = null;
            String stableBuild = null;
            while ((line = bin.readLine()) != null) {
                if (line.startsWith(".build")) develBuild = line.substring(6).trim(); else if (line.startsWith(".stablebuild")) stableBuild = line.substring(12).trim();
            }
            bin.close();
            if (develBuild != null && stableBuild != null) {
                doVersionCheck(view, stableBuild, develBuild);
            }
        } catch (IOException e) {
            String[] args = { jEdit.getProperty("version-check.url"), e.toString() };
            GUIUtilities.error(view, "read-error", args);
        }
        view.hideWaitCursor();
    }
} </s>
<s>class temp {    public void convert(File src, File dest) throws IOException {
        InputStream in = new BufferedInputStream(new FileInputStream(src));
        DcmParser p = pfact.newDcmParser(in);
        Dataset ds = fact.newDataset();
        p.setDcmHandler(ds.getDcmHandler());
        try {
            FileFormat format = p.detectFileFormat();
            if (format != FileFormat.ACRNEMA_STREAM) {
                System.out.println("\n" + src + ": not an ACRNEMA stream!");
                return;
            }
            p.parseDcmFile(format, Tags.PixelData);
            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {
                System.out.println("\n" + src + ": contains UIDs!" + " => probable already DICOM - do not convert");
                return;
            }
            boolean hasPixelData = p.getReadTag() == Tags.PixelData;
            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;
            int pxlen = p.getReadLength();
            if (hasPixelData) {
                if (inflate) {
                    ds.putUS(Tags.BitsAllocated, 16);
                    pxlen = pxlen * 4 / 3;
                }
                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {
                    System.out.println("\n" + src + ": mismatch pixel data length!" + " => do not convert");
                    return;
                }
            }
            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));
            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));
            ds.putUI(Tags.SOPInstanceUID, uid(instUID));
            ds.putUI(Tags.SOPClassUID, classUID);
            if (!ds.contains(Tags.NumberOfSamples)) {
                ds.putUS(Tags.NumberOfSamples, 1);
            }
            if (!ds.contains(Tags.PhotometricInterpretation)) {
                ds.putCS(Tags.PhotometricInterpretation, "MONOCHROME2");
            }
            if (fmi) {
                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));
            }
            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
            try {
            } finally {
                ds.writeFile(out, encodeParam());
                if (hasPixelData) {
                    if (!skipGroupLen) {
                        out.write(PXDATA_GROUPLEN);
                        int grlen = pxlen + 8;
                        out.write((byte) grlen);
                        out.write((byte) (grlen >> 8));
                        out.write((byte) (grlen >> 16));
                        out.write((byte) (grlen >> 24));
                    }
                    out.write(PXDATA_TAG);
                    out.write((byte) pxlen);
                    out.write((byte) (pxlen >> 8));
                    out.write((byte) (pxlen >> 16));
                    out.write((byte) (pxlen >> 24));
                }
                if (inflate) {
                    int b2, b3;
                    for (; pxlen > 0; pxlen -= 3) {
                        out.write(in.read());
                        b2 = in.read();
                        b3 = in.read();
                        out.write(b2 & 0x0f);
                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));
                        out.write(b3 >> 4);
                    }
                } else {
                    for (; pxlen > 0; --pxlen) {
                        out.write(in.read());
                    }
                }
                out.close();
            }
            System.out.print('.');
        } finally {
            in.close();
        }
    }
} </s>
<s>class temp {    public void sort(int[] mas) {
        int temp;
        boolean t = true;
        while (t) {
            t = false;
            for (int i = 0; i < mas.length - 1; i++) {
                if (mas[i] > mas[i + 1]) {
                    temp = mas[i];
                    mas[i] = mas[i + 1];
                    mas[i + 1] = temp;
                    t = true;
                }
            }
        }
    }
} </s>
<s>class temp {    private static String getDocumentAt(String urlString) {
        StringBuffer html_text = new StringBuffer();
        try {
            URL url = new URL(urlString);
            URLConnection conn = url.openConnection();
            BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));
            String line = null;
            while ((line = reader.readLine()) != null) html_text.append(line + "\n");
            reader.close();
        } catch (MalformedURLException e) {
            System.out.println("  Ч  URL: " + urlString);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return html_text.toString();
    }
} </s>
<s>class temp {    public static void copyFile(File src, File dest) throws IOException {
        if (!src.exists()) throw new IOException("File not found '" + src.getAbsolutePath() + "'");
        BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(dest));
        BufferedInputStream in = new BufferedInputStream(new FileInputStream(src));
        byte[] read = new byte[128];
        int len = 128;
        while ((len = in.read(read)) > 0) out.write(read, 0, len);
        out.flush();
        out.close();
        in.close();
    }
} </s>
<s>class temp {    private String unJar(String jarPath, String jarEntry) {
        String path;
        if (jarPath.lastIndexOf("lib/") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf("lib/")); else path = jarPath.substring(0, jarPath.lastIndexOf("/"));
        String relPath = jarEntry.substring(0, jarEntry.lastIndexOf("/"));
        try {
            new File(path + "/" + relPath).mkdirs();
            JarFile jar = new JarFile(jarPath);
            ZipEntry ze = jar.getEntry(jarEntry);
            File bin = new File(path + "/" + jarEntry);
            IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));
        } catch (Exception e) {
            e.printStackTrace();
        }
        return path + "/" + jarEntry;
    }
} </s>
<s>class temp {    private void unJarStart(String jarPath, String jarEntryStart) {
        String path;
        if (jarPath.lastIndexOf("lib/") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf("lib/")); else path = jarPath.substring(0, jarPath.lastIndexOf("/"));
        String relPath = jarEntryStart.substring(0, jarEntryStart.lastIndexOf("/"));
        try {
            new File(path + "/" + relPath).mkdirs();
            JarFile jar = new JarFile(jarPath);
            Enumeration<JarEntry> entries = jar.entries();
            while (entries.hasMoreElements()) {
                JarEntry entry = entries.nextElement();
                String jarEntry = entry.getName();
                if (jarEntry.startsWith(jarEntryStart)) {
                    ZipEntry ze = jar.getEntry(jarEntry);
                    File bin = new File(path + "/" + jarEntry);
                    IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
} </s>
<s>class temp {    public static void main(String args[]) {
        InputStream input = System.in;
        OutputStream output = System.out;
        if (args.length > 0) {
            try {
                input = new FileInputStream(args[0]);
            } catch (FileNotFoundException e) {
                System.err.println("Unable to open file: " + args[0]);
                System.exit(-1);
            } catch (IOException e) {
                System.err.println("Unable to access file: " + args[0]);
                System.exit(-1);
            }
        }
        if (args.length > 1) {
            try {
                output = new FileOutputStream(args[1]);
            } catch (FileNotFoundException e) {
                System.err.println("Unable to open file: " + args[1]);
                System.exit(-1);
            } catch (IOException e) {
                System.err.println("Unable to access file: " + args[1]);
                System.exit(-1);
            }
        }
        byte buffer[] = new byte[512];
        int len;
        try {
            while ((len = input.read(buffer)) > 0) output.write(buffer, 0, len);
        } catch (IOException e) {
            System.err.println("Error copying file");
        } finally {
            input.close();
            output.close();
        }
    }
} </s>
<s>class temp {    public static void main(String[] args) throws Exception {
        InputStream in = null;
        try {
            in = new URL(args[0]).openStream();
            IOUtils.copyBytes(in, System.out, 4096, false);
        } finally {
            IOUtils.closeStream(in);
        }
    }
} </s>
<s>class temp {    public static void transfer(FileInputStream fileInStream, FileOutputStream fileOutStream) throws IOException {
        FileChannel fileInChannel = fileInStream.getChannel();
        FileChannel fileOutChannel = fileOutStream.getChannel();
        long fileInSize = fileInChannel.size();
        try {
            long transferred = fileInChannel.transferTo(0, fileInSize, fileOutChannel);
            if (transferred != fileInSize) {
                throw new IOException("transfer() did not complete");
            }
        } finally {
            ensureClose(fileInChannel, fileOutChannel);
        }
    }
} </s>
<s>class temp {    public void run() {
        try {
            Debug.log("Integrity test", "Getting MD5 instance");
            MessageDigest m = MessageDigest.getInstance("MD5");
            Debug.log("Integrity test", "Creating URL " + target);
            URL url = new URL(this.target);
            Debug.log("Integrity test", "Setting up connection");
            URLConnection urlConnection = url.openConnection();
            InputStream in = urlConnection.getInputStream();
            byte[] buffer = new byte[1024];
            int numRead;
            int fileSize = 0;
            Debug.log("Integrity test", "Reading file");
            while ((numRead = in.read(buffer)) != -1) {
                m.update(buffer, 0, numRead);
                fileSize += numRead;
            }
            in.close();
            Debug.log("Integrity test", "File read: " + fileSize + " bytes");
            Debug.log("Integrity test", "calculating Hash");
            String fileHash = new BigInteger(1, m.digest()).toString(16);
            if (fileHash.equals(this.hash)) {
                Debug.log("Integrity test", "Test OK");
                this.result.put("Integrity", "OK");
            } else {
                Debug.log("Integrity test", "Test failed: different hashes (" + fileHash + " but expected " + hash + ")");
                this.result.put("Integrity", "FAIL");
            }
        } catch (Exception e) {
            Debug.log("Integrity test", "Test failed");
            this.result.put("Integrity", "FAIL");
        }
    }
} </s>
<s>class temp {    public void read(Model m, String url) throws JenaException {
        try {
            URLConnection conn = new URL(url).openConnection();
            String encoding = conn.getContentEncoding();
            if (encoding == null) read(m, conn.getInputStream(), url); else read(m, new InputStreamReader(conn.getInputStream(), encoding), url);
        } catch (FileNotFoundException e) {
            throw new DoesNotExistException(url);
        } catch (IOException e) {
            throw new JenaException(e);
        }
    }
} </s>
<s>class temp {    public boolean addSiteScore(ArrayList<InitScoreTable> siteScores, InitScoreTable scoreTable, String filePath, String strTime) {
        boolean bResult = false;
        String strSql = "";
        Connection conn = null;
        Statement stm = null;
        try {
            conn = db.getConnection();
            conn.setAutoCommit(false);
            stm = conn.createStatement();
            strSql = "delete from t_siteScore  where strTaskId = '" + scoreTable.getStrSiteScoreTaskId() + "'";
            stm.executeUpdate(strSql);
            for (int i = 0; i < siteScores.size(); i++) {
                InitScoreTable temp = siteScores.get(i);
                String tempSql = "select * from t_tagConf where strTagName='" + temp.getStrSiteScoreTagName() + "' and strTagYear='" + temp.getStrSiteScoreYear() + "' ";
                System.out.println(tempSql);
                ResultSet rst = stm.executeQuery(tempSql);
                if (rst.next()) {
                    temp.setStrSiteScoreTagId(rst.getString("strId"));
                    temp.setStrSiteinfoScoreParentId(rst.getString("strParentId"));
                }
                rst = null;
            }
            Iterator<InitScoreTable> it = siteScores.iterator();
            String strCreatedTime = com.siteeval.common.Format.getDateTime();
            String taskId = "";
            while (it.hasNext()) {
                InitScoreTable thebean = it.next();
                taskId = thebean.getStrSiteScoreTaskId();
                String strId = UID.getID();
                strSql = "INSERT INTO " + strTableName3 + "(strId,strTaskId,strTagId," + "strTagType,strTagName,strParentId,flaTagScore,strYear,datCreatedTime,strCreator) " + "VALUES('" + strId + "','" + taskId + "','" + thebean.getStrSiteScoreTagId() + "','" + thebean.getStrSiteScoreTagType() + "','" + thebean.getStrSiteScoreTagName() + "','" + thebean.getStrSiteinfoScoreParentId() + "','" + thebean.getFlaSiteScoreTagScore() + "','" + thebean.getStrSiteScoreYear() + "','" + strCreatedTime + "','" + thebean.getStrSiteScoreCreator() + "')";
                stm.executeUpdate(strSql);
            }
            strSql = "update t_siteTotalScore set strSiteState=1,flaSiteScore='" + scoreTable.getFlaSiteScore() + "',flaInfoDisclosureScore='" + scoreTable.getFlaInfoDisclosureScore() + "',flaOnlineServicesScore='" + scoreTable.getFlaOnlineServicesScore() + "',flaPublicParticipationSore='" + scoreTable.getFlaPublicParticipationSore() + "',flaWebDesignScore='" + scoreTable.getFlaWebDesignScore() + "',strSiteFeature='" + scoreTable.getStrTotalScoreSiteFeature() + "',strSiteAdvantage='" + scoreTable.getStrTotalScoreSiteAdvantage() + "',strSiteFailure='" + scoreTable.getStrTotalScoreSiteFailure() + "' where strTaskId='" + scoreTable.getStrSiteScoreTaskId() + "'";
            stm.executeUpdate(strSql);
            strSql = "update " + strTableName1 + " set templateUrl='" + filePath + "',dTaskBeginTime='" + strTime + "',dTaskEndTime='" + strTime + "' where strid = '" + scoreTable.getStrSiteScoreTaskId() + "'";
            stm.executeUpdate(strSql);
            conn.commit();
            bResult = true;
        } catch (Exception e) {
            try {
                conn.rollback();
            } catch (Exception eee) {
            }
            System.out.println("      վ   ֱ   Ϣʱ   ?");
        } finally {
            try {
                conn.setAutoCommit(true);
                if (stm != null) {
                    stm.close();
                }
                if (conn != null) {
                    conn.close();
                }
            } catch (Exception ee) {
            }
        }
        return bResult;
    }
} </s>
